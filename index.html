<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/11/13/iOS音视频编辑系列-音视频合成/" itemprop="url">
                  iOS音视频编辑系列-音视频合成
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-11-13T15:04:57+08:00" content="2021-11-13">
              2021-11-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/11/13/iOS音视频编辑系列-音视频合成/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/11/13/iOS音视频编辑系列-音视频合成/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h3><h4 id="AVComposition-amp-amp-AVCompositionTrack"><a href="#AVComposition-amp-amp-AVCompositionTrack" class="headerlink" title="AVComposition &amp;&amp; AVCompositionTrack"></a>AVComposition &amp;&amp; AVCompositionTrack</h4><p>composition在音视频处理中起到最关键的大管家作用，基本上所有操作都需要交给composition进行，而且composition是asset的子类，可以直接用avplayer进行播放，也就是说编辑后是可以直接预览的和导出的，非常方便。</p>
<p>track是可以理解为音视频数据的存储通道，音视频数据通过track进行存储，视频编辑也是在track上进行，比如剪辑一段视频的话，先拿到该视频所在的track，然后指定剪辑的时间范围，最后将选定的内容导出即可。</p>
<h4 id="CMTime-amp-amp-CMTimeRange"><a href="#CMTime-amp-amp-CMTimeRange" class="headerlink" title="CMTime &amp;&amp; CMTimeRange"></a>CMTime &amp;&amp; CMTimeRange</h4><p>cmtime是视频编辑中最基本的单位，表示一个时间节点，比如视频时长duration等。cmtime结构中最主要的属性是value和timescale，value/timescale才是cmtime真正标识的值。</p>
<p>cmtimerange标识一个时间区间，start标识该范围的起点，duration标识该范围的长度，这两个属于一起决定了该段时间范围。</p>
<h4 id="具体编码"><a href="#具体编码" class="headerlink" title="具体编码"></a>具体编码</h4><p>这里简单写一个demo,取01.mp4和02.mp4两个视频的前6s，再添加一个03.m4a的音频，然后合成导出一个新的视频。</p>
<h5 id="step0-加载原始资源"><a href="#step0-加载原始资源" class="headerlink" title="step0 加载原始资源"></a>step0 加载原始资源</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let url01 = Bundle.main.url(forResource: &quot;01&quot;, withExtension: &quot;mp4&quot;)</div><div class="line">let asset01 = AVURLAsset(url: url01!)</div><div class="line">    </div><div class="line">let url02 = Bundle.main.url(forResource: &quot;02&quot;, withExtension: &quot;mp4&quot;)</div><div class="line">let asset02 = AVURLAsset(url: url02!)</div><div class="line">    </div><div class="line">let url03 = Bundle.main.url(forResource: &quot;03&quot;, withExtension: &quot;m4a&quot;)</div><div class="line">let asset03 = AVURLAsset(url: url03!)</div></pre></td></tr></table></figure>
<h5 id="step1-创建composition和track"><a href="#step1-创建composition和track" class="headerlink" title="step1 创建composition和track"></a>step1 创建composition和track</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// compposition</div><div class="line">let composition = AVMutableComposition.init()</div><div class="line">/// video track</div><div class="line">let videoTrack = composition.addMutableTrack(withMediaType: .video, preferredTrackID: kCMPersistentTrackID_Invalid)</div><div class="line">let audioTrack = composition.addMutableTrack(withMediaType: .audio, preferredTrackID: kCMPersistentTrackID_Invalid)</div></pre></td></tr></table></figure>
<h5 id="step02-裁剪视频"><a href="#step02-裁剪视频" class="headerlink" title="step02 裁剪视频"></a>step02 裁剪视频</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// segment</div><div class="line">var cursorTime = CMTime.zero</div><div class="line">let videoDuration = CMTimeMake(value: 6, timescale: 1)</div><div class="line">let videoTimeRange = CMTimeRangeMake(start: cursorTime, duration: videoDuration)</div><div class="line">    </div><div class="line">// video asset track</div><div class="line">let track01 = asset01.tracks(withMediaType: .video).first</div><div class="line">do &#123;</div><div class="line">    try videoTrack?.insertTimeRange(videoTimeRange, of: track01!, at: cursorTime)</div><div class="line">    &#125; catch let error as NSError &#123;</div><div class="line">        print(&quot;error when adding video to mix = \(error)&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">cursorTime = CMTimeAdd(cursorTime, videoDuration)</div><div class="line">let track02 = asset02.tracks(withMediaType: .video).first</div><div class="line">do &#123;</div><div class="line">    try videoTrack?.insertTimeRange(videoTimeRange, of: track02!, at: cursorTime)</div><div class="line">    &#125; catch let error as NSError &#123;</div><div class="line">        print(&quot;error when adding video to mix = \(error)&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="step03-添加音频"><a href="#step03-添加音频" class="headerlink" title="step03 添加音频"></a>step03 添加音频</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cursorTime = CMTime.zero</div><div class="line">let audioDuration = composition.duration</div><div class="line">let audioTimeRange = CMTimeRangeMake(start: cursorTime, duration: audioDuration)</div><div class="line">let track03 = asset03.tracks(withMediaType: .audio).first</div><div class="line">do &#123;</div><div class="line">    try audioTrack?.insertTimeRange(audioTimeRange, of: track03!, at: cursorTime)</div><div class="line">    &#125; catch let error as NSError &#123;</div><div class="line">        print(&quot;error when adding audio to mix = \(error)&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="step04-效果预览"><a href="#step04-效果预览" class="headerlink" title="step04 效果预览"></a>step04 效果预览</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self.playerItem = AVPlayerItem.init(asset: composition)</div><div class="line">self.player = AVPlayer.init(playerItem: self.playerItem!)</div><div class="line">self.playerLayer = AVPlayerLayer.init(player: self.player!)</div><div class="line">self.playerLayer?.frame = self.view.bounds</div><div class="line">self.view.layer.addSublayer(self.playerLayer!)</div><div class="line">self.player?.play()</div></pre></td></tr></table></figure>
<h5 id="step05-视频导出到文件和相册"><a href="#step05-视频导出到文件和相册" class="headerlink" title="step05 视频导出到文件和相册"></a>step05 视频导出到文件和相册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">let path = NSTemporaryDirectory().appending(&quot;tmp.mp4&quot;)</div><div class="line">if FileManager.default.fileExists(atPath: path) &#123;</div><div class="line">    do &#123;</div><div class="line">        try FileManager.default.removeItem(atPath: path)</div><div class="line">    &#125;</div><div class="line">    catch &#123;</div><div class="line">        print(&quot;Temporary file removing error.&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 导出到文件</div><div class="line">let outputUrl = URL.init(fileURLWithPath: path)</div><div class="line">let exportSession = AVAssetExportSession.init(asset: composition, presetName: AVAssetExportPresetHighestQuality)</div><div class="line">exportSession?.outputURL = outputUrl</div><div class="line">exportSession?.outputFileType = .mp4</div><div class="line">exportSession?.shouldOptimizeForNetworkUse = true</div><div class="line">exportSession?.exportAsynchronously(completionHandler: &#123;</div><div class="line">    switch exportSession?.status &#123;</div><div class="line">    case .none: break</div><div class="line">        </div><div class="line">    case .some(.waiting): break</div><div class="line">        </div><div class="line">    case .some(.exporting): break</div><div class="line">        </div><div class="line">    case .some(.completed):</div><div class="line">        // 导入到相册</div><div class="line">        PHPhotoLibrary.shared().performChanges &#123;</div><div class="line">            PHAssetChangeRequest.creationRequestForAssetFromVideo(atFileURL: outputUrl)</div><div class="line">        &#125; completionHandler: &#123; (success, error) in</div><div class="line">            if success &#123;</div><div class="line">                print(&quot;导入相册成功&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        break</div><div class="line">        </div><div class="line">    case .some(.failed): break</div><div class="line">        </div><div class="line">    case .some(.cancelled): break</div><div class="line">        </div><div class="line">    case .some(_): break</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>一个简单的合成视频就完成了，可以进相册看看效果，原视频的音频丢了，取代的是我们添加的音频，现在两段拼接的视频之间还没有加转场动画，下一步可以给两段视频之间加一下过渡动画。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/05/OC类从应用启动到加载流程探究/" itemprop="url">
                  OC类从应用启动到加载流程探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-05T12:05:30+08:00" content="2021-01-05">
              2021-01-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/05/OC类从应用启动到加载流程探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/05/OC类从应用启动到加载流程探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要分析类的启动加载流程，我们可以从一个点入手，即<em>load</em>方法的调用，因为该方法会在应用启动时自动调用，我们根据这个特性查看一下调用堆栈，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1</div><div class="line">  * frame #0: 0x0000000100bb9dec AppLaunch`+[ViewController load](self=ViewController, _cmd=&quot;load&quot;) at ViewController.m:17:5</div><div class="line">    frame #1: 0x00000001c0d3c25c libobjc.A.dylib`load_images + 944</div><div class="line">    frame #2: 0x0000000100fca21c dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 464</div><div class="line">    frame #3: 0x0000000100fdb5e8 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 512</div><div class="line">    frame #4: 0x0000000100fd9878 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 184</div><div class="line">    frame #5: 0x0000000100fd9940 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 92</div><div class="line">    frame #6: 0x0000000100fca6d8 dyld`dyld::initializeMainExecutable() + 216</div><div class="line">    frame #7: 0x0000000100fcf928 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 5216</div><div class="line">    frame #8: 0x0000000100fc9208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396</div><div class="line">    frame #9: 0x0000000100fc9038 dyld`_dyld_start + 56</div></pre></td></tr></table></figure>
<p>可以看到，程序是从<em>_dyld_start</em>这个函数开始运行的，老办法，我们到<em>dyld</em>的源码中去一探究竟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#if __arm64__</div><div class="line">	.text</div><div class="line">	.align 2</div><div class="line">	.globl __dyld_start</div><div class="line">__dyld_start:</div><div class="line">	mov 	x28, sp</div><div class="line">	and     sp, x28, #~15		// force 16-byte alignment of stack</div><div class="line">	mov	x0, #0</div><div class="line">	mov	x1, #0</div><div class="line">	stp	x1, x0, [sp, #-16]!	// make aligned terminating frame</div><div class="line">	mov	fp, sp			// set up fp to point to terminating frame</div><div class="line">	sub	sp, sp, #16             // make room for local variables</div><div class="line">#if __LP64__</div><div class="line">	ldr     x0, [x28]               // get app&apos;s mh into x0</div><div class="line">	ldr     x1, [x28, #8]           // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</div><div class="line">	add     x2, x28, #16            // get argv into x2</div><div class="line">#else</div><div class="line">	ldr     w0, [x28]               // get app&apos;s mh into x0</div><div class="line">	ldr     w1, [x28, #4]           // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</div><div class="line">	add     w2, w28, #8             // get argv into x2</div><div class="line">#endif</div><div class="line">	adrp	x3,___dso_handle@page</div><div class="line">	add 	x3,x3,___dso_handle@pageoff // get dyld&apos;s mh in to x4</div><div class="line">	mov	x4,sp                   // x5 has &amp;startGlue</div><div class="line"></div><div class="line">	// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</div><div class="line">	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</div><div class="line">	mov	x16,x0                  // save entry point address in x16</div><div class="line">#if __LP64__</div><div class="line">	ldr     x1, [sp]</div><div class="line">#else</div><div class="line">	ldr     w1, [sp]</div><div class="line">#endif</div><div class="line">	cmp	x1, #0</div><div class="line">	b.ne	Lnew</div><div class="line"></div><div class="line">	// LC_UNIXTHREAD way, clean up stack and jump to result</div><div class="line">#if __LP64__</div><div class="line">	add	sp, x28, #8             // restore unaligned stack pointer without app mh</div><div class="line">#else</div><div class="line">	add	sp, x28, #4             // restore unaligned stack pointer without app mh</div><div class="line">#endif</div><div class="line">#if __arm64e__</div><div class="line">	braaz   x16                     // jump to the program&apos;s entry point</div><div class="line">#else</div><div class="line">	br      x16                     // jump to the program&apos;s entry point</div><div class="line">#endif</div><div class="line"></div><div class="line">	// LC_MAIN case, set up stack for call to main()</div><div class="line">Lnew:	mov	lr, x1		    // simulate return address into _start in libdyld.dylib</div><div class="line">#if __LP64__</div><div class="line">	ldr	x0, [x28, #8]       // main param1 = argc</div><div class="line">	add	x1, x28, #16        // main param2 = argv</div><div class="line">	add	x2, x1, x0, lsl #3</div><div class="line">	add	x2, x2, #8          // main param3 = &amp;env[0]</div><div class="line">	mov	x3, x2</div><div class="line">Lapple:	ldr	x4, [x3]</div><div class="line">	add	x3, x3, #8</div><div class="line">#else</div><div class="line">	ldr	w0, [x28, #4]       // main param1 = argc</div><div class="line">	add	x1, x28, #8         // main param2 = argv</div><div class="line">	add	x2, x1, x0, lsl #2</div><div class="line">	add	x2, x2, #4          // main param3 = &amp;env[0]</div><div class="line">	mov	x3, x2</div><div class="line">Lapple:	ldr	w4, [x3]</div><div class="line">	add	x3, x3, #4</div><div class="line">#endif</div><div class="line">	cmp	x4, #0</div><div class="line">	b.ne	Lapple		    // main param4 = apple</div><div class="line">#if __arm64e__</div><div class="line">	braaz   x16</div><div class="line">#else</div><div class="line">	br      x16</div><div class="line">#endif</div><div class="line"></div><div class="line">#endif // __arm64__</div></pre></td></tr></table></figure>
<p><em>dyld</em>的入口函数也是使用汇编来编写的，我们不需要逐行理解，找一下关键字，结合上面的堆栈信息和汇编注释，我们定位到<em>dyldbootstrap::start</em>这个关键方法，最终跟踪到以下调用链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__dyld_start -&gt; dyldbootstrap::start -&gt; _main -&gt; initializeMainExecutable -&gt; runInitializers -&gt; ImageLoader::runInitializers -&gt; ImageLoader::processInitializers -&gt; ImageLoader::recursiveInitialization -&gt; notifySingle -&gt; objc::load_images -&gt; [ViewController load]</div></pre></td></tr></table></figure>
<p>上面的流程有一个比较奇怪的调用出现在<em>objc::load_images</em>，因为全局都没有找到这个方法的任何申明和定义，我们猜测这个函数可能是外界传过来的一个函数指针，那么如何验证呢？回到线索中断前的最后一个方法中去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)</div><div class="line">&#123;</div><div class="line">	//dyld::log(&quot;notifySingle(state=%d, image=%s)\n&quot;, state, image-&gt;getPath());</div><div class="line">	std::vector&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers);</div><div class="line">	if ( handlers != NULL ) &#123;</div><div class="line">		dyld_image_info info;</div><div class="line">		info.imageLoadAddress	= image-&gt;machHeader();</div><div class="line">		info.imageFilePath		= image-&gt;getRealPath();</div><div class="line">		info.imageFileModDate	= image-&gt;lastModified();</div><div class="line">		for (std::vector&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;begin(); it != handlers-&gt;end(); ++it) &#123;</div><div class="line">			const char* result = (*it)(state, 1, &amp;info);</div><div class="line">			if ( (result != NULL) &amp;&amp; (state == dyld_image_state_mapped) ) &#123;</div><div class="line">				//fprintf(stderr, &quot;  image rejected by handler=%p\n&quot;, *it);</div><div class="line">				// make copy of thrown string so that later catch clauses can free it</div><div class="line">				const char* str = strdup(result);</div><div class="line">				throw str;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if ( state == dyld_image_state_mapped ) &#123;</div><div class="line">		// &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache</div><div class="line">		if ( !image-&gt;inSharedCache() ) &#123;</div><div class="line">			dyld_uuid_info info;</div><div class="line">			if ( image-&gt;getUUID(info.imageUUID) ) &#123;</div><div class="line">				info.imageLoadAddress = image-&gt;machHeader();</div><div class="line">				addNonSharedCacheImageUUID(info);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != NULL) &amp;&amp; image-&gt;notifyObjC() ) &#123;</div><div class="line">		uint64_t t0 = mach_absolute_time();</div><div class="line">		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0);</div><div class="line">		// 重点！！！</div><div class="line">		(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</div><div class="line">		uint64_t t1 = mach_absolute_time();</div><div class="line">		uint64_t t2 = mach_absolute_time();</div><div class="line">		uint64_t timeInObjC = t1-t0;</div><div class="line">		uint64_t emptyTime = (t2-t1)*100;</div><div class="line">		if ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != NULL) ) &#123;</div><div class="line">			timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    // mach message csdlc about dynamically unloaded images</div><div class="line">	if ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123;</div><div class="line">		notifyKernel(*image, false);</div><div class="line">		const struct mach_header* loadAddress[] = &#123; image-&gt;machHeader() &#125;;</div><div class="line">		const char* loadPath[] = &#123; image-&gt;getPath() &#125;;</div><div class="line">		notifyMonitoringDyld(true, 1, loadAddress, loadPath);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，在里面我们发现有一些比较敏感的关键字<em>sNotifyObjCInit</em>，这个应该跟objc的初始化有关系，我们全局搜索一下，最后定位到下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Note: only for use by objc runtime</div><div class="line">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</div><div class="line">// Dyld will call back the &quot;mapped&quot; function with an array of images that contain an objc-image-info section.</div><div class="line">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</div><div class="line">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</div><div class="line">// dyld will call the &quot;mapped&quot; function with already loaded objc images.  During any later dlopen() call,</div><div class="line">// dyld will also call the &quot;mapped&quot; function.  Dyld will call the &quot;init&quot; function when dyld would be called</div><div class="line">// initializers in that image.  This is when objc calls any +load methods in that image.</div><div class="line">//</div><div class="line">void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</div><div class="line">                                _dyld_objc_notify_init      init,</div><div class="line">                                _dyld_objc_notify_unmapped  unmapped);</div><div class="line">                                </div><div class="line"></div><div class="line">void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</div><div class="line">                                _dyld_objc_notify_init      init,</div><div class="line">                                _dyld_objc_notify_unmapped  unmapped)</div><div class="line">&#123;</div><div class="line">	dyld::registerObjCNotifiers(mapped, init, unmapped);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的注释写得已经比较清楚，这个函数专供 objc runtime。那我们就去runtime的源码中找找嘛。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _objc_init</div><div class="line">* Bootstrap initialization. Registers our image notifier with dyld.</div><div class="line">* Called by libSystem BEFORE library initialization time</div><div class="line">**********************************************************************/</div><div class="line"></div><div class="line">void _objc_init(void)</div><div class="line">&#123;</div><div class="line">    static bool initialized = false;</div><div class="line">    if (initialized) return;</div><div class="line">    initialized = true;</div><div class="line">    </div><div class="line">    // fixme defer initialization until an objc-using image is found?</div><div class="line">    environ_init();</div><div class="line">    tls_init();</div><div class="line">    static_init();</div><div class="line">    runtime_init();</div><div class="line">    exception_init();</div><div class="line">    cache_init();</div><div class="line">    _imp_implementationWithBlock_init();</div><div class="line"></div><div class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</div><div class="line"></div><div class="line">#if __OBJC2__</div><div class="line">    didCallDyldNotifyRegister = true;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然在<em>_objc_init</em>初始化函数中发现了调用逻辑，分别注册了<em>map_images</em>和<em>load_images</em>两个回调函数，看到这里熟悉应用启动流程的同学应该想到了，这不就是可执行文件的mmap和load么。但是新的问题又来了，这个<em>_objc_init</em>又是在什么时候被调用的呢？我们直接在里面搞个断点看看调用堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class="line">    frame #0: 0x00000001c0d4ce0c libobjc.A.dylib`_objc_init</div><div class="line">  * frame #1: 0x00000001003b88f8 libdispatch.dylib`_os_object_init + 20</div><div class="line">    frame #2: 0x00000001003c7ea0 libdispatch.dylib`libdispatch_init + 292</div><div class="line">    frame #3: 0x00000001dadfd888 libSystem.B.dylib`libSystem_initializer + 200</div><div class="line">    frame #4: 0x0000000100120810 dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 424</div><div class="line">    frame #5: 0x0000000100120bd8 dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 52</div><div class="line">    frame #6: 0x000000010011b600 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 536</div><div class="line">    frame #7: 0x000000010011b56c dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 388</div><div class="line">    frame #8: 0x0000000100119878 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 184</div><div class="line">    frame #9: 0x0000000100119940 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 92</div><div class="line">    frame #10: 0x000000010010a688 dyld`dyld::initializeMainExecutable() + 136</div><div class="line">    frame #11: 0x000000010010f928 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 5216</div><div class="line">    frame #12: 0x0000000100109208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396</div><div class="line">    frame #13: 0x0000000100109038 dyld`_dyld_start + 56</div></pre></td></tr></table></figure>
<p>前面我们已经看过的函数跳过，直接从<em>ImageLoaderMachO::doInitialization</em>开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	CRSetCrashLogMessage2(this-&gt;getPath());</div><div class="line"></div><div class="line">	// mach-o has -init and static initializers</div><div class="line">	doImageInit(context);</div><div class="line">	doModInitFunctions(context);</div><div class="line">	</div><div class="line">	CRSetCrashLogMessage2(NULL);</div><div class="line">	</div><div class="line">	return (fHasDashInit || fHasInitializers);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void ImageLoaderMachO::doModInitFunctions(const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	// 去掉我们不关心的信息 我眼里只有下面这句话</div><div class="line">	if ( ! dyld::gProcessInfo-&gt;libSystemInitialized ) &#123;</div><div class="line">		// &lt;rdar://problem/17973316&gt; libSystem initializer must run first</div><div class="line">		const char* installPath = getInstallPath();</div><div class="line">		if ( (installPath == NULL) || (strcmp(installPath, libSystemPath(context)) != 0) )</div><div class="line">			dyld::throwf(&quot;initializer in image (%s) that does not link with libSystem.dylib\n&quot;, this-&gt;getPath());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看注释和异常文案，<em>libSystem</em>必须最先被初始化，这也解释了上面的堆栈情况。行吧，那我们再去<em>libSystem</em>的源码中看看有没有<em>libSystem_initializer</em>这个初始化方法。</p>
<p>果然是有的，去掉一些不关系的信息，大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">// libsyscall_initializer() initializes all of libSystem.dylib</div><div class="line">// &lt;rdar://problem/4892197&gt;</div><div class="line">__attribute__((constructor))</div><div class="line">static void</div><div class="line">libSystem_initializer(int argc,</div><div class="line">		      const char* argv[],</div><div class="line">		      const char* envp[],</div><div class="line">		      const char* apple[],</div><div class="line">		      const struct ProgramVars* vars)</div><div class="line">&#123;</div><div class="line">		</div><div class="line">	_libSystem_ktrace0(ARIADNE_LIFECYCLE_libsystem_init | DBG_FUNC_START);</div><div class="line"></div><div class="line">	__libkernel_init(&amp;libkernel_funcs, envp, apple, vars);</div><div class="line">	_libSystem_ktrace_init_func(KERNEL);</div><div class="line"></div><div class="line">	__libplatform_init(NULL, envp, apple, vars);</div><div class="line">	_libSystem_ktrace_init_func(PLATFORM);</div><div class="line"></div><div class="line">	__pthread_init(&amp;libpthread_funcs, envp, apple, vars);</div><div class="line">	_libSystem_ktrace_init_func(PTHREAD);</div><div class="line"></div><div class="line">	_libc_initializer(&amp;libc_funcs, envp, apple, vars);</div><div class="line">	_libSystem_ktrace_init_func(LIBC);</div><div class="line"></div><div class="line">	// TODO: Move __malloc_init before __libc_init after breaking malloc&apos;s upward link to Libc</div><div class="line">	__malloc_init(apple);</div><div class="line">	_libSystem_ktrace_init_func(MALLOC);</div><div class="line"></div><div class="line">#if TARGET_OS_OSX</div><div class="line">	/* &lt;rdar://problem/9664631&gt; */</div><div class="line">	__keymgr_initializer();</div><div class="line">	_libSystem_ktrace_init_func(KEYMGR);</div><div class="line">#endif</div><div class="line"></div><div class="line">	// No ASan interceptors are invoked before this point. ASan is normally initialized via the malloc interceptor:</div><div class="line">	// _dyld_initializer() -&gt; tlv_load_notification -&gt; wrap_malloc -&gt; ASanInitInternal</div><div class="line"></div><div class="line">	_dyld_initializer();</div><div class="line">	_libSystem_ktrace_init_func(DYLD);</div><div class="line"></div><div class="line">	libdispatch_init();</div><div class="line">	_libSystem_ktrace_init_func(LIBDISPATCH);</div><div class="line"></div><div class="line">#if !TARGET_OS_DRIVERKIT</div><div class="line">	_libxpc_initializer();</div><div class="line">	_libSystem_ktrace_init_func(LIBXPC);</div><div class="line"></div><div class="line">#if CURRENT_VARIANT_asan</div><div class="line">	setenv(&quot;DT_BYPASS_LEAKS_CHECK&quot;, &quot;1&quot;, 1);</div><div class="line">#endif</div><div class="line">#endif // !TARGET_OS_DRIVERKIT</div><div class="line"></div><div class="line">	// must be initialized after dispatch</div><div class="line">	_libtrace_init();</div><div class="line">	_libSystem_ktrace_init_func(LIBTRACE);</div><div class="line"></div><div class="line">#if !TARGET_OS_DRIVERKIT</div><div class="line">#if defined(HAVE_SYSTEM_SECINIT)</div><div class="line">	_libsecinit_initializer();</div><div class="line">	_libSystem_ktrace_init_func(SECINIT);</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(HAVE_SYSTEM_CONTAINERMANAGER)</div><div class="line">	_container_init(apple);</div><div class="line">	_libSystem_ktrace_init_func(CONTAINERMGR);</div><div class="line">#endif</div><div class="line"></div><div class="line">	__libdarwin_init();</div><div class="line">	_libSystem_ktrace_init_func(DARWIN);</div><div class="line">#endif // !TARGET_OS_DRIVERKIT</div><div class="line"></div><div class="line">	//...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，里面做了很多系统库的初始化工作，我们也看到了熟悉的身影</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 这里有点意思，因为libSystem的初始化流程就是从dyld进来的，但是进来后才对dyld做初始化。</div><div class="line">_dyld_initializer();</div><div class="line">_libSystem_ktrace_init_func(DYLD);</div><div class="line"></div><div class="line">// 堆栈里面的</div><div class="line">libdispatch_init();</div><div class="line">_libSystem_ktrace_init_func(LIBDISPATCH);</div></pre></td></tr></table></figure>
<p>看了一堆初始化方法，还是没有找到我们要的<em>_objc_init</em>呀，这货到底藏哪了。我们回到堆栈，发现在<em>libdispatch</em>的初始化后又调用了<em>_os_object_init</em>这个方法，猜测是不是跟这个方法有关系呢？没办法，我们还得去<em>libdispatch</em>的源码中看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">_os_object_init(void)</div><div class="line">&#123;</div><div class="line">	_objc_init(); //我在这里哦~~~</div><div class="line">	</div><div class="line">	Block_callbacks_RR callbacks = &#123;</div><div class="line">		sizeof(Block_callbacks_RR),</div><div class="line">		(void (*)(const void *))&amp;objc_retain,</div><div class="line">		(void (*)(const void *))&amp;objc_release,</div><div class="line">		(void (*)(const void *))&amp;_os_objc_destructInstance</div><div class="line">	&#125;;</div><div class="line">	_Block_use_RR2(&amp;callbacks);</div><div class="line">#if DISPATCH_COCOA_COMPAT</div><div class="line">	const char *v = getenv(&quot;OBJC_DEBUG_MISSING_POOLS&quot;);</div><div class="line">	if (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</div><div class="line">	v = getenv(&quot;DISPATCH_DEBUG_MISSING_POOLS&quot;);</div><div class="line">	if (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</div><div class="line">	v = getenv(&quot;LIBDISPATCH_DEBUG_MISSING_POOLS&quot;);</div><div class="line">	if (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>呵呵，妖怪哪里跑！！！</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在我们终于把OC类从app启动到加载的整个流程跑通了，但是光知道流程显然还是不够啊，类是如何从二进制文件被创建成类对象的呢？我们之后再继续探索这一块的内容吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/04/OC的消息转发流程底层探究/" itemprop="url">
                  OC的消息转发流程底层探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-04T22:50:57+08:00" content="2021-01-04">
              2021-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/04/OC的消息转发流程底层探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/OC的消息转发流程底层探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="转发流程定位"><a href="#转发流程定位" class="headerlink" title="转发流程定位"></a>转发流程定位</h4><p>接<a href="http://llyblog.com/2021/01/04/OC方法调用慢查找流程底层逻辑探究/" target="_blank" rel="noopener">上一篇文章</a>的最后，我们找了方法未实现时的默认函数，下面我们调一个未实现的方法，看看具体的调用栈.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2021-01-04 20:05:16.074234+0800 LLYObjc[11678:7221659] -[LLYModel fun0]: unrecognized selector sent to instance 0x1006f2150</div><div class="line">2021-01-04 20:05:16.075692+0800 LLYObjc[11678:7221659] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[LLYModel fun0]: unrecognized selector sent to instance 0x1006f2150&apos;</div></pre></td></tr></table></figure>
<p>bt下看看堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGABRT</div><div class="line">frame #0: 0x00007fff717f633a libsystem_kernel.dylib`__pthread_kill + 10</div><div class="line">frame #1: 0x00000001004bc9bc libsystem_pthread.dylib`pthread_kill + 430</div><div class="line">frame #2: 0x00007fff7177d808 libsystem_c.dylib`abort + 120</div><div class="line">frame #3: 0x00007fff6e9e4458 libc++abi.dylib`abort_message + 231</div><div class="line">frame #4: 0x00007fff6e9d58bf libc++abi.dylib`demangling_terminate_handler() + 262</div><div class="line">* frame #5: 0x00000001002e99b3 libobjc.A.dylib`_objc_terminate() at objc-exception.mm:701:13</div><div class="line">frame #6: 0x00007fff6e9e3887 libc++abi.dylib`std::__terminate(void (*)()) + 8</div><div class="line">frame #7: 0x00007fff6e9e61a2 libc++abi.dylib`__cxxabiv1::failed_throw(__cxxabiv1::__cxa_exception*) + 27</div><div class="line">frame #8: 0x00007fff6e9e6169 libc++abi.dylib`__cxa_throw + 113</div><div class="line">frame #9: 0x00000001002e9158 libobjc.A.dylib`objc_exception_throw(obj=&quot;-[LLYModel fun0]: unrecognized selector sent to instance 0x1006f2150&quot;) at objc-exception.mm:591:5</div><div class="line">frame #10: 0x00007fff37660936 CoreFoundation`-[NSObject(NSObject) doesNotRecognizeSelector:] + 132</div><div class="line">frame #11: 0x00007fff37545ec0 CoreFoundation`___forwarding___ + 1427</div><div class="line">frame #12: 0x00007fff37545898 CoreFoundation`__forwarding_prep_0___ + 120</div><div class="line">frame #13: 0x0000000100003960 LLYObjc`main(argc=1, argv=0x00007ffeefbff4f8) at main.m:55:9 [opt]</div><div class="line">frame #14: 0x00007fff716aecc9 libdyld.dylib`start + 1</div><div class="line">frame #15: 0x00007fff716aecc9 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p>在<em>main</em>后和<em>doesNotRecognizeSelector</em>方法前分别调用了 <em>__forwarding_prep_0__</em> 和 <em>__<em>forwarding__</em></em> 这两个函数，我们猜测是OC的消息转发逻辑，那么如何去验证呢，老办法，我们先去源码中看看。</p>
<p>一无所获。</p>
<p>那我们再想想其他办法，我们分别点开这两个函数的堆栈，在头部发现了一些信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CoreFoundation`__forwarding_prep_0___:</div><div class="line"></div><div class="line">CoreFoundation`___forwarding___:</div></pre></td></tr></table></figure>
<p>看来这两个函数的定义可能在CoreFoundation库中，那么我们自然就去开源库里面找找看，<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CoreFoundation</a>的源码我们是找到了，打开发现还是没有上面的函数，看来并未全部开源，那么还是其他办法去探索么？</p>
<p>答案是有的，还可以通过反汇编工具来查看CF的动态库文件，这里推荐<em>Hopper Disassembler</em>.<br>在Hopper中,我们找到了如下伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">int ____forwarding___(int arg0, int arg1) &#123;</div><div class="line"></div><div class="line">	// 去掉了一些参数的赋值和传递逻辑和判断逻辑</div><div class="line">loc_649bb:</div><div class="line">    var_148 = r13;</div><div class="line">    var_138 = r12;</div><div class="line">    var_158 = rsi;</div><div class="line">    rax = object_getClass(rbx);</div><div class="line">    r12 = rax;</div><div class="line">    r13 = class_getName(rax);</div><div class="line">    if (class_respondsToSelector(r12, @selector(forwardingTargetForSelector:)) == 0x0) goto loc_64a67;</div><div class="line"></div><div class="line">loc_64a8a:</div><div class="line">    rax = class_respondsToSelector(r12, @selector(methodSignatureForSelector:));</div><div class="line">    r14 = var_138;</div><div class="line">    var_148 = r15;</div><div class="line">    if (rax == 0x0) goto loc_64dd7;</div><div class="line">    </div><div class="line">    loc_64ad5:</div><div class="line">    r12 = rax;</div><div class="line">    rax = [rax _frameDescriptor];</div><div class="line">    r13 = rax;</div><div class="line">    if (((*(int16_t *)(*rax + 0x22) &amp; 0xffff) &gt;&gt; 0x6 &amp; 0x1) != rbx) &#123;</div><div class="line">            rax = sel_getName(stack[-328]);</div><div class="line">            _CFLog(0x4, @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;, rax);</div><div class="line">    &#125;</div><div class="line">    rax = object_getClass(r14);</div><div class="line">    rax = class_respondsToSelector(rax, @selector(_forwardStackInvocation:));</div><div class="line">    stack[-344] = r13;</div><div class="line">    if (rax == 0x0) goto loc_64c19;</div><div class="line"></div><div class="line">loc_64c19:</div><div class="line">    if (class_respondsToSelector(object_getClass(r14), @selector(forwardInvocation:)) == 0x0) goto loc_64ec2;</div><div class="line"></div><div class="line">loc_64e3c:</div><div class="line">    rax = sel_getName(var_140);</div><div class="line">    r14 = rax;</div><div class="line">    rax = sel_getUid(rax);</div><div class="line">    if (rax != var_140) &#123;</div><div class="line">            _CFLog(0x4, @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;, var_140, r14, rax, r9, stack[-360]);</div><div class="line">    &#125;</div><div class="line">    if (class_respondsToSelector(object_getClass(var_138), @selector(doesNotRecognizeSelector:)) == 0x0) &#123;</div><div class="line">            ____forwarding___.cold.2(var_138);</div><div class="line">    &#125;</div><div class="line">    (*_objc_msgSend)(var_138, @selector(doesNotRecognizeSelector:));</div><div class="line">    asm &#123; ud2 &#125;;</div><div class="line">    rax = loc_64ec2(rdi, rsi);</div><div class="line">    return rax;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面伪代码，我们提炼出了几个比较重要的函数，即我们常说的消息转发的流程（除了<em>_forwardStackInvocation</em>这个函数，这个函数我们下面在说）原来出处在CoreFoundation中，知道了出处，我们再来验证下他们的逻辑。</p>
<h4 id="转发流程验证"><a href="#转发流程验证" class="headerlink" title="转发流程验证"></a>转发流程验证</h4><h5 id="resolveInstanceMethod-amp-amp-resolveClassMethod-动态方法决议"><a href="#resolveInstanceMethod-amp-amp-resolveClassMethod-动态方法决议" class="headerlink" title="resolveInstanceMethod &amp;&amp; resolveClassMethod 动态方法决议"></a>resolveInstanceMethod &amp;&amp; resolveClassMethod 动态方法决议</h5><p>该部分的源码就在objc中，上一篇解释消息慢查询的时候只是一笔带过了，这里我们再来分析下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior) &#123;</div><div class="line">	</div><div class="line">	//...</div><div class="line">	//上面是imp查找过程</div><div class="line">	</div><div class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</div><div class="line">        behavior ^= LOOKUP_RESOLVER;</div><div class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //...</div><div class="line">    //下面的缓存过程</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">static NEVER_INLINE IMP</div><div class="line">resolveMethod_locked(id inst, SEL sel, Class cls, int behavior)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line"></div><div class="line">    runtimeLock.unlock();</div><div class="line"></div><div class="line">    if (! cls-&gt;isMetaClass()) &#123;</div><div class="line">        // cls是类对象</div><div class="line">        resolveInstanceMethod(inst, sel, cls);</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // cls是元类对象</div><div class="line">        resolveClassMethod(inst, sel, cls);</div><div class="line"></div><div class="line">        // 类方法列表中没有，再去实例方法中找，这里就有一个坑点，根元类的superclass指针指向根类，也就是最终会找到NSObject中去，所以理论上我们能在NSObject的分类中处理所有的类方法找不到问题。</div><div class="line">        if (!lookUpImpOrNil(inst, sel, cls)) &#123;</div><div class="line">            resolveInstanceMethod(inst, sel, cls);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // chances are that calling the resolver have populated the cache</div><div class="line">    // so attempt using it</div><div class="line">    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</div><div class="line"></div><div class="line">	// 未实现直接返回</div><div class="line">    if (!lookUpImpOrNil(cls, resolve_sel, cls-&gt;ISA())) &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	 // 如果该类resolveInstanceMethod方法已实现，帮我们调一次</div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(cls, resolve_sel, sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveInstanceMethod adds to self a.k.a. cls</div><div class="line">    </div><div class="line">    // 继续走一遍查找逻辑</div><div class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</div><div class="line">    </div><div class="line">    // ...</div><div class="line">    // 非重要信息</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">static void resolveClassMethod(id inst, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line">    ASSERT(cls-&gt;isMetaClass());</div><div class="line"></div><div class="line">	// 未实现直接返回</div><div class="line">    if (!lookUpImpOrNil(inst, @selector(resolveClassMethod:), cls)) &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 // 如果该类resolveClassMethod方法已实现，帮我们调一次</div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</div><div class="line"></div><div class="line">    // 继续走一遍查找逻辑</div><div class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</div><div class="line">    </div><div class="line">    // ...</div><div class="line">    // 非重要信息</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了源码，我们知道了只要重写一下上面两个方法，系统就会调一次这两方法，相当于一个钩子，我们可以在钩子里面动态的给该类加上缺失的方法，正常逻辑ok，那如果我们只是重写但是不动态添加方法实现会怎么样呢？我们来验证下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSLog(@&quot;%@ %s&quot;,NSStringFromSelector(sel),__func__);</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2021-01-04 21:29:51.339930+0800 LLYObjc[12200:7268336] fun0 +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 21:29:51.340714+0800 LLYObjc[12200:7268336] fun0 +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 21:29:51.340894+0800 LLYObjc[12200:7268336] -[LLYModel fun0]: unrecognized selector sent to instance 0x101918dc0</div></pre></td></tr></table></figure>
<p>奇怪的事情发生了，<em>resolveInstanceMethod</em>进来了两次，第一次进来比较好理解，但是第二次是从哪里进来的呢？是不是因为递归查找的原因？我们打个断点看看两个打印时的bt：</p>
<p><strong>第一次</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class="line">* frame #0: 0x0000000100313413 libobjc.A.dylib`resolveInstanceMethod(inst=0x000000010113abd0, sel=&quot;fun0&quot;, cls=LLYModel) at objc-runtime-new.mm:6005:30</div><div class="line">frame #1: 0x00000001002fee83 libobjc.A.dylib`resolveMethod_locked(inst=0x000000010113abd0, sel=&quot;fun0&quot;, cls=LLYModel, behavior=1) at objc-runtime-new.mm:6043:9</div><div class="line">frame #2: 0x00000001002fe7ac libobjc.A.dylib`lookUpImpOrForward(inst=0x000000010113abd0, sel=&quot;fun0&quot;, cls=LLYModel, behavior=1) at objc-runtime-new.mm:6192:16</div><div class="line">frame #3: 0x00000001002d9899 libobjc.A.dylib`_objc_msgSend_uncached at objc-msg-x86_64.s:1101</div><div class="line">frame #4: 0x0000000100003890 LLYObjc`main(argc=1, argv=0x00007ffeefbff4f8) at main.m:55:9 [opt]</div><div class="line">frame #5: 0x00007fff716aecc9 libdyld.dylib`start + 1</div><div class="line">frame #6: 0x00007fff716aecc9 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p><strong>第二次</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class="line">  * frame #0: 0x0000000100313413 libobjc.A.dylib`resolveInstanceMethod(inst=0x0000000000000000, sel=&quot;fun0&quot;, cls=LLYModel) at objc-runtime-new.mm:6005:30</div><div class="line">    frame #1: 0x00000001002fee83 libobjc.A.dylib`resolveMethod_locked(inst=0x0000000000000000, sel=&quot;fun0&quot;, cls=LLYModel, behavior=0) at objc-runtime-new.mm:6043:9</div><div class="line">    frame #2: 0x00000001002fe7ac libobjc.A.dylib`lookUpImpOrForward(inst=0x0000000000000000, sel=&quot;fun0&quot;, cls=LLYModel, behavior=0) at objc-runtime-new.mm:6192:16</div><div class="line">    frame #3: 0x00000001002d8379 libobjc.A.dylib`class_getInstanceMethod(cls=LLYModel, sel=&quot;fun0&quot;) at objc-runtime-new.mm:5922:5</div><div class="line">    frame #4: 0x00007fff3755d697 CoreFoundation`__methodDescriptionForSelector + 282</div><div class="line">    frame #5: 0x00007fff37579204 CoreFoundation`-[NSObject(NSObject) methodSignatureForSelector:] + 38</div><div class="line">    frame #6: 0x00007fff37545ac5 CoreFoundation`___forwarding___ + 408</div><div class="line">    frame #7: 0x00007fff37545898 CoreFoundation`__forwarding_prep_0___ + 120</div><div class="line">    frame #8: 0x0000000100003890 LLYObjc`main(argc=1, argv=0x00007ffeefbff4f8) at main.m:55:9 [opt]</div><div class="line">    frame #9: 0x00007fff716aecc9 libdyld.dylib`start + 1</div><div class="line">    frame #10: 0x00007fff716aecc9 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p>可以看到，第一次堆栈就是正常的<em>lookUpImpOrForward</em>查找逻辑触发的，但是第二次的触发确是在消息转发中获取到函数签名后，那如何验证呢？很简单，我们去实现下<em>methodSignatureForSelector</em>这个方法看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2021-01-04 22:06:15.458988+0800 LLYObjc[12668:7297440] fun0 +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 22:06:15.459889+0800 LLYObjc[12668:7297440] _forwardStackInvocation: +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 22:06:15.460152+0800 LLYObjc[12668:7297440] -[LLYModel fun0]: unrecognized selector sent to instance 0x100738090</div></pre></td></tr></table></figure>
<p>果然，第二次打印的函数变成了这个<em>_forwardStackInvocation</em>，这是哪来的呢？请看上面的CoreFoundation伪代码。大胆猜测就是如果没有实现自己的函数签名的话，系统还是用之前的函数签名（fun0）去调用一次<em>lookUpImpOrForward</em>，实现后换成CoreFoundation内部的（_forwardStackInvocation）函数签名去调用一次<em>lookUpImpOrForward</em>.</p>
<h5 id="forwardingTargetForSelector-快速转发"><a href="#forwardingTargetForSelector-快速转发" class="headerlink" title="forwardingTargetForSelector 快速转发"></a>forwardingTargetForSelector 快速转发</h5><p>快速转发需要做的操作比较简单，返回一个实现了该方法的类。</p>
<h5 id="methodSignatureForSelector-amp-amp-forwardInvocation-慢速转发"><a href="#methodSignatureForSelector-amp-amp-forwardInvocation-慢速转发" class="headerlink" title="methodSignatureForSelector &amp;&amp; forwardInvocation 慢速转发"></a>methodSignatureForSelector &amp;&amp; forwardInvocation 慢速转发</h5><p>慢速转发有下面两个有意思的点：</p>
<p><strong>趣点一：</strong>方法签名并未指定格式，你可以返回任意正确的格式，比如我返回下面这种格式也ok：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>项目中应该没有那个函数带了这么多参数吧。</p>
<p>但是下面这个格式就不行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为缺少最基本的sel参数。</p>
<p><strong>趣点二：</strong> 只需要重写<em>forwardInvocation</em>函数，即使是一个空函数，系统即认为当前被转发的方法已经被人处理，不会抛出异常。这里我们就可以做一些其他的事情了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上探索，我们不仅掌握了OC消息转发的实现方式，还了解了转发逻辑内部的实现原理，也为我们在生产环境的灵活使用打下基础，比如我们可以通过消息转发机制实现方法调用的防护工作等比较重要的内容，更多的功能需要我们进一步的探索和实践。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/04/OC方法调用慢查找流程底层逻辑探究/" itemprop="url">
                  OC方法调用慢查找流程底层逻辑探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-04T13:54:47+08:00" content="2021-01-04">
              2021-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/04/OC方法调用慢查找流程底层逻辑探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/OC方法调用慢查找流程底层逻辑探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="http://llyblog.com/2021/01/03/OC方法调用快查找流程底层逻辑探究/" target="_blank" rel="noopener">OC方法调用快查找流程底层逻辑探究</a>中,我们分析了方法调用快查找的逻辑，所谓的快查找也就是对方法缓存列表的查找，如果没有命中缓存，则会进入到慢查找的逻辑，即对类的方法列表的查找，下面我们就来探究下OC底层是如何进行慢查找的。</p>
<p>在快查找未命中的出口，有如下的代码逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">.macro JumpMiss</div><div class="line">.if $0 == GETIMP</div><div class="line">	b	LGetImpMiss</div><div class="line">.elseif $0 == NORMAL</div><div class="line">	b	__objc_msgSend_uncached</div><div class="line">.elseif $0 == LOOKUP</div><div class="line">	b	__objc_msgLookup_uncached</div><div class="line">.else</div><div class="line">.abort oops</div><div class="line">.endif</div><div class="line">.endmacro</div><div class="line"></div><div class="line">STATIC_ENTRY __objc_msgSend_uncached</div><div class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</div><div class="line"></div><div class="line">// THIS IS NOT A CALLABLE C FUNCTION</div><div class="line">// Out-of-band p16 is the class to search</div><div class="line">	</div><div class="line">MethodTableLookup</div><div class="line">TailCallFunctionPointer x17</div><div class="line"></div><div class="line">END_ENTRY __objc_msgSend_uncached</div><div class="line"></div><div class="line"></div><div class="line">STATIC_ENTRY __objc_msgLookup_uncached</div><div class="line">UNWIND __objc_msgLookup_uncached, FrameWithNoSaves</div><div class="line"></div><div class="line">// THIS IS NOT A CALLABLE C FUNCTION</div><div class="line">// Out-of-band p16 is the class to search</div><div class="line">	</div><div class="line">MethodTableLookup</div><div class="line">ret</div><div class="line"></div><div class="line">END_ENTRY __objc_msgLookup_uncached</div></pre></td></tr></table></figure>
<p>共同指向了<em>MethodTableLookup</em>这个方法，我们来看看这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">.macro MethodTableLookup</div><div class="line">	</div><div class="line">// push frame</div><div class="line">SignLR</div><div class="line">stp	fp, lr, [sp, #-16]!</div><div class="line">mov	fp, sp</div><div class="line"></div><div class="line">// save parameter registers: x0..x8, q0..q7</div><div class="line">sub	sp, sp, #(10*8 + 8*16)</div><div class="line">stp	q0, q1, [sp, #(0*16)]</div><div class="line">stp	q2, q3, [sp, #(2*16)]</div><div class="line">stp	q4, q5, [sp, #(4*16)]</div><div class="line">stp	q6, q7, [sp, #(6*16)]</div><div class="line">stp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">stp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">stp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">stp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">str	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</div><div class="line">// receiver and selector already in x0 and x1</div><div class="line">mov	x2, x16</div><div class="line">mov	x3, #3</div><div class="line">bl	_lookUpImpOrForward</div><div class="line"></div><div class="line">// IMP in x0</div><div class="line">mov	x17, x0</div><div class="line">	</div><div class="line">// restore registers and return</div><div class="line">ldp	q0, q1, [sp, #(0*16)]</div><div class="line">ldp	q2, q3, [sp, #(2*16)]</div><div class="line">ldp	q4, q5, [sp, #(4*16)]</div><div class="line">ldp	q6, q7, [sp, #(6*16)]</div><div class="line">ldp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">ldp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">ldp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">ldp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">ldr	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">mov	sp, fp</div><div class="line">ldp	fp, lr, [sp], #16</div><div class="line">AuthenticateLR</div><div class="line"></div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>我们暂时忽略寄存器先关操作，主要看方法调用逻辑，可以看到，内部是调用了<em>_lookUpImpOrForward</em> 这个方法，看命名应该能猜到是跟imp的查找和转发逻辑相关，那我们找找这个函数的定义，发现在汇编代码中没有相关定义，我们去runtime原文件中看看，果然在<em>objc_runtime-new.mm</em>的6094行发现了该函数的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* lookUpImpOrForward.</div><div class="line">* The standard IMP lookup. </div><div class="line">* Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)</div><div class="line">* Without LOOKUP_CACHE: skips optimistic unlocked lookup (but uses cache elsewhere)</div><div class="line">* Most callers should use LOOKUP_INITIALIZE and LOOKUP_CACHE</div><div class="line">* inst is an instance of cls or a subclass thereof, or nil if none is known. </div><div class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</div><div class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </div><div class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</div><div class="line">*   If you don&apos;t want forwarding at all, use LOOKUP_NIL.</div><div class="line">**********************************************************************/</div><div class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</div><div class="line">&#123;</div><div class="line">    const IMP forward_imp = (IMP)_objc_msgForward_impcache; // 这里imp有一个默认值 是一个坑点 具体下面解释。</div><div class="line">    </div><div class="line">    IMP imp = nil;</div><div class="line">    Class curClass;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line"></div><div class="line">    // Optimistic cache lookup // 再去缓存中查找一遍，防止多线程已调用</div><div class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        if (imp) goto done_nolock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.lock(); // 线程安全哦</div><div class="line"></div><div class="line">    checkIsKnownClass(cls);</div><div class="line"></div><div class="line">	// 下面两个操作是对类的继承链,ro,rw等数据的递归实例化，比较重要，不过不在这个文章的讨论范围 先不进去细看。</div><div class="line">    if (slowpath(!cls-&gt;isRealized())) &#123;</div><div class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</div><div class="line">    	 // 类的initialize()方法就是在这里被调用</div><div class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.assertLocked();</div><div class="line">    curClass = cls;</div><div class="line"></div><div class="line">    for (unsigned attempts = unreasonableClassCount();;) &#123;</div><div class="line">        </div><div class="line">        // 直接能从当前类的方法列表中查找到 </div><div class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">        if (meth) &#123;</div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">			</div><div class="line">		  // 如果已经查找完当前类的父类中了 给imp一个默认值然后跳出本次递归 </div><div class="line">		  // 还没有查找则将当前类赋值为父类 下面继续对父类进行查找</div><div class="line">        if (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</div><div class="line">            imp = forward_imp;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 是否还在继承链中查找</div><div class="line">        if (slowpath(--attempts == 0)) &#123;</div><div class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 从父类的缓存中查找 curclass已经在上面被赋值为父类了</div><div class="line">        // 这个方法也是汇编实现 复用的快查找的逻辑</div><div class="line">        imp = cache_getImp(curClass, sel);</div><div class="line">        </div><div class="line">        // 父类缓存中没有找到 跳出本轮递归 下次又从父类的父类中开始查找</div><div class="line">        if (slowpath(imp == forward_imp)) &#123;</div><div class="line">           break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 找到了 goto done </div><div class="line">        if (fastpath(imp)) &#123;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	// 以上逻辑走完，说明imp还是没有找到，这个时候会做一个动态的方法决议，这部分属于方法转发逻辑，暂时不进去细看。</div><div class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</div><div class="line">        behavior ^= LOOKUP_RESOLVER;</div><div class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> done:</div><div class="line"> 	// imp找到了，则进行缓存，缓存逻辑参考之前的文章</div><div class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">    runtimeLock.unlock();</div><div class="line"> done_nolock:</div><div class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上源码就是慢查找的整个流程，整体是一个递归查找继承连的过程，其中还有一些小的点可以在扩展下。</p>
<h5 id="扩展一-对当前方法列表的查找策略"><a href="#扩展一-对当前方法列表的查找策略" class="headerlink" title="扩展一 对当前方法列表的查找策略"></a>扩展一 对当前方法列表的查找策略</h5><p>我们可以深入看看代码逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">static method_t *</div><div class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line">    // fixme nil cls? </div><div class="line">    // fixme nil sel?</div><div class="line"></div><div class="line">	// 方法列表是多级的 </div><div class="line">    auto const methods = cls-&gt;data()-&gt;methods();</div><div class="line">    for (auto mlists = methods.beginLists(),</div><div class="line">              end = methods.endLists();</div><div class="line">         mlists != end;</div><div class="line">         ++mlists)</div><div class="line">    &#123;</div><div class="line">       method_t *m = search_method_list_inline(*mlists, sel);</div><div class="line">        if (m) return m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE static method_t *</div><div class="line">search_method_list_inline(const method_list_t *mlist, SEL sel)</div><div class="line">&#123;</div><div class="line">    int methodListIsFixedUp = mlist-&gt;isFixedUp();</div><div class="line">    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);</div><div class="line">    </div><div class="line">    if (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) &#123;</div><div class="line">        // 对已排序数据进行查找 你想到了什么？？？</div><div class="line">        return findMethodInSortedMethodList(sel, mlist);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Linear search of unsorted method list</div><div class="line">        for (auto&amp; meth : *mlist) &#123;</div><div class="line">            if (meth.name == sel) return &amp;meth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE static method_t *</div><div class="line">findMethodInSortedMethodList(SEL key, const method_list_t *list)</div><div class="line">&#123;</div><div class="line">    ASSERT(list);</div><div class="line"></div><div class="line">    const method_t * const first = &amp;list-&gt;first;</div><div class="line">    const method_t *base = first;</div><div class="line">    const method_t *probe;</div><div class="line">    uintptr_t keyValue = (uintptr_t)key;</div><div class="line">    uint32_t count;</div><div class="line">    </div><div class="line">    // 没有错 就是折半查找 不过apple的折半写的比较有逼格。</div><div class="line">    for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123;</div><div class="line">        probe = base + (count &gt;&gt; 1);</div><div class="line">        </div><div class="line">        uintptr_t probeValue = (uintptr_t)probe-&gt;name;</div><div class="line">        </div><div class="line">        // 如果已找到 则找到同名方法的第一个 这里说明列表内可能有方法名相同的方法，什么情况会出现呢？比如分类同名方法。说明一点，上层的结论在底层都是都代码依据的。</div><div class="line">        if (keyValue == probeValue) &#123;</div><div class="line">            while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123;</div><div class="line">                probe--;</div><div class="line">            &#125;</div><div class="line">            return (method_t *)probe;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (keyValue &gt; probeValue) &#123;</div><div class="line">            base = probe + 1;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="扩展二-默认的imp"><a href="#扩展二-默认的imp" class="headerlink" title="扩展二 默认的imp"></a>扩展二 默认的imp</h5><p>在查找函数的最前面，有下面这行初始化代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const IMP forward_imp = (IMP)_objc_msgForward_impcache;</div></pre></td></tr></table></figure>
<p>这个默认的imp具体指向哪里，我们来全局查找一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">STATIC_ENTRY __objc_msgForward_impcache</div><div class="line"></div><div class="line">// No stret specialization.</div><div class="line">b	__objc_msgForward</div><div class="line"></div><div class="line">END_ENTRY __objc_msgForward_impcache</div><div class="line"></div><div class="line"></div><div class="line">ENTRY __objc_msgForward</div><div class="line">// Non-stret version</div><div class="line"></div><div class="line">MI_GET_EXTERN(r12, __objc_forward_handler)</div><div class="line">ldr	r12, [r12]</div><div class="line">bx	r12</div><div class="line"></div><div class="line">END_ENTRY __objc_msgForward</div></pre></td></tr></table></figure>
<p>在汇编代码中找到<em> __objc_forward_handler</em>这里就线索中断，这个猜测应该是一个回调函数，ok，那我们去源代码里面看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Default forward handler halts the process.</div><div class="line">__attribute__((noreturn, cold)) void</div><div class="line">objc_defaultForwardHandler(id self, SEL sel)</div><div class="line">&#123;</div><div class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class="line">                &quot;(no message forward handler is installed)&quot;, </div><div class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div><div class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div></pre></td></tr></table></figure>
<p>是不是看到了我们非常熟悉的一个错误信息，没有错，这个默认的imp就是找不到方法实现的错误处理函数。此时，坑点也就出现了，如果你使用<em>class_getMethodImplementation</em>去查找一个未实现的方法时，不会返回空，而是返回这个函数的地址，这里需要注意一下。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上就是整个慢查找的流程和其中的一些相关的知识点的梳理，除了整体流程的分析，上面的两个扩展也是比较重要的。其中还有一些比较重要的内容没有做深入分析，如<em>realizeClassMaybeSwiftAndLeaveLocked</em>和<em>initializeAndLeaveLocked</em>,留到以后再做分析，毕竟这篇文章主要分析慢查找的流程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/04/从【nonpointer】探究OC类中isa指针/" itemprop="url">
                  从【nonpointer】探究OC类中isa指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-04T10:45:18+08:00" content="2021-01-04">
              2021-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/04/从【nonpointer】探究OC类中isa指针/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/从【nonpointer】探究OC类中isa指针/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在这篇文章<a href="http://llyblog.com/2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/" target="_blank" rel="noopener">从【class_getInstanceSize方法】探究iOS的内存分配策略</a>中，我们分析了OC类的内存分配策略，但是具体的初始化过程并没有提及，这里我们来探究下OC在内存的初始化过程中都做了什么。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们还是先看一下整个OC类的创建流程，如下图：</p>
<p><img src="https://raw.githubusercontent.com/lilingyu0620/LLYBlogImageSource/master/Alloc分析/alloc01.png" alt=""></p>
<p>其中标红的<em>_class_createInstanceFromZone</em>函数就是核心内容，我们直接来看看其内部实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">static ALWAYS_INLINE id</div><div class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</div><div class="line">                              int construct_flags = OBJECT_CONSTRUCT_NONE,</div><div class="line">                              bool cxxConstruct = true,</div><div class="line">                              size_t *outAllocatedSize = nil)</div><div class="line">&#123;</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line"></div><div class="line">    // Read class&apos;s info bits all at once for performance</div><div class="line">    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</div><div class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</div><div class="line">    bool fast = cls-&gt;canAllocNonpointer(); //是否支持nonpointer 这个是关键</div><div class="line">    size_t size;</div><div class="line"></div><div class="line">    size = cls-&gt;instanceSize(extraBytes);</div><div class="line">    if (outAllocatedSize) *outAllocatedSize = size;</div><div class="line"></div><div class="line">    id obj;</div><div class="line">    if (zone) &#123;</div><div class="line">        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</div><div class="line">    &#125; else &#123;</div><div class="line">        obj = (id)calloc(1, size);</div><div class="line">    &#125;</div><div class="line">    if (slowpath(!obj)) &#123;</div><div class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</div><div class="line">            return _objc_callBadAllocHandler(cls);</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!zone &amp;&amp; fast) &#123;</div><div class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor); // 支持nonpointer的类初始化过程 见下面的分析</div><div class="line">    &#125; else &#123;</div><div class="line">        // Use raw pointer isa on the assumption that they might be</div><div class="line">        // doing something weird with the zone or RR.</div><div class="line">        obj-&gt;initIsa(cls); // 不支持nonpointer的类初始化过程 见下面的分析</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (fastpath(!hasCxxCtor)) &#123;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</div><div class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags); // 默认添加一个cxx的析构函数</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">inline void </div><div class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</div><div class="line">&#123;</div><div class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</div><div class="line">    ASSERT(hasCxxDtor == cls-&gt;hasCxxDtor());</div><div class="line"></div><div class="line">    initIsa(cls, true, hasCxxDtor); // nonpointer直接写死为true</div><div class="line">&#125;</div><div class="line"></div><div class="line">inline void </div><div class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </div><div class="line">&#123; </div><div class="line">    ASSERT(!isTaggedPointer());  // 小对象类型直接返回 没有isa指针</div><div class="line">    </div><div class="line">    if (!nonpointer) &#123;</div><div class="line">        isa = isa_t((uintptr_t)cls); // 不支持nonpointer的对象直接将类对象赋值给isa</div><div class="line">    &#125; else &#123;</div><div class="line">        ASSERT(!DisableNonpointerIsa);</div><div class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</div><div class="line"></div><div class="line">        isa_t newisa(0);</div><div class="line">#if SUPPORT_INDEXED_ISA //判断平台</div><div class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; 0);</div><div class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</div><div class="line">        // isa.magic is part of ISA_MAGIC_VALUE</div><div class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</div><div class="line">#else</div><div class="line">        newisa.bits = ISA_MAGIC_VALUE;</div><div class="line">        // isa.magic is part of ISA_MAGIC_VALUE</div><div class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; // 前三位都不是存的类信息 所以先抛弃前三位再赋值</div><div class="line">#endif</div><div class="line">        // This write must be performed in a single store in some cases</div><div class="line">        // (for example when realizing a class because other threads</div><div class="line">        // may simultaneously try to use the class).</div><div class="line">        // fixme use atomics here to guarantee single-store and to</div><div class="line">        // guarantee memory order w.r.t. the class index table</div><div class="line">        // ...but not too atomic because we don&apos;t want to hurt instantiation</div><div class="line">        isa = newisa;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源码中我们看到初始化的过程实际上就是对<em>isa</em>指针赋值的过程，对于不满足nonpointer的对象，isa指针直接等于类对象，而nonpointer对象的isa就比较复杂了，这里我们再来分析下nonpointer下的isa指针的数据结构，如下：</p>
<h5 id="isa结构分析"><a href="#isa结构分析" class="headerlink" title="isa结构分析"></a>isa结构分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">// isa_t 也就是isa指针的结构类型是一个联合体，cls和bits共享64位的内存空间</div><div class="line">union isa_t &#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line">#if defined(ISA_BITFIELD)</div><div class="line">    struct &#123;</div><div class="line">        ISA_BITFIELD;  // defined in isa.h</div><div class="line">    &#125;;</div><div class="line">#endif</div><div class="line">&#125;;</div><div class="line"></div><div class="line"># if __arm64__</div><div class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class="line">#   define ISA_BITFIELD                                                      \</div><div class="line">      uintptr_t nonpointer        : 1; //是否是nonponiter类型                                     \</div><div class="line">      uintptr_t has_assoc         : 1; //是否有关联对象                                     \</div><div class="line">      uintptr_t has_cxx_dtor      : 1; //是否添加了cxx的析构函数                                     \</div><div class="line">      uintptr_t shiftcls          : 33;//类对象信息 /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</div><div class="line">      uintptr_t magic             : 6; //魔数                                      \</div><div class="line">      uintptr_t weakly_referenced : 1; //是否有弱引用                                     \</div><div class="line">      uintptr_t deallocating      : 1; //是否正在析构                                      \</div><div class="line">      uintptr_t has_sidetable_rc  : 1; //引用计数表中是否存了该对象的引用计数                                      \</div><div class="line">      uintptr_t extra_rc          : 19 //引用计数</div><div class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</div><div class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</div><div class="line"></div><div class="line"># elif __x86_64__</div><div class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class="line">#   define ISA_BITFIELD                                                        \</div><div class="line">      uintptr_t nonpointer        : 1;                                         \</div><div class="line">      uintptr_t has_assoc         : 1;                                         \</div><div class="line">      uintptr_t has_cxx_dtor      : 1;                                         \</div><div class="line">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \</div><div class="line">      uintptr_t magic             : 6;                                         \</div><div class="line">      uintptr_t weakly_referenced : 1;                                         \</div><div class="line">      uintptr_t deallocating      : 1;                                         \</div><div class="line">      uintptr_t has_sidetable_rc  : 1;                                         \</div><div class="line">      uintptr_t extra_rc          : 8</div><div class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</div><div class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</div></pre></td></tr></table></figure>
<p>可视化结构</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ISA/isa.jpeg" alt=""></p>
<p>结合上面的源码和图，nonpointer的isa指针的结构应该就比较清楚了。这个结构我们之后在分析iOS的内存管理的时候应该还会在具体分析。这里暂时先只做了解。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上分析，OC类的创建过程就比较清晰了，首先是通过内存对齐原则计算需要分配的内存大小，然后对类的isa指针进行初始化。到这里就可以确定一个类的对象了，那么类中superclass,cache（第一次有消息发送行为时创建内存）,bits等是在何时初始化的呢，这个留在以后探究。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/OC方法调用快查找流程底层逻辑探究/" itemprop="url">
                  OC方法调用快查找流程底层逻辑探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-03T20:23:45+08:00" content="2021-01-03">
              2021-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/03/OC方法调用快查找流程底层逻辑探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/03/OC方法调用快查找流程底层逻辑探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>As we know, OC上层的方法调用的底层逻辑都是通过<em>objc_msgSend</em>来实现的，那么如何验证呢？我们通过clang反编译看看就知道了：</p>
<p>上层的OC调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        // insert code here...</div><div class="line">        </div><div class="line">        LLYModel *model = [LLYModel alloc];</div><div class="line">        </div><div class="line">        [model func0];</div><div class="line">        </div><div class="line">        [model func1];</div><div class="line">        </div><div class="line">        NSLog(@&quot;Hello, World!&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用clang命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m -o main.cpp</div></pre></td></tr></table></figure>
<p>反编译之后的底层实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line"></div><div class="line">        LLYModel *model = ((LLYModel *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;LLYModel&quot;), sel_registerName(&quot;alloc&quot;));</div><div class="line"></div><div class="line">        ((void (*)(id, SEL))(void *)objc_msgSend)((id)model, sel_registerName(&quot;func0&quot;));</div><div class="line"></div><div class="line">        ((void (*)(id, SEL))(void *)objc_msgSend)((id)model, sel_registerName(&quot;func1&quot;));</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_71_gd0d02_n7td1h8k9l7bx0jqh0000gp_T_main_f2985d_mi_0);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，所有的方法调用全都被编译器转换为了<em>objc_msgSend</em>方法的调用，我们很自然的去runtime源码中找该函数的实现逻辑，结果在<em>.mm</em>文件中没有发现，以为线索就要断了的时候，在<em>objc-msg-arm64.s</em>文件内看到了下面几行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ENTRY _objc_msgSend</div><div class="line">UNWIND _objc_msgSend, NoFrame</div><div class="line"></div><div class="line">cmp	p0, #0	 //p0寄存器保存的应该是objc_msgSend()的第一个参数receive // nil check and tagged pointer check </div><div class="line"></div><div class="line">// taggedpointer判断</div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</div><div class="line">#else</div><div class="line">b.eq	LReturnZero</div><div class="line">#endif</div><div class="line"></div><div class="line">// 拿到receive的isa指针</div><div class="line">ldr	p13, [x0]		// p13 = isa</div><div class="line"></div><div class="line">// 拿到类对象</div><div class="line">GetClassFromIsa_p16 p13		// p16 = class</div><div class="line">LGetIsaDone:</div><div class="line"></div><div class="line">// calls imp or objc_msgSend_uncached</div><div class="line">CacheLookup NORMAL, _objc_msgSend</div></pre></td></tr></table></figure>
<p>这里应该就是<em>objc_msgSend</em>的入口了，原来是使用汇编代码来实现的，只能硬着头皮看下去了。</p>
<p>上面的逻辑最终调用了<em>CacheLookup</em>这个函数，我们全局搜一下，找到了该函数的实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.macro CacheLookup</div><div class="line"></div><div class="line">LLookupStart$1:</div><div class="line"></div><div class="line">	// p1 = SEL, p16 = isa</div><div class="line">	// #define CACHE            (2 * __SIZEOF_POINTER__)</div><div class="line">	// 从isa指针首地址偏移16个字节，这一步操作是拿到类的cache数据，原理参考类结构的定义。</div><div class="line">	ldr	p11, [x16, #CACHE]				// p11 = mask|buckets</div><div class="line"></div><div class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</div><div class="line">	// 参考cache_t中的结构 这一步是拿到缓存的buckts数组</div><div class="line">	and	p10, p11, #0x0000ffffffffffff	// p10 = buckets</div><div class="line">	// 计算_cmd(也就是sel)的索引</div><div class="line">	and	p12, p1, p11, LSR #48		// x12 = _cmd &amp; mask</div><div class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</div><div class="line">	and	p10, p11, #~0xf			// p10 = buckets</div><div class="line">	and	p11, p11, #0xf			// p11 = maskShift</div><div class="line">	mov	p12, #0xffff</div><div class="line">	lsr	p11, p12, p11				// p11 = mask = 0xffff &gt;&gt; p11</div><div class="line">	and	p12, p1, p11				// x12 = _cmd &amp; mask</div><div class="line">#else</div><div class="line">#error Unsupported cache mask storage for ARM64.</div><div class="line">#endif</div><div class="line">	// #define PTRSHIFT 3  // 1&lt;&lt;PTRSHIFT == PTRSIZE</div><div class="line">	// 根据上面的索引值获取具体的bucket数据 每一个bucket是16个字节 所以这一要向左平移4位</div><div class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</div><div class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class="line"></div><div class="line">	// 拿到sel和imp元组</div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">	</div><div class="line">	// 下面就是一个条件判断和分支语句了</div><div class="line">	</div><div class="line">	// 找到的sel不是当前执行的方法</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	// goto 2</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	// 否则直接命中</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">	// 未命中逻辑</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	// 空判断</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	// 当前是否已经寻址到buckets的第一个元素</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	// 是的话 goto 3</div><div class="line">	b.eq	3f</div><div class="line">	// 不是的话 向前移位继续查找</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	// 这是一个循环查找的过程</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// wrap: p12 = first bucket, w11 = mask</div><div class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</div><div class="line">	// 已经寻址到buckets的第一个元素，直接干到最后一个元素，再重新开始向前查找。</div><div class="line">	add	p12, p12, p11, LSR #(48 - (1+PTRSHIFT))</div><div class="line">					// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</div><div class="line">	add	p12, p12, p11, LSL #(1+PTRSHIFT)</div><div class="line">					// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line">#else</div><div class="line">#error Unsupported cache mask storage for ARM64.</div><div class="line">#endif</div><div class="line"></div><div class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class="line">	// The slow path may detect any corruption and halt later.</div><div class="line"></div><div class="line">	// 这里的逻辑和上面类似</div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	// 如果再次寻址到第一个元素 </div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	// goto 3 未命中 跳出循环</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">LLookupEnd$1:</div><div class="line">LLookupRecover$1:</div><div class="line">3:	// double wrap</div><div class="line">	JumpMiss $0</div><div class="line"></div><div class="line">.endmacro</div><div class="line"></div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">通过以上汇编代码分析，可以发现方法缓存的查找是一个从后往前遍历buckets的过程，如果当前遍历到第一个元素，会回到队尾继续遍历，知道找到我们需要的元素，或者在再一次查找到第一个元素后，会退出循环，然后我们看看缓存命中和未命中分别做了啥：</div><div class="line"></div><div class="line">##### 缓存命中</div></pre></td></tr></table></figure>
<p>.macro CacheHit<br>.if $0 == NORMAL<br>    TailCallCachedImp x17, x12, x1, x16    // authenticate and call imp<br>.elseif $0 == GETIMP<br>    mov    p0, p17<br>    cbz    p0, 9f            // don’t ptrauth a nil imp<br>    AuthAndResignAsIMP x0, x12, x1, x16    // authenticate imp and re-sign as IMP<br>9:    ret                // return IMP<br>.elseif $0 == LOOKUP<br>    // No nil check for ptrauth: the caller would crash anyway when they<br>    // jump to a nil IMP. We don’t care if that jump also fails ptrauth.<br>    AuthAndResignAsIMP x17, x12, x1, x16    // authenticate imp and re-sign as IMP<br>    ret                // return imp via x17<br>.else<br>.abort oops<br>.endif<br>.endmacro</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 缓存未命中</div></pre></td></tr></table></figure>
<p>.macro JumpMiss<br>.if $0 == GETIMP<br>    b    LGetImpMiss<br>.elseif $0 == NORMAL<br>    b    <strong>objc_msgSend_uncached<br>.elseif $0 == LOOKUP<br>    b    </strong>objc_msgLookup_uncached<br>.else<br>.abort oops<br>.endif<br>.endmacro</p>
<p>```</p>
<p>都只是根据类型不同调用了对应的方法，这里已经不再是快查询的逻辑，我们暂时不看。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这里先点个题，所谓的快查找就是对cache的查找，与之对应的慢查找就是对method_list的查找了，method_list的查找可能涉及到不同文件的遍历过程，所以会比cache慢很多。通过查看汇编实现，我的主要感受就是对类结构的熟悉是非常重要的，因为所有的查找逻辑都是基于类的结构来的。我们在实际编码过程中，也应该做到庖丁解牛，而不是盲人摸象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/OC方法缓存策略底层探究/" itemprop="url">
                  OC方法缓存策略底层探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-03T16:51:09+08:00" content="2021-01-03">
              2021-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/03/OC方法缓存策略底层探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/03/OC方法缓存策略底层探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="源码结构分析"><a href="#源码结构分析" class="headerlink" title="源码结构分析"></a>源码结构分析</h4><p>我们先来看一下OC类的最新结构定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA;</div><div class="line">    Class superclass;</div><div class="line">    cache_t cache;             // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class="line">    // 函数部分...</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">public:</div><div class="line">    // 函数部分...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的文章中我们分析了bits这个属性，里面存放的就是类的子结构，比如方法，属性，协议等。今天我们再来探究下上面的cache内部的结构和底层原理。</p>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>相信大家对cache都不会陌生，即OC中的方法缓存，在objc_msgSend的流程中，最先查找的就是这个列表，那OC是如何维护这个列表的呢，内部的存储结构又是如何？今天我们就来一探究竟。</p>
<p>之前我们使用lldb调试了bits内部的存储结构，但是这个方式比较繁琐，今天我们换一种简单点的方式来Debug，我们首先镜像一个objc_class结构体，然后对镜像的结构体进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct lly_bucket_t &#123;</div><div class="line">    SEL _sel;</div><div class="line">    IMP _imp;</div><div class="line">&#125;;</div><div class="line">struct lly_cache_t &#123;</div><div class="line">    struct lly_bucket_t * _buckets;</div><div class="line">    uint32_t _mask;</div><div class="line">    uint16_t _flags;</div><div class="line">    uint16_t _occupied;</div><div class="line">&#125;;</div><div class="line">struct lly_class_data_bits_t &#123;</div><div class="line">    Class objc_class;</div><div class="line">    // Values are the FAST_ flags above.</div><div class="line">    uintptr_t bits;</div><div class="line">&#125;;</div><div class="line">struct lly_objc_class &#123;</div><div class="line">    Class ISA;</div><div class="line">    Class superclass;</div><div class="line">    struct lly_cache_t cache;</div><div class="line">    struct lly_class_data_bits_t bits;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void printCache(Class model) &#123;</div><div class="line">    </div><div class="line">    struct lly_objc_class * llyClass = (__bridge struct lly_objc_class *)(model);</div><div class="line">    struct lly_cache_t cache = llyClass-&gt;cache;</div><div class="line">    NSLog(@&quot;_occupied = %d,_mask = %d&quot;,cache._occupied,cache._mask);</div><div class="line">    for (uint32_t i = 0; i &lt; cache._mask; i++) &#123;</div><div class="line">        struct lly_bucket_t bucket = cache._buckets[i];</div><div class="line">        NSLog(@&quot;method : sel = %@, imp = %p&quot;,NSStringFromSelector(bucket._sel),bucket._imp);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">	    // insert code here...</div><div class="line">	    LLYModel *objc2 = [LLYModel alloc];</div><div class="line">	    Class llyClass = [LLYModel class];</div><div class="line">	    printCache(llyClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们不调用任何实例方法，查看打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2021-01-03 15:59:51.995108+0800 LLYObjc[1738:6603344] _occupied = 0,_mask = 0</div></pre></td></tr></table></figure>
<p>可以看到，初始状态都是0，里面的for也没有进 说明当前缓存列表为空。</p>
<p>然后我们分次调用方法并打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        // insert code here...</div><div class="line">        LLYModel *objc2 = [LLYModel alloc];</div><div class="line">        Class llyClass = [LLYModel class];</div><div class="line">        printCache(llyClass);</div><div class="line">        </div><div class="line">        [objc2 fun0];</div><div class="line">        [objc2 fun1];</div><div class="line">        </div><div class="line">        printCache(llyClass);</div><div class="line">                </div><div class="line">        [objc2 fun2];</div><div class="line">        [objc2 fun3];</div><div class="line">        </div><div class="line">        printCache(llyClass);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">2021-01-03 16:05:09.335088+0800 LLYModel[1804:6607181] _occupied = 0,_mask = 0</div><div class="line">2021-01-03 16:05:09.335668+0800 LLYModel[1804:6607181] ---------------------------------------------------------------------------</div><div class="line">2021-01-03 16:05:09.335785+0800 LLYModel[1804:6607181] -[LLYModel fun0]</div><div class="line">2021-01-03 16:05:09.335875+0800 LLYModel[1804:6607181] -[LLYModel fun1]</div><div class="line">2021-01-03 16:05:09.335959+0800 LLYModel[1804:6607181] _occupied = 2,_mask = 3</div><div class="line">2021-01-03 16:05:09.336174+0800 LLYModel[1804:6607181] method : sel = fun1, imp = 0xbf90</div><div class="line">2021-01-03 16:05:09.336245+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.336344+0800 LLYModel[1804:6607181] method : sel = fun0, imp = 0xbfc0</div><div class="line">2021-01-03 16:05:09.336397+0800 LLYModel[1804:6607181] ---------------------------------------------------------------------------</div><div class="line">2021-01-03 16:05:09.336447+0800 LLYModel[1804:6607181] -[LLYModel fun2]</div><div class="line">2021-01-03 16:05:09.336497+0800 LLYModel[1804:6607181] -[LLYModel fun3]</div><div class="line">2021-01-03 16:05:09.336542+0800 LLYModel[1804:6607181] _occupied = 2,_mask = 7</div><div class="line">2021-01-03 16:05:09.336618+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.336737+0800 LLYModel[1804:6607181] method : sel = fun3, imp = 0xbf30</div><div class="line">2021-01-03 16:05:09.336818+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344380+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344554+0800 LLYModel[1804:6607181] method : sel = fun2, imp = 0xbf60</div><div class="line">2021-01-03 16:05:09.344657+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344746+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344833+0800 LLYModel[1804:6607181] ---------------------------------------------------------------------------</div></pre></td></tr></table></figure>
<p>分析打印结果，我们存在几个疑惑的地方：</p>
<ul>
<li>_occupied 和 _mask 分别是什么，为什么调用方法会改变它们的值？</li>
<li>方法的调用顺序和缓存列表的顺序为什么不一致？</li>
<li>当我们调用后面的方法后，前面缓存的方法为什么会丢失？</li>
</ul>
<p>带着上面的问题，我们去源码中看看能不能找到满意的答案。</p>
<h4 id="源码逻辑分析"><a href="#源码逻辑分析" class="headerlink" title="源码逻辑分析"></a>源码逻辑分析</h4><p>通过对<em>occupied</em>关键字的搜索，我们最终定位到下面这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">ALWAYS_INLINE</div><div class="line">void cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)</div><div class="line">&#123;	 </div><div class="line">	// 去掉我们不关系的旁枝末节</div><div class="line"></div><div class="line">    // Use the cache as-is if it is less than 3/4 full</div><div class="line">    // 每次新插入缓存时occupied + 1，这里我们大概就能猜到它的含义了，就是保存当前已缓存方法的数量。</div><div class="line">    mask_t newOccupied = occupied() + 1;</div><div class="line">    unsigned oldCapacity = capacity(), capacity = oldCapacity;</div><div class="line">    </div><div class="line">    // 如果当前缓存列表为空 去创建一个</div><div class="line">    if (slowpath(isConstantEmptyCache())) &#123;</div><div class="line">        // Cache is read-only. Replace it.</div><div class="line">        // INIT_CACHE_SIZE_LOG2 = 2,</div><div class="line">    	 // INIT_CACHE_SIZE      = (1 &lt;&lt; INIT_CACHE_SIZE_LOG2),</div><div class="line">    	 // 看这里，初始的缓存列表的容量是 1 &lt;&lt; 2 = 4。</div><div class="line">        if (!capacity) capacity = INIT_CACHE_SIZE;</div><div class="line">        reallocate(oldCapacity, capacity, /* freeOld */false);</div><div class="line">    &#125;</div><div class="line">    else if (fastpath(newOccupied + CACHE_END_MARKER &lt;= capacity / 4 * 3)) &#123;</div><div class="line">        // Cache is less than 3/4 full. Use it as-is.</div><div class="line">        // (当前缓存列表用到的容量 + 1 ) &lt;= 总容量的四分之三时 说明还够用 啥也不用干</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">    	 // 要扩容了，新的容量大小为当前容量的2倍哦 当然有最大值的限制哈。 </div><div class="line">    	 // 具体扩容逻辑下看面的扩容函数注释</div><div class="line">        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;</div><div class="line">        if (capacity &gt; MAX_CACHE_SIZE) &#123;</div><div class="line">            capacity = MAX_CACHE_SIZE;</div><div class="line">        &#125;</div><div class="line">        reallocate(oldCapacity, capacity, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bucket_t *b = buckets();</div><div class="line">    // _mask = 当前容量 - 1</div><div class="line">    mask_t m = capacity - 1;</div><div class="line">    // 缓存的索引通过这个hash计算 </div><div class="line">    mask_t begin = cache_hash(sel, m);</div><div class="line">    mask_t i = begin;</div><div class="line"></div><div class="line">    // Scan for the first unused slot and insert there.</div><div class="line">    // There is guaranteed to be an empty slot because the</div><div class="line">    // minimum size is 4 and we resized at 3/4 full.</div><div class="line">    do &#123;</div><div class="line">    	 // 如果当前索引没有数据，直接插入</div><div class="line">        if (fastpath(b[i].sel() == 0)) &#123;</div><div class="line">        	  // _occupied++;</div><div class="line">            incrementOccupied();</div><div class="line">            b[i].set&lt;Atomic, Encoded&gt;(sel, imp, cls);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 如果当前索引内存的就是传入的方法，直接返回</div><div class="line">        if (b[i].sel() == sel) &#123;</div><div class="line">            // The entry was added to the cache by some other thread</div><div class="line">            // before we grabbed the cacheUpdateLock.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 否则就是寻找下一个索引</div><div class="line">    &#125; while (fastpath((i = cache_next(i, m)) != begin));</div><div class="line"></div><div class="line">    cache_t::bad_cache(receiver, (SEL)sel, cls);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 初始化和扩容都走这个函数</div><div class="line">ALWAYS_INLINE</div><div class="line">void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld)</div><div class="line">&#123;</div><div class="line">    bucket_t *oldBuckets = buckets();</div><div class="line">    // 分配内存</div><div class="line">    bucket_t *newBuckets = allocateBuckets(newCapacity);</div><div class="line"></div><div class="line">    // Cache&apos;s old contents are not propagated. </div><div class="line">    // This is thought to save cache memory at the cost of extra cache fills.</div><div class="line">    // fixme re-measure this</div><div class="line"></div><div class="line">    ASSERT(newCapacity &gt; 0);</div><div class="line">    ASSERT((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1);</div><div class="line">	</div><div class="line">	// 存储新创建缓存列表 _occupied置0</div><div class="line">    setBucketsAndMask(newBuckets, newCapacity - 1);</div><div class="line">    </div><div class="line">    // 要扩容了 free调旧值</div><div class="line">    if (freeOld) &#123;</div><div class="line">        cache_collect_free(oldBuckets, oldCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当前索引 </div><div class="line">static inline mask_t cache_hash(SEL sel, mask_t mask) </div><div class="line">&#123;</div><div class="line">    return (mask_t)(uintptr_t)sel &amp; mask;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 下一个索引</div><div class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class="line">    return (i+1) &amp; mask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这又是一个内联函数，意味这你在调用堆栈里面是看不到的。但是我们通过源码还是可以Debug进来的。<br>通过以上源码的分析过程，应该能够回答我们上面的疑问了。</p>
<ul>
<li>_occupied表示当前已缓存的的方法数，_mask标识当前缓存列表最大数-1，有新的方法调用_occupied就会更新，缓存列表扩容时_mask会更新。</li>
<li>存储到缓存列表中的方法并不一定是连续的，和具体的hash算法有关。</li>
<li>当缓存列表扩容后，之前缓存过的方法都会被清除，所以会丢失。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当前的探索因为工程比较小，可能还不能看出方法cache的好处，在实际的工程中，方法的调用是大量且频繁的，这时就能体现出方法缓存的实际意义。之前的学习中对方法缓存丢失的逻辑不太了解，经过这次的探索，对整个方法缓存的策略有了更深刻的理解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/OC方法isKindOfClass趣探/" itemprop="url">
                  OC方法isKindOfClass趣探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-03T11:44:27+08:00" content="2021-01-03">
              2021-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/03/OC方法isKindOfClass趣探/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/03/OC方法isKindOfClass趣探/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="起"><a href="#起" class="headerlink" title="起"></a>起</h4><p>我们先来看一下下面的一个面试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];       //</div><div class="line">BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];     //</div><div class="line">BOOL re3 = [(id)[LLYModel class] isKindOfClass:[LLYModel class]];       //</div><div class="line">BOOL re4 = [(id)[LLYModel class] isMemberOfClass:[LLYModel class]];     //</div><div class="line">NSLog(@&quot; re1 :%hhd\n re2 :%hhd\n re3 :%hhd\n re4 :%hhd\n&quot;,re1,re2,re3,re4);</div><div class="line"></div><div class="line">BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];       //</div><div class="line">BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     //</div><div class="line">BOOL re7 = [(id)[LLYModel alloc] isKindOfClass:[LLYModel class]];       //</div><div class="line">BOOL re8 = [(id)[LLYModel alloc] isMemberOfClass:[LLYModel class]];     //</div><div class="line">NSLog(@&quot; re5 :%hhd\n re6 :%hhd\n re7 :%hhd\n re8 :%hhd\n&quot;,re5,re6,re7,re8);</div></pre></td></tr></table></figure>
<p>请问输出分别是多少呢？大家可以自己试一试，答案分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">re1 :1</div><div class="line">re2 :0</div><div class="line">re3 :0</div><div class="line">re4 :0</div><div class="line"></div><div class="line">re5 :1</div><div class="line">re6 :1</div><div class="line">re7 :1</div><div class="line">re8 :1</div></pre></td></tr></table></figure>
<h4 id="承"><a href="#承" class="headerlink" title="承"></a>承</h4><p>我们直接看源码进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//直接判断当前类的元类是否和后面的类相等。</div><div class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return self-&gt;ISA() == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//直接判断是不是同一个类对象</div><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用当前类对象的元类的继承链和后面的类对象进行比较，只要后面的类对象在当前元类的继承链中，既判断相等。</div><div class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用当前实例的类对象的继承链和后面的类对象进行比较，只要后面的类在当前类的继承链中，既判断是相等。</div><div class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下上面的判断逻辑大概是这样：</p>
<p>isKindOfClass会使用继承链比较，实例方法使用类对象的继承链，类方法使用元类对象的继承链。<br>isMemberOfClass直接比较，实例方法使用类对象，类方法使用元类对象。</p>
<p>看到这里，不得不再次祭出下面这张图了：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ISA/isa流程图.png" alt=""></p>
<p>我们来瞧瞧元类对象的继承链，根元类的superclass指针指向的是根类，这也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];       //</div></pre></td></tr></table></figure>
<p>这里为什么返回1的原因。</p>
<h4 id="转"><a href="#转" class="headerlink" title="转"></a>转</h4><p>有了以上结论，我们再来Debug一下runtime的代码，看一下这几个函数内部的运行逻辑是否和我们上面的结论一致。</p>
<h5 id="isMemberOfClass-lldb分析"><a href="#isMemberOfClass-lldb分析" class="headerlink" title="isMemberOfClass lldb分析"></a>isMemberOfClass lldb分析</h5><p>先来看看类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];     //</div><div class="line"></div><div class="line">(lldb) x/4gx self //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100888a40 0x0001801000000003</div><div class="line">(lldb) x/4gx cls  //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100888a40 0x0001801000000003</div><div class="line">(lldb) x/4gx 0x000000010034c0f0（ISA） //元类对象也是根源类</div><div class="line">0x10034c0f0: 0x000000010034c0f0 0x000000010034c140</div><div class="line">0x10034c100: 0x0000000100739650 0x0004e03100000007</div></pre></td></tr></table></figure>
<p>这里就很清晰，类对象只有一个，因为他们的首地址和内部变量都相同 ,根元类对象也只有一个，但是和类对象首地址不同，ISA指针相同，这又证明了上图的内容，即根源类的ISA指向自己。根元类和类对象不相等，返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">BOOL re4 = [(id)[LLYModel class] isMemberOfClass:[LLYModel class]];     //</div><div class="line"></div><div class="line">(lldb) x/4gx self //类对象</div><div class="line">0x100008408: 0x00000001000083e0 0x000000010034c140</div><div class="line">0x100008418: 0x0000000100346430 0x0000802400000000</div><div class="line">(lldb) x/4gx cls  //类对象</div><div class="line">0x100008408: 0x00000001000083e0 0x000000010034c140</div><div class="line">0x100008418: 0x0000000100346430 0x0000802400000000</div><div class="line">(lldb) x/4gx 0x00000001000083e0 //元类对象</div><div class="line">0x1000083e0: 0x000000010034c0f0 0x000000010034c0f0</div><div class="line">0x1000083f0: 0x00000001007396d0 0x0002e03500000003</div><div class="line">(lldb) x/4gx 0x000000010034c0f0 //根源类对象</div><div class="line">0x10034c0f0: 0x000000010034c0f0 0x000000010034c140</div><div class="line">0x10034c100: 0x0000000100739650 0x0004e03100000007</div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>因为是自定义的类，所以会有一个元类对象，元类对象isa指向上面的根元类，元类和类对象不相等，返回0，没有问题。</p>
<p>然后我们来看看实例方法，<strong>实例对象的内存分析和类对象有一点区别，请注意！！！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     //</div><div class="line"></div><div class="line">(lldb) x/4gx self //实例对象</div><div class="line">0x100629c30: 0x001d80010034c141 0x0000000000000000</div><div class="line">0x100629c40: 0x00007fff7ba35c58 0x00000000e642baab</div><div class="line">(lldb) x/4gx cls  //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100629c80 0x0001801000000007</div><div class="line">(lldb) p/x 0x001d80010034c141 &amp; 0x00007ffffffffff8ULL //这里是重要，实例对象的isa指针是nonpointer_isa 如果想要拿到类对象信息，需要带个面具。！！！</div><div class="line">(unsigned long long) $40 = 0x000000010034c140</div><div class="line">(lldb) x/4gx 0x000000010034c140 //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100629c80 0x0001801000000007</div></pre></td></tr></table></figure>
<p>在分析前，我们先回到源码部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self class]</div></pre></td></tr></table></figure>
<p>怎么理解呢？</p>
<p>实际上分两种情况：</p>
<ul>
<li>当self是实例对象时，class是实例方法，返回isa指针，也就是类对象</li>
<li>当self是类或者元类对象时，class是类方法，返回自己。</li>
</ul>
<p>所以上面我需要拿到self的isa指向的内存，但是self的isa不能直接打印内存，因为nonpointer_isa对isa进行了优化，存储很多其他的信息，我们需要先使用面具过滤掉其他不需要的信息，才能拿到isa中存储的类对象地址。从lldb打印情况可以看到，self实例对象的isa指向的就是类对象，所以这里返回1.</p>
<p>re8的分析过程和re6相似，就不再重复劳动了。</p>
<h5 id="特殊的isKindOfClass"><a href="#特殊的isKindOfClass" class="headerlink" title="特殊的isKindOfClass"></a>特殊的isKindOfClass</h5><p>为什么要加上【特殊】这个前缀呢，原因很简单，isKindOfClass里面的断点根本没有进去，可见runtime内部对这个方法的调用可能走的就不是我们上面的实现，这种情况我们之前在alloc的分析过程中也遇到过，所以不要慌。经过在源码中一番搜索，我们最终找到下面这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// Calls [obj isKindOfClass]</div><div class="line">BOOL</div><div class="line">objc_opt_isKindOfClass(id obj, Class otherClass)</div><div class="line">&#123;</div><div class="line">#if __OBJC2__</div><div class="line">    if (slowpath(!obj)) return NO;</div><div class="line">    Class cls = obj-&gt;getIsa();</div><div class="line">    if (fastpath(!cls-&gt;hasCustomCore())) &#123;</div><div class="line">        for (Class tcls = cls; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">            if (tcls == otherClass) return YES;</div><div class="line">        &#125;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    return ((BOOL(*)(id, SEL, Class))objc_msgSend)(obj, @selector(isKindOfClass:), otherClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部的判断逻辑和我们上面看到的源码一样，所有我们可以在这个函数中进行debug了，不过这个debug过程已经不是重点了，重点是为什么会走到这个函数里面，上面的函数又是什么时候调用，因为有了之前的经验，我们直接去llvm中看能否寻找的一些答案。</p>
<p>果不其然，我们在llvm的源码中发现了这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// This is the table of ObjC &quot;accelerated dispatch&quot; functions.  They are a set</div><div class="line">// of objc methods that are &quot;seldom overridden&quot; and so the compiler replaces the</div><div class="line">// objc_msgSend with a call to one of the dispatch functions.  That will check</div><div class="line">// whether the method has been overridden, and directly call the Foundation </div><div class="line">// implementation if not.  </div><div class="line">// This table is supposed to be complete.  If ones get added in the future, we</div><div class="line">// will have to add them to the table.</div><div class="line">const char *AppleObjCTrampolineHandler::g_opt_dispatch_names[] = &#123;</div><div class="line">    &quot;objc_alloc&quot;,</div><div class="line">    &quot;objc_autorelease&quot;,</div><div class="line">    &quot;objc_release&quot;,</div><div class="line">    &quot;objc_retain&quot;,</div><div class="line">    &quot;objc_alloc_init&quot;,</div><div class="line">    &quot;objc_allocWithZone&quot;,</div><div class="line">    &quot;objc_opt_class&quot;,</div><div class="line">    &quot;objc_opt_isKindOfClass&quot;,</div><div class="line">    &quot;objc_opt_new&quot;,</div><div class="line">    &quot;objc_opt_respondsToSelector&quot;,</div><div class="line">    &quot;objc_opt_self&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在注释中，我们发现了【加速派发】，【不常重写】等字样，这里我们大胆猜测就是llvm在底层为了优化方法的调用速度，对下面列表中的方法做了优化，会优先进到这些优化方法中去，如果我们重写isKindOfClass等方法，可能才会进入之前我们看到的函数中去。</p>
<p>ok 来尝试一下我们的猜测，很简单，我们只需要重写一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isKindOfClass:(Class)aClass &#123;</div><div class="line">    return [super isKindOfClass:aClass];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isKindOfClass:(Class)aClass &#123;</div><div class="line">    return [super isKindOfClass:aClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，在我们重写之后，之前的断点就生效了，完美！！！</p>
<h4 id="合"><a href="#合" class="headerlink" title="合"></a>合</h4><p>源码的探索过程还是比较有趣的，不过如果你找不到正确的方法的话，可能跟到一个方法后就很难再深入进入，导致直接放弃，打击学习的积极性，所以还是要多看多学，不断积累才行啊。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/02/借助lldb探究OC类结构的底层实现/" itemprop="url">
                  借助lldb探究OC类结构的底层实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-02T21:12:55+08:00" content="2021-01-02">
              2021-01-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/02/借助lldb探究OC类结构的底层实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/02/借助lldb探究OC类结构的底层实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="类结构源码"><a href="#类结构源码" class="headerlink" title="类结构源码"></a>类结构源码</h4><p>我们先来看一下runtime中类的结构定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">//下面的函数部分去掉 因为不影响类结构</div><div class="line">//...</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA; // 8字节</div><div class="line">    Class superclass; // 8字节</div><div class="line">    cache_t cache;    // 16字节         // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits; //这里存的就是类的主要结构    // class_rw_t * plus custom rr/alloc flags</div><div class="line">    </div><div class="line">    // 具体结构体数据</div><div class="line">    class_rw_t *data() const &#123;</div><div class="line">        return bits.data();</div><div class="line">    &#125;</div><div class="line">    void setData(class_rw_t *newData) &#123;</div><div class="line">        bits.setData(newData);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //下面的函数部分去掉 因为不影响类结构</div><div class="line">	//...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的结构体定义可以看出，每一个类的第一个属性都会是一个isa指针，然后是super和cache,之后的bits里面就是类的结构，我们需要使用llbd命令Debug bits内部的内存分配情况，在开始探究之前，我们可以先熟悉下bits中包含的主要数据结构，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">struct class_rw_t &#123;</div><div class="line">   </div><div class="line">   	 // 去掉了一些不关心的函数 只留下比较关心的下面这几个数据</div><div class="line">    </div><div class="line">    // 只读部分</div><div class="line">    const class_ro_t *ro() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (slowpath(v.is&lt;class_rw_ext_t *&gt;())) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;ro;</div><div class="line">        &#125;</div><div class="line">        return v.get&lt;const class_ro_t *&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void set_ro(const class_ro_t *ro) &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            v.get&lt;class_rw_ext_t *&gt;()-&gt;ro = ro;</div><div class="line">        &#125; else &#123;</div><div class="line">            set_ro_or_rwe(ro);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    const method_array_t methods() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;methods;</div><div class="line">        &#125; else &#123;</div><div class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseMethods()&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const property_array_t properties() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;properties;</div><div class="line">        &#125; else &#123;</div><div class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProperties&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const protocol_array_t protocols() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;protocols;</div><div class="line">        &#125; else &#123;</div><div class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProtocols&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们熟悉的函数列表，属性列表和协议列表都在其中，下面我们就通过内存堆栈的Debug来证明下上面的类结构。</p>
<h4 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h4><p>在开始探索前，我们先来看一下这张图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ISA/isa流程图.png" alt=""></p>
<p>这里有一个知识点我们需要了解，一个类（不考虑继承）在内存中会存在3种与它有关联的对象，分别是实例对象，类对象和元类对象，这3种对象通过isa指针进行关联，实例对象可能存在多个，类对象和元类对象是唯一的。其中类对象存储实例方法和属性，元类对象存储类方法。</p>
<h4 id="开始探究"><a href="#开始探究" class="headerlink" title="开始探究"></a>开始探究</h4><p>我们先来自定义一个简单的类，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface LLYModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *name;</div><div class="line"></div><div class="line">- (void)sayHey;</div><div class="line"></div><div class="line">+ (void)sayBey;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation LLYModel &#123;</div><div class="line">    int _age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sayHey&#123;&#125;</div><div class="line"></div><div class="line">+ (void)sayBey&#123;&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        // insert code here...</div><div class="line">        LLYModel *objc2 = [LLYModel alloc];</div><div class="line">        objc2.name      = @&quot;lly&quot;;</div><div class="line">        NSLog(@&quot;Hello, World!  %@&quot;,objc2.name);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h5><p>在主函数中我们简单创建一个上面的model实例，然后就可以断点调试了,首先我们查看实例对象的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/4gx objc2</div><div class="line">0x1006a8a20: 0x001d8001000083ed 0x0000000000000000</div><div class="line">0x1006a8a30: 0x0000000100004018 0x0000000000000000</div></pre></td></tr></table></figure>
<p>根据对源码的分析，我们知道bits数据存储在首地址偏移32个字节的地方，so我们这样访问bits的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) p (class_data_bits_t *)0x1006a8a40</div><div class="line">(class_data_bits_t *) $94 = 0x00000001006a8a40</div></pre></td></tr></table></figure>
<p>拿到bits的地址后，然后访问改结构体的data方法拿到class_rw_t数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(lldb) p $94-&gt;data()</div><div class="line">(class_rw_t *) $97 = 0x00007fff97ca45c0</div><div class="line">(lldb) p *$97</div><div class="line">(class_rw_t) $98 = &#123;</div><div class="line">  flags = 2546615872</div><div class="line">  witness = 32767</div><div class="line">  ro_or_rw_ext = &#123;</div><div class="line">    std::__1::atomic&lt;unsigned long&gt; = &#123;</div><div class="line">      Value = 140735591042296</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  firstSubclass = 0x0000000100346430</div><div class="line">  nextSiblingClass = 0x0000800000000000</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以访问该结构内部的相关方法获取数据了，比如方法列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(lldb) p $98.methods()</div><div class="line">(const method_array_t) $99 = &#123;</div><div class="line">  list_array_tt&lt;method_t, method_list_t&gt; = &#123;</div><div class="line">     = &#123;</div><div class="line">      list = 0x0000000102004ee0</div><div class="line">      arrayAndFlag = 4328541920</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $99.list</div><div class="line">(method_list_t *const) $100 = 0x0000000102004ee0</div><div class="line">(lldb) p *$100</div><div class="line">(method_list_t) $101 = &#123;</div><div class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</div><div class="line">    entsizeAndFlags = 2148007936</div><div class="line">    count = 0</div><div class="line">    first = &#123;</div><div class="line">      name = &quot;\x10&quot;</div><div class="line">      types = 0x00007fff97ca45c0 &quot;@Fʗ</div><div class="line">      imp = 0x00007fff8ee94d20 ((void *)0x00007fff8ee959a0: __NSStackBlock)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过查看内存情况，发现方法列表内部的count为0，说明方法并未存放在实例对象中。</p>
<p>然后看看属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) p $98.properties()</div><div class="line">(const property_array_t) $102 = &#123;</div><div class="line">  list_array_tt&lt;property_t, property_list_t&gt; = &#123;</div><div class="line">     = &#123;</div><div class="line">      list = 0x0000001000000000</div><div class="line">      arrayAndFlag = 68719476736</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $102.list</div><div class="line">(property_list_t *const) $103 = 0x0000001000000000</div><div class="line">(lldb) p *$103</div><div class="line">error: Couldn&apos;t apply expression side effects : Couldn&apos;t dematerialize a result variable: couldn&apos;t read its memory</div></pre></td></tr></table></figure>
<p>属性列表访问失败，说明也是没有数据的。</p>
<h5 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h5><p>然后我们再来看看类对象中的内存情况，这里我们先拿到类对象的首地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/4gx LLYModel.class</div><div class="line">0x1000083e8: 0x00000001000083c0 0x000000010034c140</div><div class="line">0x1000083f8: 0x00000001006ace60 0x0004802400000007</div></pre></td></tr></table></figure>
<p>上面也提到过，类对象是唯一的，所以可以这样访问，其他步骤都差不多就不在重复粘贴，这里只放最后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">(method_list_t) $117 = &#123;</div><div class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</div><div class="line">    entsizeAndFlags = 26</div><div class="line">    count = 4</div><div class="line">    first = &#123;</div><div class="line">      name = &quot;sayHey&quot;</div><div class="line">      types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">      imp = 0x0000000100003da0 (KCObjc`-[LLYModel sayHey])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(0)</div><div class="line">(method_t) $118 = &#123;</div><div class="line">  name = &quot;sayHey&quot;</div><div class="line">  types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">  imp = 0x0000000100003da0 (KCObjc`-[LLYModel sayHey])</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(1)</div><div class="line">(method_t) $119 = &#123;</div><div class="line">  name = &quot;.cxx_destruct&quot;</div><div class="line">  types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">  imp = 0x0000000100003e00 (KCObjc`-[LLYModel .cxx_destruct])</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(2)</div><div class="line">(method_t) $120 = &#123;</div><div class="line">  name = &quot;name&quot;</div><div class="line">  types = 0x0000000100003f87 &quot;@16@0:8&quot;</div><div class="line">  imp = 0x0000000100003db0 (KCObjc`-[LLYModel name])</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(3)</div><div class="line">(method_t) $121 = &#123;</div><div class="line">  name = &quot;setName:&quot;</div><div class="line">  types = 0x0000000100003f8f &quot;v24@0:8@16&quot;</div><div class="line">  imp = 0x0000000100003dd0 (KCObjc`-[LLYModel setName:])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了我们定义的实例方法外，还看到了属性的get和set方法，还有一个编译器默认添加的析构方法。接着是属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(property_list_t) $124 = &#123;</div><div class="line">  entsize_list_tt&lt;property_t, property_list_t, 0&gt; = &#123;</div><div class="line">    entsizeAndFlags = 16</div><div class="line">    count = 1</div><div class="line">    first = (name = &quot;name&quot;, attributes = &quot;T@\&quot;NSString\&quot;,&amp;,N,V_name&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个我们定义的name属性。</p>
<h5 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h5><p>最后我们来看看元类的内存分配情况，首先我们拿到元类的首地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/4gx objc_getMetaClass(object_getClassName(objc2))</div><div class="line">0x1000083c0: 0x000000010034c0f0 0x000000010034c0f0</div><div class="line">0x1000083d0: 0x000000010200d880 0x0004e03500000007</div></pre></td></tr></table></figure>
<p>方法列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(method_list_t) $135 = &#123;</div><div class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</div><div class="line">    entsizeAndFlags = 26</div><div class="line">    count = 1</div><div class="line">    first = &#123;</div><div class="line">      name = &quot;sayBey&quot;</div><div class="line">      types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">      imp = 0x0000000100003d90 (KCObjc`+[LLYModel sayBey])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>元类中存放了我们上面定义的一个类方法</p>
<p>属性列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) p $132.properties()</div><div class="line">(const property_array_t) $136 = &#123;</div><div class="line">  list_array_tt&lt;property_t, property_list_t&gt; = &#123;</div><div class="line">     = &#123;</div><div class="line">      list = 0x0000000000000000</div><div class="line">      arrayAndFlag = 0</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $136.list</div><div class="line">(property_list_t *const) $137 = 0x0000000000000000</div><div class="line">(lldb) p *$137</div><div class="line">error: Couldn&apos;t apply expression side effects : Couldn&apos;t dematerialize a result variable: couldn&apos;t read its memory</div></pre></td></tr></table></figure>
<p>元类中没有存放属性。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上的探索过程，证明了我们之前的结论<strong>其中类对象存储实例方法和属性，元类对象存储类方法。</strong>，通过源码+lldb相结合的方式，可以更好的证明我们已知的一些结论。也给我们探索更广阔的空间提供了可能。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/" itemprop="url">
                  从【class_getInstanceSize方法】探究iOS的内存分配策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-01T21:39:15+08:00" content="2021-01-01">
              2021-01-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="先抛问题"><a href="#先抛问题" class="headerlink" title="先抛问题"></a>先抛问题</h4><p>各位看官请看下面两种case的输出分别是多少：</p>
<h5 id="case1"><a href="#case1" class="headerlink" title="case1:"></a>case1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@interface LLYModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, copy) NSString *nickName;</div><div class="line">@property (nonatomic, assign) int age;</div><div class="line">@property (nonatomic, assign) long height;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">LLYModel *objc = [LLYModel alloc];</div><div class="line">objc.name = @&quot;lly&quot;;</div><div class="line">objc.nickName = @&quot;123&quot;;</div><div class="line">objc.age = 18;</div><div class="line">objc.height = 180;</div><div class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,objc,sizeof(objc),class_getInstanceSize([LLYModel class]),malloc_size((__bridge const void *)(objc)));</div></pre></td></tr></table></figure>
<h5 id="case2"><a href="#case2" class="headerlink" title="case2:"></a>case2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface LLYModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, copy) NSString *nickName;</div><div class="line">@property (nonatomic, assign) int age;</div><div class="line">@property (nonatomic, assign) long height;</div><div class="line">@property (nonatomic, assign) long weight;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">LLYModel *objc = [LLYModel alloc];</div><div class="line">objc.name = @&quot;lly&quot;;</div><div class="line">objc.nickName = @&quot;123&quot;;</div><div class="line">objc.age = 18;</div><div class="line">objc.height = 180;</div><div class="line">objc.weight = 180;</div><div class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,objc,sizeof(objc),class_getInstanceSize([LLYModel class]),malloc_size((__bridge const void *)(objc)));</div></pre></td></tr></table></figure>
<p>可以先分析一下打印情况，我这里直接上结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">case1:&lt;LLYModel: 0x1006cf490&gt; - 8 - 40 - 48</div><div class="line">case2:&lt;LLYModel: 0x1006cf490&gt; - 8 - 48 - 48</div></pre></td></tr></table></figure>
<p>这就有点意思了，class_getInstanceSize获取到的大小并不完全和对象的真实大小完全一致，通过对相关源码的探究，最终发现了原因，这里先上结论：</p>
<p><strong>class_getInstanceSize获取的大小是根据8字节对齐计算，而内存的实际分配策略是根据16字节对齐计算</strong></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们首先来看看runtime中class_getInstanceSize的实现，通过调用栈的追踪，最终定位到下面几个比较重要的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Class&apos;s ivar size rounded up to a pointer-size boundary. </div><div class="line">// 这里返回类的实例变量的大小 因为只有实例变量是存放在类对象中的。</div><div class="line">uint32_t alignedInstanceSize() const &#123;</div><div class="line">    return word_align(unalignedInstanceSize());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// May be unaligned depending on class&apos;s ivars.</div><div class="line">// 未对齐的实例变量的大小</div><div class="line">uint32_t unalignedInstanceSize() const &#123;</div><div class="line">    ASSERT(isRealized());</div><div class="line">    return data()-&gt;ro()-&gt;instanceSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#ifdef __LP64__</div><div class="line">#   define WORD_SHIFT 3UL</div><div class="line">#   define WORD_MASK 7UL</div><div class="line">#   define WORD_BITS 64</div><div class="line">#else</div><div class="line">#   define WORD_SHIFT 2UL</div><div class="line">#   define WORD_MASK 3UL</div><div class="line">#   define WORD_BITS 32</div><div class="line">#endif</div><div class="line"></div><div class="line">// 64位下8字节对齐 32位下4字节对齐 </div><div class="line">static inline uint32_t word_align(uint32_t x) &#123;</div><div class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上几个函数的调用，就可以验证上面的结论<strong>class_getInstanceSize是以8字节对齐的</strong>，<br>在上面的函数中，我们还发现了一个很熟悉的身影，就是下面这个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class_ro_t *ro()</div></pre></td></tr></table></figure>
<p>我们知道，这里面的数据都是只读数据，是在程序编译期就决定了的，我们常用的实例变量就存放在这个结构体中，这也是为什么类在初始化后不能再动态添加实例变量的原因。</p>
<p>然后我们再来看看类的创建过程，还是从源码入手，不过内存创建的函数调用栈比较复杂，我画个简单的流程图来表示下先：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Alloc分析/alloc01.png" alt=""></p>
<p>在runtime库中，这个调用堆栈跟到最后两个标黄部分就进不去了，不过我们还是通过一些细节找到了这两个函数的出处，并最终定位到了负责内存分配过程中size计算的函数，该部分代码位于libsystem_malloc库中，具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static MALLOC_INLINE size_t</div><div class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</div><div class="line">&#123;</div><div class="line">	size_t k, slot_bytes;</div><div class="line"></div><div class="line">	//最小16字节</div><div class="line">	if (0 == size) &#123;</div><div class="line">		size = NANO_REGIME_QUANTA_SIZE; // Historical behavior </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//先加上16个字节 然后抹掉零头</div><div class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta </div><div class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;							// multiply by power of two quanta size</div><div class="line">	*pKey = k - 1;													// Zero-based!</div><div class="line"></div><div class="line">	return slot_bytes;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#define NANO_MAX_SIZE			256 /* Buckets sized &#123;16, 32, 48, ..., 256&#125; */</div><div class="line">#define SHIFT_NANO_QUANTUM		4</div><div class="line">#define NANO_REGIME_QUANTA_SIZE	(1 &lt;&lt; SHIFT_NANO_QUANTUM)	// 16</div><div class="line">#define NANO_QUANTA_MASK		(NANO_REGIME_QUANTA_SIZE - 1)</div><div class="line">#define NANO_SIZE_CLASSES		(NANO_MAX_SIZE/NANO_REGIME_QUANTA_SIZE)</div></pre></td></tr></table></figure>
<p>通过以上源码也证明了上面的结论<strong>内存的实际分配策略是根据16字节对齐计算</strong></p>
<h4 id="补充部分"><a href="#补充部分" class="headerlink" title="补充部分"></a>补充部分</h4><p>因为iOS中的类本质上都是结构体，所以他们的内存大小应该也需要满足c语言中结构体对齐的原则，这里简单介绍下c语言中如何进行字节对齐：</p>
<h5 id="内部对齐"><a href="#内部对齐" class="headerlink" title="内部对齐"></a>内部对齐</h5><p>即结构体内部变量的起始地址需要是变量自身大小的倍数。具体对齐逻辑参考下图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Alloc分析/alig.png" alt=""></p>
<h5 id="外部对齐"><a href="#外部对齐" class="headerlink" title="外部对齐"></a>外部对齐</h5><p>即结构体的整体大小需要和当前运行环境的字对齐。</p>
<p><strong>这里还有一个知识点需要提及，为了更高效的利用内存，xcode编译器会对实例变量进行重排序，这个在我上面的LLYModel中并未体现，感兴趣的同学可以自行实验</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上就是这次对iOS类分配内存大小探索的全部内容，首先是发现问题，然后通过源码的分析找到问题产生的原因，中间的探索过程一度中断，不过最后还是通过一些小的线索定位到问题的所在，在源码分析过程中，我们应该做到抓住关键问题，忽略干扰条件，多一些细心和耐心。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">77</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
