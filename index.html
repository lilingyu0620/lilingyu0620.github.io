<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/AudioUnit学习笔记/" itemprop="url">
                  AudioUnit学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T16:15:43+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/AudioUnit学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/AudioUnit学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioUnit简介"><a href="#AudioUnit简介" class="headerlink" title="AudioUnit简介"></a>AudioUnit简介</h3><p>在iOS中，所有的上层音频技术都是基于AudioUnit来实现的。<br>下图可以直观的反应出AudioUnit的层级关系。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/auidounit1-1.png" alt=""></p>
<p>对于普通的音频播放功能可能不需要直接使用AudioUnit来实现，但是如果你需要实现比较高级的功能（比如回声消除），就需要使用AudioUnit了。</p>
<p>根据不同的音频目的，iOS将AudioUnit共分为7类。如下图所示</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-2.png" alt=""></p>
<ul>
<li><p>effect units 这个是用在ipod类app上的，比较少使用到。</p>
</li>
<li><p>mixer units 做混音的，有2个audio unit，3D mixer比较适合用来做游戏的3d音效。multichannel mixer提供混合任意数量的单声道或立体声流,立体声输出。</p>
</li>
<li><p>i/o units  远程I/O单元是最常用的。它连接到输入和输出音频硬件和给你对传入和传出的低延迟访问音频样本值。它提供了硬件音频格式和应用程序之间的格式转换音频格式。声音处理I/O单元扩展了远程I/O单元，通过添加声学回声取消使用网络电话或者语音聊天应用程序。通用输出装置不连接到音频硬件,而是提供了一个机制来处理链的输出发送到您的应用程序。</p>
</li>
<li><p>Format Converter Unit 用来处理音频格式的转换。</p>
</li>
</ul>
<h3 id="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit"><a href="#iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit" class="headerlink" title="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit."></a>iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit.</h3><h4 id="通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit"><a href="#通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit" class="headerlink" title="通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit"></a>通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit</h4><p>在创建一个AudioUnit实例之前，需要先创建一个audiocomponent 创建方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//组件描述</div><div class="line">AudioComponentDescription ioUnitDescription;</div><div class="line">//组件类型</div><div class="line">ioUnitDescription.componentType          = kAudioUnitType_Output;</div><div class="line">//组件子类型</div><div class="line">ioUnitDescription.componentSubType       = kAudioUnitSubType_RemoteIO;</div><div class="line">//默认值</div><div class="line">ioUnitDescription.componentManufacturer  = kAudioUnitManufacturer_Apple;</div><div class="line">ioUnitDescription.componentFlags         = 0;</div><div class="line">ioUnitDescription.componentFlagsMask     = 0;</div><div class="line"></div><div class="line">AudioComponent foundIoUnitReference = AudioComponentFindNext (NULL,&amp;ioUnitDescription);</div><div class="line">AudioUnit ioUnitInstance;</div><div class="line">AudioComponentInstanceNew (</div><div class="line">    foundIoUnitReference,</div><div class="line">    &amp;ioUnitInstance</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="使用AUGraph创建AudioUnit"><a href="#使用AUGraph创建AudioUnit" class="headerlink" title="使用AUGraph创建AudioUnit"></a>使用AUGraph创建AudioUnit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">AUGraph processingGraph;</div><div class="line">NewAUGraph (&amp;processingGraph);</div><div class="line"> </div><div class="line">// Add an audio unit node to the graph, then instantiate the audio unit</div><div class="line">AUNode ioNode;</div><div class="line">AUGraphAddNode (</div><div class="line">    processingGraph,</div><div class="line">    &amp;ioUnitDescription,</div><div class="line">    &amp;ioNode</div><div class="line">);</div><div class="line">AUGraphOpen (processingGraph); // indirectly performs audio unit instantiation</div><div class="line"> </div><div class="line">// Obtain a reference to the newly-instantiated I/O unit</div><div class="line">AudioUnit ioUnit;</div><div class="line">AUGraphNodeInfo (</div><div class="line">    processingGraph,</div><div class="line">    ioNode,</div><div class="line">    NULL,</div><div class="line">    &amp;ioUnit</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="使用Scopes和Elements来指定AudioUnit"><a href="#使用Scopes和Elements来指定AudioUnit" class="headerlink" title="使用Scopes和Elements来指定AudioUnit"></a>使用Scopes和Elements来指定AudioUnit</h3><p>Scope和Elements的关系如下图所示：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-3.png" alt=""></p>
<p>对于通用的audioUnit,可以有1-2条输入输出流，输入和输出不一定相等，比如mixer,可以两个音频输入，混音合成一个音频流输出。每个element表示一个音频处理上下文(context), 也称为bus。每个element有输出和输出部分，称为scope，分别是input scope和Output scope。Global scope确定只有一个element，就是element0，有些属性只能在Global scope上设置。</p>
<p>inputbus = Element1 = 1,outputbus = Element0 = 0</p>
<h3 id="使用Property来config-AudioUnit"><a href="#使用Property来config-AudioUnit" class="headerlink" title="使用Property来config AudioUnit"></a>使用Property来config AudioUnit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UInt32 busCount = 2;</div><div class="line"> </div><div class="line">OSStatus result = AudioUnitSetProperty (</div><div class="line">    mixerUnit,</div><div class="line">    kAudioUnitProperty_ElementCount,   // the property key</div><div class="line">    kAudioUnitScope_Input,             // the scope to set the property on</div><div class="line">    0,                                 // the element to set the property on</div><div class="line">    &amp;busCount,                         // the property value</div><div class="line">    sizeof (busCount)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一个普通的播放行为可能需要设置的属性有 <em>kAudioOutputUnitProperty_EnableIO</em>，<em>kAudioUnitProperty_StreamFormat</em>，<em>kAudioUnitProperty_SetRenderCallback</em> 三个，不同行为需要设置不同的属性。</p>
<h3 id="I-O-Unit的基本特征"><a href="#I-O-Unit的基本特征" class="headerlink" title="I/O Unit的基本特征"></a>I/O Unit的基本特征</h3><p>i/o unit是最常见的一种AudioUnit</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-4.png" alt=""></p>
<p>对于remote_IO类型audioUnit，即从硬件采集和输出到硬件的audioUnit,它的逻辑是固定的：固定2个element,麦克风经过element1到APP，APP经element0到扬声器。</p>
<p>我们能把控的是中间的“APP内处理”部分，结合上图，淡黄色的部分就是APP可控的，Element1这个组件负责链接麦克风和APP，它的输入部分是系统控制，输出部分是APP控制；Element0负责连接APP和扬声器，输入部分APP控制，输出部分系统控制。</p>
<h3 id="使用AUGraph来管理AudioUnit"><a href="#使用AUGraph来管理AudioUnit" class="headerlink" title="使用AUGraph来管理AudioUnit"></a>使用AUGraph来管理AudioUnit</h3><h3 id="Render-Callback-Functions-Feed-Audio-to-Audio-Units"><a href="#Render-Callback-Functions-Feed-Audio-to-Audio-Units" class="headerlink" title="Render Callback Functions Feed Audio to Audio Units"></a>Render Callback Functions Feed Audio to Audio Units</h3><p>当音频数据是由内存或者磁盘提供的话，数据都需要从渲染回调函数这里提供给inputbus，当你想要对音频数据进行自定义的处理的话，就在这里进行吧。</p>
<p>渲染回调函数格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static OSStatus MyAURenderCallback (</div><div class="line">    void                        *inRefCon,</div><div class="line">    AudioUnitRenderActionFlags  *ioActionFlags,</div><div class="line">    const AudioTimeStamp        *inTimeStamp,</div><div class="line">    UInt32                      inBusNumber,</div><div class="line">    UInt32                      inNumberFrames,</div><div class="line">    AudioBufferList             *ioData</div><div class="line">) &#123; /* callback body */ &#125;</div></pre></td></tr></table></figure>
<p>各参数的关系如下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-5.png" alt=""></p>
<h3 id="Working-with-the-AudioStreamBasicDescription-structure"><a href="#Working-with-the-AudioStreamBasicDescription-structure" class="headerlink" title="Working with the AudioStreamBasicDescription structure"></a>Working with the AudioStreamBasicDescription structure</h3><p>AudioStreamBasicDescription 这个结构体表示当前音频的格式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct AudioStreamBasicDescription &#123;</div><div class="line">    Float64 mSampleRate;//采样率</div><div class="line">    UInt32  mFormatID;//格式ID</div><div class="line">    UInt32  mFormatFlags;//存储标识</div><div class="line">    UInt32  mBytesPerPacket;//每个packet的字节数</div><div class="line">    UInt32  mFramesPerPacket;//每个packet包含几个frame</div><div class="line">    UInt32  mBytesPerFrame;//每个frame的字节数</div><div class="line">    UInt32  mChannelsPerFrame;//每个frame的声道数</div><div class="line">    UInt32  mBitsPerChannel;//每个声道的位数</div><div class="line">    UInt32  mReserved;</div><div class="line">&#125;;</div><div class="line">typedef struct AudioStreamBasicDescription  AudioStreamBasicDescription;</div></pre></td></tr></table></figure>
<h3 id="Understanding-Where-and-How-to-Set-Stream-Formats"><a href="#Understanding-Where-and-How-to-Set-Stream-Formats" class="headerlink" title="Understanding Where and How to Set Stream Formats"></a>Understanding Where and How to Set Stream Formats</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-6.png" alt=""></p>
<p>这个图展示了一个完整的录音+混音+播放的流程，在组件两边设置stream的格式，在代码里的概念是scope。</p>
<p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/flv格式和seek原理/" itemprop="url">
                  flv格式和seek原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T09:42:55+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/flv格式和seek原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/flv格式和seek原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FLV（Flash Video）是Adobe公司设计开发的一种流行的流媒体格式，由于其视频文件体积轻巧、封装简单等特点，使其很适合在互联网上进行应用。此外，FLV可以使用Flash Player进行播放，而Flash Player插件已经安装在全世界绝大部分浏览器上，这使得通过网页播放FLV视频十分容易。目前主流的视频网站如优酷网，土豆网，乐视网等网站无一例外地使用了FLV格式。FLV封装格式的文件后缀通常为“.flv”。</p>
<h3 id="flv数据格式"><a href="#flv数据格式" class="headerlink" title="flv数据格式"></a>flv数据格式</h3><p>从整个文件上来看,FLV是由The FLV header 和 The FLV File Body 组成.</p>
<h4 id="FLV-header"><a href="#FLV-header" class="headerlink" title="FLV header"></a>FLV header</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/header.png" alt=""></p>
<p>Signature: FLV 文件的前3个字节为固定的‘F’‘L’‘V’,用来标识这个文件是flv格式的.在做格式探测的时候，</p>
<p>如果发现前3个字节为“FLV”，就认为它是flv文件.</p>
<p>Version: 第4个字节表示flv版本号.</p>
<p>Flags: 第5个字节中的第0位和第2位,分别表示 video 与 audio 存在的情况.(1表示存在,0表示不存在)</p>
<p>DataOffset : 最后4个字节表示FLV header 长度.</p>
<h4 id="FLV-File-Body"><a href="#FLV-File-Body" class="headerlink" title="FLV File Body"></a>FLV File Body</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/body.png" alt=""></p>
<p>FLV File Body是由一连串的<strong>Previous Tag Size</strong> + tags构成.<strong>Previous Tag Size</strong>就是4个字节数据,表示前一个tag的size.</p>
<h4 id="FLV-Tag"><a href="#FLV-Tag" class="headerlink" title="FLV Tag"></a>FLV Tag</h4><p>FLV文件中的数据都是由一个个TAG组成,TAG里面的数据可能是video、audio、scripts.</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/tag2.png" alt=""></p>
<p>TagType: TAG中第1个字节中的前5位表示这个TAG中包含数据的类型,8 = audio,9 = video,18 = script data.</p>
<p>DataSize:StreamID之后的数据长度.</p>
<p>Timestamp和TimestampExtended组成了这个TAG 包数据的PTS信息,PTS= Timestamp | TimestampExtended &lt;&lt; 24.</p>
<p>StreamID之后的数据就是每种格式的情况不一样了，接下格式进行详细的介绍.</p>
<h4 id="Audio-Tags"><a href="#Audio-Tags" class="headerlink" title="Audio Tags"></a>Audio Tags</h4><p>如果TAG包中的TagType==8时，就表示这个TAG是audio。</p>
<p>StreamID之后的数据就表示是AudioTagHeader，AudioTagHeader结构如下：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiotagheader.png" alt=""></p>
<h4 id="Video-Tags"><a href="#Video-Tags" class="headerlink" title="Video Tags"></a>Video Tags</h4><p>如果TAG包中的TagType==9时，就表示这个TAG是video.</p>
<p>StreamID之后的数据就表示是VideoTagHeader，VideoTagHeader结构如下：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/videotagheader.png" alt=""></p>
<h4 id="SCRIPTDATA-控制帧）"><a href="#SCRIPTDATA-控制帧）" class="headerlink" title="SCRIPTDATA(控制帧）"></a>SCRIPTDATA(控制帧）</h4><p>如果TAG包中的TagType==18时，就表示这个TAG是SCRIPT.</p>
<p>该类型Tag又通常被称为Metadata Tag，会放一些关于FLV视频和音频的元数据信息如：duration、width、height等。<strong>通常该类型Tag会跟在File Header后面作为第一个Tag出现，而且只有一个。</strong></p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/STD.png" alt=""></p>
<p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，用来装入一个“onMetaData”标志，这个标志与Adobe的一些API调用有，在此不细述。第二个AMF包封装一个数组类型，这个数组中包含了音视频信息项的名称和值。具体说明如下，大家可以参照图片上的数据进行理解。</p>
<p>第一个AMF包：<br>       第1个字节表示AMF包类型，一般总是0x02，表示字符串，其他值表示意义请查阅文档。<br>       第2-3个字节为UI16类型值，表示字符串的长度，一般总是0x000A（“onMetaData”长度）。<br>       后面字节为字符串数据，一般总为“onMetaData”。</p>
<p>第二个AMF包：<br>       第1个字节表示AMF包类型，一般总是0x08，表示数组。<br>       第2-5个字节为UI32类型值，表示数组元素的个数。<br>       后面即为各数组元素的封装，数组元素为元素名称和值组成的对。表示方法如下：<br>       第1-2个字节表示元素名称的长度，假设为L。<br>       后面跟着为长度为L的字符串。<br>       第L+3个字节表示元素值的类型。<br>       后面跟着为对应值，占用字节数取决于值的类型</p>
<h4 id="onMetaData"><a href="#onMetaData" class="headerlink" title="onMetaData"></a>onMetaData</h4><p>onMetaData 是SCRIPTDATA中对我们来说十分重要的信息，结构如下表：<br><img src="http://ofy1hyquv.bkt.clouddn.com/onMetaData.png" alt=""></p>
<p>这里面的duration、filesize、视频的width、height等这些信息对我们来说很有用.</p>
<h3 id="metadata和yamdi-flvtool2-ruby-FLVMDI-非开源"><a href="#metadata和yamdi-flvtool2-ruby-FLVMDI-非开源" class="headerlink" title="metadata和yamdi,flvtool2(ruby),FLVMDI(非开源)"></a>metadata和yamdi,flvtool2(ruby),FLVMDI(非开源)</h3><p>yamdi为flv文件增加了很多metadata信息，比如创建者、是否有关键帧、是否有视频、是否有音频，视频高度和宽度等等。而yamdi加入的meta数据中，最有效的要数关键帧。被注入了关键帧的flv可以实现像土豆网、优酷网等大型视频网站一样的“拖进度”，提前拖到缓冲还未加载到的位置开始播放。</p>
<h4 id="keyframes"><a href="#keyframes" class="headerlink" title="keyframes"></a>keyframes</h4><p>keyframes中包含着2个内容 ‘filepositions’ and ‘times’分别指的是关键帧的文件位置和关键帧的PTS.通过keyframes可以建立起自己的Index，然后再seek和快进快退的操作中，快速有效的跳转到你想要找的关键帧的位置进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/20/IP地址与协议详解/" itemprop="url">
                  IP地址与协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-20T18:29:57+08:00" content="2018-03-20">
              2018-03-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/20/IP地址与协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/20/IP地址与协议详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本的ip地址结构"><a href="#基本的ip地址结构" class="headerlink" title="基本的ip地址结构"></a>基本的ip地址结构</h3><p>ipv4:点分十进制，共32位</p>
<p>ipv6:冒号隔开8个16位数，共128位</p>
<h4 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h4><p>ip地址中一些连续的位称为网络号，其余位称为主机号。</p>
<p>ip地址空间的划分涉及五大类：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/ipcategory.png" alt=""></p>
<p>A,B,C为单播，D为组播。</p>
<h4 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h4><p>在一个站点接入Internet后为其分配一个网络号，然后由站点管理员进一步划分本地的子网数。</p>
<p>通过子网寻址，一个站点被分配一个A，B或C类的<strong>网络号</strong>，保留一些剩余主机号进一步用于站点内分配。该站点可能将基础地址中的主机部分进一步划分为一个<strong>子网号</strong>和一个<strong>主机号</strong>.</p>
<p>如下图，该站点将每一个地址的前16位固定为网络号，后16位8位为子网号，8位为主机号。这个特殊配置允许站点支持256个子网，每个子网最多可包含254台主机。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/subnet.png" alt=""></p>
<p><strong>同一个子网中每台主机的IPv4地址拥有相同的子网号</strong></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应的IP地址中获取网络和子网信息。</p>
<p>掩码由路由器和主机使用，以确认一个IP地址的网络/子网部分的结束和主机部分的开始。子网掩码中的一位设为1表示一个IP地址的对应位与一个地址的网络/子网部分的对应位相结合（位与）.并将结果作为转发数据报的基础。</p>
<p>IP地址与子网掩码做（位与）运算，以形成用于路由的地址的网络/子网标识符。</p>
<p>子网掩码纯粹是站点内部的局部问题。。。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议是无连接的，这意味着IP不维护网络单元（路由器）中数据报相关的任何链接状态信息，每个数据报独立于其他数据报来处理。这也意味着IP数据报可不按顺序交付。</p>
<p>当某些错误发生时，例如一台路由器临时用尽缓冲区，IP提供一个简单的错误处理方式：丢弃一些数据（通常是最后到达的数据报）。</p>
<h4 id="协议头部结构"><a href="#协议头部结构" class="headerlink" title="协议头部结构"></a>协议头部结构</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/ipv4head.png" alt=""></p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>它包含IP数据报的版本号：IPV4是4，IPV6是6.</p>
<p>IPV4和IPV6两个协议之间不能直接互操作。</p>
<h4 id="IHL（头部长度）"><a href="#IHL（头部长度）" class="headerlink" title="IHL（头部长度）"></a>IHL（头部长度）</h4><p>保存IPV4头部中32位字的数量，包括任何选项。由于他是一个4位的字段，所以IPV4的头部被限制最多15个32位字（60个字节）.</p>
<h4 id="DS-区分服务"><a href="#DS-区分服务" class="headerlink" title="DS(区分服务)"></a>DS(区分服务)</h4><p>前6位被称为区分服务字段，后两位是显示拥塞通知字段或指示位。</p>
<h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>IPV4数据报的总长度。通过这个字段和IHL字段，我们知道数据报的数据部分从哪里开始，以及他的长度。由于它是一个16位的字段，所以IPV4数据报的最大长度是65535字节。</p>
<p>由于一些携带IPV4数据报的低层协议不能精确表达自己封装数据的大小，所以需要在头部中给出总长度字段。例如，以太网会将短帧补充到最小长度（64字节）。虽然以太网最小有效载荷为46字节，单一个IPV4数据报也可能会更小（20字节）。如果没有提供总长度字段，IPV4实现将无法知道一个46字节的以太网帧是一个IP数据报，还是经过填充的IP数据报，这样可能会导致混淆。</p>
<p>尽管可发送一个65535字节的IP数据报，但是大多数链路层不能携带这么大的数据，所以会对发数据进行<strong>分片</strong>。主机不接受大于576字节的IPV4数据报。</p>
<h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>标识字段帮助标识由IPV4主机发送的数据报，为了避免将一个数据报分片和其他分片混淆，发送主机通常在每次发送数据报时都将一个内部计数器加1，并将该计算器值复制到IPV4标识字段。</p>
<h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>TTL字段用于设置一个数据报可经过的路由器数量的上限。发送方将他初始化为某一个值（文档建议为64，但128或255也不少见），每台路由器在转发数据报时将该值减1.当这个字段值达到0时，改数据报被丢弃，并使用一个ICMP消息通知发送方。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>IPV4头部中的协议字段包含一个数字，表示数据报有效载荷部分的数据类型。最常见的值为17（UDP）和6（TCP）。</p>
<h4 id="头部校验和"><a href="#头部校验和" class="headerlink" title="头部校验和"></a>头部校验和</h4><p>头部校验和字段仅计算IPV4头部。理解这一点很重要，因为这意味着IP协议不检测IPV4数据报有效载荷的正确性。需要其他上层协议自己去实现（<strong>比如TCP的校验和字段</strong>）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/05/TCP协议学习笔记/" itemprop="url">
                  TCP协议学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-05T10:35:50+08:00" content="2018-03-05">
              2018-03-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/05/TCP协议学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/05/TCP协议学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="tcp报文段格式如下"><a href="#tcp报文段格式如下" class="headerlink" title="tcp报文段格式如下"></a>tcp报文段格式如下</h3><p>图中保留字段有6位，看最新的书上面是4位，还有2位分别是<strong>CWR</strong>和<strong>ECE</strong>位。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/tcp%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h4 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h4><p>这两个值与IP头部的源和目标IP地址一起唯一的标识了每个连接。端口和IP地址的组合被称为端点或套接字</p>
<h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>在发送用于建立连接的SYN之前，通信双方会选择一个初始序列号。<strong>初始序列号会随着时间而改变</strong>。因此每一个连接都拥有不同的序列号。文档指出，序列号可以被视为一个32位的计算器。<strong>该计算器的数值每4微秒+1</strong><br>主要是防止序列号重复。</p>
<p>标识了TCP发送端发送到接收端的数据的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节。这是一个32位的无符号数，到达2的32次方-1之后在循环回到0。</p>
<p><strong>消耗一个序列号意味着使用重传进行可靠传输</strong></p>
<h4 id="确认序号"><a href="#确认序号" class="headerlink" title="确认序号"></a>确认序号</h4><p>包含的值是该确认号的发送方期待接收到的下一个序列号。 <strong>即最后被成功接收的数据字节的序列号+1.</strong></p>
<p>这个字段只有在ACK位被启用的情况下才有效。这个ACK位字段通常用于除了初始化和末尾报文段之外的所有报文段。</p>
<h4 id="数据偏移（头部长度）"><a href="#数据偏移（头部长度）" class="headerlink" title="数据偏移（头部长度）"></a>数据偏移（头部长度）</h4><p>给出了头部的长度，以32位字节为单位，这个字段是必须的，因为选项字段的长度是可变的。作为一个4位的字段，TCP被限制为只能带60个字节的头部。而不带选项。大小是20字节。</p>
<h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>TCP的流量控制由每一个端点使用窗口大小字段来通告一个窗口大小来完成。这个窗口大小是字节数，从ACK号指定的，也是接收方想要接收的那个字节开始。这是一个16位的字段，限制窗口大小65535字节，从而限制了TCP的吞吐量性能。</p>
<h4 id="TCP校验和"><a href="#TCP校验和" class="headerlink" title="TCP校验和"></a>TCP校验和</h4><p>覆盖了TCP的头部和数据以及头部中的一些字段。这个字段是强制的，由发送发进行计算和保存，然后由接收发验证。</p>
<h4 id="CWR拥塞窗口减（发送方降低它的发送速度）"><a href="#CWR拥塞窗口减（发送方降低它的发送速度）" class="headerlink" title="CWR拥塞窗口减（发送方降低它的发送速度）"></a>CWR拥塞窗口减（发送方降低它的发送速度）</h4><h4 id="ECE（发送发接收了一个更早的拥塞通告）"><a href="#ECE（发送发接收了一个更早的拥塞通告）" class="headerlink" title="ECE（发送发接收了一个更早的拥塞通告）"></a>ECE（发送发接收了一个更早的拥塞通告）</h4><h4 id="URG-紧急（紧急字段有效很少被用到）"><a href="#URG-紧急（紧急字段有效很少被用到）" class="headerlink" title="URG 紧急（紧急字段有效很少被用到）"></a>URG 紧急（紧急字段有效很少被用到）</h4><h4 id="ACK-确认（确认号字段有效，连接建立以后一般都是开启状态）"><a href="#ACK-确认（确认号字段有效，连接建立以后一般都是开启状态）" class="headerlink" title="ACK 确认（确认号字段有效，连接建立以后一般都是开启状态）"></a>ACK 确认（确认号字段有效，连接建立以后一般都是开启状态）</h4><h4 id="PSH-推送"><a href="#PSH-推送" class="headerlink" title="PSH 推送"></a>PSH 推送</h4><h4 id="RST重置连接（连接取消，一般是因为错误）"><a href="#RST重置连接（连接取消，一般是因为错误）" class="headerlink" title="RST重置连接（连接取消，一般是因为错误）"></a>RST重置连接（连接取消，一般是因为错误）</h4><h4 id="SYN（用于初始化一个连接的同步序列号）"><a href="#SYN（用于初始化一个连接的同步序列号）" class="headerlink" title="SYN（用于初始化一个连接的同步序列号）"></a>SYN（用于初始化一个连接的同步序列号）</h4><h4 id="FIN-该报文段的发送发已经结束向对方发送数据"><a href="#FIN-该报文段的发送发已经结束向对方发送数据" class="headerlink" title="FIN 该报文段的发送发已经结束向对方发送数据"></a>FIN 该报文段的发送发已经结束向对方发送数据</h4><h4 id="tcp选项"><a href="#tcp选项" class="headerlink" title="tcp选项"></a>tcp选项</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/tcpchoice.png" alt=""></p>
<h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/tcpshark.png" alt=""></p>
<p>一个TCP连接由4个元组组成，它们分别是2个IP地址和2个端口号。即一对端点或者套接字。</p>
<p>为了建立一个TCP连接，需要完成以下步骤：</p>
<ul>
<li><p>主动开启者（一般称为客户端）发送一个SYN报文段，并指明自己想要连接的端口号和它的客户端初始序列号（即为ISN(c)）。通常客户端还会借此发送一个或者多个选项。</p>
</li>
<li><p>服务器在收到客户端的SYN报文段后，也发送自己的SYN报文段作为响应，并包含它们初始序列号（记为SIN(s)）。此外，为了确认客户端的SYN，服务器将其包含的ISN(c)数值+1后作为返回的ACK数值。因此，每发送一个SYN，序列号就会自动+1，这样如果出现丢失的情况，该SYN段将会重传。</p>
</li>
<li><p>为了确认服务器的SYN，客户端将ISN(s)的数字+1作为返回的ACK数值。</p>
</li>
</ul>
<p>通过上述的3个报文段就能够完成一个TCP连接的建立。它们也常称为<em>三次握手</em></p>
<p>TCP协议规定通过发送一个FIN段来发起关闭操作。只有当连接双方都完成关闭操作以后，才构成一个完整关闭。</p>
<ul>
<li><p>连接的主动关闭者发送一个FIN段指明接收者希望看到的自己当前的序列号（K），FIN段还包含了一个ACK段用于确认对方最近一次发来的数据。</p>
</li>
<li><p>连接的被动关闭者将K的数值+1作为响应的ACK值，以表示它已经成功接收到主动关闭者发送的FIN。</p>
</li>
<li><p>被动关闭者将身份转变为主动关闭者，发送自己的FIN.</p>
</li>
<li><p>为了完成连接的关闭，最后发送的报文段还包含一个ACK用于确认上一个FIN.值得注定的是，如果出现FIN丢失的情况，那么被动关闭方将重新传输直到收到一个ACK确认为止。</p>
</li>
</ul>
<p>通过上诉的4个报文就能够完成一个TCP连接的关闭。他们也常称为<em>四次挥手</em></p>
<h3 id="TCP的状态转换图"><a href="#TCP的状态转换图" class="headerlink" title="TCP的状态转换图"></a>TCP的状态转换图</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/tcpstatus.png" alt=""></p>
<p>tcp连接和断开过程中的状态变化</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/tcpsharkstatus.png" alt=""></p>
<h3 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h3><p>TCP拥有两套独立机制来完成重传，一是基于时间，二是基于确认信息的构成。</p>
<p>TCP在发送数据的会设置一个计时器，若计时器超时仍未收到数据的确认信息，则会引发相应的<em>超时</em>或者<em>基于计时器的重传</em>操作，计时器超时称为<em>重传超时（RTO）</em>。</p>
<p>另一种方式的重传称为<em>快速重传</em>，通常发生在没有延时的情况下，若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢失包。在发送端认为接收端可能出现数据丢失时，需要决定发送新数据还是重传。</p>
<ul>
<li><p>使用往返时间（RTT）估计策略</p>
<p>  TCP在收到数据后会返回确认信息，因此可在该信息中携带一个字节的数据来测量传输该确认信息所需要的时间。每个此类的测量结果称为RTT样本。TCP首先需要根据一段时间内的样本值建立好的估计值。然后使用计算公式根据RTT估值得到RTO值。</p>
<p>  选择一组RTT样本的样本均值作为真实的RTT是最有可能的，注意这个均值很自然的会随着时间而改变，因为通信穿过的网络的路径可能改变。</p>
</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传机制基于接收端的反馈信息来引发重传，而非重传计时器的超时。因此与超时重传相比，快速重传能更加及时有效的修复丢包情况。</p>
<p>当接收到失序报文段时，TCP需要立即生成确认信息（重复ACK）。并且失序情况表明在后续数据到达前出现了丢段，即<strong>接收端缓存</strong>出现了空缺。发送端的工作即为尽快的，高效的填补空缺。所以当失序数据到达是，重复ACK应该立即返回，不能延迟发送。</p>
<p>当重复ACK的数量达到一定的数目（称为重复ACK阈值）时，快速重传机制才会被触发。</p>
<h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>ACK号与接收端缓存中的的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为<strong>失序数据</strong>，因为这些数据与之前接收的序列号不连续。</p>
<p>TCP发送端的任务是通过重传丢失数据来填补接收端缓存中的空缺，但同时也要尽可能保证不重传 已正确接收到的数据。在很多环境下，合理采用SACK信息能更快的实现空缺填补，且能减少不必要的重传，原因在于其在一个RTT内能获知多个空缺。当采用SACK选项时，一个ACK可包含三四个告知失序数据的SACK信息。每个SACK信息包含32位的序列号，代表接收端存储的失序数据的起始至最后一个序列号（+1）。    </p>
<h3 id="数据流与窗口管理"><a href="#数据流与窗口管理" class="headerlink" title="数据流与窗口管理"></a>数据流与窗口管理</h3><p>可以采用可变滑动窗口来实现流量控制</p>
<h4 id="发送窗口结构"><a href="#发送窗口结构" class="headerlink" title="发送窗口结构"></a>发送窗口结构</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/tcpwindow.png" alt=""></p>
<p>TCP发送端滑动窗口结构记录了已确认，在传以及还未传的数据的序列号。<strong>提供窗口的大小控制由接收端返回的ACK中的窗口大小字段控制</strong></p>
<p>随着时间的推移，当接收到返回的数据ACK，滑动窗口也随之右移。窗口两端的相对运动使得窗口增大或减小。可用三个术语来描述窗口左右边界的运动。</p>
<ul>
<li>关闭：即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小。</li>
<li>打开：即窗口右边界右移，使得可发送数据增大。当已确认数据得到处理，接收端可用缓存增大，窗口也随之变大。</li>
<li>收缩：即窗口右边界左移。</li>
</ul>
<h4 id="接收窗口结构"><a href="#接收窗口结构" class="headerlink" title="接收窗口结构"></a>接收窗口结构</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/tcpreceivewindow.png" alt=""></p>
<p>该窗口结构记录了已接收并确认的数据，以及它能够接收的最大序列号。该窗口可以保证其接收数据的正确性。特别是接收端希望避免存储重复的已接收和确认的数据，以及避免存储不应该接收的数据。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象称为拥塞。</p>
<p>在有线网络中，出现在路由器或者交换机中的拥塞是造成丢包的主要原因；<br>在无线网络中，传输和接收错误是导致丢包的重要因素。</p>
<p>反映网络传输能力的变量称为拥塞窗口，记做（cwnd）.</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当一个新的TCP连接建立或者检测到由重传超时（RTO）导致的丢包时，需要执行慢启动。TCP发送端长时间处于空闲状态也可能调用慢启动算法。慢启动的目的是，是TCP在用拥塞避免探寻更多可用带宽之前得到cwnd值，以及帮助TCP建立ACK时钟。通常，TCP在建立新连接时执行慢启动，直至有丢包时，执行拥塞避免算法进入稳定状态。</p>
<p><strong>在传输初始阶段，由于未知网络传输能力，需要缓慢探测可用传输资源，防止短时间内大量数据注入导致拥塞。慢启动算法正是针对这一问题而设计。在数据传输之初或者重传计时器检测到丢包后，需要执行慢启动</strong></p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>为了得到更多的传输资源而不至于影响其他连接传输，TCP实现了拥塞避免算法。一旦确立慢启动阈值，TCP会进入拥塞避免阶段，cwnd每次的增长值近似于成功传输的数据段大小。这种随时间线性增长的方式于慢启动的指数增长相比缓慢许多。</p>
<h4 id="慢启动和拥塞避免的选择"><a href="#慢启动和拥塞避免的选择" class="headerlink" title="慢启动和拥塞避免的选择"></a>慢启动和拥塞避免的选择</h4><p>慢启动阈值（ssthresh）和cwnd的关系决定了采用慢启动还是拥塞避免的界限。当cwnd<ssthresh 使用慢启动算法。当cwnd="">ssthresh时，需要执行拥塞避免，而当两者相等时，任何一种算法都可以。</ssthresh></p>
<p>慢启动和拥塞控制之间最大的却别在于，cwnd怎样增长。慢启动是指数增长，拥塞避免时是线性增长。</p>
<h3 id="TCP保活机制（keepalive）"><a href="#TCP保活机制（keepalive）" class="headerlink" title="TCP保活机制（keepalive）"></a>TCP保活机制（keepalive）</h3><p>保活机制是一种不影响数据流内容的情况下探测对方的方式。它是由一个保活计时器实现的。当计时器被激活，连接一端将发送一个保活报文，另一端接收到报文的同时会发送一个ACK作为响应。</p>
<p>如果在一段时间（<strong>保活时间keepalive time</strong>）内连接处于非活动状态，开启保活功能的一端将向对方发送一个保活探测报文。如果发送端没有收到响应报文，那么经过一个已经提前配置好的保活时间间隔（keepalive interval），将继续发送保活探测报文，直到发送探测报文的次数达到保活探测数（keepalive probe）。这是对方主机将被确认为不可到达，连接也将中断。</p>
<p>保活探测报文为一个空报文段（或只包含一个字节），他的序列号等于对方主机发送的ACK报文的最大序列号减1.因为这一序列号的数据已经被成功接收，所以不会对到达的报文段造成影响。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/01/iOS中cookie的使用/" itemprop="url">
                  iOS中cookie的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-01T17:57:47+08:00" content="2018-03-01">
              2018-03-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/01/iOS中cookie的使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/01/iOS中cookie的使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="cookie是啥？"><a href="#cookie是啥？" class="headerlink" title="cookie是啥？"></a>cookie是啥？</h3><p>简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie 只包含数据，就其本身而言并不有害。</p>
<p>在浏览器访问WEB服务器的某个资源时，由WEB服务器在HTTP响应消息头中附带传送给浏览器的一个小文本文件。一旦WEB浏览器保存了某个Cookie，那么它在以后每次访问该WEB服务器时，都会在HTTP请求头中将这个Cookie回传给WEB服务器。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>WEB服务器通过在HTTP响应消息中增加Set-Cookie响应头字段将Cookie信息发送给浏览器，浏览器则通过在HTTP请求消息中增加Cookie请求头字段将Cookie回传给WEB服务器。<br>一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。<br>一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。<br>浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Cookie可以分为两类，会话Cookie和持久Cookie,会话Cookie是临时Cookie,当前会话结束(浏览器退出)时Cookie会被删除。持久Cookie会存储在用户的硬盘上,浏览器退出，然后重新启动后Cookie仍然存在。会话Cookie和持久Cookie的区别在于过期时间，如果设置了Discard参数(Cookie 版本1)或者没有设置Expires(Cookie版本0)或Max-Age(Cookie版本1)<br>没有设置过期时间，则此Cookie为会话Cookie</p>
<p>Cookie有两个版本,一个是版本0(Netscape Cookies)和版本1(RFC 2965),目前大多数服务器使用的Cookie 0。</p>
<h3 id="iOS中如何使用cookie"><a href="#iOS中如何使用cookie" class="headerlink" title="iOS中如何使用cookie"></a>iOS中如何使用cookie</h3><h4 id="NSHTTPCookie"><a href="#NSHTTPCookie" class="headerlink" title="NSHTTPCookie"></a>NSHTTPCookie</h4><p>在iOS中使用NSHTTPCookie类封装一条cookie,通过NSHTTPCookie的方法读取到cookie的通用属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)version;</div><div class="line">- (NSString *)name;</div><div class="line">- (NSString *)value;</div><div class="line">- (NSString *)domain;</div><div class="line">- (NSString *)path;</div><div class="line">- (BOOL)isSessionOnly;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以通过手工赋值的方式创建Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (id)cookieWithProperties:(NSDictionary *)properties;</div><div class="line">- (id)initWithProperties:(NSDictionary *)properties;</div></pre></td></tr></table></figure>
<p>也可以从Cookie中读取到所有属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSDictionary *)properties;</div></pre></td></tr></table></figure>
<p>使用NSHTTPCookie的类方法可以将NSHTTPCookie实例与HTTP cookie header相互转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">根据NSHTTPCookie实例数组生成对应的HTTP cookie header</div><div class="line">+ (NSDictionary *)requestHeaderFieldsWithCookies:(NSArray *)cookies;</div><div class="line"></div><div class="line">从headerFileds中读取到Cookie相关内容,生成NSHTTPCookie实例对象数组。</div><div class="line">+ (NSArray *)cookiesWithResponseHeaderFields:(NSDictionary *)headerFields forURL:(NSURL *)theURL;</div><div class="line"></div><div class="line">该方法会忽略headerFileds中与cookie无关的字段，如果headerFileds中的cookie没有指定domain,则使用theURL的domain,如果没有指定path,则使用”/”.</div><div class="line"></div><div class="line">除非NSURLRequest明确指定不使用cookie(HTTPShouldHandleCookies设为NO),否则URL loading system会自动为NSURLRequest发送合适的存储cookie。从NSURLResponse返回的cookie也会根据当前的cookie访问策略(cookie acceptance policy)接收到系统中。</div></pre></td></tr></table></figure>
<h4 id="NSHTTPCookieStorage"><a href="#NSHTTPCookieStorage" class="headerlink" title="NSHTTPCookieStorage"></a>NSHTTPCookieStorage</h4><p>NSHTTPCookieStorage单件类提供了管理所有NSHTTPCookie对象的接口，在OS X里,cookie是在所有程序中共享的，而在iOS中,cookie只当当前应用中有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">通过sharedHTTPCookieStorage方法可获取到共享的NSHTTPCookieStorage单件对象。</div><div class="line">+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage；</div><div class="line"></div><div class="line">使用NSHTTPCookieStorage单件对象可获取到当前存储的所有cookie</div><div class="line">- (NSArray *)cookies</div><div class="line"></div><div class="line">或针对特定URL的cookie</div><div class="line">- (NSArray *)cookiesForURL:(NSURL *)theURL;</div><div class="line"></div><div class="line">还可以添加/删除Cookie</div><div class="line">– deleteCookie:</div><div class="line">– setCookie:</div><div class="line">– setCookies:forURL:mainDocumentURL:</div><div class="line"></div><div class="line">通过NSHTTPCookieStorage可读取/修改cookie接收策略,默认为NSHTTPCookieAcceptPolicyAlways.</div><div class="line">- (NSHTTPCookieAcceptPolicy)cookieAcceptPolicy；</div><div class="line">- (void)setCookieAcceptPolicy:(NSHTTPCookieAcceptPolicy)aPolicy.</div><div class="line"></div><div class="line">一共有三种cookie accept policy,</div><div class="line">typedef enum &#123;</div><div class="line">   NSHTTPCookieAcceptPolicyAlways,</div><div class="line">   NSHTTPCookieAcceptPolicyNever,</div><div class="line">   NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain</div><div class="line">&#125; NSHTTPCookieAcceptPolicy;</div><div class="line"></div><div class="line">NSHTTPCookieAcceptPolicyAlways:接收所有cookie,默认策略.</div><div class="line">NSHTTPCookieAcceptPolicyNever: 拒绝所有cookie</div><div class="line">NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain:只接收main document domain中的cookie.</div></pre></td></tr></table></figure>
<p>相关通知Notification</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieManagerCookiesChangedNotification</div><div class="line">当NSHTTPCookieStorage实例中的cookies变化时发出此通知。</div><div class="line">NSHTTPCookieManagerAcceptPolicyChangedNotification</div><div class="line">当NSHTTPCookieStorage实例的cookie acceptance policy变化时发出此通知。</div></pre></td></tr></table></figure>
<h4 id="cookie的使用"><a href="#cookie的使用" class="headerlink" title="cookie的使用"></a>cookie的使用</h4><p>当你利用一个URL请求时，NSURLRequest都会帮你主动记录下来你访问的站点设置的cookie（因为NSHTTPCookieStorage可读取/修改cookie接收策略,默认为NSHTTPCookieAcceptPolicyAlways.当然你也可以给它设置为NSHTTPCookieAcceptPolicyNever: 拒绝所有cookie），而且很负责任的，当你下次再访问这个站点时，NSURLRequest会拿着上次保存下来了的cookie继续去请求。这规律同样适用于 ASIHTTPRequest。所以当你做一些基于认证的网络请求时，cookie不失为一个完美的解决方案。</p>
<h5 id="查看cookie"><a href="#查看cookie" class="headerlink" title="查看cookie"></a>查看cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123;</div><div class="line">       NSLog(@&quot;%@&quot;, cookie);</div><div class="line">&#125;</div><div class="line">这样就列出了所有已保存的cookie,如果当前为空怎么办呢？随便请求一个url喽。</div><div class="line">NSURLRequest *request = [NSURLRequest requestWithURL:</div><div class="line">[NSURL URLWithString:@&quot;http://blog.cnrainbird.com&quot;] cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData    timeoutInterval:3];</div><div class="line">[NSURLConnection sendSynchronousRequest:request </div><div class="line">                      returningResponse:nil </div><div class="line">                                     error:nil]; </div><div class="line"></div><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, cookie);</div><div class="line">&#125;</div><div class="line"></div><div class="line">是不是得到了类似:</div><div class="line">&lt;NSHTTPCookie version:0 name:&quot;PHPSESSID&quot; value:&quot;evf5rcboo8th1dnl53fs4ukmt2&quot; expiresDate:(null) created:2012-03-13 14:28:13 +0000 (3.53342e+08) sessionOnly:TRUE domain:&quot;blog.cnrainbird.com&quot; path:&quot;/&quot; isSecure:FALSE&gt;</div><div class="line">的东东？这就是cookie啦</div></pre></td></tr></table></figure>
<h5 id="清空cookie"><a href="#清空cookie" class="headerlink" title="清空cookie"></a>清空cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">NSArray *_tmpArray = [NSArray arrayWithArray:[cookieJar cookies]];</div><div class="line">for (id obj in _tmpArray) &#123;</div><div class="line">    [cookieJar deleteCookie:obj];</div><div class="line">&#125;</div><div class="line">这样cookie就消失的一干二净了。</div></pre></td></tr></table></figure>
<h5 id="设置指定的cookie"><a href="#设置指定的cookie" class="headerlink" title="设置指定的cookie"></a>设置指定的cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];</div><div class="line">[cookieProperties setObject:@&quot;username&quot; forKey:NSHTTPCookieName];</div><div class="line">[cookieProperties setObject:@&quot;rainbird&quot; forKey:NSHTTPCookieValue];</div><div class="line">[cookieProperties setObject:@&quot;cnrainbird.com&quot; forKey:NSHTTPCookieDomain];</div><div class="line">[cookieProperties setObject:@&quot;cnrainbird.com&quot; forKey:NSHTTPCookieOriginURL];</div><div class="line">[cookieProperties setObject:@&quot;/&quot; forKey:NSHTTPCookiePath];</div><div class="line">[cookieProperties setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion];</div><div class="line"></div><div class="line">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];</div><div class="line">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</div></pre></td></tr></table></figure>
<p><a href="http://jinqianchina.github.io/2016/01/07/Cookie机制以及cookie在iOS中使用介绍/" target="_blank" rel="noopener">参考资料一</a></p>
<p><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">参考资料二</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/28/MAC地址和IP地址的区别和联系/" itemprop="url">
                  MAC地址、IP地址和端口号
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-02-28T16:50:33+08:00" content="2018-02-28">
              2018-02-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/28/MAC地址和IP地址的区别和联系/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/28/MAC地址和IP地址的区别和联系/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>简单的说：IP地址是网络服务商给你分配的，MAC地址是网卡制造商写在网卡上的，端口号用来区分同一台设备上的不同服务。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于IP地址，相信大家都很熟悉，即指使用TCP/IP协议指定给主机的32位地址。IP地址由用点分隔开的4个8八位组构成，如192.168.0.1就是一个IP地址，这种写法叫点分十进制格式。IP地址由网络地址和主机地址两部分组成，分配给这两部分的位数随地址类（A类、B类、C类等）的不同而不同。网络地址用于路由选择，而主机地址用于在网络或子网内部寻找一个单独的主机。一个IP地址使得将来自源地址的数据通过路由而传送到目的地址变为可能。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>对于MAC地址，由于我们不直接和它接触，所以大家不一定很熟悉。在OSI（Open System Interconnection，开放系统互连）7层网络协议（物理层，数据链路层，网络层，传输层，会话层，表示层，应用层）参考模型中，第二层为数据链路层（Data Link）。它包含两个子层，上一层是逻辑链路控制（LLC：Logical Link Control），下一层即是我们前面所提到的MAC（Media Access Control）层，即介质访问控制层。所谓介质（Media），是指传输信号所通过的多种物理环境。常用网络介质包括电缆（如：双绞线，同轴电缆，光纤），还有微波、激光、红外线等，有时也称介质为物理介质。MAC地址也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。这个地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，它都有相同的MAC地址，MAC地址一般不可改变，不能由用户自己设定。</p>
<p>MAC地址的长度为48位（6个字节），通常表示为12个16进制数，每2个16进制数之间用冒号隔开，如：08:00:20:0A:8C:6D就是一个MAC地址，其中前6位16进制数08:00:20代表网络硬件制造商的编号，它由IEEE（Istitute of Electrical and Electronics Engineers，电气与电子工程师协会）分配，而后3位16进制数0A:8C:6D代表该制造商所制造的某个网络产品（如网卡）的系列号。每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC地址。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p> 为了在一台设备上可以运行多个程序，人为的设计了端口(Port)的概念，类似的例子是公司内部的分机号码。规定一个设备有216个，也就是65536个端口，每个端口对应一个唯一的程序。每个网络程序，无论是客户端还是服务器端，都对应一个或多个特定的端口号。由于0-1024之间多被操作系统占用，所以实际编程时一般采用1024以后的端口号。 下面是一些常见的服务对应的端口：</p>
<p>ftp：23，telnet：23，smtp：25，dns：53，http：80，https：443</p>
<p>使用端口号，可以找到一台设备上唯一的一个程序。  所以如果需要和某台计算机建立连接的话，只需要知道IP地址或域名即可，但是如果想和该台计算机上的某个程序交换数据的话，还必须知道该程序使用的端口号。</p>
<h3 id="IP地址与MAC地址在互连网中的作用"><a href="#IP地址与MAC地址在互连网中的作用" class="headerlink" title="IP地址与MAC地址在互连网中的作用"></a>IP地址与MAC地址在互连网中的作用</h3><p>既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？或者说为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：（1）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。（3）无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的。下面我们来通过一个例子看看IP地址和MAC地址是怎样结合来传送数据包的。</p>
<p>　　假设网络上要将一个数据包（名为PAC）由北京的一台主机（名称为A，IP地址为IP_A，MAC地址为MAC_A）发送到华盛顿的一台主机（名称为B，IP地址为IP_B，MAC地址为MAC_B）。这两台主机之间不可能是直接连接起来的，因而数据包在传递时必然要经过许多中间节点（如路由器，服务器等等），我们假定在传输过程中要经过C1、C2、C3（其MAC地址分别为M1，M2，M3）三个节点。A在将PAC发出之前，先发送一个ARP请求，找到其要到达IP_B所必须经历的第一个中间节点C1的MAC地址M1，然后在其数据包中封装（Encapsulation）这些地址：IP_A、IP_B，MAC_A和M1。当PAC传到C1后，再由ARP根据其目的IP地址IP_B，找到其要经历的第二个中间节点C2的MAC地址M2，然后再将带有M2的数据包传送到C2。如此类推，直到最后找到带有IP地址为IP_B的B主机的地址MAC_B，最终传送给主机B。在传输过程中，IP_A、IP_B和MAC_A不变，而中间节点的MAC地址通过ARP在不断改变（M1，M2，M3），直至目的地址MAC_B。</p>
<h3 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h3><ul>
<li><p>IP地址和MAC地址相同点是它们都唯一</p>
</li>
<li><p>对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。</p>
</li>
<li><p>长度不同。IP地址为32位，MAC地址为48位。</p>
</li>
<li><p>分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。</p>
</li>
<li><p>寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/21/Python的一些高级特性/" itemprop="url">
                  Python的一些高级特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-21T10:26:11+08:00" content="2017-08-21">
              2017-08-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/08/21/Python的一些高级特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/21/Python的一些高级特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Python的一些高级特性"><a href="#Python的一些高级特性" class="headerlink" title="Python的一些高级特性"></a>Python的一些高级特性</h3><h4 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h4><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def person(name, age, **kw):</div><div class="line">    print &apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw</div></pre></td></tr></table></figure>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">person(&apos;Michael&apos;, 30)</div><div class="line"></div><div class="line">person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</div><div class="line"></div><div class="line">person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kw = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">person(&apos;Jack&apos;, 24, **kw)</div></pre></td></tr></table></figure>
<h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p><strong>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数</strong></p>
<ul>
<li>变量可以指向函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = abs</div><div class="line"></div><div class="line">f(-10)</div></pre></td></tr></table></figure>
<ul>
<li>函数名也是变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abs = 10</div><div class="line"></div><div class="line">abs</div><div class="line"></div><div class="line">abs(-10)</div></pre></td></tr></table></figure>
<ul>
<li>传入参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f = abs</div><div class="line"></div><div class="line">def add(x,y,f):</div><div class="line">	return f(x) + f(y)</div></pre></td></tr></table></figure>
<ul>
<li><p>内建map()</p>
<p>  <strong>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def f(x):</div><div class="line">	return x * x</div><div class="line"></div><div class="line">map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div class="line"></div><div class="line">map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div class="line"></div><div class="line">//&apos;&apos; &quot;&quot; 区别</div></pre></td></tr></table></figure>
<ul>
<li><p>内建reduce()</p>
<p>  <strong>reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</strong></p>
</li>
</ul>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def add(x,y):</div><div class="line">	return x + y</div><div class="line"></div><div class="line">reduce(add,range(1,10))</div><div class="line"></div><div class="line">sum(range(1,10))</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def fn(x,y)</div><div class="line">	return x * 10 + y</div><div class="line"></div><div class="line">reduce(fn,[1,3,5,7,9])</div></pre></td></tr></table></figure>
<ul>
<li><p>内建filter()</p>
<p>  <strong>filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//奇数</div><div class="line">def is_odd(n):</div><div class="line">    return n % 2 == 1</div><div class="line"></div><div class="line">filter(is_odd,range(1,10))</div></pre></td></tr></table></figure>
<ul>
<li>内建sorted()</li>
</ul>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 逆序</div><div class="line">def reversed_cmp(x, y):</div><div class="line">    if x &gt; y:</div><div class="line">        return -1</div><div class="line">    if x &lt; y:</div><div class="line">        return 1</div><div class="line">    return 0</div><div class="line"></div><div class="line">sorted([36, 5, 12, 9, 21], reversed_cmp)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 字符串忽略大小写排序</div><div class="line">def cmp_ignore_case(s1, s2):</div><div class="line">    u1 = s1.upper()</div><div class="line">    u2 = s2.upper()</div><div class="line">    if u1 &lt; u2:</div><div class="line">        return -1</div><div class="line">    if u1 &gt; u2:</div><div class="line">        return 1</div><div class="line">    return 0</div><div class="line"></div><div class="line">sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)</div></pre></td></tr></table></figure>
<h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def lazy_sum(L=[]):</div><div class="line">    def sum():</div><div class="line">        ax = 0</div><div class="line">        for n in L:</div><div class="line">            ax = ax + n</div><div class="line">        return ax</div><div class="line">    return sum</div><div class="line">    </div><div class="line">f = lazy_sum(range(1,10))</div><div class="line"></div><div class="line">f</div><div class="line"></div><div class="line">f()</div></pre></td></tr></table></figure>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p><strong>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</strong></p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print &apos;call %s():&apos; % func.__name__</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line">    </div><div class="line">@log</div><div class="line">def name():</div><div class="line">    print &apos;lly&apos;</div></pre></td></tr></table></figure>
<p>把<em>@log</em>放到<em>now()</em>函数的定义处，相当于执行了语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now = log(now)</div></pre></td></tr></table></figure>
<p>由于<em>log()</em>是一个<strong>decorator</strong>，返回一个函数，所以，原来的<em>now()</em>函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用<em>now()</em>将执行新函数，即在<em>log()</em>函数中返回的<em>wrapper()</em>函数。</p>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def log(text):</div><div class="line">    def decorator(func):</div><div class="line">        def wrapper(*args, **kw):</div><div class="line">            print &apos;%s %s():&apos; % (text, func.__name__)</div><div class="line">            return func(*args, **kw)</div><div class="line">        return wrapper</div><div class="line">    return decorator</div><div class="line">    </div><div class="line">@log(&apos;netease&apos;)</div><div class="line">def name():</div><div class="line">    print &apos;lly&apos;</div></pre></td></tr></table></figure>
<p>示例三:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line"></div><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print &apos;call %s():&apos; % func.__name__</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="属性、方法的动态绑定和限制"><a href="#属性、方法的动态绑定和限制" class="headerlink" title="属性、方法的动态绑定和限制"></a>属性、方法的动态绑定和限制</h5><p>一、属性的动态绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">s = Student()</div><div class="line">s.name = &apos;lly&apos;</div><div class="line"></div><div class="line">print s.name</div></pre></td></tr></table></figure>
<p>二、方法的动态绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">def set_age(self, age): # 定义一个函数作为实例方法</div><div class="line">	self.age = age</div><div class="line"></div><div class="line">from types import MethodType</div><div class="line"></div><div class="line">s.set_age = MethodType(set_age, s, Student)</div><div class="line">s.set_age(25)</div><div class="line"></div><div class="line">s.age</div></pre></td></tr></table></figure>
<p>三、类的方法绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">def set_score(self, score):</div><div class="line">	self.score = score</div><div class="line"></div><div class="line">from types import MethodType</div><div class="line"></div><div class="line">Student.set_score = MethodType(set_score, None, Student)</div></pre></td></tr></table></figure>
<p>四、限制动态添加</p>
<p><strong>Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class能添加的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	__slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 插槽</div><div class="line"></div><div class="line">s = Student() # 创建新的实例</div><div class="line">s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</div><div class="line">s.age = 25 # 绑定属性&apos;age&apos;</div><div class="line">s.score = 99 # 绑定属性&apos;score&apos;</div></pre></td></tr></table></figure>
<p><em><strong>slots</strong>定义的属性仅对当前类起作用，对继承的子类是不起作用</em></p>
<h5 id="安全简洁的属性"><a href="#安全简洁的属性" class="headerlink" title="安全简洁的属性"></a>安全简洁的属性</h5><p><strong>Python内置的@property装饰器就是负责把一个方法变成属性调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line"></div><div class="line">    @property</div><div class="line">    def score(self):</div><div class="line">        return self._score</div><div class="line"></div><div class="line">    @score.setter</div><div class="line">    def score(self, value):</div><div class="line">        if not isinstance(value, int):</div><div class="line">            raise ValueError(&apos;score must be an integer!&apos;)</div><div class="line">        if value &lt; 0 or value &gt; 100:</div><div class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</div><div class="line">        self._score = value</div><div class="line">        </div><div class="line">s = Student()</div><div class="line">s.score = 60 # OK，实际转化为s.set_score(60)</div><div class="line">s.score # OK，实际转化为s.get_score()</div></pre></td></tr></table></figure>
<h4 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h4><h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">print &apos;Process (%s) start...&apos; % os.getpid()</div><div class="line">pid = os.fork()</div><div class="line">if pid==0:</div><div class="line">    print &apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getppid())</div><div class="line">else:</div><div class="line">    print &apos;I (%s) just created a child process (%s).&apos; % (os.getpid(), pid)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def run_proc(name):</div><div class="line">    print &apos;Run child process %s (%s)...&apos; % (name, os.getpid())</div><div class="line"></div><div class="line">if __name__==&apos;__main__&apos;:</div><div class="line">    print &apos;Parent process %s.&apos; % os.getpid()</div><div class="line">    p = multiprocessing.Process(target=run_proc, args=(&apos;test&apos;,))</div><div class="line">    print &apos;Process will start.&apos;</div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    print &apos;Process end.&apos;</div></pre></td></tr></table></figure>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import time, threading</div><div class="line"></div><div class="line"># 新线程执行的代码:</div><div class="line">def loop():</div><div class="line">    print &apos;thread %s is running...&apos; % threading.current_thread().name</div><div class="line">    n = 0</div><div class="line">    while n &lt; 5:</div><div class="line">        n = n + 1</div><div class="line">        print &apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)</div><div class="line">        time.sleep(1)</div><div class="line">    print &apos;thread %s ended.&apos; % threading.current_thread().name</div><div class="line"></div><div class="line">print &apos;thread %s is running...&apos; % threading.current_thread().name</div><div class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</div><div class="line">t.start()</div><div class="line">t.join()</div><div class="line">print &apos;thread %s ended.&apos; % threading.current_thread().name</div></pre></td></tr></table></figure>
<p>线程加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">balance = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def run_thread(n):</div><div class="line">    for i in range(100000):</div><div class="line">        # 先要获取锁:</div><div class="line">        lock.acquire()</div><div class="line">        try:</div><div class="line">            # 放心地改吧:</div><div class="line">            change_it(n)</div><div class="line">        finally:</div><div class="line">            # 改完了一定要释放锁:</div><div class="line">            lock.release()</div></pre></td></tr></table></figure>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<h4 id="简单爬虫"><a href="#简单爬虫" class="headerlink" title="简单爬虫"></a>简单爬虫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import urllib</div><div class="line"></div><div class="line">uf = urllib.urlopen(&apos;https://baidu.com&apos;)</div><div class="line"></div><div class="line">uf.read()</div><div class="line"></div><div class="line">urllib.urlretrieve(&apos;urlpath&apos;,&apos;filename&apos;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/" itemprop="url">
                  高性能iOS应用开发读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-07T10:02:22+08:00" content="2017-07-07">
              2017-07-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/%E9%AB%98%E6%80%A7%E8%83%BDiOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.png" alt=""></p>
<h3 id="第一章-移动应用的性能"><a href="#第一章-移动应用的性能" class="headerlink" title="第一章 移动应用的性能"></a>第一章 移动应用的性能</h3><ul>
<li>应用首次工作出错以后，79%的用户只会再重试一两次</li>
<li>当应用载入时间超过3秒时，25%的用户会放弃使用该应用。</li>
<li>31%的用户会将糟糕的体验转告他人。</li>
</ul>
<h4 id="定义性能"><a href="#定义性能" class="headerlink" title="定义性能"></a>定义性能</h4><p>高性能有着多重的含义和丰富的解释方式。</p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul>
<li>内存</li>
<li>电池消耗</li>
<li>程序初始化时间</li>
<li>执行速度</li>
<li>响应速度</li>
<li>本地存储</li>
<li>互操作性</li>
<li>网络环境</li>
<li>带宽</li>
<li>数据刷新</li>
<li>多用户支持</li>
<li>单点登录</li>
<li>安全</li>
<li>崩溃</li>
</ul>
<h4 id="应用性能分析"><a href="#应用性能分析" class="headerlink" title="应用性能分析"></a>应用性能分析</h4><ul>
<li>采样</li>
<li>埋点</li>
</ul>
<h4 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h4><p>过早优化是编程领域的万恶之源–高德纳？？？</p>
<p><a href="https://github.com/gvaish/hpios" target="_blank" rel="noopener">测试代码地址</a></p>
<h3 id="第二章-内存管理"><a href="#第二章-内存管理" class="headerlink" title="第二章 内存管理"></a>第二章 内存管理</h3><p>90%的应用崩溃与内存管理有关，其中最主要的原因是错误的内存访问和保留环所引起的内存泄露 – Apple Dev</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/06/程序员的自我修养-链接、装载和库读书笔记/" itemprop="url">
                  程序员的自我修养--链接、装载和库读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-06T18:14:55+08:00" content="2017-07-06">
              2017-07-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/06/程序员的自我修养-链接、装载和库读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/06/程序员的自我修养-链接、装载和库读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.png" alt=""></p>
<h3 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h3><h4 id="从-Hello-World说起"><a href="#从-Hello-World说起" class="headerlink" title="从 Hello World说起"></a>从 Hello World说起</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">int mian()</div><div class="line">&#123;</div><div class="line">	printf(&quot;Hello World\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Hello World 被输出的整个流程的思考…</li>
</ul>
<h4 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h4><ul>
<li>计算机的关键部件：中央处理器CPU,内存和I/O控制芯片</li>
<li>北桥和南桥的概念</li>
<li>SMP（对称多处理器）和多核</li>
</ul>
<h4 id="站得高，望得远"><a href="#站得高，望得远" class="headerlink" title="站得高，望得远"></a>站得高，望得远</h4><ul>
<li>系统软件分类：平台性的（系统工具类）和开发类的（IDE,汇编器，链接器等）</li>
<li><p>计算机软件体系结构</p>
<pre><code>从上到下
应用--&gt;运行时库--&gt;操作系统内核--&gt;硬件
</code></pre></li>
<li><p>运行时库使用系统接口一般使用软件中断实现        </p>
</li>
<li>硬件相关接口（驱动程序）即硬件规格</li>
</ul>
<h4 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a>操作系统做什么</h4><h5 id="不让CPU打盹"><a href="#不让CPU打盹" class="headerlink" title="不让CPU打盹"></a>不让CPU打盹</h5><ul>
<li>分时系统，多任务系统</li>
<li>进程的概念，进程有自己的地址空间，互相隔离。根据优先级由操作系统统一分配CPU运行时间</li>
<li>抢占式的分配方式</li>
<li>CPU在多个进程间快速切换，从而造成很多进程在同时运行的假象。</li>
</ul>
<h5 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h5><ul>
<li>硬件驱动程序的开发由硬件生产商完成。</li>
<li><p>硬盘的结构，每个扇区512k</p>
<pre><code>扇片-磁道（65536）-扇区（1024）
</code></pre></li>
</ul>
<h4 id="内存不够怎么办"><a href="#内存不够怎么办" class="headerlink" title="内存不够怎么办"></a>内存不够怎么办</h4><p>直接顺序分配的问题：</p>
<ol>
<li>地址空间不隔离</li>
<li>内存使用率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p>解决方法：添加中间层（虚拟地址）</p>
<h5 id="关于隔离"><a href="#关于隔离" class="headerlink" title="关于隔离"></a>关于隔离</h5><ul>
<li>虚拟地址空间和物理地址空间</li>
<li>虚拟地址空间是指虚拟的、人们想象出来的地址空间，其实他并不存在，每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程隔离。</li>
</ul>
<h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><ul>
<li>将内存分为多段，每段对应一个进程。</li>
<li>物理地址空间和虚拟地址空间相对应。</li>
<li>分段使用效率低</li>
</ul>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><ul>
<li>每页大小为4K</li>
<li>MMU页面映射</li>
</ul>
<h4 id="众人拾柴火焰高"><a href="#众人拾柴火焰高" class="headerlink" title="众人拾柴火焰高"></a>众人拾柴火焰高</h4><h5 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h5><ul>
<li>线程有时被称为轻量级进程。</li>
<li>由线程ID,当前指令指针（PC），寄存器集合和堆栈组成。</li>
<li>一个进程由一个到多个线程组成，每个线程共享进程的内存空间（代码段，数据段，堆等）。</li>
<li>线程的私有存储空间包括栈，线程局部存储（TLS）和寄存器。</li>
<li>线程的访问权限有私有权限和线程共享权限两种。</li>
<li>私有权限包括局部变量，函数的参数和TLS数据</li>
<li>线程的状态包括运行，就绪和等待。</li>
<li>处于运行中的线程拥有一段可以执行的时间称为时间片。</li>
<li>线程调度方案包括优先级调度和轮转法调度。</li>
<li>I/O密集型线程（频繁等待的线程）优先级更容易改变</li>
<li>CPU密集型线程（很少等待的线程）容易饿死其他低优先级的线程</li>
<li><p>改变优先级的方式有三种：</p>
<pre><code>1.用户指定优先级
2.根据进入等待状态的频繁程度提升或降低优先级
3.长时间得不到执行而被提升优先级
</code></pre></li>
<li>可抢占线程（一般为可抢占）和不可抢占线程（线程利用率低）</li>
</ul>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><ul>
<li>多线程访问一个共享资源时</li>
<li>原子操作（单指令操作）</li>
<li>同步锁（Synchronization）</li>
<li>二元信号量是一种简单的锁，只有两种状态（占有和非占有）适合只能被一个线程独占的资源。</li>
<li>Semaphore(信号量)N个信号量允许N个线程并发访问</li>
<li>互斥量（Mutex）和二元信号量很类似，不同处是互斥量需要在哪个线程获取必须在哪个线程释放。而信号量可以被任意线程获取并释放。</li>
<li>临界区是比互斥量更加严格的同步手段。临界区的作用范围只在本进程。其他进程无法获取该锁。而互斥量可以被其他线程获取（但不能被其他线程释放）。</li>
<li>读写锁。其他线程可读但是不可写。</li>
<li>条件变量，使用条件变量可以让许多线程等待同一个条件的发生。</li>
</ul>
<h5 id="多线程内部情况"><a href="#多线程内部情况" class="headerlink" title="多线程内部情况"></a>多线程内部情况</h5><p>用户线程和内核线程（CPU）的对应关系</p>
<ul>
<li>一对一，线程并发是真正的并发，线程数受内核限制，上线文切换开销大。</li>
<li>多对一，如果一个用户线程堵塞，其他用户线程也会阻塞。</li>
<li>多对多，结合了上面两种的优点。（常用）</li>
</ul>
<h3 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h3><p>编译和链接合并到一起的过程叫构建（Build）</p>
<h4 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h4><p>helloworld输出可以分解为4个步骤，分别是 <em>预处理</em> <em>编译</em> <em>汇编</em> <em>链接</em></p>
<h5 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h5><ul>
<li>将所有的 <em>#deifne</em> 删除 并展开所有的宏定义</li>
<li>处理所有的条件编译指令 比如#if #else #ifdef #endif 等等。</li>
<li>处理#include预编译指令 将所包含的文件插入到预编译指令的位置</li>
<li>删除所有的注释 // /<em> </em>/ 等等</li>
<li>添加行号和文件名标识</li>
<li>保留所有#pragma编译器指令</li>
</ul>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>编译过程就是把预处理完成的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件。</p>
<h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令</p>
<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>模块的拼接过程 下面还会详细讲。</p>
<h4 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h4><ul>
<li>直观角度讲，编译器就是将高级语言翻译为机器语言。</li>
<li>流程：词法分析-&gt;语法分析-&gt;语义分析-&gt;源代码优化-&gt;代码生成&gt;目标代码优化.</li>
</ul>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul>
<li>扫描源代码 生成一系列记号（Token）</li>
<li>记号分类：关键字、标识符、字面量（包括数字，字符串）、特殊符号（+、=）。</li>
<li>每种记号存入对应的表内</li>
<li>词法规则可以自定义</li>
</ul>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><ul>
<li>对上面的词法表进行语法分析、生成语法树</li>
<li>整个分析过程采用上下文无关语法</li>
<li>语法树以表达式为节点</li>
<li>语法树是一种二叉树的应用（个人理解）</li>
</ul>
<h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><ul>
<li>编译器所能分析的语义是静态语义</li>
<li>静态语义通常包括声明和类型的匹配，类型的转换。</li>
<li>经过语义分析，语法树被标识了类型</li>
<li>语义分析判断该语法是否合法（个人理解）</li>
</ul>
<h5 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h5><ul>
<li>直接在语法树上面优化比较困难，所以源代码优化器会先将语法树转换为中间代码</li>
<li>中间代码是设备无关的</li>
<li>编译器前端负责产生机器无关的中间代码，后端负责将中间代码转换成目标机器代码。</li>
<li>跨平台编译器就是有一个前端和多个后端的组合</li>
</ul>
<h5 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h5><ul>
<li>编译器后端主要包括代码生成器和目标代码优化器</li>
</ul>
<h4 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h4><ul>
<li>重新计算各个目标的地址过程被叫做重定向。</li>
<li>模块的拼接过程在这里被叫做链接</li>
</ul>
<h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><ul>
<li>链接的过程主要包括：地址和空间分配、符号决议、重定向。</li>
<li>目标文件和库一起链接生成可执行文件</li>
<li>库其实是一种编译后的目标文件</li>
<li>目标文件之间的函数和变量的访问在链接过程中被重定向。</li>
</ul>
<h3 id="第三章-目标文件里有什么？"><a href="#第三章-目标文件里有什么？" class="headerlink" title="第三章 目标文件里有什么？"></a>第三章 目标文件里有什么？</h3><p>编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，目标文件从结构上讲是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能还有一些符号或者有些地址还没有被调整。</p>
<h4 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h4><ul>
<li>windows下是叫PE-COFF文件格式，Linux下叫ELF文件。</li>
<li>动态链接库和静态链接库也是以上格式。</li>
</ul>
<h4 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h4><ul>
<li>目标文件由各种段（Section）组成。</li>
<li>段类型有.text .data .bss .commment等</li>
<li>.text主要存放源代码</li>
<li>.data主要存放已初始化的全局变量和局部变量</li>
<li>.bss存放未初始化的全局和静态变量</li>
</ul>
<h5 id="数据段和指令段分开存储的好处："><a href="#数据段和指令段分开存储的好处：" class="headerlink" title="数据段和指令段分开存储的好处："></a>数据段和指令段分开存储的好处：</h5><ul>
<li>读写权限的不同，数据段是可读写的，指令段是只读的，当程序被装载后，数据和指令会被映射到不同的虚存区域。这样可以防止程序的指令被有意或者无意的改写。</li>
<li>提高了缓存的命中率</li>
<li>最主要的原因：当系统运行多个该程序的副本时，它们的指令都是一样的，所以在内存中只需要保存一份程序的指令部分，而数据会有多份。</li>
</ul>
<h4 id="挖掘SimpleSection-o"><a href="#挖掘SimpleSection-o" class="headerlink" title="挖掘SimpleSection.o"></a>挖掘SimpleSection.o</h4><ul>
<li>.rodata存放的是只读数据（ROM）。</li>
<li>部分编译器不存放为初始化变量，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在.bss段分配空间</li>
</ul>
<h5 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h5><ul>
<li>.rodata </li>
<li>.comment</li>
<li>.debug</li>
<li>.dynamic</li>
<li>.hash </li>
<li>.line </li>
<li>.note </li>
<li>.strtab </li>
<li>.symtab </li>
<li>.shstrtab </li>
<li>.plt </li>
<li>.got </li>
<li>.init </li>
<li>.fini</li>
</ul>
<h4 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h4><h5 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h5><ul>
<li>ELF魔数</li>
<li>文件机器字节长度</li>
<li>数据存储方式</li>
<li>版本</li>
<li>运行平台</li>
<li>ABI版本</li>
<li>ELF重定位类型</li>
<li>硬件平台</li>
<li>硬件平台版本</li>
<li>入口地址</li>
<li>程序头入口和长度</li>
<li>段表的位置和长度</li>
<li>段的数量</li>
</ul>
<h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><ul>
<li>段表就是保存各个段的基本属性的结构</li>
<li>每个段的基本属性保存在一个叫段描述符的结构体里。</li>
<li>.rel.data和.rel.text 重定向的段。</li>
<li>.strtabl和.shstrtab 字符串表和段表字符串表。</li>
</ul>
<h4 id="链接的接口–符号"><a href="#链接的接口–符号" class="headerlink" title="链接的接口–符号"></a>链接的接口–符号</h4><ul>
<li>在链接中，目标文件之间的相互拼合实际上是目标文件之间对地址的引用，我们将函数和变量统称为符号，函数名和变量名就是符号名。</li>
<li>每一个目标文件都有一个相应的符号表，这个表里面记录了目标文件中所用到的所有的符号</li>
<li>每个对应的符号有一个对应值叫做符号值，对于变量和函数来说，符号值就是他们的地址。</li>
</ul>
<h5 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h5><ul>
<li>全局符号</li>
<li>外部符号</li>
<li>段名</li>
<li>局部符号</li>
<li>行号信息</li>
</ul>
<h5 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h5><ul>
<li>symtab</li>
<li>每个符号对应一个结构体（Elf32_Sym）</li>
</ul>
<h5 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h5><ul>
<li>程序起始地址</li>
<li>text段结束地址</li>
<li>data段结束地址</li>
<li>程序结束地址</li>
<li>以上地址都是程序被装载时的虚拟地址</li>
</ul>
<h5 id="符号修饰和函数签名"><a href="#符号修饰和函数签名" class="headerlink" title="符号修饰和函数签名"></a>符号修饰和函数签名</h5><ul>
<li>加前缀下划线和后缀下划线</li>
<li>通过命名空间</li>
<li>函数签名信息包括：函数名、参数类型、所在类、命名空间等。</li>
</ul>
<h5 id="extren-“C”"><a href="#extren-“C”" class="headerlink" title="extren “C”"></a>extren “C”</h5><p>extern修饰的代码段编译器会按C语言的编译规则来处理</p>
<h5 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h5><ul>
<li>函数和初始化了的全局变量为强符号</li>
<li>未初始化的变量为弱符号</li>
</ul>
<h3 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h3><p>当我们有两个目标文件时，如何将它们链接起来形成一个可执行文件？这个过程中发生了什么？这基本上就是链接的核心内容：静态链接</p>
<h4 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h4><p>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件?</p>
<h5 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h5><ul>
<li>缺点：浪费空间，文件零散。</li>
<li>段的装载地址和空间对齐单位是<strong>页</strong>，每一页有4096个字节。</li>
</ul>
<h5 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h5><p>我们这里谈的空间地址分配只关注虚拟地址空间的分配，不关心输出在可执行文件中的空间</p>
<p>两步链接：</p>
<ul>
<li><p>空间与地址分配</p>
</li>
<li><p>符号解析与重定向</p>
</li>
</ul>
<h5 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h5><p>存储在符号表内</p>
<h4 id="符号解析与重定向"><a href="#符号解析与重定向" class="headerlink" title="符号解析与重定向"></a>符号解析与重定向</h4><p>静态链接的核心内容是符号解析和重定向</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>重定向需要参考重定位表</p>
<h5 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h5><p>每一个要被重定位的地方叫一个重定位入口，重定位入口的偏移表示该入口在要被重定位的段中的位置。</p>
<h5 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h5><p>重定位的过程中，每一个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确认这个符号的目标地址，这个时候链接器就会去查找所有目标文件的符号表，这个过程叫做符号解析。</p>
<h5 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h5><p>不同的处理器指令对于地址的格式和方式都不一样。</p>
<ul>
<li><p>绝对寻址修正</p>
</li>
<li><p>相对寻址修正</p>
</li>
</ul>
<p>区别：绝对地址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差</p>
<h4 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h4><ul>
<li><p>存放弱符号的块</p>
</li>
<li><p>当不同的目标文件需要的COMMON块的空间大小不一致时，以最大的那块为准。</p>
</li>
</ul>
<h4 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h4><h5 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h5><ul>
<li>模板、外部内联函数、虚函数表都有可能在不同的编译单元生成相同的代码</li>
</ul>
<p>弊端：</p>
<ul>
<li>空间的浪费</li>
<li>地址较易出错</li>
<li>指令运行效率较低</li>
</ul>
<p><strong>函数级别链接</strong>的作用就是让所有的函数都像模板一样单独的保存到一个段里面。</p>
<h5 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h5><p>c++的全局对象构造函数在main()之前被执行，c++的全局对象析构函数在main()之后被执行</p>
<ul>
<li><p>.init段 全局构造</p>
</li>
<li><p>.fini段 全局析构</p>
</li>
</ul>
<h5 id="c-与ABI"><a href="#c-与ABI" class="headerlink" title="c++与ABI"></a>c++与ABI</h5><p>ABI：符号修饰标准，变量内存布局方式，函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI</p>
<h4 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h4><p>将多个静态库链接到一个可执行文件中的过程。</p>
<h4 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h4><h5 id="链接控制脚本"><a href="#链接控制脚本" class="headerlink" title="链接控制脚本"></a>链接控制脚本</h5><ul>
<li><p>使用命令行来给链接器指定参数</p>
</li>
<li><p>将链接指令存放在目标文件里面</p>
</li>
<li><p>使用链接控制脚本</p>
</li>
</ul>
<p>c++把这种控制脚本叫做模块定义文件，它们的扩展名一般为.def</p>
<h5 id="使用ld链接脚本"><a href="#使用ld链接脚本" class="headerlink" title="使用ld链接脚本"></a>使用ld链接脚本</h5><p>控制链接过程无非是控制输入段如何变成输出段，比如哪些输入段要合并一个输出段，哪些输入段要丢弃，指定输出段的名字，装载地址，属性等。</p>
<p>有人专门研究过最小的ELF可执行文件的大小为45个字节。</p>
<h5 id="ld链接脚本语法简介"><a href="#ld链接脚本语法简介" class="headerlink" title="ld链接脚本语法简介"></a>ld链接脚本语法简介</h5><ul>
<li><p>语句之间使用；号作为分隔符</p>
</li>
<li><p>表达式与运算符</p>
</li>
<li><p>注释和字符引用</p>
</li>
</ul>
<h4 id="BFD库"><a href="#BFD库" class="headerlink" title="BFD库"></a>BFD库</h4><p>BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件格式。</p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>本章介绍了静态链接中的第一个步骤，即目标文件在被连接成最终可执行文件时，输入目标文件的各个段是如何被合并到输出文件中的，链接器如何为他们分配在输出文件中空间和地址。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/27/SceneKit的那些坑/" itemprop="url">
                  SceneKit的那些坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-27T16:27:35+08:00" content="2017-05-27">
              2017-05-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/27/SceneKit的那些坑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/27/SceneKit的那些坑/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SceneKit是苹果爸爸自带的一个3D引擎，应该是高度封装了OpenGL ES相关的内容，使用起来比OpenGL方便了不止100倍，当然功能上肯定不能和手撸OpenGL相比较啦，但是一些简单的3D场景用它做起来还是比较方便的。比如加载显示个3D模型啥的。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>产品想在咱的app里面加一套勋章体系，这个也不是啥新鲜功能啦，纵观各大直播app,勋章体系做的都是66的，但是呢，咱们产品大大看上了QQ的勋章展示方式，如下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/qqmedel.gif" alt=""></p>
<p>第一反应是OpenGL ES，后来同事推荐了SceneKit这个框架，于是有了这一篇踩坑之旅。</p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="http://www.jianshu.com/u/1c37e216663b" target="_blank" rel="noopener">这位同学</a> 的入门教程还不错，不过现在他把教程转为了收费项目，但是代码还是可以在<a href="https://github.com/XJALYN/SceneKit_Learn" target="_blank" rel="noopener">他的Github上</a>下载到的，而且看他的提交记录.md文件里面会有惊喜哦。</p>
<p>so 我这里就直说我踩过的一些坑啦，想学习整个流程的童鞋可以参考上面的教程。在这里先谢谢这位同学啦~~~</p>
<h3 id="坑s"><a href="#坑s" class="headerlink" title="坑s"></a>坑s</h3><p>SceneKit是支持两个格式的文件的.scn和.dae 但是 这两种格式好像并没有太大的区别，都可以通过下面2中方式加载到程序中：</p>
<p>通过记事本打开文件，就会发现每个模型（node）都有一个id和name</p>
<h4 id="通过id加载"><a href="#通过id加载" class="headerlink" title="通过id加载"></a>通过id加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSURL *bundlePathUrl = [[NSBundle mainBundle] bundleURL];</div><div class="line">bundlePathUrl = [bundlePathUrl URLByAppendingPathComponent:@&quot;art.scnassets/medle1.dae&quot;];</div><div class="line">            </div><div class="line">SCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:bundlePathUrl options:nil];</div><div class="line">SCNNode *myNode = [sceneSource entryWithIdentifier:@&quot;ID4&quot; withClass:[SCNNode class]];</div></pre></td></tr></table></figure>
<h4 id="通过name加载"><a href="#通过name加载" class="headerlink" title="通过name加载"></a>通过name加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SCNScene *scene = [SCNScene sceneNamed:@&quot;art.scnassets/medle1.dae&quot;];</div><div class="line">SCNNode *myNode = [scene.rootNode childNodeWithName:@&quot;medle1&quot; recursively:YES];</div></pre></td></tr></table></figure>
<h4 id="自定义材质-Material"><a href="#自定义材质-Material" class="headerlink" title="自定义材质(Material)"></a>自定义材质(Material)</h4><p>想要自定义模型的材质，就需要获取到模型的几何属性(geometry),but 自定义的模型加载进来的时候默认的geometry属性是nil的你敢信吗。。。google了一番之后，找到了一个解决方案 先遍历一下这个模型的childNodes 然后修改child的geometry的firstMaterial。。。这也算曲线救国了</p>
<p>这里还有一个坑，美工导出的模型可能会有好几个child我擦嘞。。。这个时候咋办呢 ，取哪个都不对啊， 每个child可能都只是整个模型的一部分而已，让美工的同学先把这几个child合并为一个child，然后再导出试试吧。</p>
<h4 id="材质叠加"><a href="#材质叠加" class="headerlink" title="材质叠加"></a>材质叠加</h4><p>美工同学可能建好了模型，并成功导出正确的模型格式，还把材质也一起导出来了，是不是很完美。拿来直接用就可以啦。but 我要再添加一个材质到模型上该如何实现呢（比如我要贴一张图片到模型上），如果我直接修改firstMaterial的话，那么不好意思哦，原来美工导出的材质就被remove掉了。</p>
<p>这个时候就不能直接修改firstMaterial啦，需要修改firstMaterial的diffuse和multiply属性来实现，美工同学导出的材质图片= diffuse.contents  自定义贴图 = multiply.contents。 然后就是微调图片的位置啥的了，通过修改contentsTransform这个属性来实现。</p>
<h4 id="添加射灯"><a href="#添加射灯" class="headerlink" title="添加射灯"></a>添加射灯</h4><p>可以看到，qq的勋章在滑动的时候，上面有高亮的金属光泽，这个应该是可以通过添加灯光来实现的。SceneKit有提供4中灯光，分别是环境光，点光源，方向光和聚光灯（我这里叫他射灯）。</p>
<p>首先 环境光和点光源都是必须的 实现高光的话，还需要再添加一个射灯，然后调整照射的位置到你满意就可以啦。见如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (SCNNode *)spotNode&#123;</div><div class="line"></div><div class="line">    if (!_spotNode) &#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        SCNLight *spotLight = [SCNLight light];// 创建光对象</div><div class="line">        spotLight.type = SCNLightTypeSpot;// 设置类型</div><div class="line">        spotLight.color = [UIColor whiteColor]; // 设置光的颜色</div><div class="line">        spotLight.castsShadow = TRUE;// 捕捉阴影</div><div class="line">        spotLight.attenuationStartDistance = 0;</div><div class="line">        spotLight.attenuationEndDistance = 100;</div><div class="line">        spotLight.attenuationFalloffExponent = 2;</div><div class="line">        spotLight.spotInnerAngle = 0;</div><div class="line">        spotLight.spotOuterAngle = 30;</div><div class="line">        _spotNode = [SCNNode node];</div><div class="line">        _spotNode.position = SCNVector3Make(0, 2, 10); //设置光源节点的位置</div><div class="line">        _spotNode.light  = spotLight;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _spotNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="勋章的旋转"><a href="#勋章的旋转" class="headerlink" title="勋章的旋转"></a>勋章的旋转</h4><p>勋章需要支持手势，主要是通过滑动手势旋转勋章，而且需要在不同滑动力度时旋转不同的角度，当然，最后旋转的角度都是M_PI的整数倍，所以勋章才会始终保持正面或者背面面向屏幕而不是侧面面向屏幕了。</p>
<h5 id="手势的选择"><a href="#手势的选择" class="headerlink" title="手势的选择"></a>手势的选择</h5><p>手势识别我尝试了2种方案，第一种是touchBegan系列响应事件，还有一种是添加UIPanGestureRecognizer手势，其实二者的处理方案是差不多的，但是使用touch系列方法不能检测到滑动的速度，而UIPanGestureRecognizer有提供检测速率的方法，so 当然是选择UIPanGestureRecognizer啦~</p>
<h5 id="属性的选择"><a href="#属性的选择" class="headerlink" title="属性的选择"></a>属性的选择</h5><p>然后就是选择改变node的哪个属性来实现旋转了，SCNNode有好几个属性都是可以旋转node，比如transform,pivot,rotation等,不同点是前两个是矩阵运算，后一个是向量运算。这里我也做了2种尝试，最初我使用的是pivot，在处理旋转角度小于M_PI时还行，但是如果想让勋章旋转一圈或者几圈时，无论我的角度设置的是多大，最终效果都只能旋转M_PI。好吧，然后我就转向使用rotation旋转勋章，这里还有一点需要注意的，要保证勋章是平滑的转动而不会出现突出旋转到某个方向，必须要在勋章的初始角度上进行加减，并保存勋章旋转后的角度以便下一次旋转时计算角度值。</p>
<h5 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h5><p>当手指离开屏幕后，勋章会根据手指滑动的速率和方向做一个旋转的弹簧动画，因为SCNNode本身是支持CA动画的，所以我首先想到的就是使用CA动画去做，ok,第一次旋转是木有问题的，但是动画结束之后，如果你再去旋转勋章你会发现，勋章完全不动了，不管你的旋转角度是多少。。。我想可能是因为CA动画本身并没有改变rotation的值，所以当我再次旋转时计算的角度值并不是从当前勋章的其实角度开始的。</p>
<p>CA动画不行，还好Scenekit提供了另外一种动画的实现方式，SCNTransaction动画，类似于CATransaction的使用方式。好吧 动画这块的效果终于差不多搞定了。</p>
<h4 id="自定义贴图"><a href="#自定义贴图" class="headerlink" title="自定义贴图"></a>自定义贴图</h4><p>勋章的背面需要显示用户的相关信息，这些信息都是动态的，不可能是美工同学在建模的时候加，只能是通过代码的方式动态的加上去。</p>
<p>因为图片可以直接作为材质的contents，so 我将需要显示的信息放到一个label上，然后对这个label做截图操作就可以得到我想要的图片文件了。</p>
<p>SCNNode有很多的材质相关的属性，而且还有一个材质列表，模型所有使用的材质都在这个列表中可以找到，所以我的做法就是取出你需要改变的材质，将自定义贴图和当前材质做一个合并，然后使用合并后的材质替换之前的。</p>
<p>这里有点需要注意的就是调试贴图到正确的位置，因为图片的坐标系是01坐标系，所以在调试的时候参数需要尽量小，慢慢调，如果你合并材质和替换都成功了但是在模型上面看不到图片，可能就是图片的位置不对。</p>
<h4 id="模型的动态加载"><a href="#模型的动态加载" class="headerlink" title="模型的动态加载"></a>模型的动态加载</h4><p>Xcode在build的时候，会把项目中引用了的.dae模型(这里指本地模型)通过一个脚本copy到.ipa中，copy的过程中可能对模型的格式进行了特殊处理，因为copy后的文件比原文件小了很多。</p>
<p>如果我们要动态加载模型的话，Xcode是没有对模型进行copy操作的，我们直接使用设计给的模型文件，在模型被保存到沙盒中后，通过文件路径加载无法正常加载出模型，后来在网上找到<a href="https://the-nerd.be/2014/11/07/dynamically-load-collada-files-in-scenekit-at-runtime/#more-457" target="_blank" rel="noopener">这个解决方案</a>，<a href="http://www.jianshu.com/p/78be2688ef4c" target="_blank" rel="noopener">这里还有一篇中文的，内容差不多</a>，先将模型用Xcode在build时使用的脚步copy一份，然后把copy的模型文件给服务器，下载后就可以正常显示了。</p>
<p>相当于我们帮Xcode做了copy的操作。</p>
<p><a href="https://github.com/lilingyu0620/LLYSceneKitDemo" target="_blank" rel="noopener">这是我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
