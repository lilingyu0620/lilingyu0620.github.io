<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/04/FDFullscreenPopGesture全屏返回实现原理解析/" itemprop="url">
                  FDFullscreenPopGesture全屏返回实现原理解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-04T14:47:58+08:00" content="2018-07-04">
              2018-07-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/04/FDFullscreenPopGesture全屏返回实现原理解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/04/FDFullscreenPopGesture全屏返回实现原理解析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在项目中处理了一个UIScrollView右滑返回上级页的问题，刚好项目中也使用了<a href="https://github.com/forkingdog/FDFullscreenPopGesture" target="_blank" rel="noopener">FDFullscreenPopGesture</a>这个全屏返回的库，于是来分析它的实现吧。</p>
<p>这个库是sunngxx之前在百度的时候弄的，已经好久没有更新了，不过目前还能用，star也已经有5k多了，而且sunngxx这种runtime小王子，写的这个库几乎所有函数都是runtime实现，还是很有学习的价值的。</p>
<p>FDFullscreenPopGesture是以一个分类文件的形式提供给使用者，在内部重写了<strong>+(void)load;</strong>方法，只要把代码集成到项目中就可以使用全屏返回了。</p>
<p>先来看一下头文件中的内容，首先是UINavigationController的分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface UINavigationController (FDFullscreenPopGesture)</div><div class="line"></div><div class="line">/// The gesture recognizer that actually handles interactive pop.</div><div class="line">@property (nonatomic, strong, readonly) UIPanGestureRecognizer *fd_fullscreenPopGestureRecognizer;</div><div class="line"></div><div class="line">/// A view controller is able to control navigation bar&apos;s appearance by itself,</div><div class="line">/// rather than a global way, checking &quot;fd_prefersNavigationBarHidden&quot; property.</div><div class="line">/// Default to YES, disable it if you don&apos;t want so.</div><div class="line">@property (nonatomic, assign) BOOL fd_viewControllerBasedNavigationBarAppearanceEnabled;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>第一个属性是当前实际相应右滑的手势对象，这个对象替换了系统的手势对象，具体咋替换的后面在说。</p>
<p>第二个属性设置是否使用fd的方法去控制导航栏的显示隐藏。</p>
<p>然后我们看一下UIViewController的分类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/// Allows any view controller to disable interactive pop gesture, which might</div><div class="line">/// be necessary when the view controller itself handles pan gesture in some</div><div class="line">/// cases.</div><div class="line">@interface UIViewController (FDFullscreenPopGesture)</div><div class="line"></div><div class="line">/// Whether the interactive pop gesture is disabled when contained in a navigation</div><div class="line">/// stack.</div><div class="line">@property (nonatomic, assign) BOOL fd_interactivePopDisabled;</div><div class="line"></div><div class="line">/// Indicate this view controller prefers its navigation bar hidden or not,</div><div class="line">/// checked when view controller based navigation bar&apos;s appearance is enabled.</div><div class="line">/// Default to NO, bars are more likely to show.</div><div class="line">@property (nonatomic, assign) BOOL fd_prefersNavigationBarHidden;</div><div class="line"></div><div class="line">/// Max allowed initial distance to left edge when you begin the interactive pop</div><div class="line">/// gesture. 0 by default, which means it will ignore this limit.</div><div class="line">@property (nonatomic, assign) CGFloat fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>fd_interactivePopDisabled:当前页面是否支持右滑返回</li>
<li>fd_prefersNavigationBarHidden:控制当前页面导航栏的显示隐藏</li>
<li>fd_interactivePopMaxAllowedInitialDistanceToLeftEdge:右滑返回触发的位置，这里是距离左边距的距离。</li>
</ul>
<h3 id="全屏返回"><a href="#全屏返回" class="headerlink" title="全屏返回"></a>全屏返回</h3><p>我们先来看一下全屏返回的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">@interface _FDFullscreenPopGestureRecognizerDelegate : NSObject &lt;UIGestureRecognizerDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, weak) UINavigationController *navigationController;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation _FDFullscreenPopGestureRecognizerDelegate</div><div class="line"></div><div class="line">//判断是否处理返回手势</div><div class="line">- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer</div><div class="line">&#123;</div><div class="line">    // Ignore when no view controller is pushed into the navigation stack.</div><div class="line">    if (self.navigationController.viewControllers.count &lt;= 1) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Ignore when the active view controller doesn&apos;t allow interactive pop.</div><div class="line">    UIViewController *topViewController = self.navigationController.viewControllers.lastObject;</div><div class="line">    if (topViewController.fd_interactivePopDisabled) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Ignore when the beginning location is beyond max allowed initial distance to left edge.</div><div class="line">    CGPoint beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view];</div><div class="line">    CGFloat maxAllowedInitialDistance = topViewController.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;</div><div class="line">    if (maxAllowedInitialDistance &gt; 0 &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Ignore pan gesture when the navigation controller is currently in transition.</div><div class="line">    if ([[self.navigationController valueForKey:@&quot;_isTransitioning&quot;] boolValue]) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Prevent calling the handler when the gesture begins in an opposite direction.</div><div class="line">    CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view];</div><div class="line">    BOOL isLeftToRight = [UIApplication sharedApplication].userInterfaceLayoutDirection == UIUserInterfaceLayoutDirectionLeftToRight;</div><div class="line">    CGFloat multiplier = isLeftToRight ? 1 : - 1;</div><div class="line">    if ((translation.x * multiplier) &lt;= 0) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化返回手势</div><div class="line">- (UIPanGestureRecognizer *)fd_fullscreenPopGestureRecognizer</div><div class="line">&#123;</div><div class="line">    UIPanGestureRecognizer *panGestureRecognizer = objc_getAssociatedObject(self, _cmd);</div><div class="line"></div><div class="line">    if (!panGestureRecognizer) &#123;</div><div class="line">        panGestureRecognizer = [[UIPanGestureRecognizer alloc] init];</div><div class="line">        panGestureRecognizer.maximumNumberOfTouches = 1;</div><div class="line">        </div><div class="line">        objc_setAssociatedObject(self, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    return panGestureRecognizer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化返回手势的代理</div><div class="line">- (_FDFullscreenPopGestureRecognizerDelegate *)fd_popGestureRecognizerDelegate</div><div class="line">&#123;</div><div class="line">    _FDFullscreenPopGestureRecognizerDelegate *delegate = objc_getAssociatedObject(self, _cmd);</div><div class="line"></div><div class="line">    if (!delegate) &#123;</div><div class="line">        delegate = [[_FDFullscreenPopGestureRecognizerDelegate alloc] init];</div><div class="line">        delegate.navigationController = self;</div><div class="line">        </div><div class="line">        objc_setAssociatedObject(self, _cmd, delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    return delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//hook系统的pushViewController方法，每个vc在被push后都会调用fd的fd_pushViewController方法</div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    // Inject &quot;-pushViewController:animated:&quot;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(pushViewController:animated:);</div><div class="line">        SEL swizzledSelector = @selector(fd_pushViewController:animated:);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">        if (success) &#123;</div><div class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重要代码部分，这里替换系统右滑手势为fd自己的对象，并给对象设置fd自定义的delegate</div><div class="line">- (void)fd_pushViewController:(UIViewController *)viewController animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123;</div><div class="line">        </div><div class="line">        // Add our own gesture recognizer to where the onboard screen edge pan gesture recognizer is attached to.</div><div class="line">        [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer];</div><div class="line"></div><div class="line">        // Forward the gesture events to the private handler of the onboard gesture recognizer.</div><div class="line">        NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@&quot;targets&quot;];</div><div class="line">        id internalTarget = [internalTargets.firstObject valueForKey:@&quot;target&quot;];</div><div class="line">        SEL internalAction = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;);</div><div class="line">        self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate;</div><div class="line">        [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction];</div><div class="line"></div><div class="line">        // Disable the onboard gesture recognizer.</div><div class="line">        self.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Handle perferred navigation bar appearance.</div><div class="line">    [self fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController];</div><div class="line">    </div><div class="line">    // Forward to primary implementation.</div><div class="line">    if (![self.viewControllers containsObject:viewController]) &#123;</div><div class="line">        [self fd_pushViewController:viewController animated:animated];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码展示了fd是怎么一步步的替换了系统的右滑手势的，其他部分比较好理解，这里我们来重点看一下替换代理的部分，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123;</div><div class="line">    </div><div class="line">    // Add our own gesture recognizer to where the onboard screen edge pan gesture recognizer is attached to.</div><div class="line">    [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer];</div><div class="line"></div><div class="line">    // Forward the gesture events to the private handler of the onboard gesture recognizer.</div><div class="line">    NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@&quot;targets&quot;];</div><div class="line">    id internalTarget = [internalTargets.firstObject valueForKey:@&quot;target&quot;];</div><div class="line">    SEL internalAction = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;);</div><div class="line">    self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate;</div><div class="line">    [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction];</div><div class="line"></div><div class="line">    // Disable the onboard gesture recognizer.</div><div class="line">    self.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，先判断当前view的手势列表中是否包含我们自定义的右滑手势，如果不包含，先将自定义手势add到手势列表中，然后重点来了，获取interactivePopGestureRecognizer这个系统右滑返回手势的所有target,然后取出该手势的第一响应者，然后生成系统返回手势处理函数（handleNavigationTransition）的SEL结构体，然后设置自定义手势的代理，最后将系统的target和SEL添加给自定义的手势对象，并将系统的返回手势关闭。这样，fd就可以通过自定义的代理控制右滑返回了。</p>
<h3 id="隐藏导航栏"><a href="#隐藏导航栏" class="headerlink" title="隐藏导航栏"></a>隐藏导航栏</h3><p>看完了右滑返回，再看一下fd是如何隐藏系统导航栏的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(fd_viewWillAppear:);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">        if (success) &#123;</div><div class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fd_viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    // Forward to primary implementation.</div><div class="line">    [self fd_viewWillAppear:animated];</div><div class="line">    </div><div class="line">    if (self.fd_willAppearInjectBlock) &#123;</div><div class="line">        self.fd_willAppearInjectBlock(self, animated);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (_FDViewControllerWillAppearInjectBlock)fd_willAppearInjectBlock</div><div class="line">&#123;</div><div class="line">    return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setFd_willAppearInjectBlock:(_FDViewControllerWillAppearInjectBlock)block</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(fd_willAppearInjectBlock), block, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(UIViewController *)appearingViewController</div><div class="line">&#123;</div><div class="line">    if (!self.fd_viewControllerBasedNavigationBarAppearanceEnabled) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    _FDViewControllerWillAppearInjectBlock block = ^(UIViewController *viewController, BOOL animated) &#123;</div><div class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">        if (strongSelf) &#123;</div><div class="line">            [strongSelf setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    // Setup will appear inject block to appearing view controller.</div><div class="line">    // Setup disappearing view controller as well, because not every view controller is added into</div><div class="line">    // stack by pushing, maybe by &quot;-setViewControllers:&quot;.</div><div class="line">    appearingViewController.fd_willAppearInjectBlock = block;</div><div class="line">    UIViewController *disappearingViewController = self.viewControllers.lastObject;</div><div class="line">    if (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) &#123;</div><div class="line">        disappearingViewController.fd_willAppearInjectBlock = block;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>隐藏这个就比较简单了，也是在fd_pushViewController里面处理的，具体说一下，这里先生成一个用来隐藏导航栏的block，使用的方法还是系统的setNavigationBarHidden：animation 方式。然后将这个block赋值给self.fd_willAppearInjectBlock，然后再每次fd_viewWillAppear时，会调用一下这个block。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，代码大量的使用runtime来编写，学习一遍下来对应runtime相关的内容会有更深刻的认识。然后就是fd替换系统方法的这种骚操作，如果有类似的需求的话也是可以参考的。这个库代码也不太多，内容也比较好理解，个人觉得有学习的价值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/19/SDWebImage学习笔记/" itemprop="url">
                  SDWebImage学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-19T11:09:20+08:00" content="2018-06-19">
              2018-06-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/19/SDWebImage学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/19/SDWebImage学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/sd1.png" alt=""></p>
<p>上图按模块整理了sd各模块的类</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/sd2.png" alt=""></p>
<p>上图则表示了各模块和类在整理项目中的层级关系。</p>
<p>根据上面的模块图，我这里先按照模块对源码进行学习和分析。</p>
<h3 id="下载模块"><a href="#下载模块" class="headerlink" title="下载模块"></a>下载模块</h3><p>因为之前看了af，sd的下载模块应该也是基于NSUrlSession封装的，所以先看下载模块。</p>
<h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>SDWebImageDownloaderOperation是继承自系统的NSOperation,然后自己实现了一套异步操作的相关操作。这里不展开讲自定义NSOpration需要做哪些事情，网上应该有很多相关demo和文章。</p>
<p>SDWebImageDownloaderOperation的内部通过NSUrlSession创建task进行图片的下载，每个request的httpmethod默认为GET方式，这也方便拿到下载过程中的图片数据。</p>
<p>SDWebImageDownloaderOperation里面使用NSURLCache对URL的resopne进行缓存，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">    // Grab the cached data for later check</div><div class="line">    NSURLCache *URLCache = session.configuration.URLCache;</div><div class="line">    if (!URLCache) &#123;</div><div class="line">        URLCache = [NSURLCache sharedURLCache];</div><div class="line">    &#125;</div><div class="line">    NSCachedURLResponse *cachedResponse;</div><div class="line">    // NSURLCache&apos;s `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483</div><div class="line">    @synchronized (URLCache) &#123;</div><div class="line">        cachedResponse = [URLCache cachedResponseForRequest:self.request];</div><div class="line">    &#125;</div><div class="line">    if (cachedResponse) &#123;</div><div class="line">        self.cachedData = cachedResponse.data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>URLCache相关内容可以<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="noopener">参考这一篇文章</a></p>
<p>SDWebImageDownloaderOperation同时支持了后台下载，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</div><div class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">    __weak __typeof__ (self) wself = self;</div><div class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</div><div class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">        __strong __typeof (wself) sself = wself;</div><div class="line"></div><div class="line">        if (sself) &#123;</div><div class="line">            [sself cancel];</div><div class="line"></div><div class="line">            [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">            sself.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SDWebImageDownloaderOperation将每个task的progress回调和Complete回调存放在一个 <em>callbackBlocks</em> 的数组中，方便在收到NSURLSessionDelegate的代理时调用相对应的block,将数据传出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//添加了查找block</div><div class="line"></div><div class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</div><div class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</div><div class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</div><div class="line">    LOCK(self.callbacksLock);</div><div class="line">    [self.callbackBlocks addObject:callbacks];</div><div class="line">    UNLOCK(self.callbacksLock);</div><div class="line">    return callbacks;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123;</div><div class="line">    LOCK(self.callbacksLock);</div><div class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</div><div class="line">    UNLOCK(self.callbacksLock);</div><div class="line">    // We need to remove [NSNull null] because there might not always be a progress block for each callback</div><div class="line">    [callbacks removeObjectIdenticalTo:[NSNull null]];</div><div class="line">    return [callbacks copy]; // strip mutability here</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用Progress block</div><div class="line">for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">    progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用Complete block</div><div class="line"></div><div class="line">[self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</div><div class="line"></div><div class="line">- (void)callCompletionBlocksWithImage:(nullable UIImage *)image</div><div class="line">                            imageData:(nullable NSData *)imageData</div><div class="line">                                error:(nullable NSError *)error</div><div class="line">                             finished:(BOOL)finished &#123;</div><div class="line">    NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey];</div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123;</div><div class="line">            completedBlock(image, imageData, error, finished);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在收到didReceiveData回调后，如果当前options为SDWebImageDownloaderProgressiveDownload的话，还需要将收到的这部分图片数据进行解码后显示，显然这不是完整的数据，不过这部分数据也是可以正常显示的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if (!self.progressiveCoder) &#123;</div><div class="line">    // We need to create a new instance for progressive decoding to avoid conflicts</div><div class="line">    for (id&lt;SDWebImageCoder&gt;coder in [SDWebImageCodersManager sharedInstance].coders) &#123;</div><div class="line">        if ([coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)] &amp;&amp;</div><div class="line">            [((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</div><div class="line">            self.progressiveCoder = [[[coder class] alloc] init];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">// progressive decode the image in coder queue</div><div class="line">dispatch_async(self.coderQueue, ^&#123;</div><div class="line">    UIImage *image = [self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</div><div class="line">    if (image) &#123;</div><div class="line">        NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">        image = [self scaledImageForKey:key image:image];</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</div><div class="line">        </div><div class="line">        [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在收到didCompleteWithError回调后，会异步解码收到的image数据,gif和webp除外，这两会走另外的解码接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// decode the image in coder queue</div><div class="line">dispatch_async(self.coderQueue, ^&#123;</div><div class="line">    UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</div><div class="line">    NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">    image = [self scaledImageForKey:key image:image];</div><div class="line">    </div><div class="line">    BOOL shouldDecode = YES;</div><div class="line">    // Do not force decoding animated GIFs and WebPs</div><div class="line">    if (image.images) &#123;</div><div class="line">        shouldDecode = NO;</div><div class="line">    &#125; else &#123;</div><div class="line">#ifdef SD_WEBP</div><div class="line">        SDImageFormat imageFormat = [NSData sd_imageFormatForImageData:imageData];</div><div class="line">        if (imageFormat == SDImageFormatWebP) &#123;</div><div class="line">            shouldDecode = NO;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (shouldDecode) &#123;</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            BOOL shouldScaleDown = self.options &amp; SDWebImageDownloaderScaleDownLargeImages;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    CGSize imageSize = image.size;</div><div class="line">    if (imageSize.width == 0 || imageSize.height == 0) &#123;</div><div class="line">        [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];</div><div class="line">    &#125;</div><div class="line">    [self done];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>sd做https的证书验证方法很简单，如果自定义的证书不为空，则返回自定义的证书，为空的话，直接将服务器的证书返回并标识验证成功，所以实际上它这里只是简单的返回证书，并没有对证书做一个校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</div><div class="line">    </div><div class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">    __block NSURLCredential *credential = nil;</div><div class="line">    </div><div class="line">    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">        if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125; else &#123;</div><div class="line">            credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">            disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (challenge.previousFailureCount == 0) &#123;</div><div class="line">            if (self.credential) &#123;</div><div class="line">                credential = self.credential;</div><div class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p>SDWebImageDownloader是SDWebImageDownloaderOperation的管理类，和af不同的是，SDWebImageDownloader创建了一个NSOperationQueue，管理每个nsoperation。当nsoperation被标记为finish或者cancel后，会自动从Queue中移除。</p>
<p>看一下SDWebImageDownloader是如何管理operation的，比较重要的就是下面这一段代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(nullable NSURL *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</div><div class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</div><div class="line">    if (url == nil) &#123;</div><div class="line">        if (completedBlock != nil) &#123;</div><div class="line">            completedBlock(nil, nil, nil, NO);</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LOCK(self.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</div><div class="line">    // There is a case that the operation may be marked as finished, but not been removed from `self.URLOperations`.</div><div class="line">    if (!operation || operation.isFinished) &#123;</div><div class="line">        operation = createCallback();</div><div class="line">        __weak typeof(self) wself = self;</div><div class="line">        operation.completionBlock = ^&#123;</div><div class="line">            __strong typeof(wself) sself = wself;</div><div class="line">            if (!sself) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            LOCK(sself.operationsLock);</div><div class="line">            [sself.URLOperations removeObjectForKey:url];</div><div class="line">            UNLOCK(sself.operationsLock);</div><div class="line">        &#125;;</div><div class="line">        [self.URLOperations setObject:operation forKey:url];</div><div class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</div><div class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</div><div class="line">        [self.downloadQueue addOperation:operation];</div><div class="line">    &#125;</div><div class="line">    UNLOCK(self.operationsLock);</div><div class="line"></div><div class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">    </div><div class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</div><div class="line">    token.downloadOperation = operation;</div><div class="line">    token.url = url;</div><div class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line"></div><div class="line">    return token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sd将每一个operation存在URLOperations里面，key是url，value是operation,当需要创建一个下载任务时，先从这个URLOperations的字典中查找是否已经有对应的下载任务，如果没有的话，将createCallback（）这个block的返回值赋值给一个新的operation对象（并在opration的完成块中将它从URLOperations字典中移除），给opration添加相应的progressBlock和completeBlock,后将它存入URLOperations中，并创建opration对应的SDWebImageDownloadToken对象，再将该token对象返回。</p>
<p>上面这段描述中有2个地方需要注意下：</p>
<p>第一个是createCallback（）这个是个啥？看看下面这段代码就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __weak SDWebImageDownloader *wself = self;</div><div class="line"></div><div class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        __strong __typeof (wself) sself = wself;</div><div class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</div><div class="line">        if (timeoutInterval == 0.0) &#123;</div><div class="line">            timeoutInterval = 15.0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</div><div class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</div><div class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</div><div class="line">                                                                    cachePolicy:cachePolicy</div><div class="line">                                                                timeoutInterval:timeoutInterval];</div><div class="line">        </div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = YES;</div><div class="line">        if (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</div><div class="line">        &#125;</div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        if (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>createCallback其实就是创建一个新的downloadoperation，然后将这个downloadoperation返回。</p>
<p>第二个问题是SDWebImageDownloadToken这个类是用来干嘛的，也是看一下下面这个方法应该就清楚了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token &#123;</div><div class="line">    NSURL *url = token.url;</div><div class="line">    if (!url) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</div><div class="line">    if (operation) &#123;</div><div class="line">        BOOL canceled = [operation cancel:token.downloadOperationCancelToken];</div><div class="line">        if (canceled) &#123;</div><div class="line">            [self.URLOperations removeObjectForKey:url];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    UNLOCK(self.operationsLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>token.url为下载的文件url,operation为当前下载这个文件的任务，downloadOperationCancelToken实际上是一个字典，里面存了这个任务的progressBlock和completedBlock，保存这个主要是为了取消的时候把operation中保存的这两block给移除掉。</p>
<p>总结一下就是，这个SDWebImageDownloadToken对象其实就是用在cancel的时候移除之前保存在相关字典中的数据的。在SDWebImageManager中也是这么用的。</p>
<h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>看完下载模块，再来看一下缓存模块。大家都知道sd里面的缓存用到了NSCache,那它到底是咋用的呢，我们具体看一下吧。</p>
<h4 id="SDImageCacheConfig"><a href="#SDImageCacheConfig" class="headerlink" title="SDImageCacheConfig"></a>SDImageCacheConfig</h4><p>先来看一下这个config类中都定义了哪些变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</div><div class="line"></div><div class="line">@implementation SDImageCacheConfig</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">    	//需要解码</div><div class="line">        _shouldDecompressImages = YES;</div><div class="line">        //不适用iCloud存储</div><div class="line">        _shouldDisableiCloud = YES;</div><div class="line">        //存到内存</div><div class="line">        _shouldCacheImagesInMemory = YES;</div><div class="line">        //系统读写相关属性</div><div class="line">        _diskCacheReadingOptions = 0;</div><div class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</div><div class="line">        //过期时间</div><div class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</div><div class="line">        //最大存储空间 0则为没有限制</div><div class="line">        _maxCacheSize = 0;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>NSCache相关内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// A memory cache which auto purge the cache on memory warning and support weak cache.</div><div class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// Private</div><div class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</div><div class="line"></div><div class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</div><div class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可以看到sd自定义了一个继承自NSCache的类，并申明了一个NSMapTable类型的属性weakCache，直接用NSCache不就可以存储变量到内存了吗，这里为啥还要加一个NSMapTable呢。我们先看一下这个NSMapTable的初始化（<a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">NSMapTable相关内容参考这里</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</div></pre></td></tr></table></figure>
<p>可以看到，NSMapTable中存在值都是weak的，如果value被释放，则存的值将变为空，然后我们看一下自定义的SDMemoryCache类的get和set方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// `setObject:forKey:` just call this with 0 cost. Override this is enough</div><div class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</div><div class="line">    [super setObject:obj forKey:key cost:g];</div><div class="line">    if (key &amp;&amp; obj) &#123;</div><div class="line">        // Store weak cache</div><div class="line">        LOCK(self.weakCacheLock);</div><div class="line">        [self.weakCache setObject:obj forKey:key];</div><div class="line">        UNLOCK(self.weakCacheLock);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)objectForKey:(id)key &#123;</div><div class="line">    id obj = [super objectForKey:key];</div><div class="line">    if (key &amp;&amp; !obj) &#123;</div><div class="line">        // Check weak cache</div><div class="line">        LOCK(self.weakCacheLock);</div><div class="line">        obj = [self.weakCache objectForKey:key];</div><div class="line">        UNLOCK(self.weakCacheLock);</div><div class="line">        if (obj) &#123;</div><div class="line">            // Sync cache</div><div class="line">            NSUInteger cost = 0;</div><div class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</div><div class="line">                cost = SDCacheCostForImage(obj);</div><div class="line">            &#125;</div><div class="line">            [super setObject:obj forKey:key cost:cost];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对内存中图片的存取都是做了2次操作，一次是存到NSCache中，一次是存到NSMapTable中，大家都知道NSCache有一个特性就是当系统内存不足的时候会首先回收NSCache的内存，看这段get的代码，这里作者应该是考虑如果NSCache中内存被回收了可以从NSMapTable中继续找到该图片数据，不用去读磁盘数据或者重新下载。</p>
<p>然后我们来看一下存储到disk的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">if (toDisk) &#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            NSData *data = imageData;</div><div class="line">            if (!data &amp;&amp; image) &#123;</div><div class="line">                // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format</div><div class="line">                SDImageFormat format;</div><div class="line">                if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</div><div class="line">                    format = SDImageFormatPNG;</div><div class="line">                &#125; else &#123;</div><div class="line">                    format = SDImageFormatJPEG;</div><div class="line">                &#125;</div><div class="line">                data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</div><div class="line">            &#125;</div><div class="line">            [self _storeImageDataToDisk:data forKey:key];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的图片data不为空则直接存在磁盘，如果为空而且图片对象不为空，则需要先对图片进行编码处理转为data在存到磁盘中,这是因为data是直接从服务器拿到的数据，是编码过的，而image则是已经解码了的，是原始数据，数据量会比较大，所以需要先编码在存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</div><div class="line">    if (!imageData || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // get cache Path for image key</div><div class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">    // transform to NSUrl</div><div class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line">    </div><div class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</div><div class="line">    </div><div class="line">    // disable iCloud backup</div><div class="line">    if (self.config.shouldDisableiCloud) &#123;</div><div class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>存储过程很简单，就是一个文件写入就OK了。写入前先判断一下文件夹是否存在，不存在的话先创建一个。</p>
<p>然后我们看一下比较重要的一个方法，图片的查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">// First check the in-memory cache...</div><div class="line">UIImage *image = [self imageFromMemoryCacheForKey:key];</div><div class="line">BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</div><div class="line">if (shouldQueryMemoryOnly) &#123;</div><div class="line">    if (doneBlock) &#123;</div><div class="line">        doneBlock(image, nil, SDImageCacheTypeMemory);</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">NSOperation *operation = [NSOperation new];</div><div class="line">void(^queryDiskBlock)(void) =  ^&#123;</div><div class="line">    if (operation.isCancelled) &#123;</div><div class="line">        // do not call the completion if cancelled</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        UIImage *diskImage;</div><div class="line">        SDImageCacheType cacheType = SDImageCacheTypeDisk;</div><div class="line">        if (image) &#123;</div><div class="line">            // the image is from in-memory cache</div><div class="line">            diskImage = image;</div><div class="line">            cacheType = SDImageCacheTypeMemory;</div><div class="line">        &#125; else if (diskData) &#123;</div><div class="line">            // decode image data only if in-memory cache missed</div><div class="line">            diskImage = [self diskImageForKey:key data:diskData options:options];</div><div class="line">            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (doneBlock) &#123;</div><div class="line">            if (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">                doneBlock(diskImage, diskData, cacheType);</div><div class="line">            &#125; else &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, cacheType);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">if (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">    queryDiskBlock();</div><div class="line">&#125; else &#123;</div><div class="line">    dispatch_async(self.ioQueue, queryDiskBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先从nscache中查找，如果查找成功且options为SDImageCacheQueryDataWhenInMemory，则返回nscache中的结果<br>如果nscache查找失败，则查找disk中的data,并解码该data同时将解码后的image塞到nscache中,然后返回。</p>
<p>sd还提供了一个删除缓存文件的方法，在该方法中，一共使用了2种删除策略，第一种是按过期时间删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</div><div class="line">NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</div><div class="line">NSUInteger currentCacheSize = 0;</div><div class="line"></div><div class="line">// Enumerate all of the files in the cache directory.  This loop has two purposes:</div><div class="line">//</div><div class="line">//  1. Removing files that are older than the expiration date.</div><div class="line">//  2. Storing file attributes for the size-based cleanup pass.</div><div class="line">NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</div><div class="line">for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">    NSError *error;</div><div class="line">    NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</div><div class="line"></div><div class="line">    // Skip directories and errors.</div><div class="line">    if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Remove files that are older than the expiration date;</div><div class="line">    NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</div><div class="line">    if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">        [urlsToDelete addObject:fileURL];</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Store a reference to this file and account for its total size.</div><div class="line">    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">    currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</div><div class="line">    cacheFiles[fileURL] = resourceValues;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">for (NSURL *fileURL in urlsToDelete) &#123;</div><div class="line">    [self.fileManager removeItemAtURL:fileURL error:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果按过期时间删除后的文件大小还是大于最大缓存空间（maxCacheSize）的话，还有一种删除策略，就是删除现有文件大小的一半的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// If our remaining disk cache exceeds a configured maximum size, perform a second</div><div class="line">// size-based cleanup pass.  We delete the oldest files first.</div><div class="line">if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</div><div class="line">    // Target half of our maximum cache size for this cleanup pass.</div><div class="line">    const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</div><div class="line"></div><div class="line">    // Sort the remaining cache files by their last modification time (oldest first).</div><div class="line">    NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</div><div class="line">                                                             usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</div><div class="line">                                                                 return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</div><div class="line">                                                             &#125;];</div><div class="line"></div><div class="line">    // Delete files until we fall below our desired cache size.</div><div class="line">    for (NSURL *fileURL in sortedFiles) &#123;</div><div class="line">        if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</div><div class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</div><div class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">            currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</div><div class="line"></div><div class="line">            if (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="图片编解码模块"><a href="#图片编解码模块" class="headerlink" title="图片编解码模块"></a>图片编解码模块</h3><p>图片的编解码模块也是sd中比较重要也比较难吃透的模块，涉及到一些图片相关的姿势，需要慢慢学习理解。</p>
<h4 id="SDWebImageCoder"><a href="#SDWebImageCoder" class="headerlink" title="SDWebImageCoder"></a>SDWebImageCoder</h4><p>先来看一下这个协议类，这个类中定义了一些编解码的协议和几个静态函数。</p>
<p>静态函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//返回图片的颜色空间，这里返回RGB</div><div class="line">CGColorSpaceRef SDCGColorSpaceGetDeviceRGB(void) &#123;</div><div class="line">    static CGColorSpaceRef colorSpace;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    &#125;);</div><div class="line">    return colorSpace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//判断图片是否有透明度</div><div class="line">BOOL SDCGImageRefContainsAlpha(CGImageRef imageRef) &#123;</div><div class="line">    if (!imageRef) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef);</div><div class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    return hasAlpha;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageImageIOCoder"><a href="#SDWebImageImageIOCoder" class="headerlink" title="SDWebImageImageIOCoder"></a>SDWebImageImageIOCoder</h4><p>这个是图片编解码的核心类，相关方法和协议都在这个类中实现。看头文件的注释，sd支持PNG,JPEG,TIFF和HEIC(需要判断设备是否支持)这几种图片格式的编解码。gif和webp有单独的编解码类。</p>
<p>因为sd是支持图片边下载边显示的，而这个显示操作需要先将接受到的部分图片解码后才可以显示，这里看一下这个解码部分图片是如何实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</div><div class="line">    if (!_imageSource) &#123;</div><div class="line">        _imageSource = CGImageSourceCreateIncremental(NULL);</div><div class="line">    &#125;</div><div class="line">    UIImage *image;</div><div class="line">    </div><div class="line">    // The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/</div><div class="line">    // Thanks to the author @Nyx0uf</div><div class="line">    </div><div class="line">    // Update the data source, we must pass ALL the data, not just the new bytes</div><div class="line">    CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished);</div><div class="line">    </div><div class="line">    if (_width + _height == 0) &#123;</div><div class="line">        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</div><div class="line">        if (properties) &#123;</div><div class="line">            NSInteger orientationValue = 1;</div><div class="line">            CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height);</div><div class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width);</div><div class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">            CFRelease(properties);</div><div class="line">            </div><div class="line">            // When we draw to Core Graphics, we lose orientation information,</div><div class="line">            // which means the image below born of initWithCGIImage will be</div><div class="line">            // oriented incorrectly sometimes. (Unlike the image born of initWithData</div><div class="line">            // in didCompleteWithError.) So save it here and pass it on later.</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_width + _height &gt; 0) &#123;</div><div class="line">        // Create the image</div><div class="line">        CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL);</div><div class="line">        </div><div class="line">        if (partialImageRef) &#123;</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef scale:1 orientation:_orientation];</div><div class="line">#elif SD_MAC</div><div class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">            CGImageRelease(partialImageRef);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (finished) &#123;</div><div class="line">        if (_imageSource) &#123;</div><div class="line">            CFRelease(_imageSource);</div><div class="line">            _imageSource = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先创建一个imagesource,然后更新imagesource的data，注意这里的data是目前接收到的图片的所有数据，不止是新增的部分，这里在下载的图片的时候sd已经处理好了，保存了之前下载的那部分数据。然后获取图片宽高属性和方向，最后生成图片后返回。</p>
<p>接着看正常图片的解码过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</div><div class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</div><div class="line">#if SD_MAC</div><div class="line">    return image;</div><div class="line">#endif</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    BOOL shouldScaleDown = NO;</div><div class="line">    if (optionsDict != nil) &#123;</div><div class="line">        NSNumber *scaleDownLargeImagesOption = nil;</div><div class="line">        if ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[NSNumber class]]) &#123;</div><div class="line">            scaleDownLargeImagesOption = (NSNumber *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</div><div class="line">        &#125;</div><div class="line">        if (scaleDownLargeImagesOption != nil) &#123;</div><div class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!shouldScaleDown) &#123;</div><div class="line">        return [self sd_decompressedImageWithImage:image];</div><div class="line">    &#125; else &#123;</div><div class="line">        UIImage *scaledDownImage = [self sd_decompressedAndScaledDownImageWithImage:image];</div><div class="line">        if (scaledDownImage &amp;&amp; !CGSizeEqualToSize(scaledDownImage.size, image.size)) &#123;</div><div class="line">            // if the image is scaled down, need to modify the data pointer as well</div><div class="line">            SDImageFormat format = [NSData sd_imageFormatForImageData:*data];</div><div class="line">            NSData *imageData = [self encodedDataWithImage:scaledDownImage format:format];</div><div class="line">            if (imageData) &#123;</div><div class="line">                *data = imageData;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return scaledDownImage;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要判断一下图片是否需要被缩放，因为在下载完以后的图片也是根据图片后缀是否带@2x@3x这种标识进行过缩放的，并不是图片的实际尺寸。</p>
<p>如果不需要缩放，直接调用下面的解码方法解码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</div><div class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</div><div class="line">    @autoreleasepool&#123;</div><div class="line">        </div><div class="line">        CGImageRef imageRef = image.CGImage;</div><div class="line">        // device color space</div><div class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef);</div><div class="line">        // iOS display alpha info (BRGA8888/BGRX8888)</div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        size_t width = CGImageGetWidth(imageRef);</div><div class="line">        size_t height = CGImageGetHeight(imageRef);</div><div class="line">        </div><div class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</div><div class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</div><div class="line">        // to create bitmap graphics contexts without alpha info.</div><div class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</div><div class="line">                                                     width,</div><div class="line">                                                     height,</div><div class="line">                                                     kBitsPerComponent,</div><div class="line">                                                     0,</div><div class="line">                                                     colorspaceRef,</div><div class="line">                                                     bitmapInfo);</div><div class="line">        if (context == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Draw the image into the context and retrieve the new bitmap image without alpha</div><div class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</div><div class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</div><div class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</div><div class="line">        CGContextRelease(context);</div><div class="line">        CGImageRelease(imageRefWithoutAlpha);</div><div class="line">        </div><div class="line">        return imageWithoutAlpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码很经典，很多图片解码相关的库都会用到，如果你想自己写一个异步的图片解码函数，也可以直接拿去用。这里用的参数及相关解释网上有很多文章分析过，<a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="noopener">比如这篇就解释的挺清楚</a>。</p>
<p>如果是需要缩放的图片，则走下面这个方法解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (![[self class] shouldScaleDownImage:image]) &#123;</div><div class="line">        return [self sd_decompressedImageWithImage:image];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CGContextRef destContext;</div><div class="line">    </div><div class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</div><div class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        CGImageRef sourceImageRef = image.CGImage;</div><div class="line">        </div><div class="line">        CGSize sourceResolution = CGSizeZero;</div><div class="line">        sourceResolution.width = CGImageGetWidth(sourceImageRef);</div><div class="line">        sourceResolution.height = CGImageGetHeight(sourceImageRef);</div><div class="line">        float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">        // Determine the scale ratio to apply to the input image</div><div class="line">        // that results in an output image of the defined size.</div><div class="line">        // see kDestImageSizeMB, and how it relates to destTotalPixels.</div><div class="line">        float imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">        CGSize destResolution = CGSizeZero;</div><div class="line">        destResolution.width = (int)(sourceResolution.width*imageScale);</div><div class="line">        destResolution.height = (int)(sourceResolution.height*imageScale);</div><div class="line">        </div><div class="line">        // device color space</div><div class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</div><div class="line">        // iOS display alpha info (BGRA8888/BGRX8888)</div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</div><div class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</div><div class="line">        // to create bitmap graphics contexts without alpha info.</div><div class="line">        destContext = CGBitmapContextCreate(NULL,</div><div class="line">                                            destResolution.width,</div><div class="line">                                            destResolution.height,</div><div class="line">                                            kBitsPerComponent,</div><div class="line">                                            0,</div><div class="line">                                            colorspaceRef,</div><div class="line">                                            bitmapInfo);</div><div class="line">        </div><div class="line">        if (destContext == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</div><div class="line">        </div><div class="line">        // Now define the size of the rectangle to be used for the</div><div class="line">        // incremental blits from the input image to the output image.</div><div class="line">        // we use a source tile width equal to the width of the source</div><div class="line">        // image due to the way that iOS retrieves image data from disk.</div><div class="line">        // iOS must decode an image from disk in full width &apos;bands&apos;, even</div><div class="line">        // if current graphics context is clipped to a subrect within that</div><div class="line">        // band. Therefore we fully utilize all of the pixel data that results</div><div class="line">        // from a decoding opertion by achnoring our tile size to the full</div><div class="line">        // width of the input image.</div><div class="line">        CGRect sourceTile = CGRectZero;</div><div class="line">        sourceTile.size.width = sourceResolution.width;</div><div class="line">        // The source tile height is dynamic. Since we specified the size</div><div class="line">        // of the source tile in MB, see how many rows of pixels high it</div><div class="line">        // can be given the input image width.</div><div class="line">        sourceTile.size.height = (int)(kTileTotalPixels / sourceTile.size.width );</div><div class="line">        sourceTile.origin.x = 0.0f;</div><div class="line">        // The output tile is the same proportions as the input tile, but</div><div class="line">        // scaled to image scale.</div><div class="line">        CGRect destTile;</div><div class="line">        destTile.size.width = destResolution.width;</div><div class="line">        destTile.size.height = sourceTile.size.height * imageScale;</div><div class="line">        destTile.origin.x = 0.0f;</div><div class="line">        // The source seem overlap is proportionate to the destination seem overlap.</div><div class="line">        // this is the amount of pixels to overlap each tile as we assemble the ouput image.</div><div class="line">        float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</div><div class="line">        CGImageRef sourceTileImageRef;</div><div class="line">        // calculate the number of read/write operations required to assemble the</div><div class="line">        // output image.</div><div class="line">        int iterations = (int)( sourceResolution.height / sourceTile.size.height );</div><div class="line">        // If tile height doesn&apos;t divide the image height evenly, add another iteration</div><div class="line">        // to account for the remaining pixels.</div><div class="line">        int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;</div><div class="line">        if(remainder) &#123;</div><div class="line">            iterations++;</div><div class="line">        &#125;</div><div class="line">        // Add seem overlaps to the tiles, but save the original tile height for y coordinate calculations.</div><div class="line">        float sourceTileHeightMinusOverlap = sourceTile.size.height;</div><div class="line">        sourceTile.size.height += sourceSeemOverlap;</div><div class="line">        destTile.size.height += kDestSeemOverlap;</div><div class="line">        for( int y = 0; y &lt; iterations; ++y ) &#123;</div><div class="line">            @autoreleasepool &#123;</div><div class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</div><div class="line">                destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</div><div class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</div><div class="line">                if( y == iterations - 1 &amp;&amp; remainder ) &#123;</div><div class="line">                    float dify = destTile.size.height;</div><div class="line">                    destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale;</div><div class="line">                    dify -= destTile.size.height;</div><div class="line">                    destTile.origin.y += dify;</div><div class="line">                &#125;</div><div class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</div><div class="line">                CGImageRelease( sourceTileImageRef );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</div><div class="line">        CGContextRelease(destContext);</div><div class="line">        if (destImageRef == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</div><div class="line">        CGImageRelease(destImageRef);</div><div class="line">        if (destImage == nil) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        return destImage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里先判断图片的总像素是否比sd设置的最大像素值大，如果总像素超出了设置的最大像素值，则需要先缩放图片再解码，不然解码需要的内存空间太大，可能造成内存暴涨等问题。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</div><div class="line">    BOOL shouldScaleDown = YES;</div><div class="line">    </div><div class="line">    CGImageRef sourceImageRef = image.CGImage;</div><div class="line">    CGSize sourceResolution = CGSizeZero;</div><div class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</div><div class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</div><div class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">    if (imageScale &lt; 1) &#123;</div><div class="line">        shouldScaleDown = YES;</div><div class="line">    &#125; else &#123;</div><div class="line">        shouldScaleDown = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return shouldScaleDown;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sd这里应该也是用了帧内压缩算法去压缩图片的尺寸，通过计算像素差值的方式将多余的像素剔除，然后sd使用了一个tile的东东去存储每次计算出来的数据，并将这些数据写入到设备上下文中。计算完成后再从上下文中取出一张位图。这个压缩解码函数的详细注释可以<a href="https://www.jianshu.com/p/dfa47380fc05" target="_blank" rel="noopener">参考这一篇文章</a>.</p>
<p>然后就是编码部分，什么时候需要编码呢？就是在存入disk的时候，因为之前用到的image可能是解码之后的图片，直接存入的话会占用比较大的内存空间，所以sd这里都是先将image编码后再存的。</p>
<p>编码的函数和解码相比还是比较简单的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (format == SDImageFormatUndefined) &#123;</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</div><div class="line">        if (hasAlpha) &#123;</div><div class="line">            format = SDImageFormatPNG;</div><div class="line">        &#125; else &#123;</div><div class="line">            format = SDImageFormatJPEG;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:format];</div><div class="line">    </div><div class="line">    // Create an image destination.</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableDictionary *properties = [NSMutableDictionary dictionary];</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSInteger exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</div><div class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge_transfer NSString *)kCGImagePropertyOrientation];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    // Add your image to the destination.</div><div class="line">    CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties);</div><div class="line">    </div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        imageData = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(imageDestination);</div><div class="line">    </div><div class="line">    return [imageData copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先创建一个CGImageDestinationRef，并绑定一个imagedata,然后获取图片的相关属性，然后将图片数据和相关属性一起add到CGImageDestinationRef中，获取之前绑定的imagedata并返回，整个编码过程结束。</p>
<h4 id="SDWebImageGIFCoder"><a href="#SDWebImageGIFCoder" class="headerlink" title="SDWebImageGIFCoder"></a>SDWebImageGIFCoder</h4><p>这个类主要做gif的编解码。直接看解码函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">#if SD_MAC</div><div class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</div><div class="line">    NSImage *animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</div><div class="line">    [animatedImage addRepresentation:imageRep];</div><div class="line">    return animatedImage;</div><div class="line">#else</div><div class="line">    </div><div class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</div><div class="line">    if (!source) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    size_t count = CGImageSourceGetCount(source);</div><div class="line">    </div><div class="line">    UIImage *animatedImage;</div><div class="line">    </div><div class="line">    if (count &lt;= 1) &#123;</div><div class="line">        animatedImage = [[UIImage alloc] initWithData:data];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</div><div class="line">            CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);</div><div class="line">            if (!imageRef) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            float duration = [self sd_frameDurationAtIndex:i source:source];</div><div class="line">            UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</div><div class="line">            CGImageRelease(imageRef);</div><div class="line">            </div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSUInteger loopCount = 1;</div><div class="line">        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(source, nil);</div><div class="line">        NSDictionary *gifProperties = [imageProperties valueForKey:(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">        if (gifProperties) &#123;</div><div class="line">            NSNumber *gifLoopCount = [gifProperties valueForKey:(__bridge_transfer NSString *)kCGImagePropertyGIFLoopCount];</div><div class="line">            if (gifLoopCount != nil) &#123;</div><div class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">        animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(source);</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sd这里自定义了一个SDWebImageFrame类用来存放每一帧图片的数据，然后将所有帧存放在一个数组中，然后通过下面这个方法将帧数组转为一个image对象,这个方法等下在分析helper类的时候再一起分析一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div></pre></td></tr></table></figure>
<p>上面还用到一个方法是如何获取每一帧的时长方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source &#123;</div><div class="line">    float frameDuration = 0.1f;</div><div class="line">    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);</div><div class="line">    if (!cfFrameProperties) &#123;</div><div class="line">        return frameDuration;</div><div class="line">    &#125;</div><div class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;</div><div class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">    </div><div class="line">    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];</div><div class="line">    if (delayTimeUnclampedProp != nil) &#123;</div><div class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];</div><div class="line">        if (delayTimeProp != nil) &#123;</div><div class="line">            frameDuration = [delayTimeProp floatValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.</div><div class="line">    // We follow Firefox&apos;s behavior and use a duration of 100 ms for any frames that specify</div><div class="line">    // a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;</div><div class="line">    // for more information.</div><div class="line">    </div><div class="line">    if (frameDuration &lt; 0.011f) &#123;</div><div class="line">        frameDuration = 0.100f;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(cfFrameProperties);</div><div class="line">    return frameDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认每一帧的时长是0.1，如果获取propertydic失败直接返回默认值，否则的话从propertydic取对应的value。</p>
<p>然后看一下gif的编码过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (format != SDImageFormatGIF) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</div><div class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</div><div class="line">    </div><div class="line">    // Create an image destination. GIF does not support EXIF image orientation</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (frames.count == 0) &#123;</div><div class="line">        // for static single GIF images</div><div class="line">        CGImageDestinationAddImage(imageDestination, image.CGImage, nil);</div><div class="line">    &#125; else &#123;</div><div class="line">        // for animated GIF images</div><div class="line">        NSUInteger loopCount = image.sd_imageLoopCount;</div><div class="line">        NSDictionary *gifProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary: @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</div><div class="line">        CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties);</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</div><div class="line">            SDWebImageFrame *frame = frames[i];</div><div class="line">            float frameDuration = frame.duration;</div><div class="line">            CGImageRef frameImageRef = frame.image.CGImage;</div><div class="line">            NSDictionary *frameProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</div><div class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        imageData = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(imageDestination);</div><div class="line">    </div><div class="line">    return [imageData copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码的时候也是需要先获取到SDWebImageFrame数组，然后和普通图片编码过程一样，也是创建一个CGImageDestinationRef，绑定imagedata,然后遍历SDWebImageFrame数组将每一帧写入CGImageDestinationRef中，然后获取imagedata并返回。</p>
<h4 id="SDWebImageWebPCoder"><a href="#SDWebImageWebPCoder" class="headerlink" title="SDWebImageWebPCoder"></a>SDWebImageWebPCoder</h4><p><a href="https://developers.google.com/speed/webp/docs/compression" target="_blank" rel="noopener">这篇文章介绍了webp的压缩算法</a></p>
<p>使用webp相关的编解码方法，需要pod中添加一个依赖仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;SDWebImage/WebP&apos;</div></pre></td></tr></table></figure>
<p>sd为webp提供了2种解码方法，分别是部分数据的解码和完整数据的解码。</p>
<p>先看完整的数据解码函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    WebPData webpData;</div><div class="line">    WebPDataInit(&amp;webpData);</div><div class="line">    webpData.bytes = data.bytes;</div><div class="line">    webpData.size = data.length;</div><div class="line">    WebPDemuxer *demuxer = WebPDemux(&amp;webpData);</div><div class="line">    if (!demuxer) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint32_t flags = WebPDemuxGetI(demuxer, WEBP_FF_FORMAT_FLAGS);</div><div class="line">    int loopCount = WebPDemuxGetI(demuxer, WEBP_FF_LOOP_COUNT);</div><div class="line">    int canvasWidth = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_WIDTH);</div><div class="line">    int canvasHeight = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_HEIGHT);</div><div class="line">    CGBitmapInfo bitmapInfo;</div><div class="line">    // `CGBitmapContextCreate` does not support RGB888 on iOS. Where `CGImageCreate` supports.</div><div class="line">    if (!(flags &amp; ALPHA_FLAG)) &#123;</div><div class="line">        // RGBX8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;</div><div class="line">    &#125; else &#123;</div><div class="line">        // RGBA8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    CGContextRef canvas = CGBitmapContextCreate(NULL, canvasWidth, canvasHeight, 8, 0, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">    if (!canvas) &#123;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!(flags &amp; ANIMATION_FLAG)) &#123;</div><div class="line">        // for static single webp image</div><div class="line">        UIImage *staticImage = [self sd_rawWebpImageWithData:webpData];</div><div class="line">        if (staticImage) &#123;</div><div class="line">            // draw on CGBitmapContext can reduce memory usage</div><div class="line">            CGImageRef imageRef = staticImage.CGImage;</div><div class="line">            size_t width = CGImageGetWidth(imageRef);</div><div class="line">            size_t height = CGImageGetHeight(imageRef);</div><div class="line">            CGContextDrawImage(canvas, CGRectMake(0, 0, width, height), imageRef);</div><div class="line">            CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            staticImage = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#else</div><div class="line">            staticImage = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">            CGImageRelease(newImageRef);</div><div class="line">        &#125;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">        return staticImage;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // for animated webp image</div><div class="line">    WebPIterator iter;</div><div class="line">    if (!WebPDemuxGetFrame(demuxer, 1, &amp;iter)) &#123;</div><div class="line">        WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">    </div><div class="line">    do &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            UIImage *image = [self sd_drawnWebpImageWithCanvas:canvas iterator:iter];</div><div class="line">            if (!image) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            int duration = iter.duration;</div><div class="line">            if (duration &lt;= 10) &#123;</div><div class="line">                // WebP standard says 0 duration is used for canvas updating but not showing image, but actually Chrome and other implementations set it to 100ms if duration is lower or equal than 10ms</div><div class="line">                // Some animated WebP images also created without duration, we should keep compatibility</div><div class="line">                duration = 100;</div><div class="line">            &#125;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration / 1000.f];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; while (WebPDemuxNextFrame(&amp;iter));</div><div class="line">    </div><div class="line">    WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">    WebPDemuxDelete(demuxer);</div><div class="line">    CGContextRelease(canvas);</div><div class="line">    </div><div class="line">    UIImage *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">    animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也是分了2种类型去解码，一种是静态图片，直接使用下面这个方法或者静态图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_rawWebpImageWithData:(WebPData)webpData &#123;</div><div class="line">    WebPDecoderConfig config;</div><div class="line">    if (!WebPInitDecoderConfig(&amp;config)) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (WebPGetFeatures(webpData.bytes, webpData.size, &amp;config.input) != VP8_STATUS_OK) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    config.output.colorspace = config.input.has_alpha ? MODE_rgbA : MODE_RGB;</div><div class="line">    config.options.use_threads = 1;</div><div class="line">    </div><div class="line">    // Decode the WebP image data into a RGBA value array</div><div class="line">    if (WebPDecode(webpData.bytes, webpData.size, &amp;config) != VP8_STATUS_OK) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int width = config.input.width;</div><div class="line">    int height = config.input.height;</div><div class="line">    if (config.options.use_scaling) &#123;</div><div class="line">        width = config.options.scaled_width;</div><div class="line">        height = config.options.scaled_height;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Construct a UIImage from the decoded RGBA value array</div><div class="line">    CGDataProviderRef provider =</div><div class="line">    CGDataProviderCreateWithData(NULL, config.output.u.RGBA.rgba, config.output.u.RGBA.size, FreeImageData);</div><div class="line">    CGColorSpaceRef colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">    CGBitmapInfo bitmapInfo;</div><div class="line">    // `CGBitmapContextCreate` does not support RGB888 on iOS. Where `CGImageCreate` supports.</div><div class="line">    if (!config.input.has_alpha) &#123;</div><div class="line">        // RGB888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNone;</div><div class="line">    &#125; else &#123;</div><div class="line">        // RGBA8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    size_t components = config.input.has_alpha ? 4 : 3;</div><div class="line">    CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;</div><div class="line">    CGImageRef imageRef = CGImageCreate(width, height, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</div><div class="line">    </div><div class="line">    CGDataProviderRelease(provider);</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</div><div class="line">#else</div><div class="line">    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">    CGImageRelease(imageRef);</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是动图的话，和GIF的解码一样，需要获取一个SDWebImageFrame的数组，先使用下面这个函数获取每一帧的图片数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_drawnWebpImageWithCanvas:(CGContextRef)canvas iterator:(WebPIterator)iter &#123;</div><div class="line">    UIImage *image = [self sd_rawWebpImageWithData:iter.fragment];</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t canvasWidth = CGBitmapContextGetWidth(canvas);</div><div class="line">    size_t canvasHeight = CGBitmapContextGetHeight(canvas);</div><div class="line">    CGSize size = CGSizeMake(canvasWidth, canvasHeight);</div><div class="line">    CGFloat tmpX = iter.x_offset;</div><div class="line">    CGFloat tmpY = size.height - iter.height - iter.y_offset;</div><div class="line">    CGRect imageRect = CGRectMake(tmpX, tmpY, iter.width, iter.height);</div><div class="line">    BOOL shouldBlend = iter.blend_method == WEBP_MUX_BLEND;</div><div class="line">    </div><div class="line">    // If not blend, cover the target image rect. (firstly clear then draw)</div><div class="line">    if (!shouldBlend) &#123;</div><div class="line">        CGContextClearRect(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    CGContextDrawImage(canvas, imageRect, image.CGImage);</div><div class="line">    CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    image = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#elif SD_MAC</div><div class="line">    image = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    CGImageRelease(newImageRef);</div><div class="line">    </div><div class="line">    if (iter.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) &#123;</div><div class="line">        CGContextClearRect(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数里面先调用静态获取图片的方法生成一张图片，然后判断是否需要混合当前上下文中的内容，如果不需要就清空之前的内容，如果需要的话将刚生成的图片再写入之前的上下文中混合成一张新的图。</p>
<p>然后使用之前gif中使用过的下面这个函数将帧数组转为一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIImage *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div></pre></td></tr></table></figure>
<p>部分数据的解码函数如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</div><div class="line">    if (!_idec) &#123;</div><div class="line">        // Progressive images need transparent, so always use premultiplied RGBA</div><div class="line">        _idec = WebPINewRGB(MODE_rgbA, NULL, 0, 0);</div><div class="line">        if (!_idec) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIImage *image;</div><div class="line">    </div><div class="line">    VP8StatusCode status = WebPIUpdate(_idec, data.bytes, data.length);</div><div class="line">    if (status != VP8_STATUS_OK &amp;&amp; status != VP8_STATUS_SUSPENDED) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int width = 0;</div><div class="line">    int height = 0;</div><div class="line">    int last_y = 0;</div><div class="line">    int stride = 0;</div><div class="line">    uint8_t *rgba = WebPIDecGetRGB(_idec, &amp;last_y, &amp;width, &amp;height, &amp;stride);</div><div class="line">    // last_y may be 0, means no enough bitmap data to decode, ignore this</div><div class="line">    if (width + height &gt; 0 &amp;&amp; last_y &gt; 0 &amp;&amp; height &gt;= last_y) &#123;</div><div class="line">        // Construct a UIImage from the decoded RGBA value array</div><div class="line">        size_t rgbaSize = last_y * stride;</div><div class="line">        CGDataProviderRef provider =</div><div class="line">        CGDataProviderCreateWithData(NULL, rgba, rgbaSize, NULL);</div><div class="line">        CGColorSpaceRef colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        </div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">        size_t components = 4;</div><div class="line">        CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;</div><div class="line">        // Why to use last_y for image height is because of libwebp&apos;s bug (https://bugs.chromium.org/p/webp/issues/detail?id=362)</div><div class="line">        // It will not keep memory barrier safe on x86 architechure (macOS &amp; iPhone simulator) but on ARM architecture (iPhone &amp; iPad &amp; tv &amp; watch) it works great</div><div class="line">        // If different threads use WebPIDecGetRGB to grab rgba bitmap, it will contain the previous decoded bitmap data</div><div class="line">        // So this will cause our drawed image looks strange(above is the current part but below is the previous part)</div><div class="line">        // We only grab the last_y height and draw the last_y heigh instead of total height image</div><div class="line">        // Besides fix, this can enhance performance since we do not need to create extra bitmap</div><div class="line">        CGImageRef imageRef = CGImageCreate(width, last_y, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</div><div class="line">        </div><div class="line">        CGDataProviderRelease(provider);</div><div class="line">        </div><div class="line">        if (!imageRef) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGContextRef canvas = CGBitmapContextCreate(NULL, width, height, 8, 0, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">        if (!canvas) &#123;</div><div class="line">            CGImageRelease(imageRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Only draw the last_y image height, keep remains transparent, in Core Graphics coordinate system</div><div class="line">        CGContextDrawImage(canvas, CGRectMake(0, height - last_y, width, last_y), imageRef);</div><div class="line">        CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">        CGImageRelease(imageRef);</div><div class="line">        if (!newImageRef) &#123;</div><div class="line">            CGContextRelease(canvas);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">        image = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#else</div><div class="line">        image = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">        CGImageRelease(newImageRef);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (finished) &#123;</div><div class="line">        if (_idec) &#123;</div><div class="line">            WebPIDelete(_idec);</div><div class="line">            _idec = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>流程都和之前的其他格式部分解码函数差不多吧，只是有写api的小差异。</p>
<p>解码的部分差不多就这些，接着看一下编码的部分是如何实现的，直接上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSData *data;</div><div class="line">    </div><div class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</div><div class="line">    if (frames.count == 0) &#123;</div><div class="line">        // for static single webp image</div><div class="line">        data = [self sd_encodedWebpDataWithImage:image];</div><div class="line">    &#125; else &#123;</div><div class="line">        // for animated webp image</div><div class="line">        WebPMux *mux = WebPMuxNew();</div><div class="line">        if (!mux) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</div><div class="line">            SDWebImageFrame *currentFrame = frames[i];</div><div class="line">            NSData *webpData = [self sd_encodedWebpDataWithImage:currentFrame.image];</div><div class="line">            int duration = currentFrame.duration * 1000;</div><div class="line">            WebPMuxFrameInfo frame = &#123; .bitstream.bytes = webpData.bytes,</div><div class="line">                .bitstream.size = webpData.length,</div><div class="line">                .duration = duration,</div><div class="line">                .id = WEBP_CHUNK_ANMF,</div><div class="line">                .dispose_method = WEBP_MUX_DISPOSE_BACKGROUND, // each frame will clear canvas</div><div class="line">                .blend_method = WEBP_MUX_NO_BLEND</div><div class="line">            &#125;;</div><div class="line">            if (WebPMuxPushFrame(mux, &amp;frame, 0) != WEBP_MUX_OK) &#123;</div><div class="line">                WebPMuxDelete(mux);</div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        int loopCount = (int)image.sd_imageLoopCount;</div><div class="line">        WebPMuxAnimParams params = &#123; .bgcolor = 0,</div><div class="line">            .loop_count = loopCount</div><div class="line">        &#125;;</div><div class="line">        if (WebPMuxSetAnimationParams(mux, &amp;params) != WEBP_MUX_OK) &#123;</div><div class="line">            WebPMuxDelete(mux);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        WebPData outputData;</div><div class="line">        WebPMuxError error = WebPMuxAssemble(mux, &amp;outputData);</div><div class="line">        WebPMuxDelete(mux);</div><div class="line">        if (error != WEBP_MUX_OK) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        data = [NSData dataWithBytes:outputData.bytes length:outputData.size];</div><div class="line">        WebPDataClear(&amp;outputData);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和gif的编码流程相似，先获取到这张图的所有帧，（静态图片只有一帧，直接调用处理每一帧的编码函数进行处理），然后循环处理每一帧的数据，然后将处理完的每一帧数据存放到WebPMuxFrameInfo这个结构体，再将每个结构体add到WebPMux这个类里面，循环结束从WebPMux这个类中取出数据并返回。</p>
<p>下面这个函数是具体处理每一帧的数据的编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">- (nullable NSData *)sd_encodedWebpDataWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSData *webpData;</div><div class="line">    CGImageRef imageRef = image.CGImage;</div><div class="line">    </div><div class="line">    size_t width = CGImageGetWidth(imageRef);</div><div class="line">    size_t height = CGImageGetHeight(imageRef);</div><div class="line">    if (width == 0 || width &gt; WEBP_MAX_DIMENSION) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (height == 0 || height &gt; WEBP_MAX_DIMENSION) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t bytesPerRow = CGImageGetBytesPerRow(imageRef);</div><div class="line">    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</div><div class="line">    CGImageAlphaInfo alphaInfo = bitmapInfo &amp; kCGBitmapAlphaInfoMask;</div><div class="line">    CGBitmapInfo byteOrderInfo = bitmapInfo &amp; kCGBitmapByteOrderMask;</div><div class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    BOOL byteOrderNormal = NO;</div><div class="line">    switch (byteOrderInfo) &#123;</div><div class="line">        case kCGBitmapByteOrderDefault: &#123;</div><div class="line">            byteOrderNormal = YES;</div><div class="line">        &#125; break;</div><div class="line">        case kCGBitmapByteOrder32Little: &#123;</div><div class="line">        &#125; break;</div><div class="line">        case kCGBitmapByteOrder32Big: &#123;</div><div class="line">            byteOrderNormal = YES;</div><div class="line">        &#125; break;</div><div class="line">        default: break;</div><div class="line">    &#125;</div><div class="line">    // If we can not get bitmap buffer, early return</div><div class="line">    CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);</div><div class="line">    if (!dataProvider) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CFDataRef dataRef = CGDataProviderCopyData(dataProvider);</div><div class="line">    if (!dataRef) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint8_t *rgba = NULL;</div><div class="line">    // We could not assume that input CGImage&apos;s color mode is always RGB888/RGBA8888. Convert all other cases to target color mode using vImage</div><div class="line">    if (byteOrderNormal &amp;&amp; ((alphaInfo == kCGImageAlphaNone) || (alphaInfo == kCGImageAlphaLast))) &#123;</div><div class="line">        // If the input CGImage is already RGB888/RGBA8888</div><div class="line">        rgba = (uint8_t *)CFDataGetBytePtr(dataRef);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Convert all other cases to target color mode using vImage</div><div class="line">        vImageConverterRef convertor = NULL;</div><div class="line">        vImage_Error error = kvImageNoError;</div><div class="line">        </div><div class="line">        vImage_CGImageFormat srcFormat = &#123;</div><div class="line">            .bitsPerComponent = (uint32_t)CGImageGetBitsPerComponent(imageRef),</div><div class="line">            .bitsPerPixel = (uint32_t)CGImageGetBitsPerPixel(imageRef),</div><div class="line">            .colorSpace = CGImageGetColorSpace(imageRef),</div><div class="line">            .bitmapInfo = bitmapInfo</div><div class="line">        &#125;;</div><div class="line">        vImage_CGImageFormat destFormat = &#123;</div><div class="line">            .bitsPerComponent = 8,</div><div class="line">            .bitsPerPixel = hasAlpha ? 32 : 24,</div><div class="line">            .colorSpace = SDCGColorSpaceGetDeviceRGB(),</div><div class="line">            .bitmapInfo = hasAlpha ? kCGImageAlphaLast | kCGBitmapByteOrderDefault : kCGImageAlphaNone | kCGBitmapByteOrderDefault // RGB888/RGBA8888 (Non-premultiplied to works for libwebp)</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        convertor = vImageConverter_CreateWithCGImageFormat(&amp;srcFormat, &amp;destFormat, NULL, kvImageNoFlags, &amp;error);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        vImage_Buffer src = &#123;</div><div class="line">            .data = (uint8_t *)CFDataGetBytePtr(dataRef),</div><div class="line">            .width = width,</div><div class="line">            .height = height,</div><div class="line">            .rowBytes = bytesPerRow</div><div class="line">        &#125;;</div><div class="line">        vImage_Buffer dest;</div><div class="line">        </div><div class="line">        error = vImageBuffer_Init(&amp;dest, height, width, destFormat.bitsPerPixel, kvImageNoFlags);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Convert input color mode to RGB888/RGBA8888</div><div class="line">        error = vImageConvert_AnyToAny(convertor, &amp;src, &amp;dest, NULL, kvImageNoFlags);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        rgba = dest.data; // Converted buffer</div><div class="line">        bytesPerRow = dest.rowBytes; // Converted bytePerRow</div><div class="line">        CFRelease(dataRef);</div><div class="line">        dataRef = NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint8_t *data = NULL; // Output WebP data</div><div class="line">    float qualityFactor = 100; // WebP quality is 0-100</div><div class="line">    // Encode RGB888/RGBA8888 buffer to WebP data</div><div class="line">    size_t size;</div><div class="line">    if (hasAlpha) &#123;</div><div class="line">        size = WebPEncodeRGBA(rgba, (int)width, (int)height, (int)bytesPerRow, qualityFactor, &amp;data);</div><div class="line">    &#125; else &#123;</div><div class="line">        size = WebPEncodeRGB(rgba, (int)width, (int)height, (int)bytesPerRow, qualityFactor, &amp;data);</div><div class="line">    &#125;</div><div class="line">    if (dataRef) &#123;</div><div class="line">        CFRelease(dataRef); // free non-converted rgba buffer</div><div class="line">        dataRef = NULL;</div><div class="line">    &#125; else &#123;</div><div class="line">        free(rgba); // free converted rgba buffer</div><div class="line">        rgba = NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (size) &#123;</div><div class="line">        // success</div><div class="line">        webpData = [NSData dataWithBytes:data length:size];</div><div class="line">    &#125;</div><div class="line">    if (data) &#123;</div><div class="line">        WebPFree(data);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return webpData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和之前的其他图片的编码不一样，它这里没有使用CGImageDestinationRef这个结构处理编码，而是使用的webp库提供的编码方法。先创建vImageConverterRef这个对象，然后设置编码前的格式和编码后的格式，然后初始化vImageConverterRef对象，然后初始化vImage_Buffer，最后调用vImageConvert_AnyToAny方法进行格式转换，最后调用WebPEncodeRGBA生成最终需要返回的数据。<br>整个过程和使用AudioUnit进行音频格式转换很相似。</p>
<h4 id="SDWebImageCodersManager"><a href="#SDWebImageCodersManager" class="headerlink" title="SDWebImageCodersManager"></a>SDWebImageCodersManager</h4><p>这个类就是对上面这几个编解码类的使用的一个封装，看初始化函数默认只使用了SDWebImageImageIOCoder这个类作为当前编解码类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        // initialize with default coders</div><div class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</div><div class="line">#ifdef SD_WEBP</div><div class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</div><div class="line">#endif</div><div class="line">        _coders = [mutableCoders copy];</div><div class="line">        _codersLock = dispatch_semaphore_create(1);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你可以通过下面这个方法手动的添加和移除你需要的编解码类，比如gif的Coder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</div><div class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</div><div class="line">    if (!mutableCoders) &#123;</div><div class="line">        mutableCoders = [NSMutableArray array];</div><div class="line">    &#125;</div><div class="line">    [mutableCoders addObject:coder];</div><div class="line">    self.coders = [mutableCoders copy];</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</div><div class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</div><div class="line">    [mutableCoders removeObject:coder];</div><div class="line">    self.coders = [mutableCoders copy];</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后它提供了直接对数据进行编解码的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canDecodeFromData:data]) &#123;</div><div class="line">            return [coder decodedImageWithData:data];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</div><div class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canDecodeFromData:*data]) &#123;</div><div class="line">            return [coder decompressedImageWithImage:image data:data options:optionsDict];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canEncodeToFormat:format]) &#123;</div><div class="line">            return [coder encodedDataWithImage:image format:format];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过判断传入的数据是否支持编解码，如果支持就调用对应的编解码函数，如果不支持直接返回空。</p>
<h4 id="SDWebImageCoderHelper"><a href="#SDWebImageCoderHelper" class="headerlink" title="SDWebImageCoderHelper"></a>SDWebImageCoderHelper</h4><p>最后来看一下这个Helper,该类提供了几个通用的方法，主要有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//使用SDWebImageFrame帧序列创建图片</div><div class="line">+ (UIImage * _Nullable)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; * _Nullable)frames;</div><div class="line">//获取图片的所有帧数据</div><div class="line">+ (NSArray&lt;SDWebImageFrame *&gt; * _Nullable)framesFromAnimatedImage:(UIImage * _Nullable)animatedImage;</div><div class="line">//判断图片的朝向</div><div class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation;</div><div class="line">//将sd的朝向转为文件中应该的值</div><div class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation;</div></pre></td></tr></table></figure>
<p>看一下具体实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; *)frames &#123;</div><div class="line">    NSUInteger frameCount = frames.count;</div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIImage *animatedImage;</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSUInteger durations[frameCount];</div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        durations[i] = frames[i].duration * 1000;</div><div class="line">    &#125;</div><div class="line">    NSUInteger const gcd = gcdArray(frameCount, durations);</div><div class="line">    __block NSUInteger totalDuration = 0;</div><div class="line">    NSMutableArray&lt;UIImage *&gt; *animatedImages = [NSMutableArray arrayWithCapacity:frameCount];</div><div class="line">    [frames enumerateObjectsUsingBlock:^(SDWebImageFrame * _Nonnull frame, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        UIImage *image = frame.image;</div><div class="line">        NSUInteger duration = frame.duration * 1000;</div><div class="line">        totalDuration += duration;</div><div class="line">        NSUInteger repeatCount;</div><div class="line">        if (gcd) &#123;</div><div class="line">            repeatCount = duration / gcd;</div><div class="line">        &#125; else &#123;</div><div class="line">            repeatCount = 1;</div><div class="line">        &#125;</div><div class="line">        for (size_t i = 0; i &lt; repeatCount; ++i) &#123;</div><div class="line">            [animatedImages addObject:image];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    animatedImage = [UIImage animatedImageWithImages:animatedImages duration:totalDuration / 1000.f];</div><div class="line">    </div><div class="line">#else</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</div><div class="line">    // Create an image destination. GIF does not support EXIF image orientation</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frameCount, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            SDWebImageFrame *frame = frames[i];</div><div class="line">            float frameDuration = frame.duration;</div><div class="line">            CGImageRef frameImageRef = frame.image.CGImage;</div><div class="line">            NSDictionary *frameProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</div><div class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        CFRelease(imageDestination);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CFRelease(imageDestination);</div><div class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:imageData];</div><div class="line">    animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</div><div class="line">    [animatedImage addRepresentation:imageRep];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>帧数组转图片，如果是iOS平台，主要调用UIImage的<strong>animatedImageWithImages:duration</strong>方法创建，mac平台上我们看到了熟悉的身影CGImageDestinationRef，这个之前在做编码的时候用到过。</p>
<p>然后是图片转帧数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">+ (NSArray&lt;SDWebImageFrame *&gt; *)framesFromAnimatedImage:(UIImage *)animatedImage &#123;</div><div class="line">    if (!animatedImage) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">    NSUInteger frameCount = 0;</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSArray&lt;UIImage *&gt; *animatedImages = animatedImage.images;</div><div class="line">    frameCount = animatedImages.count;</div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSTimeInterval avgDuration = animatedImage.duration / frameCount;</div><div class="line">    if (avgDuration == 0) &#123;</div><div class="line">        avgDuration = 0.1; // if it&apos;s a animated image but no duration, set it to default 100ms (this do not have that 10ms limit like GIF or WebP to allow custom coder provide the limit)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block NSUInteger index = 0;</div><div class="line">    __block NSUInteger repeatCount = 1;</div><div class="line">    __block UIImage *previousImage = animatedImages.firstObject;</div><div class="line">    [animatedImages enumerateObjectsUsingBlock:^(UIImage * _Nonnull image, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        // ignore first</div><div class="line">        if (idx == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if ([image isEqual:previousImage]) &#123;</div><div class="line">            repeatCount++;</div><div class="line">        &#125; else &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">            repeatCount = 1;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        previousImage = image;</div><div class="line">        // last one</div><div class="line">        if (idx == frameCount - 1) &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">#else</div><div class="line">    </div><div class="line">    NSBitmapImageRep *bitmapRep;</div><div class="line">    for (NSImageRep *imageRep in animatedImage.representations) &#123;</div><div class="line">        if ([imageRep isKindOfClass:[NSBitmapImageRep class]]) &#123;</div><div class="line">            bitmapRep = (NSBitmapImageRep *)imageRep;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (bitmapRep) &#123;</div><div class="line">        frameCount = [[bitmapRep valueForProperty:NSImageFrameCount] unsignedIntegerValue];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            // NSBitmapImageRep need to manually change frame. &quot;Good taste&quot; API</div><div class="line">            [bitmapRep setProperty:NSImageCurrentFrame withValue:@(i)];</div><div class="line">            float frameDuration = [[bitmapRep valueForProperty:NSImageCurrentFrameDuration] floatValue];</div><div class="line">            NSImage *frameImage = [[NSImage alloc] initWithCGImage:bitmapRep.CGImage size:CGSizeZero];</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:frameImage duration:frameDuration];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return frames;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也是分了iOS和mac2个平台，iOS上直接去UIImage的images属性遍历一遍，mac上使用了NSBitmapImageRep这个对象获取图片的所有帧数据，然后在循环中从这个对象中取出所有的帧数据。</p>
<p>下面这2个是朝向转换的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">// Convert an EXIF image orientation to an iOS one.</div><div class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation &#123;</div><div class="line">    // CGImagePropertyOrientation is available on iOS 8 above. Currently kept for compatibility</div><div class="line">    UIImageOrientation imageOrientation = UIImageOrientationUp;</div><div class="line">    switch (exifOrientation) &#123;</div><div class="line">        case 1:</div><div class="line">            imageOrientation = UIImageOrientationUp;</div><div class="line">            break;</div><div class="line">        case 3:</div><div class="line">            imageOrientation = UIImageOrientationDown;</div><div class="line">            break;</div><div class="line">        case 8:</div><div class="line">            imageOrientation = UIImageOrientationLeft;</div><div class="line">            break;</div><div class="line">        case 6:</div><div class="line">            imageOrientation = UIImageOrientationRight;</div><div class="line">            break;</div><div class="line">        case 2:</div><div class="line">            imageOrientation = UIImageOrientationUpMirrored;</div><div class="line">            break;</div><div class="line">        case 4:</div><div class="line">            imageOrientation = UIImageOrientationDownMirrored;</div><div class="line">            break;</div><div class="line">        case 5:</div><div class="line">            imageOrientation = UIImageOrientationLeftMirrored;</div><div class="line">            break;</div><div class="line">        case 7:</div><div class="line">            imageOrientation = UIImageOrientationRightMirrored;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return imageOrientation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Convert an iOS orientation to an EXIF image orientation.</div><div class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation &#123;</div><div class="line">    // CGImagePropertyOrientation is available on iOS 8 above. Currently kept for compatibility</div><div class="line">    NSInteger exifOrientation = 1;</div><div class="line">    switch (imageOrientation) &#123;</div><div class="line">        case UIImageOrientationUp:</div><div class="line">            exifOrientation = 1;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationDown:</div><div class="line">            exifOrientation = 3;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationLeft:</div><div class="line">            exifOrientation = 8;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationRight:</div><div class="line">            exifOrientation = 6;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationUpMirrored:</div><div class="line">            exifOrientation = 2;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationDownMirrored:</div><div class="line">            exifOrientation = 4;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationLeftMirrored:</div><div class="line">            exifOrientation = 5;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationRightMirrored:</div><div class="line">            exifOrientation = 7;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return exifOrientation;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sd中是使用下面的代码拿到在图片数据中朝向的值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</div><div class="line">NSInteger orientationValue = 1;</div><div class="line">CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</div></pre></td></tr></table></figure>
<p>以上所有编解码相关的类就分析完毕了。这里我们在设计模块的时候可应该参考sd里面的做法，首先通过协议的方式放开需要的接口，各模块按根据需求决定是否实现对应协议，虽然都是编解码，但是针对不同的格式创建不同的类去实现，然后在manager中通过判断不同的格式调用不同的模块去做具体的事情，减少逻辑的耦合。</p>
<h3 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h3><p>看完了下载，缓存和编解码这三个主要的模块，在来看看它们的manager，这个其实就比较简单了，就是对上面几个模块的相关方法进行了一些封装。</p>
<p>先看一下这个私有类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</div><div class="line"></div><div class="line">@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;</div><div class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</div><div class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</div><div class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在manager中定义了相关属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</div></pre></td></tr></table></figure>
<p>这里，manager将每一个download返回的SDWebImageDownloadToken封装为一个SDWebImageCombinedOperation，存放在runningOperations这个数组里面，主要是为了在取消的时候方便操作（这个在之前介绍下载模块的时候已经有说明）。</p>
<p>manager创建了一个集合如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</div></pre></td></tr></table></figure>
<p>主要用来存储下载失败的url，如果url下载失败会被添加到上面的集合中，如果当前url在该合集中，且option不是SDWebImageRetryFailed（这个option是消除黑名单用的），则直接返回下载失败。如果option是SDWebImageRetryFailed，则会去重新下载。</p>
<p>manager还提供了2个block，让使用者有机会修改一下内容。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef NSString * _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL * _Nullable url);</div><div class="line"></div><div class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</div></pre></td></tr></table></figure>
<p>这个block可以修改当前图片缓存时的键值，默认是使用url.absoluteString作为键值进行缓存的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef NSData * _Nullable(^SDWebImageCacheSerializerBlock)(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL);</div><div class="line"></div><div class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</div></pre></td></tr></table></figure>
<p>这个block可以用来修改缓存图片的数据。它接收当前下载的图片的image对象，data对象和url，返回一个data.你可以在block对传入的图片数据做一些处理，比如做一下编码或者格式转化什么的。</p>
<p>manager中最主要的还是下面这个loadimageurl的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">    // Invoking this method without a completedBlock is pointless</div><div class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</div><div class="line"></div><div class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t</div><div class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</div><div class="line">    if ([url isKindOfClass:NSString.class]) &#123;</div><div class="line">        url = [NSURL URLWithString:(NSString *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</div><div class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</div><div class="line">        url = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    operation.manager = self;</div><div class="line"></div><div class="line">    BOOL isFailedUrl = NO;</div><div class="line">    if (url) &#123;</div><div class="line">        LOCK(self.failedURLsLock);</div><div class="line">        isFailedUrl = [self.failedURLs containsObject:url];</div><div class="line">        UNLOCK(self.failedURLsLock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</div><div class="line">        return operation;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LOCK(self.runningOperationsLock);</div><div class="line">    [self.runningOperations addObject:operation];</div><div class="line">    UNLOCK(self.runningOperationsLock);</div><div class="line">    NSString *key = [self cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    SDImageCacheOptions cacheOptions = 0;</div><div class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</div><div class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</div><div class="line">    if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</div><div class="line">    </div><div class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</div><div class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Check whether we should download image from network</div><div class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</div><div class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</div><div class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</div><div class="line">        if (shouldDownload) &#123;</div><div class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</div><div class="line">                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</div><div class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</div><div class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</div><div class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</div><div class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</div><div class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</div><div class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</div><div class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</div><div class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</div><div class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</div><div class="line">            </div><div class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                // force progressive off if image already cached but forced refreshing</div><div class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</div><div class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</div><div class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</div><div class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</div><div class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</div><div class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</div><div class="line">                    // Do nothing if the operation was cancelled</div><div class="line">                    // See #699 for more details</div><div class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</div><div class="line">                &#125; else if (error) &#123;</div><div class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</div><div class="line">                    BOOL shouldBlockFailedURL;</div><div class="line">                    // Check whether we should block failed url</div><div class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</div><div class="line">                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</div><div class="line">                    &#125; else &#123;</div><div class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    if (shouldBlockFailedURL) &#123;</div><div class="line">                        LOCK(self.failedURLsLock);</div><div class="line">                        [self.failedURLs addObject:url];</div><div class="line">                        UNLOCK(self.failedURLsLock);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        LOCK(self.failedURLsLock);</div><div class="line">                        [self.failedURLs removeObject:url];</div><div class="line">                        UNLOCK(self.failedURLsLock);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">                    </div><div class="line">                    // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</div><div class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</div><div class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</div><div class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            if (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                NSData *cacheData;</div><div class="line">                                // pass nil if the image was transformed, so we can recalculate the data from the image</div><div class="line">                                if (self.cacheSerializer) &#123;</div><div class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</div><div class="line">                                &#125;</div><div class="line">                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            if (self.cacheSerializer) &#123;</div><div class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</div><div class="line">                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                                &#125;);</div><div class="line">                            &#125; else &#123;</div><div class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (finished) &#123;</div><div class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125; else if (cachedImage) &#123;</div><div class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</div><div class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">        &#125; else &#123;</div><div class="line">            // Image not in cache and download disallowed by delegate</div><div class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</div><div class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是一个先查找缓存，如果没有命中再去下载的过程，是一个比较经典的逻辑，网上一般说sd都会说到这里的这个逻辑。这里就不细说了。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>sd大家用的最多的其实是分类，特别是UIImageView的分类，这里我挑2个比较有内容的分类说一下，其他分类都比较简单，就是纯调api了。</p>
<h4 id="NSData-ImageContentType"><a href="#NSData-ImageContentType" class="headerlink" title="NSData + ImageContentType"></a>NSData + ImageContentType</h4><p>这个分类比较重要的知识点就是如何通过图片文件判断图片格式，看一下主要代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return SDImageFormatUndefined;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // File signatures table: http://www.garykessler.net/library/file_sigs.html</div><div class="line">    uint8_t c;</div><div class="line">    [data getBytes:&amp;c length:1];</div><div class="line">    switch (c) &#123;</div><div class="line">        case 0xFF:</div><div class="line">            return SDImageFormatJPEG;</div><div class="line">        case 0x89:</div><div class="line">            return SDImageFormatPNG;</div><div class="line">        case 0x47:</div><div class="line">            return SDImageFormatGIF;</div><div class="line">        case 0x49:</div><div class="line">        case 0x4D:</div><div class="line">            return SDImageFormatTIFF;</div><div class="line">        case 0x52: &#123;</div><div class="line">            if (data.length &gt;= 12) &#123;</div><div class="line">                //RIFF....WEBP</div><div class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</div><div class="line">                if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</div><div class="line">                    return SDImageFormatWebP;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case 0x00: &#123;</div><div class="line">            if (data.length &gt;= 12) &#123;</div><div class="line">                //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</div><div class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</div><div class="line">                if ([testString isEqualToString:@&quot;ftypheic&quot;]</div><div class="line">                    || [testString isEqualToString:@&quot;ftypheix&quot;]</div><div class="line">                    || [testString isEqualToString:@&quot;ftyphevc&quot;]</div><div class="line">                    || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</div><div class="line">                    return SDImageFormatHEIC;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return SDImageFormatUndefined;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到代码就应该很明了了，通过文件数据的第一个字节来判断文件格式，这里用2个十六进制数表示一个字节。这个函数如果有需要可以直接拿来用。</p>
<h4 id="UIView-WebCache"><a href="#UIView-WebCache" class="headerlink" title="UIView + WebCache"></a>UIView + WebCache</h4><p>这个算是所有分类的父类了，大部分UI相关的分类最后都是调用的这个分类里面的一个方法，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</div><div class="line">                  placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(nullable NSString *)operationKey</div><div class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</div><div class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context &#123;</div><div class="line">    NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</div><div class="line">    [self sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">        if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</div><div class="line">            dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</div><div class="line">            dispatch_group_enter(group);</div><div class="line">        &#125;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (url) &#123;</div><div class="line">#if SD_UIKIT</div><div class="line">        // check if activityView is enabled or not</div><div class="line">        if ([self sd_showActivityIndicatorView]) &#123;</div><div class="line">            [self sd_addActivityIndicator];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        </div><div class="line">        // reset the progress</div><div class="line">        self.sd_imageProgress.totalUnitCount = 0;</div><div class="line">        self.sd_imageProgress.completedUnitCount = 0;</div><div class="line">        </div><div class="line">        SDWebImageManager *manager;</div><div class="line">        if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</div><div class="line">            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</div><div class="line">        &#125; else &#123;</div><div class="line">            manager = [SDWebImageManager sharedManager];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        __weak __typeof(self)wself = self;</div><div class="line">        SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</div><div class="line">            wself.sd_imageProgress.totalUnitCount = expectedSize;</div><div class="line">            wself.sd_imageProgress.completedUnitCount = receivedSize;</div><div class="line">            if (progressBlock) &#123;</div><div class="line">                progressBlock(receivedSize, expectedSize, targetURL);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</div><div class="line">            __strong __typeof (wself) sself = wself;</div><div class="line">            if (!sself) &#123; return; &#125;</div><div class="line">#if SD_UIKIT</div><div class="line">            [sself sd_removeActivityIndicator];</div><div class="line">#endif</div><div class="line">            // if the progress not been updated, mark it to complete state</div><div class="line">            if (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == 0 &amp;&amp; sself.sd_imageProgress.completedUnitCount == 0) &#123;</div><div class="line">                sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</div><div class="line">                sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</div><div class="line">            &#125;</div><div class="line">            BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</div><div class="line">            BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</div><div class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</div><div class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</div><div class="line">                if (!sself) &#123; return; &#125;</div><div class="line">                if (!shouldNotSetImage) &#123;</div><div class="line">                    [sself sd_setNeedsLayout];</div><div class="line">                &#125;</div><div class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            </div><div class="line">            // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set</div><div class="line">            // OR</div><div class="line">            // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set</div><div class="line">            if (shouldNotSetImage) &#123;</div><div class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            UIImage *targetImage = nil;</div><div class="line">            NSData *targetData = nil;</div><div class="line">            if (image) &#123;</div><div class="line">                // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</div><div class="line">                targetImage = image;</div><div class="line">                targetData = data;</div><div class="line">            &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</div><div class="line">                // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</div><div class="line">                targetImage = placeholder;</div><div class="line">                targetData = nil;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">            // check whether we should use the image transition</div><div class="line">            SDWebImageTransition *transition = nil;</div><div class="line">            if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</div><div class="line">                transition = sself.sd_imageTransition;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">            if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</div><div class="line">                dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</div><div class="line">                dispatch_group_enter(group);</div><div class="line">                dispatch_main_async_safe(^&#123;</div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</div><div class="line">#else</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">#endif</div><div class="line">                &#125;);</div><div class="line">                // ensure completion block is called after custom setImage process finish</div><div class="line">                dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">                    callCompletedBlockClojure();</div><div class="line">                &#125;);</div><div class="line">            &#125; else &#123;</div><div class="line">                dispatch_main_async_safe(^&#123;</div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</div><div class="line">#else</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">#endif</div><div class="line">                    callCompletedBlockClojure();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        [self sd_setImageLoadOperation:operation forKey:validOperationKey];</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">#if SD_UIKIT</div><div class="line">            [self sd_removeActivityIndicator];</div><div class="line">#endif</div><div class="line">            if (completedBlock) &#123;</div><div class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</div><div class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接看加载图片部分吧，图片下载完成后，如果当前是MAC平台的话，还创建了一个转场动画SDWebImageTransition，这个转场动画比较简单，都是最基本的转场效果。</p>
<p>然后我们看一下设置图片给UI的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">//不带转场动画的方法</div><div class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock &#123;</div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">    [self sd_setImage:image imageData:imageData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:nil cacheType:0 imageURL:nil];</div><div class="line">#else</div><div class="line">    // watchOS does not support view transition. Simplify the logic</div><div class="line">    if (setImageBlock) &#123;</div><div class="line">        setImageBlock(image, imageData);</div><div class="line">    &#125; else if ([self isKindOfClass:[UIImageView class]]) &#123;</div><div class="line">        UIImageView *imageView = (UIImageView *)self;</div><div class="line">        [imageView setImage:image];</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">//带转场动画的方法</div><div class="line"></div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL &#123;</div><div class="line">    UIView *view = self;</div><div class="line">    SDSetImageBlock finalSetImageBlock;</div><div class="line">    if (setImageBlock) &#123;</div><div class="line">        finalSetImageBlock = setImageBlock;</div><div class="line">    &#125; else if ([view isKindOfClass:[UIImageView class]]) &#123;</div><div class="line">        UIImageView *imageView = (UIImageView *)view;</div><div class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData) &#123;</div><div class="line">            imageView.image = setImage;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">#if SD_UIKIT</div><div class="line">    else if ([view isKindOfClass:[UIButton class]]) &#123;</div><div class="line">        UIButton *button = (UIButton *)view;</div><div class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData)&#123;</div><div class="line">            [button setImage:setImage forState:UIControlStateNormal];</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    if (transition) &#123;</div><div class="line">#if SD_UIKIT</div><div class="line">        [UIView transitionWithView:view duration:0 options:0 animations:^&#123;</div><div class="line">            // 0 duration to let UIKit render placeholder and prepares block</div><div class="line">            if (transition.prepares) &#123;</div><div class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</div><div class="line">            &#125;</div><div class="line">        &#125; completion:^(BOOL finished) &#123;</div><div class="line">            [UIView transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</div><div class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</div><div class="line">                    finalSetImageBlock(image, imageData);</div><div class="line">                &#125;</div><div class="line">                if (transition.animations) &#123;</div><div class="line">                    transition.animations(view, image);</div><div class="line">                &#125;</div><div class="line">            &#125; completion:transition.completion];</div><div class="line">        &#125;];</div><div class="line">#elif SD_MAC</div><div class="line">        [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull prepareContext) &#123;</div><div class="line">            // 0 duration to let AppKit render placeholder and prepares block</div><div class="line">            prepareContext.duration = 0;</div><div class="line">            if (transition.prepares) &#123;</div><div class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</div><div class="line">            &#125;</div><div class="line">        &#125; completionHandler:^&#123;</div><div class="line">            [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull context) &#123;</div><div class="line">                context.duration = transition.duration;</div><div class="line">                context.timingFunction = transition.timingFunction;</div><div class="line">                context.allowsImplicitAnimation = (transition.animationOptions &amp; SDWebImageAnimationOptionAllowsImplicitAnimation);</div><div class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</div><div class="line">                    finalSetImageBlock(image, imageData);</div><div class="line">                &#125;</div><div class="line">                if (transition.animations) &#123;</div><div class="line">                    transition.animations(view, image);</div><div class="line">                &#125;</div><div class="line">            &#125; completionHandler:^&#123;</div><div class="line">                if (transition.completion) &#123;</div><div class="line">                    transition.completion(YES);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;];</div><div class="line">#endif</div><div class="line">    &#125; else &#123;</div><div class="line">        if (finalSetImageBlock) &#123;</div><div class="line">            finalSetImageBlock(image, imageData);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这里看一下具体的转场动画是咋做的吧，如果是iOS，使用UIView的transitionWithView方法添加动画，具体的添加动画的代码再transition.animations这个block中，就是给当前view的layer添加一个animation.在mac上则是使用NSAnimationContext的runAnimationGroup方法添加动画，具体添加方法和iOS一样。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>初看sd的代码时，觉得有点杂乱无章，命名也不太友好，然后模块层级也不太明确，和af比起来在架构方面差好多。不过在按模块分析和研读sd的代码后，还有能学到很多而且是可以运用到实际开发中的姿势点的，比如自定义一个下载器部分，可以学习sd是如何自定义封装一个NSOpearion，如何管理每一个NSOpearion的生命周期，如何回调下载中的数据等。对于编解码能学到的东西也很多，比如针对不同编解码器如何使用同一套接口去编程，最主要的当然是对不同图片数据的编解码方式，这个也是该模块最核心的功能。对于缓存模块可以学到NSCache以及NSMapTable的使用，NSURLCache的使用，对于缓存内存的限制，以及缓存不足时的删除策略等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" itemprop="url">
                  使用AudioQueue实现一个音频播放(二)--边播边缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T16:01:06+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://llyblog.com/2018/05/07/使用AudioQueue实现一个音频播放器/" target="_blank" rel="noopener">前一篇文章</a>中介绍了使用AuidoQueue实现一个音频播放器的功能,最近我又把这个项目完善了一下，做了一个边播边缓存的功能。</p>
<p>因为播放部分的逻辑我们已经完成，这里主要是怎么缓存数据的问题，实现之前我想到了2种方案。</p>
<h3 id="方案一-在didReceiveDataBlock中缓存文件"><a href="#方案一-在didReceiveDataBlock中缓存文件" class="headerlink" title="方案一 在didReceiveDataBlock中缓存文件"></a>方案一 在didReceiveDataBlock中缓存文件</h3><p>直接在拿到音频数据进行播放的同时就将数据写入文件，这种方案的优点是实时性，播放过的音频数据都会被缓存起来，缺点就是缓存的文件可能并不是一个完整的音频，比如播了1分钟后seek到2分钟的地方继续播，中间1分钟的数据可能就没有收到，这就导致缓存的文件是有问题的，如果下次直接播这个本地文件可能就凉凉了。。。</p>
<h3 id="方案二-在success的回调中缓存数据"><a href="#方案二-在success的回调中缓存数据" class="headerlink" title="方案二 在success的回调中缓存数据"></a>方案二 在success的回调中缓存数据</h3><p>在success中回调回来的数据就是完整的音频数据，缓存这个数据不会出现数据不完整的情况，但是这个回调并不是实时返回的，会在整个音频的数据都获取到以后才会返回，有一个延迟，如果网络不太好，可能直到音频播放完了才会返回。</p>
<p>考虑到方案的可行性和数据的可用性，这里我选择了方案二，毕竟完整的数据比缓存的实时性更重要一些。当然，这个方案一我觉得还是有优化的空间，如果能够优化到保证了数据的完整性，会比方案二更优。</p>
<h3 id="增加的模块"><a href="#增加的模块" class="headerlink" title="增加的模块"></a>增加的模块</h3><p>这里我增加了2个模块，一个是文件的操作模块，还有一个是网络模块。</p>
<h4 id="LLYFileManager"><a href="#LLYFileManager" class="headerlink" title="LLYFileManager"></a>LLYFileManager</h4><p>文件操作模块是对音频数据的存储相关操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@interface LLYFileManager : NSObject</div><div class="line"></div><div class="line">//网络地址转本地地址</div><div class="line">+ (NSString *)pathWithUrl:(NSString *)fileUrl;</div><div class="line">//将数据保存到本地目录下</div><div class="line">+ (BOOL)saveFileWithPath:(NSString *)path fileObject:(id)fileObject;</div><div class="line">//判断当前url对应的文件是否已经缓存</div><div class="line">+ (BOOL)isFileExit:(NSString *)url;</div><div class="line">//获取文件大小</div><div class="line">+ (unsigned long long)fileSizeWithFilePath:(NSString *)filePath;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="LLYHttpSessionManager"><a href="#LLYHttpSessionManager" class="headerlink" title="LLYHttpSessionManager"></a>LLYHttpSessionManager</h4><p>网络模块是基于AFNetworking做的一个二次封装<a href="http://llyblog.com/2018/06/14/AFNetworking学习笔记与实践/" target="_blank" rel="noopener">(参考这篇文章)</a>，主要就是请求音频数据。</p>
<h3 id="播放优化"><a href="#播放优化" class="headerlink" title="播放优化"></a>播放优化</h3><p>在播放前，我们需判断一下当前url对应的文件是否已经下载到本地了，如果已经下载就直接播本地的文件，否则还是走网络播放的逻辑。</p>
<p>这个判断逻辑我是这样处理的，先发送一个http head请求，拿到对应url文件的countOfBytesExpectedToReceive，然后将countOfBytesExpectedToReceive和本地文件大小（fileSize）进行比较，如果fileSize &gt;= contentExceptLength，则说明本地文件是完整的音频文件，可以直接播放，否则的话还是走网络播放的逻辑，并在success回调中覆盖之前的不完整文件。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioPlayer.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/AFNetworking学习笔记与实践/" itemprop="url">
                  AFNetworking学习笔记与实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T09:58:47+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/AFNetworking学习笔记与实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/AFNetworking学习笔记与实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从AF使用NSURLSession重写之后，还没有看过源码，NSURLSession是基于NSURLConnection的封装，应该是汲取了AF之前的设计，内部封装了一个NSOperation来实现异步请求。最近要做一个音频播放的边播边缓存的功能，网路请求这块需要封装一下，随便研究一下AF的源码，这里我按模块逐个分析一下。</p>
<h4 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h4><p>这个模块是AF中最大也是最重要的一个模块，它封装了一个session,提供了一系列的初始化方法和创建task的方法。如果大家对session和task的概念还不太理解，可以先看一下NSURLSession这个类的相关内容（这个大概说一下，session是管理所有网络请求的，每一个网络请求是一个task，task是使用session创建的，所有task共享session的相关设置）。</p>
<p>先来看一下创建task的方法，这里总共有datatask,uploadtask和downloadtask三种task，不过他们的创建逻辑都是一样的，以datatask为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看看上面这个宏的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</div><div class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</div><div class="line">        // Fix of bug</div><div class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</div><div class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</div><div class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</div><div class="line">    &#125; else &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static dispatch_queue_t url_session_manager_creation_queue() &#123;</div><div class="line">    static dispatch_queue_t af_url_session_manager_creation_queue;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return af_url_session_manager_creation_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里这样做主要是为了解决ios8之前的一个bug，如果异步同时创建task的话，task的id有可能是一样的，这会导致回调时出现问题（completionHandler被替换），为了解决这个问题，创建task的操作都放在一个串行队列中执行。</p>
<p>然后看一下添加代理这个又是要干嘛</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，af为每一个task都创建了一个delegate，然后将代理存在了self.mutableTaskDelegatesKeyedByTaskIdentifier这个字典中，键值是task的id,这里也解释了上面的为啥要同步创建task,那么它为啥要为每个task添加一个代理呢，我们继续往下看。</p>
<p>看完task的创建，然后我们再来看一下数据的回调。<strong>af为每个NSURLSession的回调函数创建了对应block和setBlock的方法，如果你需要哪个代理里面的数据，直接创建对应的block即可。</strong></p>
<p>我们先来看最常用的回调方法，即请求完成的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line">        </div><div class="line">        //将该task的代理从字典中移除</div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看有点奇怪，这2方法名一毛一样啊。没有错，这两个方法是同一个代理方法，只是他们的实现对象是不一样的，第一个的实现对象是AFURLSessionManager类,第二个的实现对象则是AFURLSessionManagerTaskDelegate这个类，这里就解释上面的为啥要为每一个task设置一个代理，af这里其实是吧NSURLSession的代理又包了一层，将NSURLSession的数据都传到AFURLSessionManagerTaskDelegate这个类里面去处理了。</p>
<p>然后我们看一下这个回调中对数据的处理，可以看到回调的返回都是放在一个gcd的group中处理的，如果我们设置了返回处理线程的话就使用设置的线程，否则会在主线程中处理数据的返回，如果有错误是直接返回了，没有错误的话，会先使用responeseSerializer去验证一下返回的数据格式是否合法，这个类我们下面在细看。</p>
<p>继续看其他几个我觉得比较常用的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">          dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">didReceiveResponse:(NSURLResponse *)response</div><div class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</div><div class="line">&#123;</div><div class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</div><div class="line"></div><div class="line">    if (self.dataTaskDidReceiveResponse) &#123;</div><div class="line">        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">          dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</div><div class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</div><div class="line"></div><div class="line">    if (self.dataTaskDidReceiveData) &#123;</div><div class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</div><div class="line">    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</div><div class="line"></div><div class="line">	//这里保存的数据会在complete的回调中使用</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这2个回调一个是收到responese被触发，这个回调可以拿到相应头部信息，比如接收文件的大小，格式等，一个是收到数据时被触发，进度相关的信息就在通过这个回调拿到的。<strong>还有一点就是，download的task不会走datatask的代理，意味着download的数据只能在下载完成后通过文件的方式拿到。</strong></p>
<h4 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h4><p>这个类就是继承了AFURLSessionManager，然后提供了一些封装好的创建task的方法。平时二次封装也是使用这个类就行。</p>
<p>然后这个类有三个比较重要的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;</div></pre></td></tr></table></figure>
<p>这里简单介绍每个属性的用途，下面还有详解。<br>requestSerializer主要用来设置httpheader，responseSerializer主要用来解析返回数据是否合法，<br>securityPolicy主要用来验证服务器证书。</p>
<h4 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h4><p>先来看一下AFHTTPRequestSerializer在AFHTTPSessionManager中是如何使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在调用AFURLSessionManager的创建task方法前，会先调用一下下面这个方法生成一个request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div></pre></td></tr></table></figure>
<p>那我们来具体看一下这个方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</div><div class="line">                                 URLString:(NSString *)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(method);</div><div class="line">    NSParameterAssert(URLString);</div><div class="line"></div><div class="line">    NSURL *url = [NSURL URLWithString:URLString];</div><div class="line"></div><div class="line">    NSParameterAssert(url);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</div><div class="line">    mutableRequest.HTTPMethod = method;</div><div class="line"></div><div class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</div><div class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</div><div class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</div><div class="line"></div><div class="line">	return mutableRequest;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSString *query = nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                case AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</div><div class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体流程：</p>
<ul>
<li>使用url和method创建一个mutableRequest，</li>
<li>kvo相关属性，如果不为空则kvc到mutableRequest</li>
<li>设置HTTPRequestHeaders数组中相关属性到mutableRequest</li>
<li>将传入的参数做一下url编码</li>
<li>如果是get，head,delete方式，将参数加到url后面，否则，将参数设置为mutableRequest的body，同时设置mutableRequest的Content-Type.</li>
</ul>
<p>可以看出，这个类的主要作用就是创建request，给request设置相应的header和body,对url和参数进行编码(url使用URLEncode,body使用UNICode编码).</p>
<h4 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h4><p>这个类在上面的complete回调中有提到，这里具体分析。</p>
<p>af一共提供了7种ResponseSerializer，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">AFHTTPResponseSerializer</div><div class="line"></div><div class="line">AFJSONResponseSerializer</div><div class="line"></div><div class="line">AFXMLParserResponseSerializer</div><div class="line"></div><div class="line">AFXMLDocumentResponseSerializer</div><div class="line"></div><div class="line">AFPropertyListResponseSerializer</div><div class="line"></div><div class="line">AFImageResponseSerializer</div><div class="line"></div><div class="line">AFCompoundResponseSerializer</div></pre></td></tr></table></figure>
<p>不同的response针对不同的数据类型。</p>
<p>他们的主要区别其实就在acceptableContentTypes这个属性上，它是一个集合，用来存储我们需要接受的数据类型。</p>
<p>比如JSON的acceptableContentTypes为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</div></pre></td></tr></table></figure>
<p>IMAGE的acceptableContentTypes为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;image/tiff&quot;, @&quot;image/jpeg&quot;, @&quot;image/gif&quot;, @&quot;image/png&quot;, @&quot;image/ico&quot;, @&quot;image/x-icon&quot;, @&quot;image/bmp&quot;, @&quot;image/x-bmp&quot;, @&quot;image/x-xbitmap&quot;, @&quot;image/x-win-bitmap&quot;, nil];</div></pre></td></tr></table></figure>
<p>我们可以通过NSHTTPSessionManager的responseSerializer修改你需要的数据类型。</p>
<p>回到之前的complete回调，看看具体怎么使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</div><div class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</div><div class="line"></div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[response MIMEType] 这个type就是当前服务器返回的数据的格式，需要self.acceptableContentTypes这个集合中包含上面的type，解析数据的时候才会返回成功，所以，如果遇到解析失败的话，可以断点到这里看一下这个type然后手动添加到acceptableContentTypes这个集合中。</p>
<h4 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h4><p>af提供了三种验证证书的方式，第一种不需要本地证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123;</div><div class="line">    AFSSLPinningModeNone,//默认方式，只需要验证服务器返回的证书是否合法</div><div class="line">    AFSSLPinningModePublicKey,//需要验证本地证书中的公钥是否包含服务器返回的证书中的公钥</div><div class="line">    AFSSLPinningModeCertificate,//需要验证本地证书是否在服务器证书的证书链中</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对应的有几种不同的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123;</div><div class="line">    NSArray *paths = [bundle pathsForResourcesOfType:@&quot;cer&quot; inDirectory:@&quot;.&quot;];</div><div class="line"></div><div class="line">    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];</div><div class="line">    for (NSString *path in paths) &#123;</div><div class="line">        NSData *certificateData = [NSData dataWithContentsOfFile:path];</div><div class="line">        [certificates addObject:certificateData];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [NSSet setWithSet:certificates];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)defaultPinnedCertificates &#123;</div><div class="line">    static NSSet *_defaultPinnedCertificates = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSBundle *bundle = [NSBundle bundleForClass:[self class]];</div><div class="line">        _defaultPinnedCertificates = [self certificatesInBundle:bundle];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _defaultPinnedCertificates;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)defaultPolicy &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</div><div class="line">    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = pinningMode;</div><div class="line"></div><div class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们看一下到底是如何进行证书验证的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(NSString *)domain</div><div class="line">&#123;</div><div class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</div><div class="line">        // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</div><div class="line">        //  According to the docs, you should only trust your provided certs for evaluation.</div><div class="line">        //  Pinned certificates are added to the trust. Without pinned certificates,</div><div class="line">        //  there is nothing to evaluate against.</div><div class="line">        //</div><div class="line">        //  From Apple Docs:</div><div class="line">        //          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</div><div class="line">        //           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</div><div class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableArray *policies = [NSMutableArray array];</div><div class="line">    if (self.validatesDomainName) &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</div><div class="line">    &#125; else &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</div><div class="line"></div><div class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    switch (self.SSLPinningMode) &#123;</div><div class="line">        case AFSSLPinningModeNone:</div><div class="line">        default:</div><div class="line">            return NO;</div><div class="line">        case AFSSLPinningModeCertificate: &#123;</div><div class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</div><div class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</div><div class="line"></div><div class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                return NO;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</div><div class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">            </div><div class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    return YES;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        case AFSSLPinningModePublicKey: &#123;</div><div class="line">            NSUInteger trustedPublicKeyCount = 0;</div><div class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            for (id trustChainPublicKey in publicKeys) &#123;</div><div class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</div><div class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += 1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return trustedPublicKeyCount &gt; 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</div><div class="line">    BOOL isValid = NO;</div><div class="line">    SecTrustResultType result;</div><div class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out);</div><div class="line"></div><div class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</div><div class="line"></div><div class="line">_out:</div><div class="line">    return isValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重点看一下self.allowInvalidCertificates这个参数，可以看到，如果使用默认的验证策略，同时self.allowInvalidCertificates = YES的话，会直接返回YES，相当于没有验证，所有这里我们一般将self.allowInvalidCertificates = NO。self.validatesDomainName这个参数默认为YES就可以了。</p>
<p>验证服务器证书是否合法的方法为AFServerTrustIsValid，这个方法里面就是调用的系统的方法。</p>
<p>那这个验证方法到底在哪里调用的呢，我们看一下下面这个代理，在NSURLSessionManager中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</div><div class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</div><div class="line">&#123;</div><div class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">    __block NSURLCredential *credential = nil;</div><div class="line"></div><div class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</div><div class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</div><div class="line">    &#125; else &#123;</div><div class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">                if (credential) &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">                &#125; else &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的https请求都会先进这个代理，这个challenge.protectionSpace对象中就是服务器发过来的需要客户端验证的证书，域名等相关重要信息，然后af调用evaluateServerTrust这个方法对相关信息进行验证。</p>
<h3 id="实战，简单的二次封装"><a href="#实战，简单的二次封装" class="headerlink" title="实战，简单的二次封装"></a>实战，简单的二次封装</h3><p>我这边使用一个单例来管理AFHTTPSessionManager,在init方法中，设置相关delegate对应的block.这里设置block主要是满足我需要在开始获取到音频数据的时候就对数据进行处理，不需要等到整个请求完成再处理数据的需求。如果需要其他delegate的信息，添加相应的block即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)shareInstance&#123;</div><div class="line">    static LLYHttpSessionManager *_llyHttpSessionManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _llyHttpSessionManager = [[LLYHttpSessionManager alloc]init];</div><div class="line">    &#125;);</div><div class="line">    return _llyHttpSessionManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init&#123;</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        _httpSessionManager = [[AFHTTPSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">        _httpSessionManager.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line">//        [_httpSessionManager.requestSerializer setValue:[self generateXUserAgent] forHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">//        [_httpSessionManager.requestSerializer setValue:[self generateClientCookie] forHTTPHeaderField:@&quot;Cookie&quot;];</div><div class="line">        </div><div class="line">        __weak __typeof(self)weakSelf = self;</div><div class="line">        </div><div class="line">        [_httpSessionManager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) &#123;</div><div class="line">            if (weakSelf.didReceiveResponseBlock) &#123;</div><div class="line">                weakSelf.didReceiveResponseBlock(session, dataTask, response);</div><div class="line">            &#125;</div><div class="line">            return NSURLSessionResponseAllow;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        [_httpSessionManager setDataTaskDidReceiveDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSData * _Nonnull data) &#123;</div><div class="line">            if (weakSelf.didReceiveDataBlock) &#123;</div><div class="line">                weakSelf.didReceiveDataBlock(session, dataTask, data);</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        //默认json</div><div class="line">        self.fileType = LLYHttpFileType_JSON;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为我这边需要请求音视频的数据，af提供的几种responese默认是不支持音视频格式的，所有我封装了几种文件type，每种type对应不同的responese</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, LLYHttpFileType) &#123;</div><div class="line">    LLYHttpFileType_JSON = 0,</div><div class="line">    LLYHttpFileType_IMAGE,</div><div class="line">    LLYHttpFileType_AUDIO,</div><div class="line">    LLYHttpFileType_VIDEO</div><div class="line">&#125;;</div><div class="line"></div><div class="line">- (void)setResponseSerializer:(LLYHttpFileType)fileType&#123;</div><div class="line">    </div><div class="line">    switch (fileType) &#123;</div><div class="line">        case LLYHttpFileType_JSON:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_IMAGE:</div><div class="line">        &#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFImageResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_AUDIO:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">            _httpSessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;audio/mpeg&quot;,nil];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_VIDEO:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">            _httpSessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;video/mp4&quot;,@&quot;video/mpeg&quot;,nil];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">        &#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后提供了2个block，分别是didReceiveResponseBlock和didReceiveDataBlock，如果需要拿到请求过程中的相关数据和信息，直接实现这2个block就ok了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) DidReceiveResponseBlock didReceiveResponseBlock;</div><div class="line">@property (nonatomic, copy) DidReceiveDataBlock didReceiveDataBlock;</div></pre></td></tr></table></figure>
<p>针对不同的数据类型，我这边提供了相应的task的创建方法，然后还提供了一个总的创建task的方法和一个下载方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestJSONWithMethod:(LLYHttpMethod)method</div><div class="line">                                       urlString:(nullable NSString *)URLString</div><div class="line">                                      parameters:(nullable id)parameters</div><div class="line">                                        progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                         success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                             failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestIMAGEWithMethod:(LLYHttpMethod)method</div><div class="line">                                           urlString:(nullable NSString *)URLString</div><div class="line">                                          parameters:(nullable id)parameters</div><div class="line">                                            progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                             success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                             failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestAUDIOWithMethod:(LLYHttpMethod)method</div><div class="line">                                            urlString:(nullable NSString *)URLString</div><div class="line">                                           parameters:(nullable id)parameters</div><div class="line">                                             progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                              success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                              failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestVIDEOWithMethod:(LLYHttpMethod)method</div><div class="line">                                            urlString:(nullable NSString *)URLString</div><div class="line">                                           parameters:(nullable id)parameters</div><div class="line">                                             progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                              success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                              failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestWithMethod:(LLYHttpMethod)method</div><div class="line">                                        fileType:(LLYHttpFileType)fileType</div><div class="line">                              urlString:(nullable NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure</div><div class="line">;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDownloadTask *)downloadWithUrl:(nullable NSString *)urlString</div><div class="line">                                     progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgressBlock</div><div class="line">                                  destination:(nullable NSURL * _Nullable(^)(NSURL * _Nullable targetPath, NSURLResponse * _Nullable response))destination</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse * _Nullable response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>实现部分就比较简单了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionTask *)requestWithMethod:(LLYHttpMethod)method</div><div class="line">                                        fileType:(LLYHttpFileType)fileType</div><div class="line">                                       urlString:(NSString *)URLString</div><div class="line">                                      parameters:(nullable id)parameters</div><div class="line">                                        progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    self.fileType = fileType;</div><div class="line">    </div><div class="line">    NSURLSessionTask *task = nil;</div><div class="line">    </div><div class="line">    switch (method) &#123;</div><div class="line">        case LLYHttpMethod_GET:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager GET:URLString parameters:parameters progress:downloadProgress success:success failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case LLYHttpMethod_POST:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager POST:URLString parameters:parameters progress:downloadProgress success:success failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case LLYHttpMethod_HEAD:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager HEAD:URLString parameters:parameters success:^(NSURLSessionDataTask * _Nonnull task) &#123;</div><div class="line">                if (success) &#123;</div><div class="line">                    success(task,nil);</div><div class="line">                &#125;</div><div class="line">            &#125; failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return task;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadWithUrl:(NSString *)urlString</div><div class="line">                                     progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                  destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler&#123;</div><div class="line">    NSURLSessionDownloadTask *task = nil;</div><div class="line">    </div><div class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];</div><div class="line">    </div><div class="line">    task = [_httpSessionManager downloadTaskWithRequest:request progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</div><div class="line">    </div><div class="line">    [task resume];</div><div class="line">    </div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lilingyu0620/LLYAFNetworking.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/15/使用FFMPEG解码之-音频解码/" itemprop="url">
                  使用FFMPEG解码之--音频解码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-15T11:15:41+08:00" content="2018-05-15">
              2018-05-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/15/使用FFMPEG解码之-音频解码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/15/使用FFMPEG解码之-音频解码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天一直在写使用ffmpeg完成一个视频播放器的demo,因为对音频这一块比较熟悉，所以先从音频解码开始下手，也熟悉一下ffmpeg的使用流程。音频解码这块已经完成了，所以这里先简单总结一下整个音频解码的流程。这里只说大概流程，具体实现细节参考下面的demo就可以。</p>
<h4 id="1-注册ffmpeg"><a href="#1-注册ffmpeg" class="headerlink" title="1.注册ffmpeg"></a>1.注册ffmpeg</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">av_register_all()</div></pre></td></tr></table></figure>
<h4 id="2-初始化AVFormatContext"><a href="#2-初始化AVFormatContext" class="headerlink" title="2.初始化AVFormatContext"></a>2.初始化AVFormatContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AVFormatContext *formatCtx = avformat_alloc_context();</div></pre></td></tr></table></figure>
<h4 id="3-可以注册一个打断回调"><a href="#3-可以注册一个打断回调" class="headerlink" title="3.可以注册一个打断回调"></a>3.可以注册一个打断回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AVIOInterruptCB int_cb = &#123;interrupt_callback,(__bridge void *)self&#125;;</div><div class="line">    formatCtx-&gt;interrupt_callback = int_cb;</div></pre></td></tr></table></figure>
<p>其中 interrupt_callback 是一个函数指针 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static int interrupt_callback(void *ctx)&#123;</div><div class="line">    if (!ctx) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    __unsafe_unretained LLYDecoder *decoder = (__bridge LLYDecoder *)ctx;</div><div class="line">    const BOOL bRet = [decoder detectInterrupted];</div><div class="line">    if (bRet) &#123;</div><div class="line">        NSLog(@&quot;DEBUG: INTERRUPT_CALLBACK!&quot;);</div><div class="line">    &#125;</div><div class="line">    return bRet;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打断状态</div><div class="line">- (BOOL)detectInterrupted&#123;</div><div class="line">    //打断超时</div><div class="line">    if ([[NSDate date] timeIntervalSince1970] - _readLastestFrameTime &gt; _subscribeTimeOutTimeInSecs) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return _interrupted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使返回一个是否被打断的状态。</p>
<h4 id="4-打开流地址"><a href="#4-打开流地址" class="headerlink" title="4.打开流地址"></a>4.打开流地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (int)openInputWithFormatCtx:(AVFormatContext **)formatCtx path:(NSString *)path parameter:(NSDictionary *)parameters&#123;</div><div class="line">    const char *inputURL = [path cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    AVDictionary *options = NULL;</div><div class="line">    //TCURL应该与流的CDN相关 如果原始的req中有tcUrl，就使用原始的</div><div class="line">    NSString *rtmpTCURLStr = parameters[RTMP_TCURL_KEY];</div><div class="line">    if (rtmpTCURLStr.length &gt; 0) &#123;</div><div class="line">        const char *rtmpTcURL = [rtmpTCURLStr cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">        av_dict_set(&amp;options, &quot;rtmp_tcurl&quot;, rtmpTcURL, 0);</div><div class="line">    &#125;</div><div class="line">    return avformat_open_input(formatCtx, inputURL, NULL, &amp;options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个是否打开成功的状态。0表示成功</p>
<h4 id="5-设置解析参数probesize-amp-max-analyze-duration"><a href="#5-设置解析参数probesize-amp-max-analyze-duration" class="headerlink" title="5.设置解析参数probesize &amp; max_analyze_duration"></a>5.设置解析参数probesize &amp; max_analyze_duration</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//个人理解是开始读取数据的延时和缓存空间（默认5M）</div><div class="line">- (void)initAnalyzeDurationAndProbeSize:(AVFormatContext *)formatCtx parameter:(NSDictionary *)parameters&#123;</div><div class="line">    float probeSize = [parameters[PROBE_SIZE] floatValue];</div><div class="line">    formatCtx-&gt;probesize = probeSize ?: 50 * 1024;</div><div class="line">    NSArray *durations = parameters[MAX_ANALYZE_DURATION_ARRAY];</div><div class="line">    if (durations &amp;&amp; durations.count &gt; _connectionRetry) &#123;</div><div class="line">        formatCtx-&gt;max_analyze_duration = [durations[_connectionRetry] floatValue];</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        //pow(x,y) x的y次方</div><div class="line">        float multiplier = 0.5 + (double)pow(2.0, (double)_connectionRetry) * 0.25;</div><div class="line">        formatCtx-&gt;max_analyze_duration = multiplier;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //帧率</div><div class="line">    BOOL fpsProbeSizeConfiged = [parameters[FPS_PROBE_SIZE_CONFIGURED] floatValue];</div><div class="line">    if (fpsProbeSizeConfiged) &#123;</div><div class="line">        formatCtx-&gt;fps_probe_size = 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-获取音视频信息"><a href="#6-获取音视频信息" class="headerlink" title="6.获取音视频信息"></a>6.获取音视频信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int findStreamErrorCode = 0;</div><div class="line">double startFindStreamTimeMills = CFAbsoluteTimeGetCurrent() * 1000;</div><div class="line">if ((findStreamErrorCode = avformat_find_stream_info(formatCtx, NULL)) &lt; 0) &#123;</div><div class="line">    avformat_close_input(&amp;formatCtx);</div><div class="line">    avformat_free_context(formatCtx);</div><div class="line">    NSLog(@&quot;Video decoder find stream info failed... find stream ErrCode is %s&quot;, av_err2str(findStreamErrorCode));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取的信息都在formatCtx这个参数里存着，后面很多地方要用。</p>
<h4 id="7-获取流数据的索引数组"><a href="#7-获取流数据的索引数组" class="headerlink" title="7.获取流数据的索引数组"></a>7.获取流数据的索引数组</h4><p>通过流的类型获取流的索引，有时候可能音频或者视频都有好几路流数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//获取流数据的索引</div><div class="line">static NSArray *collectionStreams(AVFormatContext *formatCtx,enum AVMediaType codecType)&#123;</div><div class="line">    NSMutableArray *ma = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; formatCtx-&gt;nb_streams; i++) &#123;</div><div class="line">        if (codecType == formatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type) &#123;</div><div class="line">            [ma addObject:@(i)];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-通过流的索引，获取每一路流的AVCodecContext-amp-AVCodec"><a href="#8-通过流的索引，获取每一路流的AVCodecContext-amp-AVCodec" class="headerlink" title="8.通过流的索引，获取每一路流的AVCodecContext &amp; AVCodec"></a>8.通过流的索引，获取每一路流的AVCodecContext &amp; AVCodec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AVCodecContext *codecCtx = _formatCtx-&gt;streams[streamIndex]-&gt;codec;</div><div class="line">//获取该stream对应的解码器</div><div class="line">AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</div><div class="line">if(!codec)&#123;</div><div class="line">    NSLog(@&quot;Find Audio Decoder Failed codec_id %d CODEC_ID_AAC is %d&quot;, codecCtx-&gt;codec_id, AV_CODEC_ID_AAC);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="9-打开解码器"><a href="#9-打开解码器" class="headerlink" title="9.打开解码器"></a>9.打开解码器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int openCodecErrorCode = 0;</div><div class="line">if ((openCodecErrorCode = avcodec_open2(codecCtx, codec, NULL)) &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;open Audio Codec Failed openCodecErr is %s&quot;, av_err2str(openCodecErrorCode));</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-如果不支持当前流的采样格式，需要做一下重新采样"><a href="#10-如果不支持当前流的采样格式，需要做一下重新采样" class="headerlink" title="10.如果不支持当前流的采样格式，需要做一下重新采样"></a>10.如果不支持当前流的采样格式，需要做一下重新采样</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//是否需要重采样</div><div class="line">SwrContext *swrContext = NULL;</div><div class="line">if (![self audioCodecIsSupported:codecCtx]) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;because of audio Codec Is Not Supported so we will init swresampler...&quot;);</div><div class="line">    /**</div><div class="line">     * 初始化resampler</div><div class="line">     * @param s               Swr context, can be NULL</div><div class="line">     * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)</div><div class="line">     * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).</div><div class="line">     * @param out_sample_rate output sample rate (frequency in Hz)</div><div class="line">     * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)</div><div class="line">     * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).</div><div class="line">     * @param in_sample_rate  input sample rate (frequency in Hz)</div><div class="line">     * @param log_offset      logging level offset</div><div class="line">     * @param log_ctx         parent logging context, can be NULL</div><div class="line">     */</div><div class="line">    swrContext = swr_alloc_set_opts(NULL, av_get_default_channel_layout(codecCtx-&gt;channels), AV_SAMPLE_FMT_S16, codecCtx-&gt;sample_rate, av_get_default_channel_layout(codecCtx-&gt;channels), codecCtx-&gt;sample_fmt, codecCtx-&gt;sample_rate, 0, NULL);</div><div class="line">    if (!swrContext || swr_init(swrContext)) &#123;</div><div class="line">        if (swrContext)</div><div class="line">            swr_free(&amp;swrContext);</div><div class="line">        avcodec_close(codecCtx);</div><div class="line">        NSLog(@&quot;init resampler failed...&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (BOOL)audioCodecIsSupported:(AVCodecContext *) audioCodecCtx;&#123;</div><div class="line">    if (audioCodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S16) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11-初始化一个AVFrame"><a href="#11-初始化一个AVFrame" class="headerlink" title="11.初始化一个AVFrame"></a>11.初始化一个AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_audioFrame = av_frame_alloc();</div><div class="line">if (!_audioFrame) &#123;</div><div class="line">    NSLog(@&quot;Alloc Audio Frame Failed...&quot;);</div><div class="line">    if (swrContext)</div><div class="line">        swr_free(&amp;swrContext);</div><div class="line">    avcodec_close(codecCtx);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="12-获取AVPacket"><a href="#12-获取AVPacket" class="headerlink" title="12.获取AVPacket"></a>12.获取AVPacket</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AVPacket packet;</div><div class="line">if (av_read_frame(_formatCtx, &amp;packet) &lt; 0) &#123;</div><div class="line">        _isEOF = YES;</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="13-获取AVFrame"><a href="#13-获取AVFrame" class="headerlink" title="13.获取AVFrame"></a>13.获取AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int gotFrame = 0;</div><div class="line">//len =  number of bytes consumed from the input *AVPacket</div><div class="line">int len = avcodec_decode_audio4(_audioCodecCtx, _audioFrame, &amp;gotFrame, &amp;packet);</div><div class="line">if (len &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;decode audio error, skip packet&quot;);</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="14-将AVFrame转为自定义的LLYAudioFrame"><a href="#14-将AVFrame转为自定义的LLYAudioFrame" class="headerlink" title="14.将AVFrame转为自定义的LLYAudioFrame"></a>14.将AVFrame转为自定义的LLYAudioFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (LLYAudioFrame *)handleAudioFrame&#123;</div><div class="line">    </div><div class="line">    if (!_audioFrame-&gt;data[0]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    const NSUInteger numChannels = _audioCodecCtx-&gt;channels;</div><div class="line">    NSInteger numFrames;</div><div class="line">    </div><div class="line">    void *audioData;</div><div class="line">    </div><div class="line">    if (_swrContext) &#123;</div><div class="line">        const NSUInteger ratio = 2;</div><div class="line">        const int bufSize = av_samples_get_buffer_size(NULL, (int)numChannels ,(int)(_audioFrame-&gt;nb_samples * ratio), AV_SAMPLE_FMT_S16, 1);</div><div class="line">        if (!_swrBuffer || _swrBufferSize &lt; bufSize) &#123;</div><div class="line">            _swrBufferSize = bufSize;</div><div class="line">            _swrBuffer = realloc(_swrBuffer, _swrBufferSize);</div><div class="line">        &#125;</div><div class="line">        Byte *outbuf[2] = &#123;_swrBuffer,0&#125;;</div><div class="line">        numFrames = swr_convert(_swrContext, outbuf, (int)(_audioFrame-&gt;nb_samples * ratio), (const uint8_t **)_audioFrame-&gt;data, _audioFrame-&gt;nb_samples);</div><div class="line">        if (numFrames &lt; 0) &#123;</div><div class="line">            NSLog(@&quot;fail resample audio&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        audioData = _swrBuffer;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (_audioCodecCtx-&gt;sample_fmt != AV_SAMPLE_FMT_S16) &#123;</div><div class="line">            NSLog(@&quot;Audio format is invalid&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        audioData = _audioFrame-&gt;data[0];</div><div class="line">        numFrames = _audioFrame-&gt;nb_samples;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //总帧数 = 一条信道的帧数*信道数</div><div class="line">    const NSUInteger numElements = numFrames * numChannels;</div><div class="line">    NSMutableData *pcmData = [NSMutableData dataWithLength:numElements * sizeof(SInt16)];</div><div class="line">    memcpy(pcmData.mutableBytes, audioData, numElements * sizeof(SInt16));</div><div class="line">    LLYAudioFrame *frame = [[LLYAudioFrame alloc]init];</div><div class="line">    frame.position = av_frame_get_best_effort_timestamp(_audioFrame) * _audioTimeBase;</div><div class="line">    frame.duration = av_frame_get_pkt_duration(_audioFrame) * _audioTimeBase;</div><div class="line">    frame.sampleData = pcmData;</div><div class="line">    frame.frameType = LLYFrameType_Audio;</div><div class="line">    </div><div class="line">    return frame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里判断一下如果是重采样的，需要做一个转换。</p>
<h3 id="视频解码（补充）"><a href="#视频解码（补充）" class="headerlink" title="视频解码（补充）"></a>视频解码（补充）</h3><p>视频解码的工作也做完了，流程和音频大同小异，只是在最后几步的时候会有差异</p>
<h4 id="获取AVFrame"><a href="#获取AVFrame" class="headerlink" title="获取AVFrame"></a>获取AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int gotFrmae = 0;</div><div class="line">int len = avcodec_decode_video2(_videoCodecCtx, _videoFrame, &amp;gotFrmae, &amp;packet);</div><div class="line">if (len &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;decode video error, skip packet %s&quot;, av_err2str(len));</div><div class="line">    *errorState = 1;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用video的解码api.</p>
<h4 id="将AVFrame转为自定义的LLYVideoFrame"><a href="#将AVFrame转为自定义的LLYVideoFrame" class="headerlink" title="将AVFrame转为自定义的LLYVideoFrame"></a>将AVFrame转为自定义的LLYVideoFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (LLYVideoFrame *)handleVideoFrame&#123;</div><div class="line">    </div><div class="line">    if (!_videoFrame-&gt;data[0]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LLYVideoFrame *videoFrame = [[LLYVideoFrame alloc]init];</div><div class="line">    //将yuv数据取出来</div><div class="line">    if (_videoCodecCtx-&gt;pix_fmt == AV_PIX_FMT_YUV420P || _videoCodecCtx-&gt;pix_fmt == AV_PIX_FMT_YUVJ420P) &#123;</div><div class="line">        videoFrame.luma = copyFrameData(_videoFrame-&gt;data[0], _videoFrame-&gt;linesize[0], _videoCodecCtx-&gt;width, _videoCodecCtx-&gt;height);</div><div class="line">        videoFrame.chromaB = copyFrameData(_videoFrame-&gt;data[1], _videoFrame-&gt;linesize[1], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">        videoFrame.chromaR = copyFrameData(_videoFrame-&gt;data[2], _videoFrame-&gt;linesize[2], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">    &#125;else&#123;</div><div class="line">        //不是yuv格式先要将格式转为yuv的</div><div class="line">        if (!_swsContext &amp;&amp;</div><div class="line">            ![self setupScaler]) &#123;</div><div class="line">            NSLog(@&quot;fail setup video scaler&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sws_scale(_swsContext,</div><div class="line">                  (const uint8_t **)_videoFrame-&gt;data,</div><div class="line">                  _videoFrame-&gt;linesize,</div><div class="line">                  0,</div><div class="line">                  _videoCodecCtx-&gt;height,</div><div class="line">                  _picture.data,</div><div class="line">                  _picture.linesize);</div><div class="line">        videoFrame.luma = copyFrameData(_picture.data[0], _videoFrame-&gt;linesize[0], _videoCodecCtx-&gt;width, _videoCodecCtx-&gt;height);</div><div class="line">        videoFrame.chromaB = copyFrameData(_picture.data[1], _videoFrame-&gt;linesize[1], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">        videoFrame.chromaR = copyFrameData(_picture.data[2], _videoFrame-&gt;linesize[2], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">    &#125;</div><div class="line">    videoFrame.width = _videoCodecCtx-&gt;width;</div><div class="line">    videoFrame.height = _videoCodecCtx-&gt;height;</div><div class="line">    videoFrame.lineSize = _videoFrame-&gt;linesize[0];</div><div class="line">    videoFrame.frameType = LLYFrameType_Video;</div><div class="line">    videoFrame.position = av_frame_get_best_effort_timestamp(_videoFrame) * _videoTimeBase;</div><div class="line">    const int64_t frameDuration = av_frame_get_pkt_duration(_videoFrame);</div><div class="line">    if (frameDuration) &#123;</div><div class="line">        videoFrame.duration = frameDuration * _videoTimeBase;</div><div class="line">        videoFrame.duration += _videoFrame-&gt;repeat_pict * _videoTimeBase * 0.5;</div><div class="line">    &#125; else &#123;</div><div class="line">        // sometimes, ffmpeg unable to determine a frame duration</div><div class="line">        // as example yuvj420p stream from web camera</div><div class="line">        videoFrame.duration = 1.0 / _fps;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return videoFrame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里转为自定义的LLYVideoFrame时需要将YUV的数据都取出来。</p>
<p>主要流程大概就是上面这些了。当然还有一些细节的东西，这里没有一一列出来，可以从demo中寻找答案。</p>
<p><a href="https://github.com/lilingyu0620/LLYFFMPEGPlayer.git" target="_blank" rel="noopener">LLYFFMPEGPlayer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/FFMPEG学习笔记/" itemprop="url">
                  FFMPEG学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-07T17:52:01+08:00" content="2018-05-07">
              2018-05-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/07/FFMPEG学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/FFMPEG学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想要从事音视频相关的工作，FFMPEG是绕不开的一道坎，就像吉他里面的大横按，既然我能给征服大横按，相信我也能征服你，FFMPEG！！！</p>
<p>自学音视频相关的内容也有一段时间啦，比如之前的H264,RTMP,FLV,还有最近的AudioUint和AudioQueue，通过这段时间的学习，我总结出来的方法就是，先将他们的数据结构分析清楚，了解主要的api，然后从简单的api开始实践。</p>
<p>所以我们先来看一下FFMPEG的主要数据结构和api…</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="文件读取相关"><a href="#文件读取相关" class="headerlink" title="文件读取相关"></a>文件读取相关</h4><h5 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h5><p>AVIOContext是FFMPEG管理输入输出数据的结构体</p>
<p>比较重要的属性：</p>
<ul>
<li><p>unsigned char *buffer：缓存读取的数据</p>
</li>
<li><p>int buffer_size：缓存大小（默认32768）</p>
</li>
<li><p>unsigned char *buf_ptr：当前指针读取到的位置</p>
</li>
<li><p>unsigned char *buf_end：缓存结束的位置</p>
</li>
<li><p>void *opaque：URLContext结构体</p>
</li>
</ul>
<h4 id="协议相关"><a href="#协议相关" class="headerlink" title="协议相关"></a>协议相关</h4><h5 id="URLContext、URLProtocol"><a href="#URLContext、URLProtocol" class="headerlink" title="URLContext、URLProtocol"></a>URLContext、URLProtocol</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">typedef struct URLContext &#123;  </div><div class="line">    const AVClass *av_class; ///&lt; information for av_log(). Set by url_open().  </div><div class="line">    struct URLProtocol *prot;  </div><div class="line">    int flags;  </div><div class="line">    int is_streamed;  /**&lt; true if streamed (no seek possible), default = false */  </div><div class="line">    int max_packet_size;  /**&lt; if non zero, the stream is packetized with this max packet size */  </div><div class="line">    void *priv_data;  </div><div class="line">    char *filename; /**&lt; specified URL */  </div><div class="line">    int is_connected;  </div><div class="line">    AVIOInterruptCB interrupt_callback;  </div><div class="line">&#125; URLContext;  </div><div class="line"></div><div class="line">typedef struct URLProtocol &#123;  </div><div class="line">    const char *name;  </div><div class="line">    int (*url_open)(URLContext *h, const char *url, int flags);  </div><div class="line">    int (*url_read)(URLContext *h, unsigned char *buf, int size);  </div><div class="line">    int (*url_write)(URLContext *h, const unsigned char *buf, int size);  </div><div class="line">    int64_t (*url_seek)(URLContext *h, int64_t pos, int whence);  </div><div class="line">    int (*url_close)(URLContext *h);  </div><div class="line">    struct URLProtocol *next;  </div><div class="line">    int (*url_read_pause)(URLContext *h, int pause);  </div><div class="line">    int64_t (*url_read_seek)(URLContext *h, int stream_index,  </div><div class="line">        int64_t timestamp, int flags);  </div><div class="line">    int (*url_get_file_handle)(URLContext *h);  </div><div class="line">    int priv_data_size;  </div><div class="line">    const AVClass *priv_data_class;  </div><div class="line">    int flags;  </div><div class="line">    int (*url_check)(URLContext *h, int mask);  </div><div class="line">&#125; URLProtocol;</div></pre></td></tr></table></figure>
<p>URLContext结构体中还有一个结构体URLProtocol,每种协议（rtp，rtmp，file等）对应一个URLProtocol。</p>
<h4 id="封装格式相关"><a href="#封装格式相关" class="headerlink" title="封装格式相关"></a>封装格式相关</h4><h5 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h5><p>这个结构体描述了一个媒体文件或媒体流的构成和基本信息</p>
<p>在使用FFMPEG进行开发的时候，AVFormatContext是一个贯穿始终的数据结构，很多函数都要用到它作为参数。</p>
<p>看几个主要变量的作用:</p>
<ul>
<li><p>struct AVInputFormat *iformat：输入数据的封装格式</p>
</li>
<li><p>AVIOContext *pb：输入数据的缓存</p>
</li>
<li><p>unsigned int nb_streams：视音频流的个数</p>
</li>
<li><p>AVStream **streams：音视频流</p>
</li>
<li><p>char filename[1024]：文件名</p>
</li>
<li><p>int64_t duration：时长（单位：微秒us，转换为秒需要除以1000000）</p>
</li>
<li><p>int bit_rate：比特率（单位bps，转换为kbps需要除以1000）</p>
</li>
<li><p>AVDictionary *metadata：元数据</p>
</li>
</ul>
<h5 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h5><p>作为输入容器，包含了输入文件的音视频流信息,程序从输入容器从读出音视频包进行解码处理</p>
<h5 id="AVOutputFormat"><a href="#AVOutputFormat" class="headerlink" title="AVOutputFormat"></a>AVOutputFormat</h5><p>作为输出容器，程序把编码好的音视频包写入到输出容器中</p>
<h4 id="编解码相关"><a href="#编解码相关" class="headerlink" title="编解码相关"></a>编解码相关</h4><h5 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h5><p>这是一个描述编解码器上下文的数据结构，包含了众多编解码器需要的参数信息</p>
<p>看一下关键属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">enum AVMediaType codec_type：编解码器的类型（视频，音频...）</div><div class="line"></div><div class="line">struct AVCodec  *codec：采用的解码器AVCodec（H.264,MPEG2...）</div><div class="line"></div><div class="line">int bit_rate：平均比特率</div><div class="line"></div><div class="line">uint8_t *extradata; int extradata_size：针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</div><div class="line"></div><div class="line">AVRational time_base：根据该参数，可以把PTS转化为实际的时间（单位为秒s）</div><div class="line"></div><div class="line">int width, height：如果是视频的话，代表宽和高</div><div class="line"></div><div class="line">int refs：运动估计参考帧的个数（H.264的话会有多帧，MPEG2这类的一般就没有了）</div><div class="line"></div><div class="line">int sample_rate：采样率（音频）</div><div class="line"></div><div class="line">int channels：声道数（音频）</div><div class="line"></div><div class="line">enum AVSampleFormat sample_fmt：采样格式</div><div class="line"></div><div class="line">int profile：型（H.264里面就有，其他编码标准应该也有）</div><div class="line"></div><div class="line">int level：级（和profile差不太多）</div></pre></td></tr></table></figure>
<h5 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h5><p>AVCodec是存储编解码器信息的结构体，每一个编解码器对应一个该结构体。</p>
<p>下面说一下最主要的几个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const char *name：编解码器的名字，比较短</div><div class="line"></div><div class="line">const char *long_name：编解码器的名字，全称，比较长</div><div class="line"></div><div class="line">enum AVMediaType type：指明了类型，是视频，音频，还是字幕</div><div class="line"></div><div class="line">enum AVCodecID id：ID，不重复</div><div class="line"></div><div class="line">const AVRational *supported_framerates：支持的帧率（仅视频）</div><div class="line"></div><div class="line">const enum AVPixelFormat *pix_fmts：支持的像素格式（仅视频）</div><div class="line"></div><div class="line">const int *supported_samplerates：支持的采样率（仅音频）</div><div class="line"></div><div class="line">const enum AVSampleFormat *sample_fmts：支持的采样格式（仅音频）</div><div class="line"></div><div class="line">const uint64_t *channel_layouts：支持的声道数（仅音频）</div><div class="line"></div><div class="line">int priv_data_size：私有数据的大小</div></pre></td></tr></table></figure>
<h5 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h5><p>AVStream是存储每一个视频/音频流信息的结构体</p>
<p>AVStream重要的变量如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int index：标识该视频/音频流</div><div class="line"></div><div class="line">AVCodecContext *codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）</div><div class="line"></div><div class="line">AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。FFMPEG其他结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。PTS*time_base=真正的时间</div><div class="line"></div><div class="line">int64_t duration：该视频/音频流长度</div><div class="line"></div><div class="line">AVDictionary *metadata：元数据信息</div><div class="line"></div><div class="line">AVRational avg_frame_rate：帧率（注：对视频来说，这个挺重要的）</div><div class="line"></div><div class="line">AVPacket attached_pic：附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面。</div></pre></td></tr></table></figure>
<h5 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h5><p>AVPacket是存储压缩编码数据相关信息的结构体</p>
<p>重要的变量有以下几个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!--例如对于H.264来说。1个AVPacket的data通常对应一个NAL。</div><div class="line"></div><div class="line">注意：在这里只是对应，而不是一模一样。他们之间有微小的差别：使用FFMPEG类库分离出多媒体文件中的H.264码流</div><div class="line"></div><div class="line">因此在使用FFMPEG进行视音频处理的时候，常常可以将得到的AVPacket的data数据直接写成文件，从而得到视音频的码流文件。</div><div class="line">--&gt;</div><div class="line"></div><div class="line">uint8_t *data：压缩编码的数据。</div><div class="line"></div><div class="line">int   size：data的大小</div><div class="line"></div><div class="line">int64_t pts：显示时间戳</div><div class="line"></div><div class="line">int64_t dts：解码时间戳</div><div class="line"></div><div class="line">int   stream_index：标识该AVPacket所属的视频/音频流。</div></pre></td></tr></table></figure>
<h5 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h5><p>AVFrame结构体一般用于存储原始数据（即非压缩数据，例如对视频来说是YUV，RGB，对音频来说是PCM），此外还包含了一些相关的信息。比如说，解码的时候存储了宏块类型表，QP表，运动矢量表等数据。编码的时候也存储了相关的数据。因此在使用FFMPEG进行码流分析的时候，AVFrame是一个很重要的结构体。</p>
<p>下面看几个主要变量的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uint8_t *data[AV_NUM_DATA_POINTERS]：解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）</div><div class="line"></div><div class="line">int linesize[AV_NUM_DATA_POINTERS]：data中“一行”数据的大小。注意：未必等于图像的宽，一般大于图像的宽。</div><div class="line"></div><div class="line">int width, height：视频帧宽和高（1920x1080,1280x720...）</div><div class="line"></div><div class="line">int nb_samples：音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个</div><div class="line"></div><div class="line">int format：解码后原始数据类型（YUV420，YUV422，RGB24...）</div><div class="line"></div><div class="line">int key_frame：是否是关键帧</div><div class="line"></div><div class="line">enum AVPictureType pict_type：帧类型（I,B,P...）</div><div class="line"></div><div class="line">AVRational sample_aspect_ratio：宽高比（16:9，4:3...）</div><div class="line"></div><div class="line">int64_t pts：显示时间戳</div><div class="line"></div><div class="line">int coded_picture_number：编码帧序号</div><div class="line"></div><div class="line">int display_picture_number：显示帧序号</div><div class="line"></div><div class="line">int8_t *qscale_table：QP表</div><div class="line"></div><div class="line">uint8_t *mbskip_table：跳过宏块表</div><div class="line"></div><div class="line">int16_t (*motion_val[2])[2]：运动矢量表</div><div class="line"></div><div class="line">uint32_t *mb_type：宏块类型表</div><div class="line"></div><div class="line">short *dct_coeff：DCT系数，这个没有提取过</div><div class="line"></div><div class="line">int8_t *ref_index[2]：运动估计参考帧列表（貌似H.264这种比较新的标准才会涉及到多参考帧）</div><div class="line"></div><div class="line">int interlaced_frame：是否是隔行扫描</div><div class="line"></div><div class="line">uint8_t motion_subsample_log2：一个宏块中的运动矢量采样个数，取log的</div></pre></td></tr></table></figure>
<p>结构体之间的关系可以参考下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/20130914204051125.jpg" alt=""></p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="avcodec-init"><a href="#avcodec-init" class="headerlink" title="avcodec_init()"></a>avcodec_init()</h4><p>初始化libavcodec,一般最先调用该函数</p>
<p>该函数必须在调用libavcodec里的其它函数前调用,一般在程序启动或模块初始化时调用,如果你调用了多次也无所谓,因为后面的调用不会做任何事情.从函数的实现里你可以发现,代码中对多次调用进行了控制.</p>
<h4 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all()"></a>av_register_all()</h4><p>初始化 libavformat和注册所有的muxers、demuxers和protocols，</p>
<p>一般在调用avcodec_init后调用该方法</p>
<p>其中会调用avcodec_register_all()注册多种音视频格式的编解码器,并注册各种文件的编解复用器</p>
<h4 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context()"></a>avformat_alloc_context()</h4><p>分配一个AVFormatContext结构，负责申请一个AVFormatContext结构的内存,并进行简单初始化</p>
<h4 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input()"></a>avformat_open_input()</h4><p>打开一个流媒体文件</p>
<h4 id="avformat-close-input"><a href="#avformat-close-input" class="headerlink" title="avformat_close_input()"></a>avformat_close_input()</h4><p>关闭一个流媒体文件</p>
<h4 id="avformat-free-context"><a href="#avformat-free-context" class="headerlink" title="avformat_free_context()"></a>avformat_free_context()</h4><p>释放一个AVFormatContext结构</p>
<p>使用 avformat_alloc_context()分配的结构,采用该函数进行释放,除释放AVFormatContext结构本身内存之外,AVFormatContext中指针所指向的内存也会一并释放</p>
<h4 id="avio-alloc-context"><a href="#avio-alloc-context" class="headerlink" title="avio_alloc_context()"></a>avio_alloc_context()</h4><p>为I/0缓存申请并初始化一个AVIOContext结构,结束使用时必须使用av_free()进行释放</p>
<h4 id="av-open-input-file"><a href="#av-open-input-file" class="headerlink" title="av_open_input_file()"></a>av_open_input_file()</h4><p>以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息.</p>
<h4 id="av-close-input-file"><a href="#av-close-input-file" class="headerlink" title="av_close_input_file()"></a>av_close_input_file()</h4><p>关闭使用avformat_close_input()打开的输入文件容器,但并不关系它的codecs</p>
<p>使用 av_close_input_file 关闭后,就不再需要使用avformat_free_context 进行释放了</p>
<h4 id="av-find-stream-info-AVFormatContext-ic"><a href="#av-find-stream-info-AVFormatContext-ic" class="headerlink" title="av_find_stream_info(AVFormatContext *ic)"></a>av_find_stream_info(AVFormatContext *ic)</h4><p>通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的</p>
<h4 id="AVCodec-avcodec-find-decoder-enum-CodecID-id"><a href="#AVCodec-avcodec-find-decoder-enum-CodecID-id" class="headerlink" title="AVCodec *avcodec_find_decoder(enum CodecID id)"></a>AVCodec *avcodec_find_decoder(enum CodecID id)</h4><p>通过code ID查找一个已经注册的音视频解码器</p>
<p>查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p>音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的ID来查找</p>
<h4 id="AVCodec-avcodec-find-decoder-by-name-constchar-name"><a href="#AVCodec-avcodec-find-decoder-by-name-constchar-name" class="headerlink" title="AVCodec  avcodec_find_decoder_by_name (constchar  name)"></a>AVCodec <em> avcodec_find_decoder_by_name (constchar </em> name)</h4><p>通过一个指定的名称查找一个已经注册的音视频解码器</p>
<p>查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p>音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的name来查找</p>
<h4 id="avcodec-find-encoder"><a href="#avcodec-find-encoder" class="headerlink" title="avcodec_find_encoder()"></a>avcodec_find_encoder()</h4><h4 id="avcodec-find-encoder-by-name"><a href="#avcodec-find-encoder-by-name" class="headerlink" title="avcodec_find_encoder_by_name()"></a>avcodec_find_encoder_by_name()</h4><p>同上。。。</p>
<h4 id="int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2"><a href="#int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2" class="headerlink" title="int avcodec_open(AVCodecContext  avctx, AVCodec  codec) / avcodec_open2()"></a>int avcodec_open(AVCodecContext <em> avctx, AVCodec </em> codec) / avcodec_open2()</h4><p>使用给定的AVCodec初始化AVCodecContext</p>
<h4 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format()"></a>av_guess_format()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AVOutputFormat *av_guess_format(constchar *short_name,</div><div class="line"></div><div class="line">                                constchar *filename,</div><div class="line"></div><div class="line">                                constchar *mime_type);</div></pre></td></tr></table></figure>
<p>返回一个已经注册的最合适的输出格式</p>
<h4 id="void-av-init-packet-AVPacket-pkt"><a href="#void-av-init-packet-AVPacket-pkt" class="headerlink" title="void av_init_packet(AVPacket *pkt);"></a>void av_init_packet(AVPacket *pkt);</h4><p>使用默认值初始化AVPacket</p>
<p>定义AVPacket对象后,请使用av_init_packet进行初始化</p>
<h4 id="int-av-read-frame-AVFormatContext-s-AVPacket-pkt"><a href="#int-av-read-frame-AVFormatContext-s-AVPacket-pkt" class="headerlink" title="int av_read_frame(AVFormatContext  s, AVPacket  pkt)"></a>int av_read_frame(AVFormatContext <em> s, AVPacket </em> pkt)</h4><p>从输入源文件容器中读取一个AVPacket数据包</p>
<p>该函数读出的包并不每次都是有效的,对于读出的包我们都应该进行相应的解码(视频解码/音频解码),</p>
<p>在返回值&gt;=0时,循环调用该函数进行读取,循环调用之前请调用av_free_packet函数清理AVPacket</p>
<h4 id="avcodec-decode-video2"><a href="#avcodec-decode-video2" class="headerlink" title="avcodec_decode_video2()"></a>avcodec_decode_video2()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int avcodec_decode_video2(AVCodecContext *avctx, 										AVFrame *picture,</div><div class="line">                         int *got_picture_ptr,</div><div class="line">                         AVPacket *avpkt);</div><div class="line">                         </div><div class="line">                         </div><div class="line">// 解码视频流AVPacket</div><div class="line">// 使用av_read_frame读取媒体流后需要进行判断,如果为视频流则调用该函数解码</div><div class="line">// 返回结果&lt;0时失败,此时程序应该退出检查原因</div><div class="line">// 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做</div><div class="line">// 如下处理:</div><div class="line">//   vPacket.size -= vLen;</div><div class="line">//   vPacket.data += vLen;</div><div class="line">// 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</div><div class="line">// 返回 got_picture_ptr &gt; 0 时,表示解码到了AVFrame *picture,其后可以对picture进程处理</div></pre></td></tr></table></figure>
<h4 id="avcodec-decode-audio3-avcodec-decode-audio4"><a href="#avcodec-decode-audio3-avcodec-decode-audio4" class="headerlink" title="avcodec_decode_audio3()/avcodec_decode_audio4()"></a>avcodec_decode_audio3()/avcodec_decode_audio4()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples,</div><div class="line"></div><div class="line">                         int *frame_size_ptr,</div><div class="line"></div><div class="line">                         AVPacket *avpkt);</div><div class="line">                         </div><div class="line">int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,</div><div class="line">int *got_frame_ptr, </div><div class="line">const AVPacket *avpkt);</div><div class="line"></div><div class="line"></div><div class="line">// 解码音频流AVPacket</div><div class="line">// 使用av_read_frame读取媒体流后需要进行判断,如果为音频流则调用该函数解码</div><div class="line">// 返回结果&lt;0时失败,此时程序应该退出检查原因</div><div class="line">// 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做</div><div class="line">// 如下处理:</div><div class="line">//   vPacket.size -= vLen;</div><div class="line">//   vPacket.data += vLen;</div><div class="line">// 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/使用AudioQueue实现一个音频播放器/" itemprop="url">
                  使用AudioQueue实现一个音频播放器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-07T15:46:32+08:00" content="2018-05-07">
              2018-05-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/07/使用AudioQueue实现一个音频播放器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/使用AudioQueue实现一个音频播放器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在系统的学习了AudioQueue相关姿势之后，我尝试使用AudioQueue做一个简单的音频播放器，包括播放，暂停，停止，快进快退，同时支持本地音频和网络音频等功能。</p>
<p>这里将整个流程分为下面几个模块：</p>
<ul>
<li><p>AudioProperty – 用来保存音频的相关属性</p>
</li>
<li><p>AudioSource – 主要负责提供音频数据</p>
<ul>
<li>LocalAudioSource 本地数据来源</li>
<li>NetAudioSource 网络数据来源</li>
</ul>
</li>
</ul>
<ul>
<li>AudioStream – 主要负责对音频流的解析</li>
</ul>
<ul>
<li>AudioQueue – 主要负责音频播放</li>
</ul>
<ul>
<li>AudioPlayer – 播放器实体，负责管理上面的几个模块。</li>
</ul>
<p>下面分模块来介绍下：</p>
<h4 id="AudioProperty"><a href="#AudioProperty" class="headerlink" title="AudioProperty"></a>AudioProperty</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@protocol LLYAudioPropertyDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)audioProrperty_error:(NSError *)error;</div><div class="line">- (void)audioProperty_statusChanged:(LLYAudioStatus)audioStatus;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface LLYAudioProperty : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign) UInt64 fileSize;</div><div class="line">@property (nonatomic, assign) UInt32 packetMaxSize;</div><div class="line">@property (nonatomic, assign) void * magicData;</div><div class="line">@property (nonatomic, assign) UInt32 cookieSize;</div><div class="line">@property (nonatomic, assign) LLYAudioStatus status;</div><div class="line">@property (nonatomic, strong) NSError *error;</div><div class="line">@property (nonatomic, weak) id &lt;LLYAudioPropertyDelegate&gt; delegate;</div><div class="line">@property (nonatomic, assign) AudioStreamBasicDescription audioDesc;</div><div class="line"></div><div class="line">- (void)error:(LLYAudioError)errorType;</div><div class="line">- (NSString *)errorDomain:(LLYAudioError)errorType;</div><div class="line">- (void)clean;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当每次音频的状态发生改变时，我们通过上面的代理将状态传给UI。</p>
<p>这里我们保存了fileSize和audioDesc，主要是用来计算音频的总时长，计算方法在之前已经介绍过了。</p>
<h4 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h4><p>因为这个模块有两种类型，所以我们先定义一个父类，然后让子类去继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@class LLYBaseAudioSource;</div><div class="line"></div><div class="line">@protocol LLYAudioSourceDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)audioSource_fileType:(LLYBaseAudioSource *)curAudioSource fileType:(AudioFileTypeID)fileType;</div><div class="line">- (void)audioSource_dataArrived:(LLYBaseAudioSource *)curAudioSource data:(NSData *)data contine:(BOOL)isContine;</div><div class="line">- (void)audioSource_finished:(LLYBaseAudioSource *)curAudioSource error:(NSError *)error;</div><div class="line">- (void)audioSource_shouldExit:(LLYBaseAudioSource*)currAudioData;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface LLYBaseAudioSource : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *urlStr;</div><div class="line">@property (nonatomic, weak) id&lt;LLYAudioSourceDelegate&gt; delegate;</div><div class="line">@property (nonatomic, assign) int audioVersion;</div><div class="line">@property (nonatomic, strong) LLYAudioProperty *audioProperty;</div><div class="line"></div><div class="line">- (void)start;</div><div class="line">- (void)cancel;</div><div class="line">- (void)seekToOffset:(UInt64)offset;</div><div class="line">- (AudioFileTypeID)fileTypeWithFileExtension:(NSString *)fileExtension;</div><div class="line">- (void)audioSourceError:(NSString *)errorDomain userInfo:(NSDictionary *)userInfo;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在我们获取到原始的音频数据后，也是通过代理的方式将数据交给其它模块去处理。</p>
<p>具体看一下本地和网络数据获取的方式有何不同：</p>
<h5 id="LLYLocalAudioSource"><a href="#LLYLocalAudioSource" class="headerlink" title="LLYLocalAudioSource"></a>LLYLocalAudioSource</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)loadData&#123;</div><div class="line">    if([[NSFileManager defaultManager] fileExistsAtPath:self.urlStr])&#123;</div><div class="line">        NSError *error;</div><div class="line">        NSDictionary *fileAttDic = [[NSFileManager defaultManager] attributesOfItemAtPath:self.urlStr error:&amp;error];</div><div class="line">        fileSize = [[fileAttDic objectForKey:NSFileSize] longValue];</div><div class="line">        if (fileSize &gt; 0) &#123;</div><div class="line">            self.audioProperty.fileSize = fileSize;</div><div class="line">            filehandle = [NSFileHandle fileHandleForReadingAtPath:self.urlStr];</div><div class="line">            currOffset = 0;</div><div class="line">            if (!fileTimer) &#123;</div><div class="line">                fileTimer = [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(fileTimer_intval) userInfo:nil repeats:YES];</div><div class="line">                [[NSRunLoop currentRunLoop] run];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            [self audioSourceError:@&quot;file read error&quot; userInfo:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        [self audioSourceError:@&quot;file not exists&quot; userInfo:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我是使用了一个计时器去读取的本地数据，用while循环应该也是ok的。然后是整个数据读取操作都需要放在子线程去操作，因为如果放在主线程的话会阻塞当前线程，造成UI卡顿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)fileTimer_intval&#123;</div><div class="line">    </div><div class="line">    if (exit) &#123;</div><div class="line">        [filehandle closeFile];</div><div class="line">        filehandle=nil;</div><div class="line">        </div><div class="line">        if (self.delegate) &#123;</div><div class="line">            [self.delegate audioSource_shouldExit:self];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CFRunLoopStop([[NSRunLoop currentRunLoop] getCFRunLoop]);//必须停止，要不线程一直不会被释放</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!filehandle) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (newOffset &gt; 0) &#123;</div><div class="line">        currOffset = newOffset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UInt64 currReadLength = readLength;</div><div class="line">    if (currOffset + currReadLength &gt; fileSize) &#123;</div><div class="line">        currReadLength = fileSize - currOffset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (currOffset == 0) &#123;</div><div class="line">        isContine = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (newOffset &gt; 0)&#123;</div><div class="line">        [filehandle seekToFileOffset:newOffset];</div><div class="line">        </div><div class="line">        newOffset = 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    audioFileData = [filehandle readDataOfLength:currReadLength];</div><div class="line">    if (audioFileData &amp;&amp; self.delegate) &#123;</div><div class="line">        [self.delegate audioSource_dataArrived:self data:audioFileData contine:isContine];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    currOffset += currReadLength;</div><div class="line"></div><div class="line">    if (currOffset &gt;= fileSize) &#123;</div><div class="line">        if (fileTimer) &#123;</div><div class="line">            [fileTimer invalidate];</div><div class="line">            fileTimer=nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!isContine) &#123;</div><div class="line">        isContine = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!fileTimer) &#123;</div><div class="line">        if (self.delegate) &#123;</div><div class="line">            [self.delegate audioSource_finished:self error:nil];</div><div class="line">            [filehandle closeFile];</div><div class="line">            filehandle=nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在数据读取过程中，我们需要记录一下当前读取了多少数据，防止最后一次读取的数据不够，这里还有2个参数是seek相关的，isContine 和 newOffset ，当newOffset不为0时，我们需要将当前文件的读取偏移量seek到newOffset处，然后在继续读文件，同时，我们标记isContine为NO，通知其他模块，清空之前的音频读取相关记录，重新开始读取新的数据。</p>
<h5 id="LLYNetAudioSource"><a href="#LLYNetAudioSource" class="headerlink" title="LLYNetAudioSource"></a>LLYNetAudioSource</h5><p>网络音频和本地音频处理起来不太一样，因为它们使用的是不同的协议，本地文件可以看做file协议，网络音频则是http协议。不过原理上其实是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)requestStart&#123;</div><div class="line">    </div><div class="line">    if (!self.audioTask) &#123;</div><div class="line">        </div><div class="line">        self.audioRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:self.urlStr]];</div><div class="line">        if (seekOffset) &#123;</div><div class="line">            [self.audioRequest setValue:[NSString stringWithFormat:@&quot;bytes=%llu-&quot;,seekOffset] forHTTPHeaderField:@&quot;Range&quot;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        self.audioSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue new]];</div><div class="line">        self.audioTask = [self.audioSession dataTaskWithRequest:self.audioRequest];</div><div class="line">        [self.audioTask resume];</div><div class="line">        </div><div class="line">        NSLog(@&quot;requestStart current thread %@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDataDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">didReceiveResponse:(NSURLResponse *)response</div><div class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;didReceiveResponse current thread %@&quot;,[NSThread currentThread]);</div><div class="line"></div><div class="line">    fileSize = seekOffset + response.expectedContentLength;</div><div class="line">    seekOffset = 0;</div><div class="line">    self.audioProperty.fileSize = fileSize;</div><div class="line">    </div><div class="line">    completionHandler(NSURLSessionResponseAllow);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;didReceiveData current thread %@&quot;,[NSThread currentThread]);</div><div class="line"></div><div class="line">    if (self.delegate) &#123;</div><div class="line">        if (currDataSize == 0) &#123;</div><div class="line">            isContine = NO;</div><div class="line">        &#125;</div><div class="line">        [self.delegate audioSource_dataArrived:self data:data contine:isContine];</div><div class="line">        currDataSize = currDataSize + data.length;</div><div class="line">        if (!isContine) &#123;</div><div class="line">            isContine = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的 ，这个数据请求过程也是放在子线程中进行。</p>
<p>这里，使用代理的方式而不是完成快的方式去请求数据，是因为音频数据相对来说还是有点大的，如果使用完成块的方式需要等待数据全部请求完成才会返回，等待时候会比较长，而且我们在开始播放音频时也并不需要全部的数据，边播放请求数据也比较符合正常的逻辑。</p>
<p>在发送请求前，也有一个seek相关的操作，如果当前是seek后第一次请求数据，通过设置http header中的Range的字段，请求seek后的数据。</p>
<h4 id="LLYAudioStream"><a href="#LLYAudioStream" class="headerlink" title="LLYAudioStream"></a>LLYAudioStream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@protocol LLYAudioStreamDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)audioStream_readyToProducePackets;</div><div class="line">- (void)audioStream_packets:(NSData *)data packetNum:(UInt32)packetCount packetDesc:(AudioStreamPacketDescription *)inPacketDesc;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface LLYAudioStream : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign) AudioStreamBasicDescription audioDesc;</div><div class="line">@property (nonatomic, assign) double duration;</div><div class="line">@property (nonatomic, weak) id&lt;LLYAudioStreamDelegate&gt; delegate;</div><div class="line">@property (nonatomic, strong) LLYAudioProperty *audioProperty;</div><div class="line">@property (nonatomic, assign) UInt64 seekByteOffset;</div><div class="line">@property (nonatomic, assign) double seekTime;</div><div class="line">@property (nonatomic, assign) NSInteger audioVersion;</div><div class="line"></div><div class="line">//- (instancetype)initWithFileType:(AudioFileTypeID)fileTypeID;</div><div class="line"></div><div class="line">- (void)audioStreamParseBytes:(NSData *)data flags:(UInt32)flags;</div><div class="line"></div><div class="line">- (void)getSeekToOffset:(double)seekToTime;</div><div class="line"></div><div class="line">- (void)close;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>收到AudioSource的数据后，使用AudioStream来解析，然后把解析到的数据通过代理给AudioQueue，这就是AudoStream需要做的事情。</p>
<p>这里主要看一下下面几个方法：</p>
<h5 id="计算seek的偏移量"><a href="#计算seek的偏移量" class="headerlink" title="计算seek的偏移量"></a>计算seek的偏移量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)getSeekToOffset:(double)seekToTime&#123;</div><div class="line">    </div><div class="line">    self.seekByteOffset = dataOffset +</div><div class="line">    (seekToTime / self.duration) * (_audioProperty.fileSize - dataOffset);</div><div class="line">    </div><div class="line">    if (self.seekByteOffset &gt; _audioProperty.fileSize - 2 * _audioProperty.packetMaxSize)&#123;</div><div class="line">        self.seekByteOffset = _audioProperty.fileSize - 2 * _audioProperty.packetMaxSize;</div><div class="line">    &#125;</div><div class="line">    self.seekTime = seekToTime;</div><div class="line">    isSeeking=YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总时长"><a href="#总时长" class="headerlink" title="总时长"></a>总时长</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(double)duration&#123;</div><div class="line">    double calculatedBitRate = [self calculatedBitRate];</div><div class="line">    </div><div class="line">    if (calculatedBitRate == 0 || _audioProperty.fileSize == 0)</div><div class="line">    &#123;</div><div class="line">        return 0.0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return (_audioProperty.fileSize-dataOffset) / (calculatedBitRate * 0.125);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (double)calculatedBitRate</div><div class="line">&#123;</div><div class="line">    if (packetDuration &amp;&amp; packetCount &gt; BitRateEstimationMinPackets)</div><div class="line">    &#123;</div><div class="line">        double averagePacketByteSize = packetDataSize / packetCount;</div><div class="line">        return 8.0 * averagePacketByteSize / packetDuration;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (bitRate)</div><div class="line">    &#123;</div><div class="line">        return (double)bitRate;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AudioQueue模块和AudioPlayer模块相对来讲就比较简单了，之前的demo里面也使用过，就不一一介绍。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioPlayer.git" target="_blank" rel="noopener">demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/28/AudioQueue学习笔记和实战/" itemprop="url">
                  AudioQueue学习笔记和实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-28T12:09:55+08:00" content="2018-04-28">
              2018-04-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/28/AudioQueue学习笔记和实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/28/AudioQueue学习笔记和实战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioQueue理论学习"><a href="#AudioQueue理论学习" class="headerlink" title="AudioQueue理论学习"></a>AudioQueue理论学习</h3><p>AudioQueue是iOS提供的又一套实现音频播放和录制的框架，怎么说呢，使用起来其实也不比AduioUnit方便很多，特别是在buffer的管理上，新手理解起来还是有点费劲的，在被她折磨了一周后，现在终于把她征服了，这里做一下总结。</p>
<p>首先看一下官方给的AudioQueue工作流程图</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audioqueue.png" alt=""></p>
<p>这里给出的是播放本地路径下的音频文件，流程总结如下：</p>
<ol>
<li>读取音频文件，在音频文件的回调中给buffers填充数据</li>
<li>将填充满的buffers给AudioQueue播放</li>
<li>AudioQueue播放完一个Buffer后,把这个buffer还给AudioQueue的回调继续填充</li>
<li>循环2和3直到音频播放完</li>
</ol>
<h4 id="主要的api"><a href="#主要的api" class="headerlink" title="主要的api:"></a>主要的api:</h4><h5 id="AudioQueueNewOutput"><a href="#AudioQueueNewOutput" class="headerlink" title="AudioQueueNewOutput"></a>AudioQueueNewOutput</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueNewOutput(const AudioStreamBasicDescription *inFormat, AudioQueueOutputCallback inCallbackProc, void *inUserData, CFRunLoopRef inCallbackRunLoop, CFStringRef inCallbackRunLoopMode, UInt32 inFlags, AudioQueueRef  _Nullable *outAQ);</div></pre></td></tr></table></figure>
<p>该方法用于创建一个用于输出音频的AudioQueue</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inFormat：该參数指明了即将播放的音频的数据格式 </li>
<li>inCallbackProc：该回调用于当AudioQueue已使用完一个缓冲区时通知用户，用户能够继续填充音频数据 </li>
<li>inUserData：由用户传入的数据指针，用于传递给回调函数 </li>
<li>inCallbackRunLoop：指明回调事件发生在哪个RunLoop之中，假设传递NULL，表示在AudioQueue所在的线程上运行该回调事件，普通情况下，传递NULL就可以。 </li>
<li>inCallbackRunLoopMode：指明回调事件发生的RunLoop的模式，传递NULL相当于kCFRunLoopCommonModes，通常情况下传递NULL就可以 </li>
<li>outAQ：该AudioQueue的引用实例，</li>
</ol>
<h5 id="AudioQueueOutput-Callback"><a href="#AudioQueueOutput-Callback" class="headerlink" title="AudioQueueOutput_Callback"></a>AudioQueueOutput_Callback</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void AudioQueueOutput_Callback(void *inClientData,AudioQueueRef inAQ,AudioQueueBufferRef inBuffer)</div></pre></td></tr></table></figure>
<p>这个是AudioQueue的回调函数，会将已经播放完的buffer还回来。</p>
<h5 id="AudioQueueAllocateBuffer"><a href="#AudioQueueAllocateBuffer" class="headerlink" title="AudioQueueAllocateBuffer"></a>AudioQueueAllocateBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueAllocateBuffer(AudioQueueRef inAQ, UInt32 inBufferByteSize, AudioQueueBufferRef  _Nullable *outBuffer);</div></pre></td></tr></table></figure>
<p>该方法的作用是为存放音频数据的缓冲区开辟空间</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inAQ：AudioQueue的引用实例 </li>
<li>inBufferByteSize：须要开辟的缓冲区的大小 </li>
<li>outBuffer：开辟的缓冲区的引用实例</li>
</ol>
<h5 id="AudioQueueEnqueueBuffer"><a href="#AudioQueueEnqueueBuffer" class="headerlink" title="AudioQueueEnqueueBuffer"></a>AudioQueueEnqueueBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueEnqueueBuffer(AudioQueueRef inAQ, AudioQueueBufferRef inBuffer, UInt32 inNumPacketDescs, const AudioStreamPacketDescription *inPacketDescs);</div></pre></td></tr></table></figure>
<p>该方法用于将已经填充数据的AudioQueueBuffer入队到AudioQueue</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inAQ：AudioQueue的引用实例 </li>
<li>inBuffer：须要入队的缓冲区实例 </li>
<li>inNumPacketDescs：缓冲区中共存在有多少帧音频数据 </li>
<li>inPacketDescs：缓冲区中每一帧的相关信息。用户须要指明当中每一帧在缓冲区中数据的偏移值，通过字段mStartOffset来指定</li>
</ol>
<h5 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueStart(AudioQueueRef inAQ, const AudioTimeStamp *inStartTime);</div><div class="line">OSStatus AudioQueuePause(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueStop(AudioQueueRef inAQ, Boolean inImmediate);</div><div class="line">OSStatus AudioQueueFlush(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueReset(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueDispose(AudioQueueRef inAQ, Boolean inImmediate);</div></pre></td></tr></table></figure>
<h4 id="AudioFileStream"><a href="#AudioFileStream" class="headerlink" title="AudioFileStream"></a>AudioFileStream</h4><p>数据的相关内容都和它相关，所以还是很重要的，其实AudioQueue使用起来比较简单，复杂的部分都在这个数据的处理上了。。。</p>
<h5 id="AudioFileStreamOpen"><a href="#AudioFileStreamOpen" class="headerlink" title="AudioFileStreamOpen"></a>AudioFileStreamOpen</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//        AudioFileStreamOpen的参数说明如下：</div><div class="line">//        1. inClientData：用户指定的数据，用于传递给回调函数，这里我们指定(__bridge LocalAudioPlayer*)self</div><div class="line">//        2. inPropertyListenerProc：当解析到一个音频信息时，将回调该方法</div><div class="line">//        3. inPacketsProc：当解析到一个音频帧时，将回调该方法</div><div class="line">//        4. inFileTypeHint：指明音频数据的格式，如果你不知道音频数据的格式，可以传0</div><div class="line">//        5. outAudioFileStream：AudioFileStreamID实例，需保存供后续使用</div><div class="line"></div><div class="line">AudioFileStreamOpen (		void * __nullable						inClientData,</div><div class="line">							AudioFileStream_PropertyListenerProc	inPropertyListenerProc,</div><div class="line">							AudioFileStream_PacketsProc				inPacketsProc,</div><div class="line">                			AudioFileTypeID							inFileTypeHint,</div><div class="line">                			AudioFileStreamID __nullable * __nonnull outAudioFileStream)</div></pre></td></tr></table></figure>
<p>这个函数会创建一个AudioFileStreamID,之后所有的操作都是基于这个ID来的，然后还是创建2个回调 inPropertyListenerProc 和 inPacketsProc，这2个回调函数比较重要，下面详说。</p>
<h5 id="AudioFileStreamParseBytes"><a href="#AudioFileStreamParseBytes" class="headerlink" title="AudioFileStreamParseBytes"></a>AudioFileStreamParseBytes</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//        参数的说明如下：</div><div class="line">//        1. inAudioFileStream：AudioFileStreamID实例，由AudioFileStreamOpen打开</div><div class="line">//        2. inDataByteSize：此次解析的数据字节大小</div><div class="line">//        3. inData：此次解析的数据大小</div><div class="line">//        4. inFlags：数据解析标志，其中只有一个值kAudioFileStreamParseFlag_Discontinuity = 1，表示解析的数据是否是不连续的，目前我们可以传0。</div><div class="line"></div><div class="line"></div><div class="line">AudioFileStreamParseBytes(	</div><div class="line">								AudioFileStreamID				inAudioFileStream,</div><div class="line">								UInt32							inDataByteSize,</div><div class="line">								const void * __nullable			inData,</div><div class="line">								AudioFileStreamParseFlags		inFlags)</div></pre></td></tr></table></figure>
<p>只有对数据进行了解析，才会进到上面的2个回调函数里面。</p>
<h5 id="AudioFileStreamPropertyListenerProc"><a href="#AudioFileStreamPropertyListenerProc" class="headerlink" title="AudioFileStreamPropertyListenerProc"></a>AudioFileStreamPropertyListenerProc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void AudioFileStreamPropertyListenerProc(void *inClientData,</div><div class="line">                                         AudioFileStreamID inAudioFileStream,</div><div class="line">                                         AudioFileStreamPropertyID inPropertyID,</div><div class="line">                                         UInt32 *ioFlags)</div></pre></td></tr></table></figure>
<p>在这个回调中，你可以拿到你想要的音频相关信息，比如音频结构（AudioStreamBasicDescription），码率（BitRate），MagicCookie等等，通过这些信息，你还可以计算其他数据，比如音频总时长。</p>
<p>这里分享下音频时长的2种计算方式：</p>
<ul>
<li><p>总时长 = 总帧数*单帧的时长</p>
<p>  单帧的时长 = 单帧的采样个数*每帧的时长</p>
<p>  每帧的时长 = 1/采样率</p>
</li>
</ul>
<p><strong>采样率：单位时间内的采样个数</strong></p>
<ul>
<li>总时长 = 文件总的字节数/码率</li>
</ul>
<p><strong>码率：单位时间内的文件字节数</strong></p>
<h5 id="AudioFileStreamPacketsProc"><a href="#AudioFileStreamPacketsProc" class="headerlink" title="AudioFileStreamPacketsProc"></a>AudioFileStreamPacketsProc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void AudioFileStreamPacketsProc(void *inClientData,</div><div class="line">                                UInt32 inNumberBytes,</div><div class="line">                                UInt32 inNumberPackets,</div><div class="line">                                const void *inInputData,</div><div class="line">                                AudioStreamPacketDescription *inPacketDescriptions)</div></pre></td></tr></table></figure>
<p>在这个回调中，你能够拿到每一个packet的数据，然后数据的填充都在这里完成。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>这里只讲几个比较重要的细节，其他的可以参考demo中的代码。</p>
<ol>
<li>AudioQueueNewOutput在创建的时候有2个runloop相关的参数，这里直接传NULL就行，不要取当前的runloop和model</li>
<li>AudioQueueOutput_Callback里面在标记可使用的buffer时要加锁，不然音频无法正常播放</li>
<li>记得设置AVAudioSession的category</li>
<li>读取音频数据时使用while循环，比使用计时器优雅</li>
<li>kAudioFileStreamProperty_DataFormat这个属性是必须要获取到的，在创建AudioQueue的时候需要传入</li>
<li>填装数据的时候要判断对当前buffer的可用填装空间，如果装不下了就别再装啦。。。</li>
<li>AudioQueueEnqueueBuffer给AudioQueue塞完数据后，需要判断下一个buffer是否可用，不可用的话得一直等着，知道可用为止。</li>
</ol>
<p><a href="https://github.com/lilingyu0620/LLYAudioUnitPlayer.git" target="_blank" rel="noopener">demo</a></p>
<p><a href="http://www.cnblogs.com/llguanli/p/8453133.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/16/AudioUnit实战/" itemprop="url">
                  AudioUnit实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-16T14:33:25+08:00" content="2018-04-16">
              2018-04-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/16/AudioUnit实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/16/AudioUnit实战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面学习了AudioUnit相关理论姿势，现在结合实际demo继续深入学习一下。。。</p>
<h3 id="AudioUnit–播放本地音频"><a href="#AudioUnit–播放本地音频" class="headerlink" title="AudioUnit–播放本地音频"></a>AudioUnit–播放本地音频</h3><p>因为AudioUnit只支持PCM文件，所以这里我们先使用一个本地的PCM文件进行播放，后续会有播放其他格式文件的demo,需要用到转码的相关API。</p>
<p>这里我们使用<strong>NSInputStream</strong>直接读取音频文件，因为不需要转码，所以读取到的数据就是可以直接拿来播放的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSInputStream *inputStream;</div><div class="line"> 	NSURL *url = [NSURL fileURLWithPath:self.pcmPath];</div><div class="line">   inputStream = [NSInputStream inputStreamWithURL:url];</div><div class="line">   if (!inputStream) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败!!!!%@&quot;,url);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">       [inputStream open];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>初始化AudioUnit相关内容前，我们需要全局设置一下<strong>AVAudioSession</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//设置audiosession</div><div class="line"></div><div class="line">   NSError *error = nil;   </div><div class="line">   AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;error];</div></pre></td></tr></table></figure>
<p>然后可以开始初始化AudioUnit，这里我们需要的是Output type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   AudioUnit playerAudioUnit;</div><div class="line"></div><div class="line">//AU描述</div><div class="line">   AudioComponentDescription audioUnitDesc;</div><div class="line">   audioUnitDesc.componentType = kAudioUnitType_Output;</div><div class="line">   audioUnitDesc.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">   audioUnitDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">   audioUnitDesc.componentFlags = 0;</div><div class="line">   audioUnitDesc.componentFlagsMask = 0;</div><div class="line">   </div><div class="line">   //AudioUnit裸创建</div><div class="line">   AudioComponent audioComponent = AudioComponentFindNext(NULL, &amp;audioUnitDesc);</div><div class="line">   AudioComponentInstanceNew(audioComponent, &amp;playerAudioUnit);</div></pre></td></tr></table></figure>
<p>接下来有一个<strong>kAudioOutputUnitProperty_EnableIO</strong>属性的设置，这里如果只是播放功能的话，实际上是不需要设置的，因为AudioUnit默认就是支持播放的，如果需要输入功能（比如录音）时，就必须设置这个属性，之后的demo会有使用，这里我们先不设置这个属性，设置的相关格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//通用参数设置,这里是设置扬声器</div><div class="line">  OSStatus status = noErr;</div><div class="line">  UInt32 flag = 1;</div><div class="line">  UInt32 outputBus = 0;//Element 0</div><div class="line">  status = AudioUnitSetProperty(playerAudioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, outputBus, &amp;flag, sizeof(flag));</div><div class="line">  if (status) &#123;</div><div class="line">      NSLog(@&quot;AudioUnitSetProperty error with status:%d&quot;, status);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后我们需要设置AudioUnit的播放音频的格式，这里一般都是PCM格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//设置音频具体结构</div><div class="line">   AudioStreamBasicDescription audioStreamDesc;</div><div class="line">//    bzero(&amp;audioStreamDesc, sizeof(audioStreamDesc));</div><div class="line">   memset(&amp;audioStreamDesc, 0, sizeof(audioStreamDesc));</div><div class="line">   audioStreamDesc.mFormatID = kAudioFormatLinearPCM;</div><div class="line">   audioStreamDesc.mSampleRate = 44100;//采样率</div><div class="line">   audioStreamDesc.mChannelsPerFrame = 1;//声道数</div><div class="line">   audioStreamDesc.mFramesPerPacket = 1;//每帧只有一个packet</div><div class="line">   audioStreamDesc.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger;//kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;</div><div class="line">   audioStreamDesc.mBitsPerChannel = 16;//位深</div><div class="line">   audioStreamDesc.mBytesPerFrame = 2;</div><div class="line">   audioStreamDesc.mBytesPerPacket = 2;</div><div class="line"></div><div class="line">//这里是设置的输出音频的格式</div><div class="line">   status = AudioUnitSetProperty(playerAudioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, outputBus, &amp;audioStreamDesc,sizeof(audioStreamDesc));</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;AudioUnitSetProperty error with status:%d&quot;, status);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>最后设置一下输出的回调，这个回调是每次扬声器需要播放数据时都会调一次这个回调，然后我们在这个回调里面把要播放的数据塞给扬声器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">	//callback</div><div class="line">    AURenderCallbackStruct callbackStruct;</div><div class="line">    callbackStruct.inputProc = PlayCallback;</div><div class="line">    callbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">    AudioUnitSetProperty(playerAudioUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, outputBus, &amp;callbackStruct, sizeof(callbackStruct));</div><div class="line"></div><div class="line">	//最后初始化AudioUnit</div><div class="line">    OSStatus result = AudioUnitInitialize(playerAudioUnit);</div><div class="line">    NSLog(@&quot;result = %d&quot;,result);</div><div class="line">    </div><div class="line">    //回调实现</div><div class="line">    static OSStatus PlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line"></div><div class="line">    __unsafe_unretained LLYAudioUnitPlayer *play = (__bridge LLYAudioUnitPlayer *)inRefCon;</div><div class="line"></div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;out size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line"></div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就可以开始播放音频了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)play&#123;</div><div class="line">    </div><div class="line">    [self initAudioUnit];</div><div class="line">    </div><div class="line">    AudioOutputUnitStart(playerAudioUnit);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stop&#123;</div><div class="line">    </div><div class="line">    AudioOutputUnitStop(playerAudioUnit);</div><div class="line">    [inputStream close];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AudioUnit–录音-播放-保存本地"><a href="#AudioUnit–录音-播放-保存本地" class="headerlink" title="AudioUnit–录音+播放+保存本地"></a>AudioUnit–录音+播放+保存本地</h3><p>这个demo做的事情是把本地播放的音频和录制的音频一起输出并写入文件。播放音频部分和上面的流程一样，这里主要说一下录制音频部分的流程。</p>
<p>AVAudioSession的设置，这里我们需要用到录音功能，同时我们还需要设置一下采样频率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//设置AVAudioSession</div><div class="line">   [[AVAudioSession sharedInstance]setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;error];</div><div class="line">   if (error) &#123;</div><div class="line">       NSLog(@&quot;setCategory error %@&quot;,error);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   [[AVAudioSession sharedInstance] setPreferredIOBufferDuration:0.05 error:&amp;error];</div><div class="line">   if (error) &#123;</div><div class="line">       NSLog(@&quot;setPreferredIOBufferDuration error:%@&quot;, error);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们使用AudioBufferList 这个数据结构来保存获取到的录音音频数据，先对该数据结构做一个初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">AudioBufferList *bufferList;</div><div class="line"></div><div class="line">// buffer list</div><div class="line">uint32_t numberBuffers = 2;</div><div class="line">bufferList = (AudioBufferList *)malloc(sizeof(AudioBufferList) + (numberBuffers - 1) * sizeof(AudioBuffer));</div><div class="line">bufferList-&gt;mNumberBuffers = numberBuffers;</div><div class="line">bufferList-&gt;mBuffers[0].mNumberChannels = 1;</div><div class="line">bufferList-&gt;mBuffers[0].mDataByteSize = BUFFERSIZE;</div><div class="line">bufferList-&gt;mBuffers[0].mData = malloc(BUFFERSIZE);</div><div class="line"></div><div class="line">for (int i =1; i &lt; numberBuffers; ++i) &#123;</div><div class="line">    bufferList-&gt;mBuffers[i].mNumberChannels = 1;</div><div class="line">    bufferList-&gt;mBuffers[i].mDataByteSize = BUFFERSIZE;</div><div class="line">    bufferList-&gt;mBuffers[i].mData = malloc(BUFFERSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着上个demo的代码，这里我们再设置一下输入的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AudioStreamBasicDescription outputFormat = inputFormat;</div><div class="line">   outputFormat.mChannelsPerFrame = 2;</div><div class="line">   status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                 kAudioUnitProperty_StreamFormat,</div><div class="line">                                 kAudioUnitScope_Input,</div><div class="line">                                 OUTPUT_BUS,</div><div class="line">                                 &amp;outputFormat,</div><div class="line">                                 sizeof(outputFormat));</div><div class="line">   </div><div class="line">   if (status != noErr) &#123;</div><div class="line">       NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后我们需要设置AudioUnit的输入能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// enable record</div><div class="line">  UInt32 flag = 1;</div><div class="line">  status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                kAudioOutputUnitProperty_EnableIO,</div><div class="line">                                kAudioUnitScope_Input,</div><div class="line">                                INPUT_BUS,</div><div class="line">                                &amp;flag,</div><div class="line">                                sizeof(flag));</div><div class="line">  if (status != noErr) &#123;</div><div class="line">      NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>之后设置一下录音的回调，在回调中获取录音的音频数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    // set callback</div><div class="line">    AURenderCallbackStruct recordCallback;</div><div class="line">    recordCallback.inputProc = RecordCallback;</div><div class="line">    recordCallback.inputProcRefCon = (__bridge void *)self;</div><div class="line">    status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                  kAudioOutputUnitProperty_SetInputCallback,</div><div class="line">                                  kAudioUnitScope_Output,</div><div class="line">                                  INPUT_BUS,</div><div class="line">                                  &amp;recordCallback,</div><div class="line">                                  sizeof(recordCallback));</div><div class="line">    if (status != noErr) &#123;</div><div class="line">        NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    #pragma mark - callback</div><div class="line">    </div><div class="line">static OSStatus RecordCallback(void *inRefCon,</div><div class="line">                               AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                               const AudioTimeStamp *inTimeStamp,</div><div class="line">                               UInt32 inBusNumber,</div><div class="line">                               UInt32 inNumberFrames,</div><div class="line">                               AudioBufferList *ioData)</div><div class="line">&#123;</div><div class="line">    LLYAudioUnitRecord *record = (__bridge LLYAudioUnitRecord *)inRefCon;</div><div class="line">    record-&gt;bufferList-&gt;mNumberBuffers = 1;</div><div class="line">    OSStatus status = AudioUnitRender(record-&gt;recordAudioUnit, ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, record-&gt;bufferList);</div><div class="line">    if (status != noErr) &#123;</div><div class="line">        NSLog(@&quot;AudioUnitRender error:%d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;size1 = %d&quot;, record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    [record writePCMData:record-&gt;bufferList-&gt;mBuffers[0].mData size:record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们把录音的音频数据保存在了bufferList中。这个bufferList中的数据将被手动塞给播放的回调进行播放，播放（输出）的回调代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static OSStatus OutPlayCallback(void *inRefCon,</div><div class="line">                             AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                             const AudioTimeStamp *inTimeStamp,</div><div class="line">                             UInt32 inBusNumber,</div><div class="line">                             UInt32 inNumberFrames,</div><div class="line">                             AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitRecord *record = (__bridge LLYAudioUnitRecord *)inRefCon;</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, record-&gt;bufferList-&gt;mBuffers[0].mData, record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    NSInteger bytes = BUFFERSIZE &lt; ioData-&gt;mBuffers[1].mDataByteSize * 2 ? BUFFERSIZE : ioData-&gt;mBuffers[1].mDataByteSize * 2; //</div><div class="line">    bytes = [record-&gt;inputStream read:record-&gt;buffer maxLength:bytes];</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt; bytes; ++i) &#123;</div><div class="line">        ((Byte*)ioData-&gt;mBuffers[1].mData)[i/2] = record-&gt;buffer[i];</div><div class="line">    &#125;</div><div class="line">    ioData-&gt;mBuffers[1].mDataByteSize = (UInt32)bytes / 2;</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[1].mDataByteSize &lt; ioData-&gt;mBuffers[0].mDataByteSize) &#123;</div><div class="line">        ioData-&gt;mBuffers[0].mDataByteSize = ioData-&gt;mBuffers[1].mDataByteSize;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    NSLog(@&quot;size2 = %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们给ioData-&gt;mBuffers塞了2组数据，一组是从bufferList中获取的录音音频数据，另外一组是从inputStream中读取的本地音频数据，所以播放时既能听到本地音频也能听到我们录音的音频。</p>
<p>将音频写入文件的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)writePCMData:(Byte *)buffer size:(int)size &#123;</div><div class="line">    static FILE *file = NULL;</div><div class="line">    NSString *pathStr = [LLYAudioUnitRecord recordPath];</div><div class="line">    if (!file) &#123;</div><div class="line">        file = fopen(pathStr.UTF8String, &quot;w&quot;);</div><div class="line">    &#125;</div><div class="line">    fwrite(buffer, size, 1, file);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSString *)recordPath&#123;</div><div class="line">    return [CommonUtil documentsPath:@&quot;/record.pcm&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AudioUnit–播放MP3"><a href="#AudioUnit–播放MP3" class="headerlink" title="AudioUnit–播放MP3"></a>AudioUnit–播放MP3</h3><p>上面说过，AudioUnit是不支持直接播放MP3文件格式的，所以这里我们先把MP3转码为pcm格式然后再塞给播放回调去播放。</p>
<p>播放的逻辑我们已经很清楚了，这里我主要说一下怎么转码。这里我们用到了<strong>AudioFile</strong>和<strong>AudioConverter</strong>两个类，AudioFile主要做音频相关信息的读取，AudioConverter主要做转码的工作。</p>
<p>先来看一下AudioFile的相关代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">   AudioFileID audioFileID;</div><div class="line">   AudioStreamBasicDescription audioFileFormat;</div><div class="line">   AudioStreamPacketDescription *audioPacketFormat;</div><div class="line">   </div><div class="line">SInt64 readedPacket;</div><div class="line">   UInt64 packetNums;</div><div class="line">   UInt64 packetNumsInBuffer;</div><div class="line">   </div><div class="line">   //获取源音频的ID</div><div class="line">   NSString *mp3Path = [CommonUtil bundlePath:@&quot;abc.mp3&quot;];</div><div class="line">   NSURL *mp3Url = [NSURL fileURLWithPath:mp3Path];</div><div class="line">   OSStatus status = AudioFileOpenURL((__bridge CFURLRef)mp3Url, kAudioFileReadPermission, 0, &amp;audioFileID);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败 %@&quot;, mp3Url);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频的FileFormat</div><div class="line">   uint32_t size = sizeof(AudioStreamBasicDescription);</div><div class="line">   status = AudioFileGetProperty(audioFileID, kAudioFilePropertyDataFormat, &amp;size, &amp;audioFileFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取fileformat失败 error status %d&quot;, status);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   //获取源音频的packetnum</div><div class="line">   size = sizeof(packetNums);</div><div class="line">   status = AudioFileGetProperty(audioFileID, kAudioFilePropertyAudioDataPacketCount, &amp;size, &amp;packetNums);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取packetnum失败 error status %d&quot;, status);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频单个packet的最大buffer数</div><div class="line">   uint32_t sizePerPacket = audioFileFormat.mFramesPerPacket;</div><div class="line">   if (sizePerPacket == 0) &#123;</div><div class="line">       size = sizeof(sizePerPacket);</div><div class="line">       status = AudioFileGetProperty(audioFileID, kAudioFilePropertyMaximumPacketSize, &amp;size, &amp;sizePerPacket);</div><div class="line">       if (status) &#123;</div><div class="line">           NSLog(@&quot;获取packetmaxnum失败 error status %d&quot;, status);</div><div class="line">           return ;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频的packetformat</div><div class="line">   audioPacketFormat = malloc(sizeof(AudioStreamPacketDescription) * (CONST_BUFFER_SIZE/sizePerPacket + 1));</div></pre></td></tr></table></figure>
<p>这里说一下packetnum这个属性，因为音频数据流都是以一个个packet的格式封装起来的，所以这个获取的packetnum实际上就是音频的总长度，而每个packet里面又以帧（frame）为单位做了一层封装，每个packet里面的帧数不固定。每一帧就是实际的音频数据了。</p>
<p>因为数据的处理都在播放回调中，我们来看看AudioConverter都做了哪些工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">	//上面拿到了音频的数据格式，这里用来做AudioConverter的初始化</div><div class="line">	//初始化audioconverter</div><div class="line">    status = AudioConverterNew(&amp;audioFileFormat, &amp;outputFormat, &amp;audioConverter);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;AudioConverterNew eror with status:%d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">	OSStatus ConPlayCallback(void *inRefCon,</div><div class="line">                      AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                      const AudioTimeStamp *inTimeStamp,</div><div class="line">                      UInt32 inBusNumber,</div><div class="line">                      UInt32 inNumberFrames,</div><div class="line">                      AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitConverter *converter = (__bridge LLYAudioUnitConverter *)inRefCon;</div><div class="line">    </div><div class="line">    converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize = CONST_BUFFER_SIZE;</div><div class="line">    OSStatus status = AudioConverterFillComplexBuffer(converter-&gt;audioConverter, InputDataProc, inRefCon, &amp;inNumberFrames, converter-&gt;bufferList, NULL);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;转换格式失败 %d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;out size: %d&quot;, converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, converter-&gt;bufferList-&gt;mBuffers[0].mData, converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    //    fwrite(player-&gt;buffList-&gt;mBuffers[0].mData, player-&gt;buffList-&gt;mBuffers[0].mDataByteSize, 1, [player pcmFile]);</div><div class="line">    </div><div class="line">    if (converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [converter onPlayEnd];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，是调用了<strong>AudioConverterFillComplexBuffer</strong>这个方法做的转码，其中第二个参数又是一个回调函数，转码后的数据同样是保存在converter-&gt;bufferList这个结构里面，然后在后面塞给ioData-&gt;mBuffers去播放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">OSStatus InputDataProc(AudioConverterRef inAudioConverter, UInt32 *ioNumberDataPackets, AudioBufferList *ioData, AudioStreamPacketDescription **outDataPacketDescription, void *inUserData)</div><div class="line">&#123;</div><div class="line">    LLYAudioUnitConverter *player = (__bridge LLYAudioUnitConverter *)(inUserData);</div><div class="line">    </div><div class="line">    UInt32 byteSize = CONST_BUFFER_SIZE;</div><div class="line">    OSStatus status = AudioFileReadPacketData(player-&gt;audioFileID, NO, &amp;byteSize, player-&gt;audioPacketFormat, player-&gt;readedPacket, ioNumberDataPackets, player-&gt;convertBuffer);</div><div class="line">    </div><div class="line">    if (outDataPacketDescription) &#123; // 这里要设置好packetFormat，否则会转码失败</div><div class="line">        *outDataPacketDescription = player-&gt;audioPacketFormat;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if(status) &#123;</div><div class="line">        NSLog(@&quot;读取文件失败&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!status &amp;&amp; ioNumberDataPackets &gt; 0) &#123;</div><div class="line">        ioData-&gt;mBuffers[0].mDataByteSize = byteSize;</div><div class="line">        ioData-&gt;mBuffers[0].mData = player-&gt;convertBuffer;</div><div class="line">        player-&gt;readedPacket += *ioNumberDataPackets;</div><div class="line">        return noErr;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return NO_MORE_DATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个回调函数主要负责读取mp3文件给上面的AudioConverterFillComplexBuffer函数用来做转码处理。</p>
<h3 id="AudioUnit–更简单的播放MP3"><a href="#AudioUnit–更简单的播放MP3" class="headerlink" title="AudioUnit–更简单的播放MP3"></a>AudioUnit–更简单的播放MP3</h3><p>上一个demo中我们使用AudioUnit播放了一个MP3文件，用到了AudioFile和AudioConverter类的相关方法，可以看到，使用这种方式播放MP3文件是比较繁琐的，我们要获取音频的很多信息，要设置回调，要使用一系列的相关api。。。下面介绍一种更简单的播放MP3的方式，使用<strong>ExtAudioFile</strong>，看名字就知道，它是上面介绍的AudioFile的扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//ExtAudioFileRef对象</div><div class="line"></div><div class="line"> ExtAudioFileRef extAudioFile;</div><div class="line">   AudioStreamBasicDescription audioFileFormat;</div><div class="line">   AudioStreamBasicDescription outputFormat;</div><div class="line">   </div><div class="line">    OSStatus status = noErr;</div><div class="line">   NSURL *mp3Url = [NSURL fileURLWithPath:[CommonUtil bundlePath:@&quot;/abc.mp3&quot;]];</div><div class="line">   status = ExtAudioFileOpenURL((__bridge CFURLRef)mp3Url, &amp;extAudioFile);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取MP3音频的格式（非必需）</div><div class="line">   uint32_t size = sizeof(AudioStreamBasicDescription);</div><div class="line">   status = ExtAudioFileGetProperty(extAudioFile, kExtAudioFileProperty_FileDataFormat, &amp;size, &amp;audioFileFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;读取音频格式失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    //initFormat 设置输出格式</div><div class="line">   memset(&amp;outputFormat, 0, sizeof(outputFormat));</div><div class="line">   outputFormat.mSampleRate       = 44100;</div><div class="line">   outputFormat.mFormatID         = kAudioFormatLinearPCM;</div><div class="line">   outputFormat.mFormatFlags      = kLinearPCMFormatFlagIsSignedInteger;</div><div class="line">   outputFormat.mBytesPerPacket   = 2;</div><div class="line">   outputFormat.mFramesPerPacket  = 1;</div><div class="line">   outputFormat.mBytesPerFrame    = 2;</div><div class="line">   outputFormat.mChannelsPerFrame = 1;</div><div class="line">   outputFormat.mBitsPerChannel   = 16;</div><div class="line">    status = ExtAudioFileSetProperty(extAudioFile, kExtAudioFileProperty_ClientDataFormat, size, &amp;outputFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;设置转码音频格式失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取总长度（非必需）</div><div class="line">    size = sizeof(totalFrame);</div><div class="line">   status = ExtAudioFileGetProperty(extAudioFile, kExtAudioFileProperty_FileLengthFrames, &amp;size, &amp;totalFrame);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取音频总长度失败&quot;);</div><div class="line">   &#125;</div><div class="line">   NSLog(@&quot;音频总长度：%llu&quot;,totalFrame);</div></pre></td></tr></table></figure>
<p>AudioUnit相关的代码参考上面的几个demo. 这个必需的操作就是open file，获取到extAudioFile。然后我们看看回调里面做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">OSStatus ExtPlayCallback(void *inRefCon,</div><div class="line">                      AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                      const AudioTimeStamp *inTimeStamp,</div><div class="line">                      UInt32 inBusNumber,</div><div class="line">                      UInt32 inNumberFrames,</div><div class="line">                      AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitExtPlayer *player = (__bridge LLYAudioUnitExtPlayer *)inRefCon;</div><div class="line">    player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize = BUFFER_SIZE_CONST;</div><div class="line">    OSStatus status = ExtAudioFileRead(player-&gt;extAudioFile, &amp;inNumberFrames, player-&gt;bufferList);</div><div class="line">    NSLog(@&quot;inNumberFrames = %d&quot;,inNumberFrames);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;转码失败&quot;);</div><div class="line">    &#125;</div><div class="line">    if (!inNumberFrames) &#123;</div><div class="line">        NSLog(@&quot;播放结束&quot;);</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;out size : %d&quot;,player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, player-&gt;bufferList-&gt;mBuffers[0].mData, player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    player-&gt;readedFrame += player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize / player-&gt;outputFormat.mBytesPerFrame;</div><div class="line">    </div><div class="line">    NSLog(@&quot;readedFrame = %d&quot;,player-&gt;readedFrame);</div><div class="line">    </div><div class="line">    if (player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [player onPlayEnd];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只调用了一个<strong>ExtAudioFileRead</strong>方法，就把MP3文件转成了pcm文件存到了player-&gt;bufferList中，最终塞给ioData-&gt;mBuffers去播放即可。是不是比上面demo要简单很多呢。</p>
<h3 id="AudioUnit–使用AUGraph播放伴奏-录音"><a href="#AudioUnit–使用AUGraph播放伴奏-录音" class="headerlink" title="AudioUnit–使用AUGraph播放伴奏+录音"></a>AudioUnit–使用AUGraph播放伴奏+录音</h3><p>前面都是直接使用AudioUnit实现播放，录音相关工作，这一小节我们来学习一下使用AUGraph管理AudioUnit，当你需要多个AudioUnit来实现不同的模块，且各模块的输入输出直接又有相关联时，使用AUGraph是比较好的选择，因为它可以为AudioUnit之间建立连接，直接进行数据传递，省去了我们手动传递数据的麻烦。</p>
<p>这里我是分了三步来实现整个功能的：</p>
<ul>
<li>1.先播放本地音频</li>
<li>2.加入录音功能</li>
<li>3.将录音音频和本地音频送给mix,mix的输出绑定到io的输出</li>
</ul>
<p>首先来看第一步，使用AUGraph播放本地音频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">//相关变量</div><div class="line"></div><div class="line">   AUGraph playerGraph;</div><div class="line">   </div><div class="line">   //io相关</div><div class="line">   AUNode ioNode;</div><div class="line">   AudioUnit ioUnit;</div><div class="line">   </div><div class="line">   AudioStreamBasicDescription audioFormat;</div><div class="line">   </div><div class="line">   NSInputStream *inputStream;</div><div class="line"></div><div class="line"></div><div class="line">//init</div><div class="line"></div><div class="line">    </div><div class="line">   NSURL *url = [NSURL fileURLWithPath:[CommonUtil bundlePath:@&quot;/abc.pcm&quot;]];</div><div class="line">   inputStream = [NSInputStream inputStreamWithURL:url];</div><div class="line">   if (!inputStream) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败!!!!%@&quot;,url);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">       [inputStream open];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayback error:nil]; // 只有播放</div><div class="line"></div><div class="line">OSStatus status = noErr;</div><div class="line">   status = NewAUGraph(&amp;playerGraph);</div><div class="line">   CheckStatus(status, @&quot;创建AUGraph失败&quot;, YES);</div><div class="line">   </div><div class="line">   AudioComponentDescription outputAudioDesc;</div><div class="line">   outputAudioDesc.componentType = kAudioUnitType_Output;</div><div class="line">   outputAudioDesc.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">   outputAudioDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">   outputAudioDesc.componentFlags = 0;</div><div class="line">   outputAudioDesc.componentFlagsMask = 0;</div><div class="line">   </div><div class="line">   status = AUGraphAddNode(playerGraph, &amp;outputAudioDesc, &amp;ioNode);</div><div class="line">   CheckStatus(status, @&quot;绑定node失败&quot;, YES);</div><div class="line">   </div><div class="line">   status = AUGraphOpen(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;打开AUGraph失败&quot;, YES);</div><div class="line">   </div><div class="line">   status = AUGraphNodeInfo(playerGraph, ioNode, NULL, &amp;ioUnit);</div><div class="line">   CheckStatus(status, @&quot;创建AudioUnit失败&quot;, YES);</div><div class="line"></div><div class="line">   // audio format</div><div class="line">   audioFormat.mSampleRate = 44100;</div><div class="line">   audioFormat.mFormatID = kAudioFormatLinearPCM;</div><div class="line">   audioFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsNonInterleaved;</div><div class="line">   audioFormat.mFramesPerPacket = 1;</div><div class="line">   audioFormat.mChannelsPerFrame = 1;</div><div class="line">   audioFormat.mBytesPerPacket = 2;</div><div class="line">   audioFormat.mBytesPerFrame = 2;</div><div class="line">   audioFormat.mBitsPerChannel = 16;</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">   CheckStatus(status, @&quot;设置输入音频数据格式失败&quot;, YES);</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">   CheckStatus(status, @&quot;设置输出音频格式失败&quot;, YES);</div><div class="line"></div><div class="line">   </div><div class="line">   //callback</div><div class="line">   AURenderCallbackStruct callbackStruct;</div><div class="line">   callbackStruct.inputProc = LLYPlayCallback;</div><div class="line">   callbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">   AudioUnitSetProperty(playerUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &amp;callbackStruct, sizeof(callbackStruct));</div><div class="line">   </div><div class="line">   status  = AUGraphInitialize(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;Graph初始化失败&quot;, YES);</div><div class="line">   status = AUGraphStart(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;Graph start失败&quot;, YES);</div></pre></td></tr></table></figure>
<p>io的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	static OSStatus LLYPlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;out size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步：加入录音功能，这里其实只需要对第一步做一下修改,将io回调数据处理的bus改为输入，设置输入相关属性即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   AudioBufferList *buffList;</div><div class="line">   Byte *buffer;</div><div class="line">   </div><div class="line">   </div><div class="line">   //init</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];</div><div class="line">   [audioSession setPreferredIOBufferDuration:0.02 error:&amp;error];</div><div class="line"></div><div class="line">   </div><div class="line">   // buffer</div><div class="line">   uint32_t numberBuffers = 1;</div><div class="line">   buffList = (AudioBufferList *)malloc(sizeof(AudioBufferList));</div><div class="line">   buffList-&gt;mNumberBuffers = numberBuffers;</div><div class="line">   buffList-&gt;mBuffers[0].mNumberChannels = 1;</div><div class="line">   buffList-&gt;mBuffers[0].mDataByteSize = GRAPH_CONST_BUFFER_SIZE;</div><div class="line">   buffList-&gt;mBuffers[0].mData = malloc(GRAPH_CONST_BUFFER_SIZE);</div><div class="line">   buffer = malloc(GRAPH_CONST_BUFFER_SIZE);</div><div class="line"></div><div class="line">//设置输入格式</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(AudioStreamBasicDescription));</div><div class="line">   CheckStatus(status, @&quot;设置输出音频格式失败&quot;, YES);</div><div class="line">   </div><div class="line">   </div><div class="line">//设置输入部分的回调，实际的录音数据是在这里获取的，</div><div class="line">   AURenderCallbackStruct outputCallbackStruct;</div><div class="line">   outputCallbackStruct.inputProc = OutputPlayCallback;</div><div class="line">   outputCallbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioOutputUnitProperty_SetInputCallback, kAudioUnitScope_Output, 1, &amp;outputCallbackStruct, sizeof(outputCallbackStruct));</div><div class="line">   CheckStatus(status, @&quot;ioUnit绑定回调失败&quot;, YES);</div></pre></td></tr></table></figure>
<p>io的回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	static OSStatus OutputPlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    play-&gt;buffList-&gt;mNumberBuffers = 1;</div><div class="line">    OSStatus status = AudioUnitRender(play-&gt;ioUnit, ioActionFlag, inTimeStamp, inBusNumber, inNumberFrames, play-&gt;buffList);</div><div class="line">    CheckStatus(status, @&quot;获取录音音频失败&quot;, YES);</div><div class="line">    </div><div class="line">//    NSLog(@&quot;record size %d:&quot;,play-&gt;buffList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    //将录音写入文件</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步：获取2路音频并同时播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    //负责获取2路音频和混合</div><div class="line">    AUNode mixNode;</div><div class="line">    AudioUnit mixUnit;</div><div class="line"></div><div class="line">	 //混合相关</div><div class="line">    AudioComponentDescription mixAudioDesc;</div><div class="line">    mixAudioDesc.componentType = kAudioUnitType_Mixer;</div><div class="line">    mixAudioDesc.componentSubType = kAudioUnitSubType_MultiChannelMixer;</div><div class="line">    mixAudioDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    mixAudioDesc.componentFlags = 0;</div><div class="line">    mixAudioDesc.componentFlagsMask = 0;</div><div class="line">    </div><div class="line">    status = AUGraphAddNode(playerGraph, &amp;mixAudioDesc, &amp;mixNode);</div><div class="line">    CheckStatus(status, @&quot;绑定混合node失败&quot;, YES);</div><div class="line">    </div><div class="line">    status = AUGraphNodeInfo(playerGraph, mixNode, NULL, &amp;mixUnit);</div><div class="line">    CheckStatus(status, @&quot;创建混合AudioUnit失败&quot;, YES);</div><div class="line"></div><div class="line">    //绑定nodes，这里就是将mix的输出和io的输出绑定起来，不再需要手动设置io的输出回调了</div><div class="line">    status = AUGraphConnectNodeInput(playerGraph, mixNode, 0, ioNode, 0);</div><div class="line">    CheckStatus(status, @&quot;绑定node失败&quot;, YES);</div><div class="line"></div><div class="line">    //设置bus数</div><div class="line">    UInt32 busCount = 2;</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &amp;busCount, sizeof(busCount));</div><div class="line">    CheckStatus(status, @&quot;设置声道数失败&quot;, YES);</div><div class="line">    </div><div class="line">    //设置混合的输入格式,有多条输入</div><div class="line">    //bus0</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">    CheckStatus(status, @&quot;设置混合音频输入数据格式失败&quot;, YES);</div><div class="line">    //bus1</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 1, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">    CheckStatus(status, @&quot;设置混合音频输入数据格式失败&quot;, YES);</div><div class="line"></div><div class="line">	 //获取背景音频数据</div><div class="line">    AURenderCallbackStruct callback0;</div><div class="line">    callback0.inputProc = mixCallback0;</div><div class="line">    callback0.inputProcRefCon = (__bridge void *)self;</div><div class="line">//    status = AUGraphSetNodeInputCallback(playerGraph, mixNode, 0, &amp;callback0);</div><div class="line">    CheckStatus(AudioUnitSetProperty(mixUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &amp;callback0, sizeof(callback0)), @&quot;add mix callback fail&quot;,YES);</div><div class="line"></div><div class="line">    //获取录音数据</div><div class="line">    AURenderCallbackStruct callback1;</div><div class="line">    callback1.inputProc = mixCallback1;</div><div class="line">    callback1.inputProcRefCon = (__bridge void *)self;</div><div class="line">//    status = AUGraphSetNodeInputCallback(playerGraph, mixNode, 1, &amp;callback1);</div><div class="line">    CheckStatus(AudioUnitSetProperty(mixUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 1, &amp;callback1, sizeof(callback1)), @&quot;add mix callback fail&quot;,YES);</div></pre></td></tr></table></figure>
<p>mix的2路数据的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	//获取本地播放的音频</div><div class="line">	static OSStatus mixCallback0(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData) &#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;audio size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	//获取录音音频</div><div class="line">	static OSStatus mixCallback1(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData) &#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line"></div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, play-&gt;buffList-&gt;mBuffers[0].mData, play-&gt;buffList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = play-&gt;buffList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    NSLog(@&quot;record size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line"></div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mix的2路回调中，我们分别获取到了数据并塞给mix的输入，然后mix直接输出到io的输出bus进行播放，中间不在需要我们做额外的工作。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioUnitPlayer.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/AudioUnit学习笔记/" itemprop="url">
                  AudioUnit学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T16:15:43+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/AudioUnit学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/AudioUnit学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioUnit简介"><a href="#AudioUnit简介" class="headerlink" title="AudioUnit简介"></a>AudioUnit简介</h3><p>在iOS中，所有的上层音频技术都是基于AudioUnit和CoreMedia来实现的。<br>下图可以直观的反应出AudioUnit的层级关系。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/auidounit1-1.png" alt=""></p>
<p>对于普通的音频播放功能可能不需要直接使用AudioUnit来实现，但是如果你需要实现比较高级的功能（比如录音，混音等），就需要使用AudioUnit了。</p>
<p>根据不同的音频目的，iOS将AudioUnit共分为7类。如下图所示</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-2.png" alt=""></p>
<ul>
<li><p>effect units 这个是用在ipod类app上的，比较少使用到。</p>
</li>
<li><p>mixer units 做混音的，有2个audio unit，3D mixer比较适合用来做游戏的3d音效。multichannel mixer提供混合任意数量的单声道或立体声流,立体声输出。</p>
</li>
<li><p>i/o units  远程I/O单元是最常用的。它连接到输入和输出音频硬件和给你对传入和传出的低延迟访问音频样本值。它提供了硬件音频格式和应用程序之间的格式转换音频格式。声音处理I/O单元扩展了远程I/O单元，通过添加声学回声取消使用网络电话或者语音聊天应用程序。通用输出装置不连接到音频硬件,而是提供了一个机制来处理链的输出发送到您的应用程序。</p>
</li>
<li><p>Format Converter Unit 用来处理音频格式的转换。</p>
</li>
</ul>
<h3 id="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit"><a href="#iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit" class="headerlink" title="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit."></a>iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit.</h3><h4 id="通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit"><a href="#通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit" class="headerlink" title="通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit"></a>通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit</h4><p>在创建一个AudioUnit实例之前，需要先创建一个audiocomponent 创建方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//组件描述</div><div class="line">AudioComponentDescription ioUnitDescription;</div><div class="line">//组件类型</div><div class="line">ioUnitDescription.componentType          = kAudioUnitType_Output;</div><div class="line">//组件子类型</div><div class="line">ioUnitDescription.componentSubType       = kAudioUnitSubType_RemoteIO;</div><div class="line">//默认值</div><div class="line">ioUnitDescription.componentManufacturer  = kAudioUnitManufacturer_Apple;</div><div class="line">ioUnitDescription.componentFlags         = 0;</div><div class="line">ioUnitDescription.componentFlagsMask     = 0;</div><div class="line"></div><div class="line">AudioComponent foundIoUnitReference = AudioComponentFindNext (NULL,&amp;ioUnitDescription);</div><div class="line">AudioUnit ioUnitInstance;</div><div class="line">AudioComponentInstanceNew (</div><div class="line">    foundIoUnitReference,</div><div class="line">    &amp;ioUnitInstance</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="使用AUGraph创建AudioUnit"><a href="#使用AUGraph创建AudioUnit" class="headerlink" title="使用AUGraph创建AudioUnit"></a>使用AUGraph创建AudioUnit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">AUGraph processingGraph;</div><div class="line">NewAUGraph (&amp;processingGraph);</div><div class="line"> </div><div class="line">// Add an audio unit node to the graph, then instantiate the audio unit</div><div class="line">AUNode ioNode;</div><div class="line">AUGraphAddNode (</div><div class="line">    processingGraph,</div><div class="line">    &amp;ioUnitDescription,</div><div class="line">    &amp;ioNode</div><div class="line">);</div><div class="line">AUGraphOpen (processingGraph); // indirectly performs audio unit instantiation</div><div class="line"> </div><div class="line">// Obtain a reference to the newly-instantiated I/O unit</div><div class="line">AudioUnit ioUnit;</div><div class="line">AUGraphNodeInfo (</div><div class="line">    processingGraph,</div><div class="line">    ioNode,</div><div class="line">    NULL,</div><div class="line">    &amp;ioUnit</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="使用Scopes和Elements来指定AudioUnit"><a href="#使用Scopes和Elements来指定AudioUnit" class="headerlink" title="使用Scopes和Elements来指定AudioUnit"></a>使用Scopes和Elements来指定AudioUnit</h3><p>Scope和Elements的关系如下图所示：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-3.png" alt=""></p>
<p>对于通用的audioUnit,可以有1-2条输入输出流，输入和输出不一定相等，比如mixer,可以两个音频输入，混音合成一个音频流输出。每个element表示一个音频处理上下文(context), 也称为bus。每个element有输出和输出部分，称为scope，分别是input scope和Output scope。Global scope确定只有一个element，就是element0，有些属性只能在Global scope上设置。</p>
<p>inputbus = Element1 = 1,outputbus = Element0 = 0</p>
<h3 id="使用Property来config-AudioUnit"><a href="#使用Property来config-AudioUnit" class="headerlink" title="使用Property来config AudioUnit"></a>使用Property来config AudioUnit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UInt32 busCount = 2;</div><div class="line"> </div><div class="line">OSStatus result = AudioUnitSetProperty (</div><div class="line">    mixerUnit,</div><div class="line">    kAudioUnitProperty_ElementCount,   // the property key</div><div class="line">    kAudioUnitScope_Input,             // the scope to set the property on</div><div class="line">    0,                                 // the element to set the property on</div><div class="line">    &amp;busCount,                         // the property value</div><div class="line">    sizeof (busCount)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一个普通的播放行为可能需要设置的属性有 <em>kAudioOutputUnitProperty_EnableIO</em>，<em>kAudioUnitProperty_StreamFormat</em>，<em>kAudioUnitProperty_SetRenderCallback</em> 三个，不同行为需要设置不同的属性。</p>
<h3 id="I-O-Unit的基本特征"><a href="#I-O-Unit的基本特征" class="headerlink" title="I/O Unit的基本特征"></a>I/O Unit的基本特征</h3><p>i/o unit是最常见的一种AudioUnit</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-4.png" alt=""></p>
<p>对于remote_IO类型audioUnit，即从硬件采集和输出到硬件的audioUnit,它的逻辑是固定的：固定2个element,麦克风经过element1到APP，APP经element0到扬声器。</p>
<p>我们能把控的是中间的“APP内处理”部分，结合上图，淡黄色的部分就是APP可控的，Element1这个组件负责链接麦克风和APP，它的输入部分是系统控制，输出部分是APP控制；Element0负责连接APP和扬声器，输入部分APP控制，输出部分系统控制。</p>
<h3 id="使用AUGraph来管理AudioUnit"><a href="#使用AUGraph来管理AudioUnit" class="headerlink" title="使用AUGraph来管理AudioUnit"></a>使用AUGraph来管理AudioUnit</h3><h3 id="Render-Callback-Functions-Feed-Audio-to-Audio-Units"><a href="#Render-Callback-Functions-Feed-Audio-to-Audio-Units" class="headerlink" title="Render Callback Functions Feed Audio to Audio Units"></a>Render Callback Functions Feed Audio to Audio Units</h3><p>当音频数据是由内存或者磁盘提供的话，数据都需要从渲染回调函数这里提供给inputbus，当你想要对音频数据进行自定义的处理的话，就在这里进行吧。</p>
<p>渲染回调函数格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static OSStatus MyAURenderCallback (</div><div class="line">    void                        *inRefCon,</div><div class="line">    AudioUnitRenderActionFlags  *ioActionFlags,</div><div class="line">    const AudioTimeStamp        *inTimeStamp,</div><div class="line">    UInt32                      inBusNumber,</div><div class="line">    UInt32                      inNumberFrames,</div><div class="line">    AudioBufferList             *ioData</div><div class="line">) &#123; /* callback body */ &#125;</div></pre></td></tr></table></figure>
<p>各参数的关系如下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-5.png" alt=""></p>
<h3 id="Working-with-the-AudioStreamBasicDescription-structure"><a href="#Working-with-the-AudioStreamBasicDescription-structure" class="headerlink" title="Working with the AudioStreamBasicDescription structure"></a>Working with the AudioStreamBasicDescription structure</h3><p>AudioStreamBasicDescription 这个结构体表示当前音频的格式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct AudioStreamBasicDescription &#123;</div><div class="line">    Float64 mSampleRate;//采样率</div><div class="line">    UInt32  mFormatID;//格式ID</div><div class="line">    UInt32  mFormatFlags;//存储标识</div><div class="line">    UInt32  mBytesPerPacket;//每个packet的字节数</div><div class="line">    UInt32  mFramesPerPacket;//每个packet包含几个frame</div><div class="line">    UInt32  mBytesPerFrame;//每个frame的字节数</div><div class="line">    UInt32  mChannelsPerFrame;//每个frame的声道数</div><div class="line">    UInt32  mBitsPerChannel;//每个声道的位数</div><div class="line">    UInt32  mReserved;</div><div class="line">&#125;;</div><div class="line">typedef struct AudioStreamBasicDescription  AudioStreamBasicDescription;</div></pre></td></tr></table></figure>
<h3 id="Understanding-Where-and-How-to-Set-Stream-Formats"><a href="#Understanding-Where-and-How-to-Set-Stream-Formats" class="headerlink" title="Understanding Where and How to Set Stream Formats"></a>Understanding Where and How to Set Stream Formats</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit1-6.png" alt=""></p>
<p>这个图展示了一个完整的录音+混音+播放的流程，在组件两边设置stream的格式，在代码里的概念是scope。</p>
<h3 id="在使用AUGraph时选择不同的设计模式"><a href="#在使用AUGraph时选择不同的设计模式" class="headerlink" title="在使用AUGraph时选择不同的设计模式"></a>在使用AUGraph时选择不同的设计模式</h3><h4 id="I-O-Pass-Through"><a href="#I-O-Pass-Through" class="headerlink" title="I/O Pass Through"></a>I/O Pass Through</h4><p>简单的音频输入输出场景，直接使用AudioUnit链接两端，不需要设置渲染回调.</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit2-1.png" alt=""></p>
<h4 id="I-O-Without-a-Render-Callback-Function"><a href="#I-O-Without-a-Render-Callback-Function" class="headerlink" title="I/O Without a Render Callback Function"></a>I/O Without a Render Callback Function</h4><p>需要多个AudioUnit来处理的场景，使用AudioUnit链接各部分，不需要设置回调。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit2-2.png" alt=""></p>
<h4 id="I-O-with-a-Render-Callback-Function"><a href="#I-O-with-a-Render-Callback-Function" class="headerlink" title="I/O with a Render Callback Function"></a>I/O with a Render Callback Function</h4><p>设置渲染回调的方式来处理输入输出的链接。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit2-3.png" alt=""></p>
<h4 id="Output-Only-with-a-Render-Callback-Function"><a href="#Output-Only-with-a-Render-Callback-Function" class="headerlink" title="Output-Only with a Render Callback Function"></a>Output-Only with a Render Callback Function</h4><p>只有输出没有输入的场景，设置渲染回调来链接输出端。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit2-4.png" alt=""></p>
<p>复杂的场景，需要设置多个渲染回调。同时需要多个AudioUnit来处理链接。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit2-5.png" alt=""></p>
<h3 id="构建AudioUnit-app的流程"><a href="#构建AudioUnit-app的流程" class="headerlink" title="构建AudioUnit app的流程"></a>构建AudioUnit app的流程</h3><p>无论选择上面的哪种设计，构建app的基本流程如下：</p>
<ul>
<li><p>Configure your audio session.</p>
</li>
<li><p>Specify audio units.</p>
</li>
<li><p>Create an audio processing graph, then obtain the<br>audio units.</p>
</li>
<li><p>Configure the audio units.</p>
</li>
<li><p>Connect the audio unit nodes.</p>
</li>
<li><p>Provide a user interface.</p>
</li>
<li><p>Initialize and then start the audio processing graph.</p>
</li>
</ul>
<h3 id="使用指定的AudioUnit"><a href="#使用指定的AudioUnit" class="headerlink" title="使用指定的AudioUnit"></a>使用指定的AudioUnit</h3><h4 id="Using-I-O-Units"><a href="#Using-I-O-Units" class="headerlink" title="Using I/O Units"></a>Using I/O Units</h4><ul>
<li>Remote I/O Unit</li>
</ul>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit3-1.png" alt=""></p>
<ul>
<li><p>Voice-Processing I/O Unit</p>
</li>
<li><p>Generic Output Unit</p>
</li>
</ul>
<h4 id="Using-Mixer-Units"><a href="#Using-Mixer-Units" class="headerlink" title="Using Mixer Units"></a>Using Mixer Units</h4><ul>
<li>Multichannel Mixer Unit</li>
</ul>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit3-2.png" alt=""></p>
<ul>
<li>3D Mixer Unit</li>
</ul>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit3-3.png" alt=""></p>
<h4 id="Using-Effect-Units"><a href="#Using-Effect-Units" class="headerlink" title="Using Effect Units"></a>Using Effect Units</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit3-4.png" alt=""></p>
<h3 id="Identifier-Keys-for-Audio-Units"><a href="#Identifier-Keys-for-Audio-Units" class="headerlink" title="Identifier Keys for Audio Units"></a>Identifier Keys for Audio Units</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/audiounit3-5.png" alt=""></p>
<p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
