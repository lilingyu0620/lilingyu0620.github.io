<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/04/OC的消息转发流程底层探究/" itemprop="url">
                  OC的消息转发流程底层探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-04T22:50:57+08:00" content="2021-01-04">
              2021-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/04/OC的消息转发流程底层探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/OC的消息转发流程底层探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="转发流程定位"><a href="#转发流程定位" class="headerlink" title="转发流程定位"></a>转发流程定位</h4><p>接<a href="http://llyblog.com/2021/01/04/OC方法调用慢查找流程底层逻辑探究/" target="_blank" rel="noopener">上一篇文章</a>的最后，我们找了方法未实现时的默认函数，下面我们调一个未实现的方法，看看具体的调用栈.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2021-01-04 20:05:16.074234+0800 LLYObjc[11678:7221659] -[LLYModel fun0]: unrecognized selector sent to instance 0x1006f2150</div><div class="line">2021-01-04 20:05:16.075692+0800 LLYObjc[11678:7221659] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[LLYModel fun0]: unrecognized selector sent to instance 0x1006f2150&apos;</div></pre></td></tr></table></figure>
<p>bt下看看堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGABRT</div><div class="line">frame #0: 0x00007fff717f633a libsystem_kernel.dylib`__pthread_kill + 10</div><div class="line">frame #1: 0x00000001004bc9bc libsystem_pthread.dylib`pthread_kill + 430</div><div class="line">frame #2: 0x00007fff7177d808 libsystem_c.dylib`abort + 120</div><div class="line">frame #3: 0x00007fff6e9e4458 libc++abi.dylib`abort_message + 231</div><div class="line">frame #4: 0x00007fff6e9d58bf libc++abi.dylib`demangling_terminate_handler() + 262</div><div class="line">* frame #5: 0x00000001002e99b3 libobjc.A.dylib`_objc_terminate() at objc-exception.mm:701:13</div><div class="line">frame #6: 0x00007fff6e9e3887 libc++abi.dylib`std::__terminate(void (*)()) + 8</div><div class="line">frame #7: 0x00007fff6e9e61a2 libc++abi.dylib`__cxxabiv1::failed_throw(__cxxabiv1::__cxa_exception*) + 27</div><div class="line">frame #8: 0x00007fff6e9e6169 libc++abi.dylib`__cxa_throw + 113</div><div class="line">frame #9: 0x00000001002e9158 libobjc.A.dylib`objc_exception_throw(obj=&quot;-[LLYModel fun0]: unrecognized selector sent to instance 0x1006f2150&quot;) at objc-exception.mm:591:5</div><div class="line">frame #10: 0x00007fff37660936 CoreFoundation`-[NSObject(NSObject) doesNotRecognizeSelector:] + 132</div><div class="line">frame #11: 0x00007fff37545ec0 CoreFoundation`___forwarding___ + 1427</div><div class="line">frame #12: 0x00007fff37545898 CoreFoundation`__forwarding_prep_0___ + 120</div><div class="line">frame #13: 0x0000000100003960 LLYObjc`main(argc=1, argv=0x00007ffeefbff4f8) at main.m:55:9 [opt]</div><div class="line">frame #14: 0x00007fff716aecc9 libdyld.dylib`start + 1</div><div class="line">frame #15: 0x00007fff716aecc9 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p>在<em>main</em>后和<em>doesNotRecognizeSelector</em>方法前分别调用了 <em>__forwarding_prep_0__</em> 和 <em>__<em>forwarding__</em></em> 这两个函数，我们猜测是OC的消息转发逻辑，那么如何去验证呢，老办法，我们先去源码中看看。</p>
<p>一无所获。</p>
<p>那我们再想想其他办法，我们分别点开这两个函数的堆栈，在头部发现了一些信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CoreFoundation`__forwarding_prep_0___:</div><div class="line"></div><div class="line">CoreFoundation`___forwarding___:</div></pre></td></tr></table></figure>
<p>看来这两个函数的定义可能在CoreFoundation库中，那么我们自然就去开源库里面找找看，<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CoreFoundation</a>的源码我们是找到了，打开发现还是没有上面的函数，看来并未全部开源，那么还是其他办法去探索么？</p>
<p>答案是有的，还可以通过反汇编工具来查看CF的动态库文件，这里推荐<em>Hopper Disassembler</em>.<br>在Hopper中,我们找到了如下伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">int ____forwarding___(int arg0, int arg1) &#123;</div><div class="line"></div><div class="line">	// 去掉了一些参数的赋值和传递逻辑和判断逻辑</div><div class="line">loc_649bb:</div><div class="line">    var_148 = r13;</div><div class="line">    var_138 = r12;</div><div class="line">    var_158 = rsi;</div><div class="line">    rax = object_getClass(rbx);</div><div class="line">    r12 = rax;</div><div class="line">    r13 = class_getName(rax);</div><div class="line">    if (class_respondsToSelector(r12, @selector(forwardingTargetForSelector:)) == 0x0) goto loc_64a67;</div><div class="line"></div><div class="line">loc_64a8a:</div><div class="line">    rax = class_respondsToSelector(r12, @selector(methodSignatureForSelector:));</div><div class="line">    r14 = var_138;</div><div class="line">    var_148 = r15;</div><div class="line">    if (rax == 0x0) goto loc_64dd7;</div><div class="line">    </div><div class="line">    loc_64ad5:</div><div class="line">    r12 = rax;</div><div class="line">    rax = [rax _frameDescriptor];</div><div class="line">    r13 = rax;</div><div class="line">    if (((*(int16_t *)(*rax + 0x22) &amp; 0xffff) &gt;&gt; 0x6 &amp; 0x1) != rbx) &#123;</div><div class="line">            rax = sel_getName(stack[-328]);</div><div class="line">            _CFLog(0x4, @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;, rax);</div><div class="line">    &#125;</div><div class="line">    rax = object_getClass(r14);</div><div class="line">    rax = class_respondsToSelector(rax, @selector(_forwardStackInvocation:));</div><div class="line">    stack[-344] = r13;</div><div class="line">    if (rax == 0x0) goto loc_64c19;</div><div class="line"></div><div class="line">loc_64c19:</div><div class="line">    if (class_respondsToSelector(object_getClass(r14), @selector(forwardInvocation:)) == 0x0) goto loc_64ec2;</div><div class="line"></div><div class="line">loc_64e3c:</div><div class="line">    rax = sel_getName(var_140);</div><div class="line">    r14 = rax;</div><div class="line">    rax = sel_getUid(rax);</div><div class="line">    if (rax != var_140) &#123;</div><div class="line">            _CFLog(0x4, @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;, var_140, r14, rax, r9, stack[-360]);</div><div class="line">    &#125;</div><div class="line">    if (class_respondsToSelector(object_getClass(var_138), @selector(doesNotRecognizeSelector:)) == 0x0) &#123;</div><div class="line">            ____forwarding___.cold.2(var_138);</div><div class="line">    &#125;</div><div class="line">    (*_objc_msgSend)(var_138, @selector(doesNotRecognizeSelector:));</div><div class="line">    asm &#123; ud2 &#125;;</div><div class="line">    rax = loc_64ec2(rdi, rsi);</div><div class="line">    return rax;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面伪代码，我们提炼出了几个比较重要的函数，即我们常说的消息转发的流程（除了<em>_forwardStackInvocation</em>这个函数，这个函数我们下面在说）原来出处在CoreFoundation中，知道了出处，我们再来验证下他们的逻辑。</p>
<h4 id="转发流程验证"><a href="#转发流程验证" class="headerlink" title="转发流程验证"></a>转发流程验证</h4><h5 id="resolveInstanceMethod-amp-amp-resolveClassMethod-动态方法决议"><a href="#resolveInstanceMethod-amp-amp-resolveClassMethod-动态方法决议" class="headerlink" title="resolveInstanceMethod &amp;&amp; resolveClassMethod 动态方法决议"></a>resolveInstanceMethod &amp;&amp; resolveClassMethod 动态方法决议</h5><p>该部分的源码就在objc中，上一篇解释消息慢查询的时候只是一笔带过了，这里我们再来分析下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior) &#123;</div><div class="line">	</div><div class="line">	//...</div><div class="line">	//上面是imp查找过程</div><div class="line">	</div><div class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</div><div class="line">        behavior ^= LOOKUP_RESOLVER;</div><div class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //...</div><div class="line">    //下面的缓存过程</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">static NEVER_INLINE IMP</div><div class="line">resolveMethod_locked(id inst, SEL sel, Class cls, int behavior)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line"></div><div class="line">    runtimeLock.unlock();</div><div class="line"></div><div class="line">    if (! cls-&gt;isMetaClass()) &#123;</div><div class="line">        // cls是类对象</div><div class="line">        resolveInstanceMethod(inst, sel, cls);</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // cls是元类对象</div><div class="line">        resolveClassMethod(inst, sel, cls);</div><div class="line"></div><div class="line">        // 类方法列表中没有，再去实例方法中找，这里就有一个坑点，根元类的superclass指针指向根类，也就是最终会找到NSObject中去，所以理论上我们能在NSObject的分类中处理所有的类方法找不到问题。</div><div class="line">        if (!lookUpImpOrNil(inst, sel, cls)) &#123;</div><div class="line">            resolveInstanceMethod(inst, sel, cls);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // chances are that calling the resolver have populated the cache</div><div class="line">    // so attempt using it</div><div class="line">    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</div><div class="line"></div><div class="line">	// 未实现直接返回</div><div class="line">    if (!lookUpImpOrNil(cls, resolve_sel, cls-&gt;ISA())) &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	 // 如果该类resolveInstanceMethod方法已实现，帮我们调一次</div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(cls, resolve_sel, sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveInstanceMethod adds to self a.k.a. cls</div><div class="line">    </div><div class="line">    // 继续走一遍查找逻辑</div><div class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</div><div class="line">    </div><div class="line">    // ...</div><div class="line">    // 非重要信息</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">static void resolveClassMethod(id inst, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line">    ASSERT(cls-&gt;isMetaClass());</div><div class="line"></div><div class="line">	// 未实现直接返回</div><div class="line">    if (!lookUpImpOrNil(inst, @selector(resolveClassMethod:), cls)) &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 // 如果该类resolveClassMethod方法已实现，帮我们调一次</div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</div><div class="line"></div><div class="line">    // 继续走一遍查找逻辑</div><div class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</div><div class="line">    </div><div class="line">    // ...</div><div class="line">    // 非重要信息</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了源码，我们知道了只要重写一下上面两个方法，系统就会调一次这两方法，相当于一个钩子，我们可以在钩子里面动态的给该类加上缺失的方法，正常逻辑ok，那如果我们只是重写但是不动态添加方法实现会怎么样呢？我们来验证下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSLog(@&quot;%@ %s&quot;,NSStringFromSelector(sel),__func__);</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2021-01-04 21:29:51.339930+0800 LLYObjc[12200:7268336] fun0 +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 21:29:51.340714+0800 LLYObjc[12200:7268336] fun0 +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 21:29:51.340894+0800 LLYObjc[12200:7268336] -[LLYModel fun0]: unrecognized selector sent to instance 0x101918dc0</div></pre></td></tr></table></figure>
<p>奇怪的事情发生了，<em>resolveInstanceMethod</em>进来了两次，第一次进来比较好理解，但是第二次是从哪里进来的呢？是不是因为递归查找的原因？我们打个断点看看两个打印时的bt：</p>
<p><strong>第一次</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class="line">* frame #0: 0x0000000100313413 libobjc.A.dylib`resolveInstanceMethod(inst=0x000000010113abd0, sel=&quot;fun0&quot;, cls=LLYModel) at objc-runtime-new.mm:6005:30</div><div class="line">frame #1: 0x00000001002fee83 libobjc.A.dylib`resolveMethod_locked(inst=0x000000010113abd0, sel=&quot;fun0&quot;, cls=LLYModel, behavior=1) at objc-runtime-new.mm:6043:9</div><div class="line">frame #2: 0x00000001002fe7ac libobjc.A.dylib`lookUpImpOrForward(inst=0x000000010113abd0, sel=&quot;fun0&quot;, cls=LLYModel, behavior=1) at objc-runtime-new.mm:6192:16</div><div class="line">frame #3: 0x00000001002d9899 libobjc.A.dylib`_objc_msgSend_uncached at objc-msg-x86_64.s:1101</div><div class="line">frame #4: 0x0000000100003890 LLYObjc`main(argc=1, argv=0x00007ffeefbff4f8) at main.m:55:9 [opt]</div><div class="line">frame #5: 0x00007fff716aecc9 libdyld.dylib`start + 1</div><div class="line">frame #6: 0x00007fff716aecc9 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p><strong>第二次</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class="line">  * frame #0: 0x0000000100313413 libobjc.A.dylib`resolveInstanceMethod(inst=0x0000000000000000, sel=&quot;fun0&quot;, cls=LLYModel) at objc-runtime-new.mm:6005:30</div><div class="line">    frame #1: 0x00000001002fee83 libobjc.A.dylib`resolveMethod_locked(inst=0x0000000000000000, sel=&quot;fun0&quot;, cls=LLYModel, behavior=0) at objc-runtime-new.mm:6043:9</div><div class="line">    frame #2: 0x00000001002fe7ac libobjc.A.dylib`lookUpImpOrForward(inst=0x0000000000000000, sel=&quot;fun0&quot;, cls=LLYModel, behavior=0) at objc-runtime-new.mm:6192:16</div><div class="line">    frame #3: 0x00000001002d8379 libobjc.A.dylib`class_getInstanceMethod(cls=LLYModel, sel=&quot;fun0&quot;) at objc-runtime-new.mm:5922:5</div><div class="line">    frame #4: 0x00007fff3755d697 CoreFoundation`__methodDescriptionForSelector + 282</div><div class="line">    frame #5: 0x00007fff37579204 CoreFoundation`-[NSObject(NSObject) methodSignatureForSelector:] + 38</div><div class="line">    frame #6: 0x00007fff37545ac5 CoreFoundation`___forwarding___ + 408</div><div class="line">    frame #7: 0x00007fff37545898 CoreFoundation`__forwarding_prep_0___ + 120</div><div class="line">    frame #8: 0x0000000100003890 LLYObjc`main(argc=1, argv=0x00007ffeefbff4f8) at main.m:55:9 [opt]</div><div class="line">    frame #9: 0x00007fff716aecc9 libdyld.dylib`start + 1</div><div class="line">    frame #10: 0x00007fff716aecc9 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p>可以看到，第一次堆栈就是正常的<em>lookUpImpOrForward</em>查找逻辑触发的，但是第二次的触发确是在消息转发中获取到函数签名后，那如何验证呢？很简单，我们去实现下<em>methodSignatureForSelector</em>这个方法看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2021-01-04 22:06:15.458988+0800 LLYObjc[12668:7297440] fun0 +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 22:06:15.459889+0800 LLYObjc[12668:7297440] _forwardStackInvocation: +[LLYModel resolveInstanceMethod:]</div><div class="line">2021-01-04 22:06:15.460152+0800 LLYObjc[12668:7297440] -[LLYModel fun0]: unrecognized selector sent to instance 0x100738090</div></pre></td></tr></table></figure>
<p>果然，第二次打印的函数变成了这个<em>_forwardStackInvocation</em>，这是哪来的呢？请看上面的CoreFoundation伪代码。大胆猜测就是如果没有实现自己的函数签名的话，系统还是用之前的函数签名（fun0）去调用一次<em>lookUpImpOrForward</em>，实现后换成CoreFoundation内部的（_forwardStackInvocation）函数签名去调用一次<em>lookUpImpOrForward</em>.</p>
<h5 id="forwardingTargetForSelector-快速转发"><a href="#forwardingTargetForSelector-快速转发" class="headerlink" title="forwardingTargetForSelector 快速转发"></a>forwardingTargetForSelector 快速转发</h5><p>快速转发需要做的操作比较简单，返回一个实现了该方法的类。</p>
<h5 id="methodSignatureForSelector-amp-amp-forwardInvocation-慢速转发"><a href="#methodSignatureForSelector-amp-amp-forwardInvocation-慢速转发" class="headerlink" title="methodSignatureForSelector &amp;&amp; forwardInvocation 慢速转发"></a>methodSignatureForSelector &amp;&amp; forwardInvocation 慢速转发</h5><p>慢速转发有下面两个有意思的点：</p>
<p><strong>趣点一：</strong>方法签名并未指定格式，你可以返回任意正确的格式，比如我返回下面这种格式也ok：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>项目中应该没有那个函数带了这么多参数吧。</p>
<p>但是下面这个格式就不行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为缺少最基本的sel参数。</p>
<p><strong>趣点二：</strong> 只需要重写<em>forwardInvocation</em>函数，即使是一个空函数，系统即认为当前被转发的方法已经被人处理，不会抛出异常。这里我们就可以做一些其他的事情了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上探索，我们不仅掌握了OC消息转发的实现方式，还了解了转发逻辑内部的实现原理，也为我们在生产环境的灵活使用打下基础，比如我们可以通过消息转发机制实现方法调用的防护工作等比较重要的内容，更多的功能需要我们进一步的探索和实践。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/04/OC方法调用慢查找流程底层逻辑探究/" itemprop="url">
                  OC方法调用慢查找流程底层逻辑探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-04T13:54:47+08:00" content="2021-01-04">
              2021-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/04/OC方法调用慢查找流程底层逻辑探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/OC方法调用慢查找流程底层逻辑探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="http://llyblog.com/2021/01/03/OC方法调用快查找流程底层逻辑探究/" target="_blank" rel="noopener">OC方法调用快查找流程底层逻辑探究</a>中,我们分析了方法调用快查找的逻辑，所谓的快查找也就是对方法缓存列表的查找，如果没有命中缓存，则会进入到慢查找的逻辑，即对类的方法列表的查找，下面我们就来探究下OC底层是如何进行慢查找的。</p>
<p>在快查找未命中的出口，有如下的代码逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">.macro JumpMiss</div><div class="line">.if $0 == GETIMP</div><div class="line">	b	LGetImpMiss</div><div class="line">.elseif $0 == NORMAL</div><div class="line">	b	__objc_msgSend_uncached</div><div class="line">.elseif $0 == LOOKUP</div><div class="line">	b	__objc_msgLookup_uncached</div><div class="line">.else</div><div class="line">.abort oops</div><div class="line">.endif</div><div class="line">.endmacro</div><div class="line"></div><div class="line">STATIC_ENTRY __objc_msgSend_uncached</div><div class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</div><div class="line"></div><div class="line">// THIS IS NOT A CALLABLE C FUNCTION</div><div class="line">// Out-of-band p16 is the class to search</div><div class="line">	</div><div class="line">MethodTableLookup</div><div class="line">TailCallFunctionPointer x17</div><div class="line"></div><div class="line">END_ENTRY __objc_msgSend_uncached</div><div class="line"></div><div class="line"></div><div class="line">STATIC_ENTRY __objc_msgLookup_uncached</div><div class="line">UNWIND __objc_msgLookup_uncached, FrameWithNoSaves</div><div class="line"></div><div class="line">// THIS IS NOT A CALLABLE C FUNCTION</div><div class="line">// Out-of-band p16 is the class to search</div><div class="line">	</div><div class="line">MethodTableLookup</div><div class="line">ret</div><div class="line"></div><div class="line">END_ENTRY __objc_msgLookup_uncached</div></pre></td></tr></table></figure>
<p>共同指向了<em>MethodTableLookup</em>这个方法，我们来看看这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">.macro MethodTableLookup</div><div class="line">	</div><div class="line">// push frame</div><div class="line">SignLR</div><div class="line">stp	fp, lr, [sp, #-16]!</div><div class="line">mov	fp, sp</div><div class="line"></div><div class="line">// save parameter registers: x0..x8, q0..q7</div><div class="line">sub	sp, sp, #(10*8 + 8*16)</div><div class="line">stp	q0, q1, [sp, #(0*16)]</div><div class="line">stp	q2, q3, [sp, #(2*16)]</div><div class="line">stp	q4, q5, [sp, #(4*16)]</div><div class="line">stp	q6, q7, [sp, #(6*16)]</div><div class="line">stp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">stp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">stp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">stp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">str	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</div><div class="line">// receiver and selector already in x0 and x1</div><div class="line">mov	x2, x16</div><div class="line">mov	x3, #3</div><div class="line">bl	_lookUpImpOrForward</div><div class="line"></div><div class="line">// IMP in x0</div><div class="line">mov	x17, x0</div><div class="line">	</div><div class="line">// restore registers and return</div><div class="line">ldp	q0, q1, [sp, #(0*16)]</div><div class="line">ldp	q2, q3, [sp, #(2*16)]</div><div class="line">ldp	q4, q5, [sp, #(4*16)]</div><div class="line">ldp	q6, q7, [sp, #(6*16)]</div><div class="line">ldp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">ldp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">ldp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">ldp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">ldr	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">mov	sp, fp</div><div class="line">ldp	fp, lr, [sp], #16</div><div class="line">AuthenticateLR</div><div class="line"></div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>我们暂时忽略寄存器先关操作，主要看方法调用逻辑，可以看到，内部是调用了<em>_lookUpImpOrForward</em> 这个方法，看命名应该能猜到是跟imp的查找和转发逻辑相关，那我们找找这个函数的定义，发现在汇编代码中没有相关定义，我们去runtime原文件中看看，果然在<em>objc_runtime-new.mm</em>的6094行发现了该函数的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* lookUpImpOrForward.</div><div class="line">* The standard IMP lookup. </div><div class="line">* Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)</div><div class="line">* Without LOOKUP_CACHE: skips optimistic unlocked lookup (but uses cache elsewhere)</div><div class="line">* Most callers should use LOOKUP_INITIALIZE and LOOKUP_CACHE</div><div class="line">* inst is an instance of cls or a subclass thereof, or nil if none is known. </div><div class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</div><div class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </div><div class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</div><div class="line">*   If you don&apos;t want forwarding at all, use LOOKUP_NIL.</div><div class="line">**********************************************************************/</div><div class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</div><div class="line">&#123;</div><div class="line">    const IMP forward_imp = (IMP)_objc_msgForward_impcache; // 这里imp有一个默认值 是一个坑点 具体下面解释。</div><div class="line">    </div><div class="line">    IMP imp = nil;</div><div class="line">    Class curClass;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line"></div><div class="line">    // Optimistic cache lookup // 再去缓存中查找一遍，防止多线程已调用</div><div class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        if (imp) goto done_nolock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.lock(); // 线程安全哦</div><div class="line"></div><div class="line">    checkIsKnownClass(cls);</div><div class="line"></div><div class="line">	// 下面两个操作是对类的继承链,ro,rw等数据的递归实例化，比较重要，不过不在这个文章的讨论范围 先不进去细看。</div><div class="line">    if (slowpath(!cls-&gt;isRealized())) &#123;</div><div class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</div><div class="line">    	 // 类的initialize()方法就是在这里被调用</div><div class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.assertLocked();</div><div class="line">    curClass = cls;</div><div class="line"></div><div class="line">    for (unsigned attempts = unreasonableClassCount();;) &#123;</div><div class="line">        </div><div class="line">        // 直接能从当前类的方法列表中查找到 </div><div class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">        if (meth) &#123;</div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">			</div><div class="line">		  // 如果已经查找完当前类的父类中了 给imp一个默认值然后跳出本次递归 </div><div class="line">		  // 还没有查找则将当前类赋值为父类 下面继续对父类进行查找</div><div class="line">        if (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</div><div class="line">            imp = forward_imp;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 是否还在继承链中查找</div><div class="line">        if (slowpath(--attempts == 0)) &#123;</div><div class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 从父类的缓存中查找 curclass已经在上面被赋值为父类了</div><div class="line">        // 这个方法也是汇编实现 复用的快查找的逻辑</div><div class="line">        imp = cache_getImp(curClass, sel);</div><div class="line">        </div><div class="line">        // 父类缓存中没有找到 跳出本轮递归 下次又从父类的父类中开始查找</div><div class="line">        if (slowpath(imp == forward_imp)) &#123;</div><div class="line">           break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 找到了 goto done </div><div class="line">        if (fastpath(imp)) &#123;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	// 以上逻辑走完，说明imp还是没有找到，这个时候会做一个动态的方法决议，这部分属于方法转发逻辑，暂时不进去细看。</div><div class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</div><div class="line">        behavior ^= LOOKUP_RESOLVER;</div><div class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> done:</div><div class="line"> 	// imp找到了，则进行缓存，缓存逻辑参考之前的文章</div><div class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">    runtimeLock.unlock();</div><div class="line"> done_nolock:</div><div class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上源码就是慢查找的整个流程，整体是一个递归查找继承连的过程，其中还有一些小的点可以在扩展下。</p>
<h5 id="扩展一-对当前方法列表的查找策略"><a href="#扩展一-对当前方法列表的查找策略" class="headerlink" title="扩展一 对当前方法列表的查找策略"></a>扩展一 对当前方法列表的查找策略</h5><p>我们可以深入看看代码逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">static method_t *</div><div class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line">    // fixme nil cls? </div><div class="line">    // fixme nil sel?</div><div class="line"></div><div class="line">	// 方法列表是多级的 </div><div class="line">    auto const methods = cls-&gt;data()-&gt;methods();</div><div class="line">    for (auto mlists = methods.beginLists(),</div><div class="line">              end = methods.endLists();</div><div class="line">         mlists != end;</div><div class="line">         ++mlists)</div><div class="line">    &#123;</div><div class="line">       method_t *m = search_method_list_inline(*mlists, sel);</div><div class="line">        if (m) return m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE static method_t *</div><div class="line">search_method_list_inline(const method_list_t *mlist, SEL sel)</div><div class="line">&#123;</div><div class="line">    int methodListIsFixedUp = mlist-&gt;isFixedUp();</div><div class="line">    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);</div><div class="line">    </div><div class="line">    if (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) &#123;</div><div class="line">        // 对已排序数据进行查找 你想到了什么？？？</div><div class="line">        return findMethodInSortedMethodList(sel, mlist);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Linear search of unsorted method list</div><div class="line">        for (auto&amp; meth : *mlist) &#123;</div><div class="line">            if (meth.name == sel) return &amp;meth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE static method_t *</div><div class="line">findMethodInSortedMethodList(SEL key, const method_list_t *list)</div><div class="line">&#123;</div><div class="line">    ASSERT(list);</div><div class="line"></div><div class="line">    const method_t * const first = &amp;list-&gt;first;</div><div class="line">    const method_t *base = first;</div><div class="line">    const method_t *probe;</div><div class="line">    uintptr_t keyValue = (uintptr_t)key;</div><div class="line">    uint32_t count;</div><div class="line">    </div><div class="line">    // 没有错 就是折半查找 不过apple的折半写的比较有逼格。</div><div class="line">    for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123;</div><div class="line">        probe = base + (count &gt;&gt; 1);</div><div class="line">        </div><div class="line">        uintptr_t probeValue = (uintptr_t)probe-&gt;name;</div><div class="line">        </div><div class="line">        // 如果已找到 则找到同名方法的第一个 这里说明列表内可能有方法名相同的方法，什么情况会出现呢？比如分类同名方法。说明一点，上层的结论在底层都是都代码依据的。</div><div class="line">        if (keyValue == probeValue) &#123;</div><div class="line">            while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123;</div><div class="line">                probe--;</div><div class="line">            &#125;</div><div class="line">            return (method_t *)probe;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (keyValue &gt; probeValue) &#123;</div><div class="line">            base = probe + 1;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="扩展二-默认的imp"><a href="#扩展二-默认的imp" class="headerlink" title="扩展二 默认的imp"></a>扩展二 默认的imp</h5><p>在查找函数的最前面，有下面这行初始化代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const IMP forward_imp = (IMP)_objc_msgForward_impcache;</div></pre></td></tr></table></figure>
<p>这个默认的imp具体指向哪里，我们来全局查找一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">STATIC_ENTRY __objc_msgForward_impcache</div><div class="line"></div><div class="line">// No stret specialization.</div><div class="line">b	__objc_msgForward</div><div class="line"></div><div class="line">END_ENTRY __objc_msgForward_impcache</div><div class="line"></div><div class="line"></div><div class="line">ENTRY __objc_msgForward</div><div class="line">// Non-stret version</div><div class="line"></div><div class="line">MI_GET_EXTERN(r12, __objc_forward_handler)</div><div class="line">ldr	r12, [r12]</div><div class="line">bx	r12</div><div class="line"></div><div class="line">END_ENTRY __objc_msgForward</div></pre></td></tr></table></figure>
<p>在汇编代码中找到<em> __objc_forward_handler</em>这里就线索中断，这个猜测应该是一个回调函数，ok，那我们去源代码里面看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Default forward handler halts the process.</div><div class="line">__attribute__((noreturn, cold)) void</div><div class="line">objc_defaultForwardHandler(id self, SEL sel)</div><div class="line">&#123;</div><div class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class="line">                &quot;(no message forward handler is installed)&quot;, </div><div class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div><div class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div></pre></td></tr></table></figure>
<p>是不是看到了我们非常熟悉的一个错误信息，没有错，这个默认的imp就是找不到方法实现的错误处理函数。此时，坑点也就出现了，如果你使用<em>class_getMethodImplementation</em>去查找一个未实现的方法时，不会返回空，而是返回这个函数的地址，这里需要注意一下。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上就是整个慢查找的流程和其中的一些相关的知识点的梳理，除了整体流程的分析，上面的两个扩展也是比较重要的。其中还有一些比较重要的内容没有做深入分析，如<em>realizeClassMaybeSwiftAndLeaveLocked</em>和<em>initializeAndLeaveLocked</em>,留到以后再做分析，毕竟这篇文章主要分析慢查找的流程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/04/从【nonpointer】探究OC类中isa指针/" itemprop="url">
                  从【nonpointer】探究OC类中isa指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-04T10:45:18+08:00" content="2021-01-04">
              2021-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/04/从【nonpointer】探究OC类中isa指针/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/从【nonpointer】探究OC类中isa指针/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在这篇文章<a href="http://llyblog.com/2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/" target="_blank" rel="noopener">从【class_getInstanceSize方法】探究iOS的内存分配策略</a>中，我们分析了OC类的内存分配策略，但是具体的初始化过程并没有提及，这里我们来探究下OC在内存的初始化过程中都做了什么。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们还是先看一下整个OC类的创建流程，如下图：</p>
<p><img src="https://raw.githubusercontent.com/lilingyu0620/LLYBlogImageSource/master/Alloc分析/alloc01.png" alt=""></p>
<p>其中标红的<em>_class_createInstanceFromZone</em>函数就是核心内容，我们直接来看看其内部实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">static ALWAYS_INLINE id</div><div class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</div><div class="line">                              int construct_flags = OBJECT_CONSTRUCT_NONE,</div><div class="line">                              bool cxxConstruct = true,</div><div class="line">                              size_t *outAllocatedSize = nil)</div><div class="line">&#123;</div><div class="line">    ASSERT(cls-&gt;isRealized());</div><div class="line"></div><div class="line">    // Read class&apos;s info bits all at once for performance</div><div class="line">    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</div><div class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</div><div class="line">    bool fast = cls-&gt;canAllocNonpointer(); //是否支持nonpointer 这个是关键</div><div class="line">    size_t size;</div><div class="line"></div><div class="line">    size = cls-&gt;instanceSize(extraBytes);</div><div class="line">    if (outAllocatedSize) *outAllocatedSize = size;</div><div class="line"></div><div class="line">    id obj;</div><div class="line">    if (zone) &#123;</div><div class="line">        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</div><div class="line">    &#125; else &#123;</div><div class="line">        obj = (id)calloc(1, size);</div><div class="line">    &#125;</div><div class="line">    if (slowpath(!obj)) &#123;</div><div class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</div><div class="line">            return _objc_callBadAllocHandler(cls);</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!zone &amp;&amp; fast) &#123;</div><div class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor); // 支持nonpointer的类初始化过程 见下面的分析</div><div class="line">    &#125; else &#123;</div><div class="line">        // Use raw pointer isa on the assumption that they might be</div><div class="line">        // doing something weird with the zone or RR.</div><div class="line">        obj-&gt;initIsa(cls); // 不支持nonpointer的类初始化过程 见下面的分析</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (fastpath(!hasCxxCtor)) &#123;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</div><div class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags); // 默认添加一个cxx的析构函数</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">inline void </div><div class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</div><div class="line">&#123;</div><div class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</div><div class="line">    ASSERT(hasCxxDtor == cls-&gt;hasCxxDtor());</div><div class="line"></div><div class="line">    initIsa(cls, true, hasCxxDtor); // nonpointer直接写死为true</div><div class="line">&#125;</div><div class="line"></div><div class="line">inline void </div><div class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </div><div class="line">&#123; </div><div class="line">    ASSERT(!isTaggedPointer());  // 小对象类型直接返回 没有isa指针</div><div class="line">    </div><div class="line">    if (!nonpointer) &#123;</div><div class="line">        isa = isa_t((uintptr_t)cls); // 不支持nonpointer的对象直接将类对象赋值给isa</div><div class="line">    &#125; else &#123;</div><div class="line">        ASSERT(!DisableNonpointerIsa);</div><div class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</div><div class="line"></div><div class="line">        isa_t newisa(0);</div><div class="line">#if SUPPORT_INDEXED_ISA //判断平台</div><div class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; 0);</div><div class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</div><div class="line">        // isa.magic is part of ISA_MAGIC_VALUE</div><div class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</div><div class="line">#else</div><div class="line">        newisa.bits = ISA_MAGIC_VALUE;</div><div class="line">        // isa.magic is part of ISA_MAGIC_VALUE</div><div class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; // 前三位都不是存的类信息 所以先抛弃前三位再赋值</div><div class="line">#endif</div><div class="line">        // This write must be performed in a single store in some cases</div><div class="line">        // (for example when realizing a class because other threads</div><div class="line">        // may simultaneously try to use the class).</div><div class="line">        // fixme use atomics here to guarantee single-store and to</div><div class="line">        // guarantee memory order w.r.t. the class index table</div><div class="line">        // ...but not too atomic because we don&apos;t want to hurt instantiation</div><div class="line">        isa = newisa;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源码中我们看到初始化的过程实际上就是对<em>isa</em>指针赋值的过程，对于不满足nonpointer的对象，isa指针直接等于类对象，而nonpointer对象的isa就比较复杂了，这里我们再来分析下nonpointer下的isa指针的数据结构，如下：</p>
<h5 id="isa结构分析"><a href="#isa结构分析" class="headerlink" title="isa结构分析"></a>isa结构分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">// isa_t 也就是isa指针的结构类型是一个联合体，cls和bits共享64位的内存空间</div><div class="line">union isa_t &#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line">#if defined(ISA_BITFIELD)</div><div class="line">    struct &#123;</div><div class="line">        ISA_BITFIELD;  // defined in isa.h</div><div class="line">    &#125;;</div><div class="line">#endif</div><div class="line">&#125;;</div><div class="line"></div><div class="line"># if __arm64__</div><div class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class="line">#   define ISA_BITFIELD                                                      \</div><div class="line">      uintptr_t nonpointer        : 1; //是否是nonponiter类型                                     \</div><div class="line">      uintptr_t has_assoc         : 1; //是否有关联对象                                     \</div><div class="line">      uintptr_t has_cxx_dtor      : 1; //是否添加了cxx的析构函数                                     \</div><div class="line">      uintptr_t shiftcls          : 33;//类对象信息 /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</div><div class="line">      uintptr_t magic             : 6; //魔数                                      \</div><div class="line">      uintptr_t weakly_referenced : 1; //是否有弱引用                                     \</div><div class="line">      uintptr_t deallocating      : 1; //是否正在析构                                      \</div><div class="line">      uintptr_t has_sidetable_rc  : 1; //引用计数表中是否存了该对象的引用计数                                      \</div><div class="line">      uintptr_t extra_rc          : 19 //引用计数</div><div class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</div><div class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</div><div class="line"></div><div class="line"># elif __x86_64__</div><div class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class="line">#   define ISA_BITFIELD                                                        \</div><div class="line">      uintptr_t nonpointer        : 1;                                         \</div><div class="line">      uintptr_t has_assoc         : 1;                                         \</div><div class="line">      uintptr_t has_cxx_dtor      : 1;                                         \</div><div class="line">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \</div><div class="line">      uintptr_t magic             : 6;                                         \</div><div class="line">      uintptr_t weakly_referenced : 1;                                         \</div><div class="line">      uintptr_t deallocating      : 1;                                         \</div><div class="line">      uintptr_t has_sidetable_rc  : 1;                                         \</div><div class="line">      uintptr_t extra_rc          : 8</div><div class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</div><div class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</div></pre></td></tr></table></figure>
<p>可视化结构</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ISA/isa.jpeg" alt=""></p>
<p>结合上面的源码和图，nonpointer的isa指针的结构应该就比较清楚了。这个结构我们之后在分析iOS的内存管理的时候应该还会在具体分析。这里暂时先只做了解。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上分析，OC类的创建过程就比较清晰了，首先是通过内存对齐原则计算需要分配的内存大小，然后对类的isa指针进行初始化。到这里就可以确定一个类的对象了，那么类中superclass,cache（第一次有消息发送行为时创建内存）,bits等是在何时初始化的呢，这个留在以后探究。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/OC方法调用快查找流程底层逻辑探究/" itemprop="url">
                  OC方法调用快查找流程底层逻辑探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-03T20:23:45+08:00" content="2021-01-03">
              2021-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/03/OC方法调用快查找流程底层逻辑探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/03/OC方法调用快查找流程底层逻辑探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>As we know, OC上层的方法调用的底层逻辑都是通过<em>objc_msgSend</em>来实现的，那么如何验证呢？我们通过clang反编译看看就知道了：</p>
<p>上层的OC调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        // insert code here...</div><div class="line">        </div><div class="line">        LLYModel *model = [LLYModel alloc];</div><div class="line">        </div><div class="line">        [model func0];</div><div class="line">        </div><div class="line">        [model func1];</div><div class="line">        </div><div class="line">        NSLog(@&quot;Hello, World!&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用clang命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m -o main.cpp</div></pre></td></tr></table></figure>
<p>反编译之后的底层实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line"></div><div class="line">        LLYModel *model = ((LLYModel *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;LLYModel&quot;), sel_registerName(&quot;alloc&quot;));</div><div class="line"></div><div class="line">        ((void (*)(id, SEL))(void *)objc_msgSend)((id)model, sel_registerName(&quot;func0&quot;));</div><div class="line"></div><div class="line">        ((void (*)(id, SEL))(void *)objc_msgSend)((id)model, sel_registerName(&quot;func1&quot;));</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_71_gd0d02_n7td1h8k9l7bx0jqh0000gp_T_main_f2985d_mi_0);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，所有的方法调用全都被编译器转换为了<em>objc_msgSend</em>方法的调用，我们很自然的去runtime源码中找该函数的实现逻辑，结果在<em>.mm</em>文件中没有发现，以为线索就要断了的时候，在<em>objc-msg-arm64.s</em>文件内看到了下面几行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ENTRY _objc_msgSend</div><div class="line">UNWIND _objc_msgSend, NoFrame</div><div class="line"></div><div class="line">cmp	p0, #0	 //p0寄存器保存的应该是objc_msgSend()的第一个参数receive // nil check and tagged pointer check </div><div class="line"></div><div class="line">// taggedpointer判断</div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</div><div class="line">#else</div><div class="line">b.eq	LReturnZero</div><div class="line">#endif</div><div class="line"></div><div class="line">// 拿到receive的isa指针</div><div class="line">ldr	p13, [x0]		// p13 = isa</div><div class="line"></div><div class="line">// 拿到类对象</div><div class="line">GetClassFromIsa_p16 p13		// p16 = class</div><div class="line">LGetIsaDone:</div><div class="line"></div><div class="line">// calls imp or objc_msgSend_uncached</div><div class="line">CacheLookup NORMAL, _objc_msgSend</div></pre></td></tr></table></figure>
<p>这里应该就是<em>objc_msgSend</em>的入口了，原来是使用汇编代码来实现的，只能硬着头皮看下去了。</p>
<p>上面的逻辑最终调用了<em>CacheLookup</em>这个函数，我们全局搜一下，找到了该函数的实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.macro CacheLookup</div><div class="line"></div><div class="line">LLookupStart$1:</div><div class="line"></div><div class="line">	// p1 = SEL, p16 = isa</div><div class="line">	// #define CACHE            (2 * __SIZEOF_POINTER__)</div><div class="line">	// 从isa指针首地址偏移16个字节，这一步操作是拿到类的cache数据，原理参考类结构的定义。</div><div class="line">	ldr	p11, [x16, #CACHE]				// p11 = mask|buckets</div><div class="line"></div><div class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</div><div class="line">	// 参考cache_t中的结构 这一步是拿到缓存的buckts数组</div><div class="line">	and	p10, p11, #0x0000ffffffffffff	// p10 = buckets</div><div class="line">	// 计算_cmd(也就是sel)的索引</div><div class="line">	and	p12, p1, p11, LSR #48		// x12 = _cmd &amp; mask</div><div class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</div><div class="line">	and	p10, p11, #~0xf			// p10 = buckets</div><div class="line">	and	p11, p11, #0xf			// p11 = maskShift</div><div class="line">	mov	p12, #0xffff</div><div class="line">	lsr	p11, p12, p11				// p11 = mask = 0xffff &gt;&gt; p11</div><div class="line">	and	p12, p1, p11				// x12 = _cmd &amp; mask</div><div class="line">#else</div><div class="line">#error Unsupported cache mask storage for ARM64.</div><div class="line">#endif</div><div class="line">	// #define PTRSHIFT 3  // 1&lt;&lt;PTRSHIFT == PTRSIZE</div><div class="line">	// 根据上面的索引值获取具体的bucket数据 每一个bucket是16个字节 所以这一要向左平移4位</div><div class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</div><div class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class="line"></div><div class="line">	// 拿到sel和imp元组</div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">	</div><div class="line">	// 下面就是一个条件判断和分支语句了</div><div class="line">	</div><div class="line">	// 找到的sel不是当前执行的方法</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	// goto 2</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	// 否则直接命中</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">	// 未命中逻辑</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	// 空判断</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	// 当前是否已经寻址到buckets的第一个元素</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	// 是的话 goto 3</div><div class="line">	b.eq	3f</div><div class="line">	// 不是的话 向前移位继续查找</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	// 这是一个循环查找的过程</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// wrap: p12 = first bucket, w11 = mask</div><div class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</div><div class="line">	// 已经寻址到buckets的第一个元素，直接干到最后一个元素，再重新开始向前查找。</div><div class="line">	add	p12, p12, p11, LSR #(48 - (1+PTRSHIFT))</div><div class="line">					// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</div><div class="line">	add	p12, p12, p11, LSL #(1+PTRSHIFT)</div><div class="line">					// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line">#else</div><div class="line">#error Unsupported cache mask storage for ARM64.</div><div class="line">#endif</div><div class="line"></div><div class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class="line">	// The slow path may detect any corruption and halt later.</div><div class="line"></div><div class="line">	// 这里的逻辑和上面类似</div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	// 如果再次寻址到第一个元素 </div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	// goto 3 未命中 跳出循环</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">LLookupEnd$1:</div><div class="line">LLookupRecover$1:</div><div class="line">3:	// double wrap</div><div class="line">	JumpMiss $0</div><div class="line"></div><div class="line">.endmacro</div><div class="line"></div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">通过以上汇编代码分析，可以发现方法缓存的查找是一个从后往前遍历buckets的过程，如果当前遍历到第一个元素，会回到队尾继续遍历，知道找到我们需要的元素，或者在再一次查找到第一个元素后，会退出循环，然后我们看看缓存命中和未命中分别做了啥：</div><div class="line"></div><div class="line">##### 缓存命中</div></pre></td></tr></table></figure>
<p>.macro CacheHit<br>.if $0 == NORMAL<br>    TailCallCachedImp x17, x12, x1, x16    // authenticate and call imp<br>.elseif $0 == GETIMP<br>    mov    p0, p17<br>    cbz    p0, 9f            // don’t ptrauth a nil imp<br>    AuthAndResignAsIMP x0, x12, x1, x16    // authenticate imp and re-sign as IMP<br>9:    ret                // return IMP<br>.elseif $0 == LOOKUP<br>    // No nil check for ptrauth: the caller would crash anyway when they<br>    // jump to a nil IMP. We don’t care if that jump also fails ptrauth.<br>    AuthAndResignAsIMP x17, x12, x1, x16    // authenticate imp and re-sign as IMP<br>    ret                // return imp via x17<br>.else<br>.abort oops<br>.endif<br>.endmacro</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 缓存未命中</div></pre></td></tr></table></figure>
<p>.macro JumpMiss<br>.if $0 == GETIMP<br>    b    LGetImpMiss<br>.elseif $0 == NORMAL<br>    b    <strong>objc_msgSend_uncached<br>.elseif $0 == LOOKUP<br>    b    </strong>objc_msgLookup_uncached<br>.else<br>.abort oops<br>.endif<br>.endmacro</p>
<p>```</p>
<p>都只是根据类型不同调用了对应的方法，这里已经不再是快查询的逻辑，我们暂时不看。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这里先点个题，所谓的快查找就是对cache的查找，与之对应的慢查找就是对method_list的查找了，method_list的查找可能涉及到不同文件的遍历过程，所以会比cache慢很多。通过查看汇编实现，我的主要感受就是对类结构的熟悉是非常重要的，因为所有的查找逻辑都是基于类的结构来的。我们在实际编码过程中，也应该做到庖丁解牛，而不是盲人摸象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/OC方法缓存策略底层探究/" itemprop="url">
                  OC方法缓存策略底层探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-03T16:51:09+08:00" content="2021-01-03">
              2021-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/03/OC方法缓存策略底层探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/03/OC方法缓存策略底层探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="源码结构分析"><a href="#源码结构分析" class="headerlink" title="源码结构分析"></a>源码结构分析</h4><p>我们先来看一下OC类的最新结构定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA;</div><div class="line">    Class superclass;</div><div class="line">    cache_t cache;             // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class="line">    // 函数部分...</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">public:</div><div class="line">    // 函数部分...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的文章中我们分析了bits这个属性，里面存放的就是类的子结构，比如方法，属性，协议等。今天我们再来探究下上面的cache内部的结构和底层原理。</p>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>相信大家对cache都不会陌生，即OC中的方法缓存，在objc_msgSend的流程中，最先查找的就是这个列表，那OC是如何维护这个列表的呢，内部的存储结构又是如何？今天我们就来一探究竟。</p>
<p>之前我们使用lldb调试了bits内部的存储结构，但是这个方式比较繁琐，今天我们换一种简单点的方式来Debug，我们首先镜像一个objc_class结构体，然后对镜像的结构体进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct lly_bucket_t &#123;</div><div class="line">    SEL _sel;</div><div class="line">    IMP _imp;</div><div class="line">&#125;;</div><div class="line">struct lly_cache_t &#123;</div><div class="line">    struct lly_bucket_t * _buckets;</div><div class="line">    uint32_t _mask;</div><div class="line">    uint16_t _flags;</div><div class="line">    uint16_t _occupied;</div><div class="line">&#125;;</div><div class="line">struct lly_class_data_bits_t &#123;</div><div class="line">    Class objc_class;</div><div class="line">    // Values are the FAST_ flags above.</div><div class="line">    uintptr_t bits;</div><div class="line">&#125;;</div><div class="line">struct lly_objc_class &#123;</div><div class="line">    Class ISA;</div><div class="line">    Class superclass;</div><div class="line">    struct lly_cache_t cache;</div><div class="line">    struct lly_class_data_bits_t bits;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void printCache(Class model) &#123;</div><div class="line">    </div><div class="line">    struct lly_objc_class * llyClass = (__bridge struct lly_objc_class *)(model);</div><div class="line">    struct lly_cache_t cache = llyClass-&gt;cache;</div><div class="line">    NSLog(@&quot;_occupied = %d,_mask = %d&quot;,cache._occupied,cache._mask);</div><div class="line">    for (uint32_t i = 0; i &lt; cache._mask; i++) &#123;</div><div class="line">        struct lly_bucket_t bucket = cache._buckets[i];</div><div class="line">        NSLog(@&quot;method : sel = %@, imp = %p&quot;,NSStringFromSelector(bucket._sel),bucket._imp);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">	    // insert code here...</div><div class="line">	    LLYModel *objc2 = [LLYModel alloc];</div><div class="line">	    Class llyClass = [LLYModel class];</div><div class="line">	    printCache(llyClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们不调用任何实例方法，查看打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2021-01-03 15:59:51.995108+0800 LLYObjc[1738:6603344] _occupied = 0,_mask = 0</div></pre></td></tr></table></figure>
<p>可以看到，初始状态都是0，里面的for也没有进 说明当前缓存列表为空。</p>
<p>然后我们分次调用方法并打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        // insert code here...</div><div class="line">        LLYModel *objc2 = [LLYModel alloc];</div><div class="line">        Class llyClass = [LLYModel class];</div><div class="line">        printCache(llyClass);</div><div class="line">        </div><div class="line">        [objc2 fun0];</div><div class="line">        [objc2 fun1];</div><div class="line">        </div><div class="line">        printCache(llyClass);</div><div class="line">                </div><div class="line">        [objc2 fun2];</div><div class="line">        [objc2 fun3];</div><div class="line">        </div><div class="line">        printCache(llyClass);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">2021-01-03 16:05:09.335088+0800 LLYModel[1804:6607181] _occupied = 0,_mask = 0</div><div class="line">2021-01-03 16:05:09.335668+0800 LLYModel[1804:6607181] ---------------------------------------------------------------------------</div><div class="line">2021-01-03 16:05:09.335785+0800 LLYModel[1804:6607181] -[LLYModel fun0]</div><div class="line">2021-01-03 16:05:09.335875+0800 LLYModel[1804:6607181] -[LLYModel fun1]</div><div class="line">2021-01-03 16:05:09.335959+0800 LLYModel[1804:6607181] _occupied = 2,_mask = 3</div><div class="line">2021-01-03 16:05:09.336174+0800 LLYModel[1804:6607181] method : sel = fun1, imp = 0xbf90</div><div class="line">2021-01-03 16:05:09.336245+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.336344+0800 LLYModel[1804:6607181] method : sel = fun0, imp = 0xbfc0</div><div class="line">2021-01-03 16:05:09.336397+0800 LLYModel[1804:6607181] ---------------------------------------------------------------------------</div><div class="line">2021-01-03 16:05:09.336447+0800 LLYModel[1804:6607181] -[LLYModel fun2]</div><div class="line">2021-01-03 16:05:09.336497+0800 LLYModel[1804:6607181] -[LLYModel fun3]</div><div class="line">2021-01-03 16:05:09.336542+0800 LLYModel[1804:6607181] _occupied = 2,_mask = 7</div><div class="line">2021-01-03 16:05:09.336618+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.336737+0800 LLYModel[1804:6607181] method : sel = fun3, imp = 0xbf30</div><div class="line">2021-01-03 16:05:09.336818+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344380+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344554+0800 LLYModel[1804:6607181] method : sel = fun2, imp = 0xbf60</div><div class="line">2021-01-03 16:05:09.344657+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344746+0800 LLYModel[1804:6607181] method : sel = (null), imp = 0x0</div><div class="line">2021-01-03 16:05:09.344833+0800 LLYModel[1804:6607181] ---------------------------------------------------------------------------</div></pre></td></tr></table></figure>
<p>分析打印结果，我们存在几个疑惑的地方：</p>
<ul>
<li>_occupied 和 _mask 分别是什么，为什么调用方法会改变它们的值？</li>
<li>方法的调用顺序和缓存列表的顺序为什么不一致？</li>
<li>当我们调用后面的方法后，前面缓存的方法为什么会丢失？</li>
</ul>
<p>带着上面的问题，我们去源码中看看能不能找到满意的答案。</p>
<h4 id="源码逻辑分析"><a href="#源码逻辑分析" class="headerlink" title="源码逻辑分析"></a>源码逻辑分析</h4><p>通过对<em>occupied</em>关键字的搜索，我们最终定位到下面这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">ALWAYS_INLINE</div><div class="line">void cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)</div><div class="line">&#123;	 </div><div class="line">	// 去掉我们不关系的旁枝末节</div><div class="line"></div><div class="line">    // Use the cache as-is if it is less than 3/4 full</div><div class="line">    // 每次新插入缓存时occupied + 1，这里我们大概就能猜到它的含义了，就是保存当前已缓存方法的数量。</div><div class="line">    mask_t newOccupied = occupied() + 1;</div><div class="line">    unsigned oldCapacity = capacity(), capacity = oldCapacity;</div><div class="line">    </div><div class="line">    // 如果当前缓存列表为空 去创建一个</div><div class="line">    if (slowpath(isConstantEmptyCache())) &#123;</div><div class="line">        // Cache is read-only. Replace it.</div><div class="line">        // INIT_CACHE_SIZE_LOG2 = 2,</div><div class="line">    	 // INIT_CACHE_SIZE      = (1 &lt;&lt; INIT_CACHE_SIZE_LOG2),</div><div class="line">    	 // 看这里，初始的缓存列表的容量是 1 &lt;&lt; 2 = 4。</div><div class="line">        if (!capacity) capacity = INIT_CACHE_SIZE;</div><div class="line">        reallocate(oldCapacity, capacity, /* freeOld */false);</div><div class="line">    &#125;</div><div class="line">    else if (fastpath(newOccupied + CACHE_END_MARKER &lt;= capacity / 4 * 3)) &#123;</div><div class="line">        // Cache is less than 3/4 full. Use it as-is.</div><div class="line">        // (当前缓存列表用到的容量 + 1 ) &lt;= 总容量的四分之三时 说明还够用 啥也不用干</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">    	 // 要扩容了，新的容量大小为当前容量的2倍哦 当然有最大值的限制哈。 </div><div class="line">    	 // 具体扩容逻辑下看面的扩容函数注释</div><div class="line">        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;</div><div class="line">        if (capacity &gt; MAX_CACHE_SIZE) &#123;</div><div class="line">            capacity = MAX_CACHE_SIZE;</div><div class="line">        &#125;</div><div class="line">        reallocate(oldCapacity, capacity, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bucket_t *b = buckets();</div><div class="line">    // _mask = 当前容量 - 1</div><div class="line">    mask_t m = capacity - 1;</div><div class="line">    // 缓存的索引通过这个hash计算 </div><div class="line">    mask_t begin = cache_hash(sel, m);</div><div class="line">    mask_t i = begin;</div><div class="line"></div><div class="line">    // Scan for the first unused slot and insert there.</div><div class="line">    // There is guaranteed to be an empty slot because the</div><div class="line">    // minimum size is 4 and we resized at 3/4 full.</div><div class="line">    do &#123;</div><div class="line">    	 // 如果当前索引没有数据，直接插入</div><div class="line">        if (fastpath(b[i].sel() == 0)) &#123;</div><div class="line">        	  // _occupied++;</div><div class="line">            incrementOccupied();</div><div class="line">            b[i].set&lt;Atomic, Encoded&gt;(sel, imp, cls);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 如果当前索引内存的就是传入的方法，直接返回</div><div class="line">        if (b[i].sel() == sel) &#123;</div><div class="line">            // The entry was added to the cache by some other thread</div><div class="line">            // before we grabbed the cacheUpdateLock.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 否则就是寻找下一个索引</div><div class="line">    &#125; while (fastpath((i = cache_next(i, m)) != begin));</div><div class="line"></div><div class="line">    cache_t::bad_cache(receiver, (SEL)sel, cls);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 初始化和扩容都走这个函数</div><div class="line">ALWAYS_INLINE</div><div class="line">void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld)</div><div class="line">&#123;</div><div class="line">    bucket_t *oldBuckets = buckets();</div><div class="line">    // 分配内存</div><div class="line">    bucket_t *newBuckets = allocateBuckets(newCapacity);</div><div class="line"></div><div class="line">    // Cache&apos;s old contents are not propagated. </div><div class="line">    // This is thought to save cache memory at the cost of extra cache fills.</div><div class="line">    // fixme re-measure this</div><div class="line"></div><div class="line">    ASSERT(newCapacity &gt; 0);</div><div class="line">    ASSERT((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1);</div><div class="line">	</div><div class="line">	// 存储新创建缓存列表 _occupied置0</div><div class="line">    setBucketsAndMask(newBuckets, newCapacity - 1);</div><div class="line">    </div><div class="line">    // 要扩容了 free调旧值</div><div class="line">    if (freeOld) &#123;</div><div class="line">        cache_collect_free(oldBuckets, oldCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当前索引 </div><div class="line">static inline mask_t cache_hash(SEL sel, mask_t mask) </div><div class="line">&#123;</div><div class="line">    return (mask_t)(uintptr_t)sel &amp; mask;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 下一个索引</div><div class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class="line">    return (i+1) &amp; mask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这又是一个内联函数，意味这你在调用堆栈里面是看不到的。但是我们通过源码还是可以Debug进来的。<br>通过以上源码的分析过程，应该能够回答我们上面的疑问了。</p>
<ul>
<li>_occupied表示当前已缓存的的方法数，_mask标识当前缓存列表最大数-1，有新的方法调用_occupied就会更新，缓存列表扩容时_mask会更新。</li>
<li>存储到缓存列表中的方法并不一定是连续的，和具体的hash算法有关。</li>
<li>当缓存列表扩容后，之前缓存过的方法都会被清除，所以会丢失。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当前的探索因为工程比较小，可能还不能看出方法cache的好处，在实际的工程中，方法的调用是大量且频繁的，这时就能体现出方法缓存的实际意义。之前的学习中对方法缓存丢失的逻辑不太了解，经过这次的探索，对整个方法缓存的策略有了更深刻的理解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/OC方法isKindOfClass趣探/" itemprop="url">
                  OC方法isKindOfClass趣探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-03T11:44:27+08:00" content="2021-01-03">
              2021-01-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/03/OC方法isKindOfClass趣探/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/03/OC方法isKindOfClass趣探/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="起"><a href="#起" class="headerlink" title="起"></a>起</h4><p>我们先来看一下下面的一个面试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];       //</div><div class="line">BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];     //</div><div class="line">BOOL re3 = [(id)[LLYModel class] isKindOfClass:[LLYModel class]];       //</div><div class="line">BOOL re4 = [(id)[LLYModel class] isMemberOfClass:[LLYModel class]];     //</div><div class="line">NSLog(@&quot; re1 :%hhd\n re2 :%hhd\n re3 :%hhd\n re4 :%hhd\n&quot;,re1,re2,re3,re4);</div><div class="line"></div><div class="line">BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];       //</div><div class="line">BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     //</div><div class="line">BOOL re7 = [(id)[LLYModel alloc] isKindOfClass:[LLYModel class]];       //</div><div class="line">BOOL re8 = [(id)[LLYModel alloc] isMemberOfClass:[LLYModel class]];     //</div><div class="line">NSLog(@&quot; re5 :%hhd\n re6 :%hhd\n re7 :%hhd\n re8 :%hhd\n&quot;,re5,re6,re7,re8);</div></pre></td></tr></table></figure>
<p>请问输出分别是多少呢？大家可以自己试一试，答案分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">re1 :1</div><div class="line">re2 :0</div><div class="line">re3 :0</div><div class="line">re4 :0</div><div class="line"></div><div class="line">re5 :1</div><div class="line">re6 :1</div><div class="line">re7 :1</div><div class="line">re8 :1</div></pre></td></tr></table></figure>
<h4 id="承"><a href="#承" class="headerlink" title="承"></a>承</h4><p>我们直接看源码进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//直接判断当前类的元类是否和后面的类相等。</div><div class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return self-&gt;ISA() == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//直接判断是不是同一个类对象</div><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用当前类对象的元类的继承链和后面的类对象进行比较，只要后面的类对象在当前元类的继承链中，既判断相等。</div><div class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用当前实例的类对象的继承链和后面的类对象进行比较，只要后面的类在当前类的继承链中，既判断是相等。</div><div class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下上面的判断逻辑大概是这样：</p>
<p>isKindOfClass会使用继承链比较，实例方法使用类对象的继承链，类方法使用元类对象的继承链。<br>isMemberOfClass直接比较，实例方法使用类对象，类方法使用元类对象。</p>
<p>看到这里，不得不再次祭出下面这张图了：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ISA/isa流程图.png" alt=""></p>
<p>我们来瞧瞧元类对象的继承链，根元类的superclass指针指向的是根类，这也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];       //</div></pre></td></tr></table></figure>
<p>这里为什么返回1的原因。</p>
<h4 id="转"><a href="#转" class="headerlink" title="转"></a>转</h4><p>有了以上结论，我们再来Debug一下runtime的代码，看一下这几个函数内部的运行逻辑是否和我们上面的结论一致。</p>
<h5 id="isMemberOfClass-lldb分析"><a href="#isMemberOfClass-lldb分析" class="headerlink" title="isMemberOfClass lldb分析"></a>isMemberOfClass lldb分析</h5><p>先来看看类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];     //</div><div class="line"></div><div class="line">(lldb) x/4gx self //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100888a40 0x0001801000000003</div><div class="line">(lldb) x/4gx cls  //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100888a40 0x0001801000000003</div><div class="line">(lldb) x/4gx 0x000000010034c0f0（ISA） //元类对象也是根源类</div><div class="line">0x10034c0f0: 0x000000010034c0f0 0x000000010034c140</div><div class="line">0x10034c100: 0x0000000100739650 0x0004e03100000007</div></pre></td></tr></table></figure>
<p>这里就很清晰，类对象只有一个，因为他们的首地址和内部变量都相同 ,根元类对象也只有一个，但是和类对象首地址不同，ISA指针相同，这又证明了上图的内容，即根源类的ISA指向自己。根元类和类对象不相等，返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">BOOL re4 = [(id)[LLYModel class] isMemberOfClass:[LLYModel class]];     //</div><div class="line"></div><div class="line">(lldb) x/4gx self //类对象</div><div class="line">0x100008408: 0x00000001000083e0 0x000000010034c140</div><div class="line">0x100008418: 0x0000000100346430 0x0000802400000000</div><div class="line">(lldb) x/4gx cls  //类对象</div><div class="line">0x100008408: 0x00000001000083e0 0x000000010034c140</div><div class="line">0x100008418: 0x0000000100346430 0x0000802400000000</div><div class="line">(lldb) x/4gx 0x00000001000083e0 //元类对象</div><div class="line">0x1000083e0: 0x000000010034c0f0 0x000000010034c0f0</div><div class="line">0x1000083f0: 0x00000001007396d0 0x0002e03500000003</div><div class="line">(lldb) x/4gx 0x000000010034c0f0 //根源类对象</div><div class="line">0x10034c0f0: 0x000000010034c0f0 0x000000010034c140</div><div class="line">0x10034c100: 0x0000000100739650 0x0004e03100000007</div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>因为是自定义的类，所以会有一个元类对象，元类对象isa指向上面的根元类，元类和类对象不相等，返回0，没有问题。</p>
<p>然后我们来看看实例方法，<strong>实例对象的内存分析和类对象有一点区别，请注意！！！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     //</div><div class="line"></div><div class="line">(lldb) x/4gx self //实例对象</div><div class="line">0x100629c30: 0x001d80010034c141 0x0000000000000000</div><div class="line">0x100629c40: 0x00007fff7ba35c58 0x00000000e642baab</div><div class="line">(lldb) x/4gx cls  //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100629c80 0x0001801000000007</div><div class="line">(lldb) p/x 0x001d80010034c141 &amp; 0x00007ffffffffff8ULL //这里是重要，实例对象的isa指针是nonpointer_isa 如果想要拿到类对象信息，需要带个面具。！！！</div><div class="line">(unsigned long long) $40 = 0x000000010034c140</div><div class="line">(lldb) x/4gx 0x000000010034c140 //类对象</div><div class="line">0x10034c140: 0x000000010034c0f0 0x0000000000000000</div><div class="line">0x10034c150: 0x0000000100629c80 0x0001801000000007</div></pre></td></tr></table></figure>
<p>在分析前，我们先回到源码部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self class]</div></pre></td></tr></table></figure>
<p>怎么理解呢？</p>
<p>实际上分两种情况：</p>
<ul>
<li>当self是实例对象时，class是实例方法，返回isa指针，也就是类对象</li>
<li>当self是类或者元类对象时，class是类方法，返回自己。</li>
</ul>
<p>所以上面我需要拿到self的isa指向的内存，但是self的isa不能直接打印内存，因为nonpointer_isa对isa进行了优化，存储很多其他的信息，我们需要先使用面具过滤掉其他不需要的信息，才能拿到isa中存储的类对象地址。从lldb打印情况可以看到，self实例对象的isa指向的就是类对象，所以这里返回1.</p>
<p>re8的分析过程和re6相似，就不再重复劳动了。</p>
<h5 id="特殊的isKindOfClass"><a href="#特殊的isKindOfClass" class="headerlink" title="特殊的isKindOfClass"></a>特殊的isKindOfClass</h5><p>为什么要加上【特殊】这个前缀呢，原因很简单，isKindOfClass里面的断点根本没有进去，可见runtime内部对这个方法的调用可能走的就不是我们上面的实现，这种情况我们之前在alloc的分析过程中也遇到过，所以不要慌。经过在源码中一番搜索，我们最终找到下面这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// Calls [obj isKindOfClass]</div><div class="line">BOOL</div><div class="line">objc_opt_isKindOfClass(id obj, Class otherClass)</div><div class="line">&#123;</div><div class="line">#if __OBJC2__</div><div class="line">    if (slowpath(!obj)) return NO;</div><div class="line">    Class cls = obj-&gt;getIsa();</div><div class="line">    if (fastpath(!cls-&gt;hasCustomCore())) &#123;</div><div class="line">        for (Class tcls = cls; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">            if (tcls == otherClass) return YES;</div><div class="line">        &#125;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    return ((BOOL(*)(id, SEL, Class))objc_msgSend)(obj, @selector(isKindOfClass:), otherClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部的判断逻辑和我们上面看到的源码一样，所有我们可以在这个函数中进行debug了，不过这个debug过程已经不是重点了，重点是为什么会走到这个函数里面，上面的函数又是什么时候调用，因为有了之前的经验，我们直接去llvm中看能否寻找的一些答案。</p>
<p>果不其然，我们在llvm的源码中发现了这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// This is the table of ObjC &quot;accelerated dispatch&quot; functions.  They are a set</div><div class="line">// of objc methods that are &quot;seldom overridden&quot; and so the compiler replaces the</div><div class="line">// objc_msgSend with a call to one of the dispatch functions.  That will check</div><div class="line">// whether the method has been overridden, and directly call the Foundation </div><div class="line">// implementation if not.  </div><div class="line">// This table is supposed to be complete.  If ones get added in the future, we</div><div class="line">// will have to add them to the table.</div><div class="line">const char *AppleObjCTrampolineHandler::g_opt_dispatch_names[] = &#123;</div><div class="line">    &quot;objc_alloc&quot;,</div><div class="line">    &quot;objc_autorelease&quot;,</div><div class="line">    &quot;objc_release&quot;,</div><div class="line">    &quot;objc_retain&quot;,</div><div class="line">    &quot;objc_alloc_init&quot;,</div><div class="line">    &quot;objc_allocWithZone&quot;,</div><div class="line">    &quot;objc_opt_class&quot;,</div><div class="line">    &quot;objc_opt_isKindOfClass&quot;,</div><div class="line">    &quot;objc_opt_new&quot;,</div><div class="line">    &quot;objc_opt_respondsToSelector&quot;,</div><div class="line">    &quot;objc_opt_self&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在注释中，我们发现了【加速派发】，【不常重写】等字样，这里我们大胆猜测就是llvm在底层为了优化方法的调用速度，对下面列表中的方法做了优化，会优先进到这些优化方法中去，如果我们重写isKindOfClass等方法，可能才会进入之前我们看到的函数中去。</p>
<p>ok 来尝试一下我们的猜测，很简单，我们只需要重写一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isKindOfClass:(Class)aClass &#123;</div><div class="line">    return [super isKindOfClass:aClass];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isKindOfClass:(Class)aClass &#123;</div><div class="line">    return [super isKindOfClass:aClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，在我们重写之后，之前的断点就生效了，完美！！！</p>
<h4 id="合"><a href="#合" class="headerlink" title="合"></a>合</h4><p>源码的探索过程还是比较有趣的，不过如果你找不到正确的方法的话，可能跟到一个方法后就很难再深入进入，导致直接放弃，打击学习的积极性，所以还是要多看多学，不断积累才行啊。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/02/借助lldb探究OC类结构的底层实现/" itemprop="url">
                  借助lldb探究OC类结构的底层实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-02T21:12:55+08:00" content="2021-01-02">
              2021-01-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/02/借助lldb探究OC类结构的底层实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/02/借助lldb探究OC类结构的底层实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="类结构源码"><a href="#类结构源码" class="headerlink" title="类结构源码"></a>类结构源码</h4><p>我们先来看一下runtime中类的结构定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">//下面的函数部分去掉 因为不影响类结构</div><div class="line">//...</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA; // 8字节</div><div class="line">    Class superclass; // 8字节</div><div class="line">    cache_t cache;    // 16字节         // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits; //这里存的就是类的主要结构    // class_rw_t * plus custom rr/alloc flags</div><div class="line">    </div><div class="line">    // 具体结构体数据</div><div class="line">    class_rw_t *data() const &#123;</div><div class="line">        return bits.data();</div><div class="line">    &#125;</div><div class="line">    void setData(class_rw_t *newData) &#123;</div><div class="line">        bits.setData(newData);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //下面的函数部分去掉 因为不影响类结构</div><div class="line">	//...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的结构体定义可以看出，每一个类的第一个属性都会是一个isa指针，然后是super和cache,之后的bits里面就是类的结构，我们需要使用llbd命令Debug bits内部的内存分配情况，在开始探究之前，我们可以先熟悉下bits中包含的主要数据结构，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">struct class_rw_t &#123;</div><div class="line">   </div><div class="line">   	 // 去掉了一些不关心的函数 只留下比较关心的下面这几个数据</div><div class="line">    </div><div class="line">    // 只读部分</div><div class="line">    const class_ro_t *ro() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (slowpath(v.is&lt;class_rw_ext_t *&gt;())) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;ro;</div><div class="line">        &#125;</div><div class="line">        return v.get&lt;const class_ro_t *&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void set_ro(const class_ro_t *ro) &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            v.get&lt;class_rw_ext_t *&gt;()-&gt;ro = ro;</div><div class="line">        &#125; else &#123;</div><div class="line">            set_ro_or_rwe(ro);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    const method_array_t methods() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;methods;</div><div class="line">        &#125; else &#123;</div><div class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseMethods()&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const property_array_t properties() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;properties;</div><div class="line">        &#125; else &#123;</div><div class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProperties&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const protocol_array_t protocols() const &#123;</div><div class="line">        auto v = get_ro_or_rwe();</div><div class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</div><div class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;protocols;</div><div class="line">        &#125; else &#123;</div><div class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProtocols&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们熟悉的函数列表，属性列表和协议列表都在其中，下面我们就通过内存堆栈的Debug来证明下上面的类结构。</p>
<h4 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h4><p>在开始探索前，我们先来看一下这张图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ISA/isa流程图.png" alt=""></p>
<p>这里有一个知识点我们需要了解，一个类（不考虑继承）在内存中会存在3种与它有关联的对象，分别是实例对象，类对象和元类对象，这3种对象通过isa指针进行关联，实例对象可能存在多个，类对象和元类对象是唯一的。其中类对象存储实例方法和属性，元类对象存储类方法。</p>
<h4 id="开始探究"><a href="#开始探究" class="headerlink" title="开始探究"></a>开始探究</h4><p>我们先来自定义一个简单的类，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface LLYModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *name;</div><div class="line"></div><div class="line">- (void)sayHey;</div><div class="line"></div><div class="line">+ (void)sayBey;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation LLYModel &#123;</div><div class="line">    int _age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sayHey&#123;&#125;</div><div class="line"></div><div class="line">+ (void)sayBey&#123;&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        // insert code here...</div><div class="line">        LLYModel *objc2 = [LLYModel alloc];</div><div class="line">        objc2.name      = @&quot;lly&quot;;</div><div class="line">        NSLog(@&quot;Hello, World!  %@&quot;,objc2.name);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h5><p>在主函数中我们简单创建一个上面的model实例，然后就可以断点调试了,首先我们查看实例对象的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/4gx objc2</div><div class="line">0x1006a8a20: 0x001d8001000083ed 0x0000000000000000</div><div class="line">0x1006a8a30: 0x0000000100004018 0x0000000000000000</div></pre></td></tr></table></figure>
<p>根据对源码的分析，我们知道bits数据存储在首地址偏移32个字节的地方，so我们这样访问bits的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) p (class_data_bits_t *)0x1006a8a40</div><div class="line">(class_data_bits_t *) $94 = 0x00000001006a8a40</div></pre></td></tr></table></figure>
<p>拿到bits的地址后，然后访问改结构体的data方法拿到class_rw_t数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(lldb) p $94-&gt;data()</div><div class="line">(class_rw_t *) $97 = 0x00007fff97ca45c0</div><div class="line">(lldb) p *$97</div><div class="line">(class_rw_t) $98 = &#123;</div><div class="line">  flags = 2546615872</div><div class="line">  witness = 32767</div><div class="line">  ro_or_rw_ext = &#123;</div><div class="line">    std::__1::atomic&lt;unsigned long&gt; = &#123;</div><div class="line">      Value = 140735591042296</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  firstSubclass = 0x0000000100346430</div><div class="line">  nextSiblingClass = 0x0000800000000000</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以访问该结构内部的相关方法获取数据了，比如方法列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(lldb) p $98.methods()</div><div class="line">(const method_array_t) $99 = &#123;</div><div class="line">  list_array_tt&lt;method_t, method_list_t&gt; = &#123;</div><div class="line">     = &#123;</div><div class="line">      list = 0x0000000102004ee0</div><div class="line">      arrayAndFlag = 4328541920</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $99.list</div><div class="line">(method_list_t *const) $100 = 0x0000000102004ee0</div><div class="line">(lldb) p *$100</div><div class="line">(method_list_t) $101 = &#123;</div><div class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</div><div class="line">    entsizeAndFlags = 2148007936</div><div class="line">    count = 0</div><div class="line">    first = &#123;</div><div class="line">      name = &quot;\x10&quot;</div><div class="line">      types = 0x00007fff97ca45c0 &quot;@Fʗ</div><div class="line">      imp = 0x00007fff8ee94d20 ((void *)0x00007fff8ee959a0: __NSStackBlock)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过查看内存情况，发现方法列表内部的count为0，说明方法并未存放在实例对象中。</p>
<p>然后看看属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) p $98.properties()</div><div class="line">(const property_array_t) $102 = &#123;</div><div class="line">  list_array_tt&lt;property_t, property_list_t&gt; = &#123;</div><div class="line">     = &#123;</div><div class="line">      list = 0x0000001000000000</div><div class="line">      arrayAndFlag = 68719476736</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $102.list</div><div class="line">(property_list_t *const) $103 = 0x0000001000000000</div><div class="line">(lldb) p *$103</div><div class="line">error: Couldn&apos;t apply expression side effects : Couldn&apos;t dematerialize a result variable: couldn&apos;t read its memory</div></pre></td></tr></table></figure>
<p>属性列表访问失败，说明也是没有数据的。</p>
<h5 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h5><p>然后我们再来看看类对象中的内存情况，这里我们先拿到类对象的首地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/4gx LLYModel.class</div><div class="line">0x1000083e8: 0x00000001000083c0 0x000000010034c140</div><div class="line">0x1000083f8: 0x00000001006ace60 0x0004802400000007</div></pre></td></tr></table></figure>
<p>上面也提到过，类对象是唯一的，所以可以这样访问，其他步骤都差不多就不在重复粘贴，这里只放最后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">(method_list_t) $117 = &#123;</div><div class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</div><div class="line">    entsizeAndFlags = 26</div><div class="line">    count = 4</div><div class="line">    first = &#123;</div><div class="line">      name = &quot;sayHey&quot;</div><div class="line">      types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">      imp = 0x0000000100003da0 (KCObjc`-[LLYModel sayHey])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(0)</div><div class="line">(method_t) $118 = &#123;</div><div class="line">  name = &quot;sayHey&quot;</div><div class="line">  types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">  imp = 0x0000000100003da0 (KCObjc`-[LLYModel sayHey])</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(1)</div><div class="line">(method_t) $119 = &#123;</div><div class="line">  name = &quot;.cxx_destruct&quot;</div><div class="line">  types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">  imp = 0x0000000100003e00 (KCObjc`-[LLYModel .cxx_destruct])</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(2)</div><div class="line">(method_t) $120 = &#123;</div><div class="line">  name = &quot;name&quot;</div><div class="line">  types = 0x0000000100003f87 &quot;@16@0:8&quot;</div><div class="line">  imp = 0x0000000100003db0 (KCObjc`-[LLYModel name])</div><div class="line">&#125;</div><div class="line">(lldb) p $117.get(3)</div><div class="line">(method_t) $121 = &#123;</div><div class="line">  name = &quot;setName:&quot;</div><div class="line">  types = 0x0000000100003f8f &quot;v24@0:8@16&quot;</div><div class="line">  imp = 0x0000000100003dd0 (KCObjc`-[LLYModel setName:])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了我们定义的实例方法外，还看到了属性的get和set方法，还有一个编译器默认添加的析构方法。接着是属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(property_list_t) $124 = &#123;</div><div class="line">  entsize_list_tt&lt;property_t, property_list_t, 0&gt; = &#123;</div><div class="line">    entsizeAndFlags = 16</div><div class="line">    count = 1</div><div class="line">    first = (name = &quot;name&quot;, attributes = &quot;T@\&quot;NSString\&quot;,&amp;,N,V_name&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个我们定义的name属性。</p>
<h5 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h5><p>最后我们来看看元类的内存分配情况，首先我们拿到元类的首地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/4gx objc_getMetaClass(object_getClassName(objc2))</div><div class="line">0x1000083c0: 0x000000010034c0f0 0x000000010034c0f0</div><div class="line">0x1000083d0: 0x000000010200d880 0x0004e03500000007</div></pre></td></tr></table></figure>
<p>方法列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(method_list_t) $135 = &#123;</div><div class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</div><div class="line">    entsizeAndFlags = 26</div><div class="line">    count = 1</div><div class="line">    first = &#123;</div><div class="line">      name = &quot;sayBey&quot;</div><div class="line">      types = 0x0000000100003f9a &quot;v16@0:8&quot;</div><div class="line">      imp = 0x0000000100003d90 (KCObjc`+[LLYModel sayBey])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>元类中存放了我们上面定义的一个类方法</p>
<p>属性列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) p $132.properties()</div><div class="line">(const property_array_t) $136 = &#123;</div><div class="line">  list_array_tt&lt;property_t, property_list_t&gt; = &#123;</div><div class="line">     = &#123;</div><div class="line">      list = 0x0000000000000000</div><div class="line">      arrayAndFlag = 0</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">(lldb) p $136.list</div><div class="line">(property_list_t *const) $137 = 0x0000000000000000</div><div class="line">(lldb) p *$137</div><div class="line">error: Couldn&apos;t apply expression side effects : Couldn&apos;t dematerialize a result variable: couldn&apos;t read its memory</div></pre></td></tr></table></figure>
<p>元类中没有存放属性。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上的探索过程，证明了我们之前的结论<strong>其中类对象存储实例方法和属性，元类对象存储类方法。</strong>，通过源码+lldb相结合的方式，可以更好的证明我们已知的一些结论。也给我们探索更广阔的空间提供了可能。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/" itemprop="url">
                  从【class_getInstanceSize方法】探究iOS的内存分配策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-01-01T21:39:15+08:00" content="2021-01-01">
              2021-01-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/01/从【class-getInstanceSize方法】探究iOS的内存分配策略/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="先抛问题"><a href="#先抛问题" class="headerlink" title="先抛问题"></a>先抛问题</h4><p>各位看官请看下面两种case的输出分别是多少：</p>
<h5 id="case1"><a href="#case1" class="headerlink" title="case1:"></a>case1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@interface LLYModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, copy) NSString *nickName;</div><div class="line">@property (nonatomic, assign) int age;</div><div class="line">@property (nonatomic, assign) long height;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">LLYModel *objc = [LLYModel alloc];</div><div class="line">objc.name = @&quot;lly&quot;;</div><div class="line">objc.nickName = @&quot;123&quot;;</div><div class="line">objc.age = 18;</div><div class="line">objc.height = 180;</div><div class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,objc,sizeof(objc),class_getInstanceSize([LLYModel class]),malloc_size((__bridge const void *)(objc)));</div></pre></td></tr></table></figure>
<h5 id="case2"><a href="#case2" class="headerlink" title="case2:"></a>case2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface LLYModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, copy) NSString *nickName;</div><div class="line">@property (nonatomic, assign) int age;</div><div class="line">@property (nonatomic, assign) long height;</div><div class="line">@property (nonatomic, assign) long weight;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">LLYModel *objc = [LLYModel alloc];</div><div class="line">objc.name = @&quot;lly&quot;;</div><div class="line">objc.nickName = @&quot;123&quot;;</div><div class="line">objc.age = 18;</div><div class="line">objc.height = 180;</div><div class="line">objc.weight = 180;</div><div class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,objc,sizeof(objc),class_getInstanceSize([LLYModel class]),malloc_size((__bridge const void *)(objc)));</div></pre></td></tr></table></figure>
<p>可以先分析一下打印情况，我这里直接上结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">case1:&lt;LLYModel: 0x1006cf490&gt; - 8 - 40 - 48</div><div class="line">case2:&lt;LLYModel: 0x1006cf490&gt; - 8 - 48 - 48</div></pre></td></tr></table></figure>
<p>这就有点意思了，class_getInstanceSize获取到的大小并不完全和对象的真实大小完全一致，通过对相关源码的探究，最终发现了原因，这里先上结论：</p>
<p><strong>class_getInstanceSize获取的大小是根据8字节对齐计算，而内存的实际分配策略是根据16字节对齐计算</strong></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们首先来看看runtime中class_getInstanceSize的实现，通过调用栈的追踪，最终定位到下面几个比较重要的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Class&apos;s ivar size rounded up to a pointer-size boundary. </div><div class="line">// 这里返回类的实例变量的大小 因为只有实例变量是存放在类对象中的。</div><div class="line">uint32_t alignedInstanceSize() const &#123;</div><div class="line">    return word_align(unalignedInstanceSize());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// May be unaligned depending on class&apos;s ivars.</div><div class="line">// 未对齐的实例变量的大小</div><div class="line">uint32_t unalignedInstanceSize() const &#123;</div><div class="line">    ASSERT(isRealized());</div><div class="line">    return data()-&gt;ro()-&gt;instanceSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#ifdef __LP64__</div><div class="line">#   define WORD_SHIFT 3UL</div><div class="line">#   define WORD_MASK 7UL</div><div class="line">#   define WORD_BITS 64</div><div class="line">#else</div><div class="line">#   define WORD_SHIFT 2UL</div><div class="line">#   define WORD_MASK 3UL</div><div class="line">#   define WORD_BITS 32</div><div class="line">#endif</div><div class="line"></div><div class="line">// 64位下8字节对齐 32位下4字节对齐 </div><div class="line">static inline uint32_t word_align(uint32_t x) &#123;</div><div class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上几个函数的调用，就可以验证上面的结论<strong>class_getInstanceSize是以8字节对齐的</strong>，<br>在上面的函数中，我们还发现了一个很熟悉的身影，就是下面这个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class_ro_t *ro()</div></pre></td></tr></table></figure>
<p>我们知道，这里面的数据都是只读数据，是在程序编译期就决定了的，我们常用的实例变量就存放在这个结构体中，这也是为什么类在初始化后不能再动态添加实例变量的原因。</p>
<p>然后我们再来看看类的创建过程，还是从源码入手，不过内存创建的函数调用栈比较复杂，我画个简单的流程图来表示下先：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Alloc分析/alloc01.png" alt=""></p>
<p>在runtime库中，这个调用堆栈跟到最后两个标黄部分就进不去了，不过我们还是通过一些细节找到了这两个函数的出处，并最终定位到了负责内存分配过程中size计算的函数，该部分代码位于libsystem_malloc库中，具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static MALLOC_INLINE size_t</div><div class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</div><div class="line">&#123;</div><div class="line">	size_t k, slot_bytes;</div><div class="line"></div><div class="line">	//最小16字节</div><div class="line">	if (0 == size) &#123;</div><div class="line">		size = NANO_REGIME_QUANTA_SIZE; // Historical behavior </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//先加上16个字节 然后抹掉零头</div><div class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta </div><div class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;							// multiply by power of two quanta size</div><div class="line">	*pKey = k - 1;													// Zero-based!</div><div class="line"></div><div class="line">	return slot_bytes;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#define NANO_MAX_SIZE			256 /* Buckets sized &#123;16, 32, 48, ..., 256&#125; */</div><div class="line">#define SHIFT_NANO_QUANTUM		4</div><div class="line">#define NANO_REGIME_QUANTA_SIZE	(1 &lt;&lt; SHIFT_NANO_QUANTUM)	// 16</div><div class="line">#define NANO_QUANTA_MASK		(NANO_REGIME_QUANTA_SIZE - 1)</div><div class="line">#define NANO_SIZE_CLASSES		(NANO_MAX_SIZE/NANO_REGIME_QUANTA_SIZE)</div></pre></td></tr></table></figure>
<p>通过以上源码也证明了上面的结论<strong>内存的实际分配策略是根据16字节对齐计算</strong></p>
<h4 id="补充部分"><a href="#补充部分" class="headerlink" title="补充部分"></a>补充部分</h4><p>因为iOS中的类本质上都是结构体，所以他们的内存大小应该也需要满足c语言中结构体对齐的原则，这里简单介绍下c语言中如何进行字节对齐：</p>
<h5 id="内部对齐"><a href="#内部对齐" class="headerlink" title="内部对齐"></a>内部对齐</h5><p>即结构体内部变量的起始地址需要是变量自身大小的倍数。具体对齐逻辑参考下图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Alloc分析/alig.png" alt=""></p>
<h5 id="外部对齐"><a href="#外部对齐" class="headerlink" title="外部对齐"></a>外部对齐</h5><p>即结构体的整体大小需要和当前运行环境的字对齐。</p>
<p><strong>这里还有一个知识点需要提及，为了更高效的利用内存，xcode编译器会对实例变量进行重排序，这个在我上面的LLYModel中并未体现，感兴趣的同学可以自行实验</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上就是这次对iOS类分配内存大小探索的全部内容，首先是发现问题，然后通过源码的分析找到问题产生的原因，中间的探索过程一度中断，不过最后还是通过一些小的线索定位到问题的所在，在源码分析过程中，我们应该做到抓住关键问题，忽略干扰条件，多一些细心和耐心。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/04/架构设计的一些思考/" itemprop="url">
                  架构设计的一些思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-07-04T17:21:34+08:00" content="2020-07-04">
              2020-07-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/07/04/架构设计的一些思考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/04/架构设计的一些思考/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从宏观上看，计算机系统整体上都是一种分层的架构设计，从网络的五层协议到分布式系统；从操作系统到应用软件。架构设计要解决的核心问题就是如何分层，层与层之间以及同层之前如何去交互的问题。在我们着手去做分层架构和通信设计之前，我们可能还需要一些设计理论和原则的支撑，历史一次次证明，如果只是全凭实践经验，我们是无法成功设计出一款好的产品的。（比如飞机的发明，飞行器古代就已经出现，但是现代意义上的飞机直到空气动力学理论出现后才由莱特兄弟设计制造出来，这样的例子在科技史上还有很多）这里我总结了三个部分：模块设计原则，设计模式的应用和重构原则。</p>
<h3 id="模块设计原则"><a href="#模块设计原则" class="headerlink" title="模块设计原则"></a>模块设计原则</h3><p>模块设计原则就是做架构的理论基础，只有熟练掌握以下这些原则，你在着手软件架构时才能得心应手，信手拈来，设计出更合理的架构，就好比有了九阳神功的张无忌再去修炼乾坤大挪移。</p>
<h4 id="单一职能原则SRP"><a href="#单一职能原则SRP" class="headerlink" title="单一职能原则SRP"></a>单一职能原则SRP</h4><p>单一职能原则强调一个模块或者一个类只应该有一种行为，也只能对一种行为负责，比如负责UI展示的类，就不要在内部去处理业务逻辑，负责业务逻辑的类，则内部必要去修改UI布局等。这个原则在MVVM的模式中被广泛采用。</p>
<h4 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h4><p>开闭原则指类或者模块应该易于扩展，而难以修改。要遵守该原则，我们在设计模块时就要尽量设计“害羞”的代码，隐藏自己的大部分行为，只将必要的接口暴露给外部，并且尽量只暴露只读的接口，不要暴露能够修改内部属性的接口，这是难以修改部分，那易于扩展部分，我们应该预留适当的钩子接口，该钩子可以扩展类的行为，将该行为的实现交于外部去处理。</p>
<h4 id="里斯替换原则LSP"><a href="#里斯替换原则LSP" class="headerlink" title="里斯替换原则LSP"></a>里斯替换原则LSP</h4><p>里斯替换也是描述的接口扩展问题，但是和开闭描述的场景又不太一样，里斯替换更像工厂，一个接口的具体行为不依赖该类，而依赖其扩展类，该接口的行为可以很容易被其扩展类替换。</p>
<h4 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h4><p>接口隔离很重要，但是经常被忽视，只有正在懂的人才会在模块封装的过程中采用这个原则，大部分人则无视该原则的好处，只是为了代码写起来更方便。我们是封装系统库和三方库时，往往会使用该原则去对系统方法做一层隔离，但是大部分也仅仅只是做到了这一层，选择忽略更上层的情况。其实对更上层的业务实体来说，每一个实体都应该再加一层的隔离，这样做的利大于弊，模块的职能划分的越清晰，维护和扩展的成本就会越低。</p>
<h4 id="依赖反转原则DIP"><a href="#依赖反转原则DIP" class="headerlink" title="依赖反转原则DIP"></a>依赖反转原则DIP</h4><p>该原则主要解决模块间比较常见的相互依赖的问题，相互依赖的坏处这里不再多描述，依赖反转将双向或者多向的依赖关系梳理为单向的依赖关系，依赖反转的工具常常使用抽象接口去实现。</p>
<h4 id="组件聚合原则"><a href="#组件聚合原则" class="headerlink" title="组件聚合原则"></a>组件聚合原则</h4><p>组件聚合原则主要介绍在做组件封装时类的归属问题，哪些类应该放入一个组件，哪些又不应该放入一个组件内，该原则主要包括以下三部分：</p>
<ul>
<li><p>复用/发布等同原则 </p>
<p>  该原则指组件中的类和模块应该是可以共同发布，也能被其他组件共同复用的，即该组件中的类应该具有紧密的关系和共同的主题，而不是毫不相干的内容。</p>
</li>
<li><p>共同闭包原则</p>
<p>  一个组件中的各类应该是会因为同一个行为而被一起修改的，如果有一些独善其身的类，那说明该类可能并不适合该组件，应该将其剥离该组件。</p>
</li>
<li><p>共同复用原则</p>
<p>  一个组件中的类应该是可以被外部共同复用的，而不应该存在只需要复用一部分的情况，一个组件应该是不可再拆分的。</p>
</li>
</ul>
<h4 id="组件解耦原则"><a href="#组件解耦原则" class="headerlink" title="组件解耦原则"></a>组件解耦原则</h4><p>该原则主要介绍组件内部或者组件之间的关系。</p>
<ul>
<li>无依赖环原则，这个上面已经介绍过（DIP）.</li>
<li><p>稳定依赖原则：</p>
<p>  这里先介绍什么是<strong>模块的稳定性</strong>，一个模块被其他模块依赖称为<em>入口依赖</em>,该模块依赖其他模块称为<em>出口依赖</em>，入口依赖越多，该模块就越稳定。</p>
<p>  组件之间的依赖关系应该是从不稳定指向稳定方向的。这里已一个分层组件举例的话，越上层的组件，应该是越不稳定，因为它依赖了太多其他组件，越底层的组件，应该越稳定，因为它几乎只被其他组件依赖，分层组件的依赖关系应该是自顶向下的单向依赖。</p>
</li>
<li><p>稳定抽象原则：</p>
<p>  抽象这个概念应该都知道，这里已接口举例，一个接口就是一个抽象方法。稳定抽象原则是指一个组件的稳定性应该和它的抽象性保持一致。</p>
<p>  这里又要解释一下<strong>抽象性的概念</strong>，组件中的抽象类和抽象方法 / 组件中的实现类和实现方法 = 组件的抽象性。其实很好理解，抽象类和抽象方法越多，表示该组件越抽象。</p>
<p>  既然稳定性和抽象性要保持一致，还是按上面的分层组件举例，就可以解释为：越是上层的组件应该越具体，越是底层的组件应该越抽象。    </p>
</li>
</ul>
<h3 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h3><p>设计模式在代码中角色很奇妙，有的人可能根据自身经验采用了许多设计模式而不自知，其实设计模式本身也是从实践和经验中总结出来的一套代码设计的真理，了解并应用这些设计模式，在模块和架构设计过程中是必不可少的。</p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>创建型设计模式这里重点介绍抽象工厂和工厂模式，工厂模式比较单一，一次只能生产一种对象，抽象工厂在工厂的基础上做了扩展，可同时生产多个对象。</p>
<p>考虑下面这种情况：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/架构设计的一些思考/factory.png" alt=""></p>
<p>这个活动目前有5种类型，我们在展示UI时可以选择创建5种cell去分别适配，如果以后还有类型的扩展再新建cell,但是这种方案会造成子类爆炸，也贡献了大量的重复代码，更好的方案是新建一个类型的抽象工厂，抽象工厂提供变化的UI元素的生成接口（设计模式的核心就是对变化的概念进行抽象），具体生成逻辑放到工厂实体类进行。这样就只需要一个cell和一个抽象工厂实体即可完全展示，后续扩展也更方便。整体类结构大概长这样：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/架构设计的一些思考/activity.png" alt=""></p>
<p>其他的创建型设计模式比如原型描述的是对象的复用（clone），单例则是对象的共享，生成器一般用在比较复杂的对象创建上，比如这个对象由很多子对象组成，如一个订单等。</p>
<h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p><strong>结构型设计模式主要描述如何组合类和对象的行为已获得更大的结构</strong></p>
<p>适配器模式主要描述如何对类和对象的行为进行扩展，方式主要是依赖和继承。iOS中还可以通过协议和消息转发扩展类。</p>
<p>桥接有点像抽象工厂，基类只提供行为接口，具体的行为逻辑放到实体类进行。这种设计方便了对行为进行替换和扩展。</p>
<p>组合是同一个类型的集合，方便统一处理一些行为，iOS中的subviews集合就是一个典型的组合模式的应用。</p>
<p>装饰其实也是在给类添加属性或者方法，iOS中的分类就是装饰模式的应用。</p>
<p>外观是将一系列相关联的方法进行封装，然后提供一个统一的入口。编译器的封装采用了外观模式,将整个编译链进行封装，隐藏内部过程，只提供一个统一的api供外部调用.</p>
<p>享元模式有点类似上面的原型，只是享元复用的对象可能颗粒度更细，而且只是内部数据，内部数据是不变的，外部数据是可变的。</p>
<p>代理模式比较好理解，类的某个行为自己不去实现，而是交给另一个代理类去实现，代理模式可以用来解耦模块间的相互依赖。</p>
<h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><p><strong>行为型设计模式具体描述算法和对象之间职能的分配方式</strong></p>
<p>责任链模式描述组合对象对同一方法的调用情况，强调每个对象都有机会去处理改方法，具体实现逻辑可以参考iOS响应链传递机制中hitTest方法的处理。</p>
<p>命令模式将用户的行为进行封装，每一个行为都抽象为一个命令，使用命令队列进行维护，该模式主要应用于编辑软件中redo和undo操作的支持。</p>
<p>解释器模式对特定的语法进行解释，这些语法往往比较复杂且多变，如果直接使用比较麻烦，比如正则表达式的匹配，就需要使用专门的解释器。</p>
<p>迭代器模式主要来用进行集合的访问，在无需暴露集合内部具体结构的情况下。不同的遍历策略对应不同的迭代器类，即多态迭代。编程语言一般都有自己的集合迭代器。</p>
<p>中介者模式为各类之间的交互提供一个环境，避免各类因为相互调用而产生双向依赖。将与其他类的通信转变为和中介者的通信。</p>
<p>备忘录模式是一种数据持久化的应用，当我们需要保存对象信息时，通过将对象持久化本地，下次需要使用时直接从本地获取。</p>
<p>观察者模式提供了一种方式，保证依赖同一属性的多个类的一致性。通过注册对这个属性的观察回调，在这个属性改变时，可以很方便的通知这些依赖类。观察者模式是一对多的通信方式。iOS中的通知和KVO都属于这种模式。</p>
<p>状态模式用来解决对象在不同的时间节点时有不同行为的场景。我们可以将不同的时间节点抽象为不同的状态，通过对状态的观察改变对象的行为。tcp的建连和断开的过程就是应用的状态模式。</p>
<p>策略模式和状态模式相似，不同的是对象在各时间节点需要调用不同的算法，这里我们将变化的概念抽象为策略，每一种算法对应一种策略。</p>
<p>模板方法将基类的逻辑复用，而将具体的数据等属性延迟到子类实现。这样子类在继承父类的逻辑的同时还能拥有自己的行为。模板方法是基类预留的钩子，能够钩住子类的特定行为。</p>
<p>访问者模式提供了一种访问类簇对象的解决方案。可以将访问行为抽象为访问者，每一种具体行为对应具体的一个访问者类，该访问者为类簇中每一个类添加一个该行为的访问方法。如果以后有新的访问行为，在不修改类簇结构的情况下，即可通过扩展访问者来实现。</p>
<h3 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h3><h4 id="类的重构"><a href="#类的重构" class="headerlink" title="类的重构"></a>类的重构</h4><h4 id="函数的重构"><a href="#函数的重构" class="headerlink" title="函数的重构"></a>函数的重构</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/30/《软技能-代码之外的生存指南-职业篇》读书笔记/" itemprop="url">
                  《软技能-代码之外的生存指南-职业篇》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-06-30T22:48:16+08:00" content="2020-06-30">
              2020-06-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/06/30/《软技能-代码之外的生存指南-职业篇》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/30/《软技能-代码之外的生存指南-职业篇》读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h3><p>该部分讲述程序员职业规划相关内容，比如对待工作的态度，长远的职业目标，同事间的相处之道，面试之道等等内容。核心点是如何获得更好的职业生涯。</p>
<h4 id="从非同凡响开始：绝不要做他人都在做的事"><a href="#从非同凡响开始：绝不要做他人都在做的事" class="headerlink" title="从非同凡响开始：绝不要做他人都在做的事"></a>从非同凡响开始：绝不要做他人都在做的事</h4><p><strong>他人都在做的事</strong>是指将工作视为一种不得不完成的任务来做。虽然公司是老板的，软件是公司的，但是职业生涯是你自己的。正确的做法是将每一份工作视为自己的事业，将软件作为自己的产品，将公司和老板想象为自己的客户，转变心态，变被动为主动。只有积极主动的人才可能获得更多的机会，从而获得更好的职业生涯。</p>
<h4 id="思考未来：你的目标是什么"><a href="#思考未来：你的目标是什么" class="headerlink" title="思考未来：你的目标是什么"></a>思考未来：你的目标是什么</h4><p>为自己的职业生涯设立至少一个远大的目标，比如十年后你会在哪里，做什么？这个目标不需要太具体，只要能给你指引大概的方向即可。在此基础上，还需要设置具体的小目标，比如每月需要读一本技术书籍，写两篇技术博客，具体到每天应该读几页等等内容，大目标指明方向，小目标督促你不断向大目标前行。</p>
<p>当然只是设置目标没有太大意义，更重要的完成这些目标，所以我们需要不断的追踪自己定下的这些目标，看看是否已正常完成，未完成的原因是什么，不断的优化和自省，找到最适合自己的节奏。</p>
<h4 id="人际交往能力：远比你想象的重要"><a href="#人际交往能力：远比你想象的重要" class="headerlink" title="人际交往能力：远比你想象的重要"></a>人际交往能力：远比你想象的重要</h4><p>软件开发并不只是和代码打交道，实际上我们大部分时间是在和人打交道。<strong>我只想一个人安静的写代码</strong>这种思想是罪恶的，人际交往能力比你想象的重要得多。</p>
<p>大部分人都希望自己能够被他人认可和尊重，所以如果你也想获得他人的认可和尊重，那么最好先认可和尊重他人。不要以贬低他人的方式来抬高自己，因为这要只会适得其反。更不要对他人进行批评，批评是一项很少能达成预期的工具，奖励才是最好的激励方式。</p>
<p>人际关系活动成功关键是换位思考，我和我想要什么并不重要，他人需要什么更重要，一次成功的沟通应该是了解对方的需求，然后将你想表达的内容以对方期望的形式传递出去。比如跟老板汇报工作时，太多的技术细节就不是一个好的选择，老板更期望听到的是整个前因后果。</p>
<p>避免争吵，因为争吵解决不了任何问题。虽然我们只是伪装成大人，将情绪隐藏起来的小孩。《人性的弱点》中说道：据我所知，普天之下解决争吵的灵丹妙药只有一个，那就是避免争吵，像避免响尾蛇和地震一样的远离争吵。</p>
<p>沟通和交流往往都是程序员的软肋和短板，根据木桶理论，恰恰是这些短板决定了人生的天花板。如果想获得一个更好的职业生涯，就要补强这些短板，有时候甚至必须强迫自己去做才行。</p>
<h4 id="破解面试之道"><a href="#破解面试之道" class="headerlink" title="破解面试之道"></a>破解面试之道</h4><p>书上这一章主要说的是打破常规的面试方法，通过获得与面试公司相关人员的联系，俗称<strong>混脸熟</strong>，来达到一条走捷径的面试之道。作为一个程序员，个人觉得还是真刀真枪的上吧，拼硬实力拿到的offer可能心里更踏实。当然运气也很重要。</p>
<p>结合自己的面试经验，个人总结面试成功与否主要有两点：面试前的准备和面试时的表达能力。面试前的准备过程可能会很长，特别是专业的技术细节方面，比如源码的实现原理等等，可能需要你始终保持学习的习惯，经常检测自己的知识体系是否出现盲区并及时补全。项目方面则应该将你最具有代表性的几个项目好好总结，具体到每个细节都要非常了解，从前期调研到线上数据，所用到的技术和难点及解决过程。</p>
<p>面试过程中的表达也很重要，对于常见的技术问题和项目介绍，我们应该尽量提前组织好语言，面对我们没有准备的问题，先不要着急回答，可以已提问的方式跟面试官多沟通，了解更多面试官想知道的问题的细节，同时也是为自己争取时间组织语言。</p>
<h4 id="就业选择：列出你的选择"><a href="#就业选择：列出你的选择" class="headerlink" title="就业选择：列出你的选择"></a>就业选择：列出你的选择</h4><p>本章主要介绍个人在职场中主要的三种角色：雇员，独立咨询师和创业者。</p>
<p>雇员的好处是稳定，轻松；缺点是没有自由，收入封顶，作为初入职场的人来说，雇员往往是一个比较好的选择，在积累足够的经验，人脉和财富以后，我们可以选择改变自己的角色。</p>
<p>独立咨询师是创业者的前期状态了，你已经准备开始为自己工作，你拥有更大的自由度和潜在的赚钱能力，但是你开始需要自己去寻找业务和客户，打理一切开销，为成为创业者打基础。</p>
<p>创业者应该是职场的终极目标了，只有优秀且有魄力的职场人士会选择创业，创业是风险和机遇并存的选择，需要创业者有一颗强大的心脏作为支撑，敏感且脆弱的人是不适合创业的。</p>
<p>以上三种角色不是一层不变，随着时间的推移和个人的发展，我们可能还在三者中间来回切换，不管是哪种角色，只有适合自己的才是最好的角色。但是有一个是共同的，那就是全力以赴。</p>
<h4 id="你是哪类软件开发人员"><a href="#你是哪类软件开发人员" class="headerlink" title="你是哪类软件开发人员"></a>你是哪类软件开发人员</h4><p>全栈开发很好，但是精通一个细分领域让你获得机会的可能性更大。因为专业化更重要，人们需要全才，更需要专才。这里作者的观点和我一样，比起了解更多的技术方向和语言，更好的建议是深入到某个细分的领域去，成为该领域的专家。即使这个领域以后不景气，凭借在该领域积累的经验，也能很快转到其他方向上去，因为计算机的姿势是相通的。</p>
<h4 id="公司与公司是不一样的"><a href="#公司与公司是不一样的" class="headerlink" title="公司与公司是不一样的"></a>公司与公司是不一样的</h4><p>小公司和创业公司关注业务增长，追求快速迭代，甚至已牺牲产品质量为代价，在这样的团队你可能会成为一个多面手，拥有快速解决问题的能力，你的影响会更大，责任也更大。在小公司你的上升机会更多，更辛苦同时回报可能更丰厚。</p>
<p>中等规模的公司比小公司稳定，甚至比大公司也稳定，保持业务的稳定是第一要素，这类公司不像小公司追求业务的快速增长，也不像大公司有一套规范的做事标准和足够的资金去探索新的领域，尝试新的技术。如果你追求稳定，这类公司是不错的选择。</p>
<p>大公司很规范，做事情一板一眼，按部就班。大部分人在大公司就是一颗小小的螺丝钉，只负责打理自己的一亩三分地。同时大公司提供了一个很好的学习平台，如果你热爱学习和专研，大公司会更适合你，你有足够的资源让自己成为某一领域的专家。</p>
<h4 id="攀登晋升阶梯"><a href="#攀登晋升阶梯" class="headerlink" title="攀登晋升阶梯"></a>攀登晋升阶梯</h4><p>在任何公司里能让你脱颖而出最重要的法宝就是承担更多的责任。更多的责任意味着更多的付出，一般付出和收获是成正比的。主动承担更多责任可以从以下几点着手：</p>
<ul>
<li>主动去负责一个不受重视的项目</li>
<li>帮助团队里面的新人快速成长</li>
<li>主动编写项目文档，并经常维护</li>
<li>那些没有人愿意去做的事情（可能会有很多坑，需要提前有思想准备）</li>
</ul>
<p>引入注目会让你更容易获得晋升的资格，这里更多介绍如何引起老板的注意：</p>
<ul>
<li>写一份亮眼的周报，除了叙述日常事务，最好加上自己的总结和思考</li>
<li>分享，分享不仅能让大家认识你，更重要的是你在这种压力下可能学到更多，百利无一害。</li>
</ul>
<p>持续不断的学习，增加自己的技能和知识，当你的水平在不断提高的时候，升职和加薪就会随之而来。</p>
<p>永远不要去做推脱问题的人，而要成为解决问题的人，你能解决别人无法解决或不愿意解决的问题，无论在哪家公司，你都能轻而易举的成为mvp。</p>
<p>不要在办公室政治上投入太多的精力。</p>
<h4 id="成为专业人士"><a href="#成为专业人士" class="headerlink" title="成为专业人士"></a>成为专业人士</h4><p>成为专业人士是一种心态。如果我们总是与恐惧，自毁，拖延和自我怀疑做斗争，那么问题就是：我们正在像外行那样思考问题。外行毫不起眼，外行人废话连篇，外行屈从于逆境。专业人士可不这么想。不管怎样，他引人注目，他恪尽职守，他始终如一。</p>
<p>专业人士会严肃对待自己的责任和事业，愿意做出艰难的选择去做自己认为正确的事情，同时承担起相应的代价。</p>
<p>成为专业人士的最基本原则就是养成良好的习惯，一切都始于习惯。坏习惯很难被打破，而新习惯又不容易养成，所以如果你养成了良好的习惯，那你就强于大部分的人，这比大部分人更专业。</p>
<p>坚守正道，坚持做自己认为正确的事情，不要被外行人的一些意见左右，除非那个人是老板。也就是培养自己说不的能力，知道什么时候应该说不，什么时候不要说不。能够说不的人，其实更专业。</p>
<p>追求品质，完善自我。不断提升自我的素养，是让你保持专业的秘诀。设置高质量的做事标准，要时刻谨记<strong>你做的每一件事就是你所做的一切</strong>，所谓代码无小事。 </p>
<h4 id="赢得自由-如何辞职"><a href="#赢得自由-如何辞职" class="headerlink" title="赢得自由-如何辞职"></a>赢得自由-如何辞职</h4><p>不要在冲动的时候做决定，辞职也是如此。可能因为公司的某些制度惹怒了你，让你很不爽，感觉在公司一秒都待不下去了，辞职的想法在你脑海中冒出来一次又一次，但是，我要提醒你，这个时候千万不要提辞职，给自己一个冷静下来的时间，考虑清楚辞职的代价你是否能承受，再做决定。</p>
<p>不要裸辞，这会让你找工作的过程背负更大的压力，适当的压力可以催人前进，但是压力过大会让人寸步难行。如果你想单干，确保已经预留了足够的资金支撑至少一年。而且最好是在已经有副业的前提下。</p>
<p>了解自己每天工作时长，8小时的正常工作时间里，你有多少时间是正在在做事，有多少时间又是在划水呢。对于以后要单干是一个很少的参考，因为单干的话，你会比现在工作更长的时间。</p>
<h4 id="成为自由职业者：开启自己的一片天地"><a href="#成为自由职业者：开启自己的一片天地" class="headerlink" title="成为自由职业者：开启自己的一片天地"></a>成为自由职业者：开启自己的一片天地</h4><p>万事开头难，如何迈出创业的第一步很重要。首先要有稳定的业务，可以先以副业的形成发展业务，待业务逐渐稳定后，就可以全职创业了。业务来源可以是朋友介绍，广告等，最好的形式是客户主动找上门，这就需要你有足够的个人影响力，后面还会专业介绍程序员如何营销自己。</p>
<p>自己创业该如何收费呢？这里也可以参考你最后一份工作的收入，然后平均到小时，如果你之前每小时50刀，那创业后至少需要100刀才能达到之前的收入水平，因为除了工资你还需要支付其他相关的开支。如果你有足够的影响力，业务多到做不完，那你的收费标准可以定得更高，高到客户开始还价为止。</p>
<h4 id="创建你的第一个产品"><a href="#创建你的第一个产品" class="headerlink" title="创建你的第一个产品"></a>创建你的第一个产品</h4><p>程序员创业有一个先天的优势，我们可以自己将想法编程一个产品而不用求助于他人。但是在实现你的想法之前，你应该先为自己的产品找到受众，当你的产品发布以后，哪些人会去使用呢？我们不可能在初期就去打造一个适合所有人的产品，所以我们需要进入细分领域，首先在该领域寻找客户，站稳脚跟，再考虑扩张问题。</p>
<p>找到受众后，我们可以开始进行市场测试，投放一些广告，然后发布一个demo级别的产品，看看市场反应如何，最重要的是前期的用户反馈，这些信息比用户本身更为宝贵，我们需要根据用户反馈调整产品结构，当然我们不可能满足所有用户的需求，做到尽量覆盖大部分的用户即可。</p>
<p>最后是风险提醒，创业失败的可能性太大，在你的产品用户可观的数据量前，尽量不要all in，如上面提到的，可以先已副业的形式开始你的创业之路，同时去学习如何成为一个创业者，在你拥有了创业的理论基础和可观的用户积累后，就可以迈出下一步。</p>
<h4 id="你打算创业吗"><a href="#你打算创业吗" class="headerlink" title="你打算创业吗"></a>你打算创业吗</h4><p>大部分程序员应该都有过自己创业的想法冒出，特别是当你脑海中有了一个点子，创业的冲动会从你脑中呼之欲出，只是迫于现实的约束，很多人最终放弃，选择更为稳定的生活。在上面也提到过，其实很多人并不适合创业，创业者需要一颗大心脏，同时还要极具冒险精神，要有激情和干劲，这些都是很难拥有的品质。</p>
<p>创业公司一般分为两种，一种是在创业初始就试图以获取外部投资来刺激公司的快速发展，通过不断的融资来提升公司的估值，不会优先考虑赢利问题，获取更多用户和市场规模在他们看来更为重要，因为这些数据就是他们下一次融资的资本。还有一种公司则自力更生，他们在创业初期可能就已经赢利，这类公司规模会更小，失败风险也更低，当然发展也会比较缓慢。</p>
<p>在创业前，想好退路也是很重要的，如果公司成功上市或者被收购，你又会在哪里，有的创业者可能希望创建一家百年老店，但是投资人可不这么想，他们希望更快的实现盈利，套现离场。这也是一些创业公司不去寻求融资的原因，资本市场就像催化剂，会快速的将你的公司催熟，如果公司过于早熟，等到资本退场后，可能迎接你的就是失败了。</p>
<p>如果你在创业初期能够加入一家孵化器，那将对你的公司发展起到很好的促进作用，特别是你是第一次创业的话。孵化器不仅可以为你的创业提供指导意见，还能帮你和投资人建立联系。</p>
<p>获取投资意味着你要放弃公司的部分股权，甚至牺牲大部分股权，失去对公司的管理权，当然资本也能帮助你更好的发展公司，获得投资的公司更容易成功。</p>
<h4 id="远程工作的生存策略"><a href="#远程工作的生存策略" class="headerlink" title="远程工作的生存策略"></a>远程工作的生存策略</h4><p>随着这次疫情的影响，远程办公也越来越流行起来，但是远程办公并没有想象的那么美好，下面介绍的是远程办公的一些弊端。</p>
<p>个人的时间管理问题。作者的建议是即使是远程办公，也最好将作息时间和在公司办公时保持一致，这样才能保持相同的状态。</p>
<p>自我激励问题。每个人都会有惰性，可能在公司班上时，环境不允许你释放自己的惰性，但是远程办公，在没有其他人监督之下，惰性更容易产生。当然如果你是一个严格自律的人，可以很好的控制自己的行为，可能不必太担心这个问题。</p>
<p>远程办公伴随而来的孤独感。远程办公减少了不必要的沟通，但也剥夺了很多必要的沟通。如果你感到孤独，好的建议就是走出去，多和他人交流，约一些朋友一起小聚。</p>
<h4 id="假装自己能成功"><a href="#假装自己能成功" class="headerlink" title="假装自己能成功"></a>假装自己能成功</h4><p>这种自我暗示很重要，对于我们不能掌控的事情，我们必须这样暗示自己，然后全力以赴的去接受挑战。<br>每个人在面对未知的时候都会恐惧，克服这种恐惧的方法之一就是自我暗示，短暂的麻痹自己。不管做什么事情，心态都是至关重要的，乐观积极的心态会让你更容易成事。</p>
<h4 id="单调乏味的简历-如何修改"><a href="#单调乏味的简历-如何修改" class="headerlink" title="单调乏味的简历-如何修改"></a>单调乏味的简历-如何修改</h4><p>最近看了一位UI同学的简历，设计排版，图表，文案都做的特别漂亮，看着就很高大上，给人一种很厉害的感觉，这就是简历的作用。相比之前，技术同学的简历就逊色好多，很多人连自己的工作内容都无法描述清楚，更不用说自己所擅长的技术和优势了。</p>
<p>技术的简历虽然不需要太花哨，但是吸引眼球的东西一样要有。不需要泛泛而谈，将项目中的核心业务和技术点列出来即可，如果你还有比较擅长的领域就会更加分。比较常用的写简历的原则即STAR，能够帮助你很好的梳理自己的项目经历，并突出重点内容，吸引到面试官的注意力。</p>
<h4 id="请勿陷入对技术的狂热之中"><a href="#请勿陷入对技术的狂热之中" class="headerlink" title="请勿陷入对技术的狂热之中"></a>请勿陷入对技术的狂热之中</h4><p>每一项技术都有它适用的场景和局限，没有必须因为自己不使用不了解就去贬低，或者因为自己正在用就去吹捧，还是应该辩证的看待技术，php到底是不是最好的语言这个话题真的没有任何意义，除了会掀起口水战。</p>
<p>面对技术我们应该做一个“拿来主义者”，需要的时候就用，不需要的时候就放到一边，要记住：技术本身只是一种工具。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">75</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
