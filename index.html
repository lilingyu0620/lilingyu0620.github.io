<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/11/04/《重构-改善既有代码的设计》系列读书笔记（二、函数的重构）/" itemprop="url">
                  《重构-改善既有代码的设计》系列读书笔记（二、函数的重构）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-11-04T21:41:04+08:00" content="2019-11-04">
              2019-11-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/11/04/《重构-改善既有代码的设计》系列读书笔记（二、函数的重构）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/11/04/《重构-改善既有代码的设计》系列读书笔记（二、函数的重构）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/11/04/《重构-改善既有代码的设计》系列读书笔记（一、从第一个案例说起）/" itemprop="url">
                  《重构-改善既有代码的设计》系列读书笔记（一、从第一个案例说起）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-11-04T21:40:25+08:00" content="2019-11-04">
              2019-11-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/11/04/《重构-改善既有代码的设计》系列读书笔记（一、从第一个案例说起）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/11/04/《重构-改善既有代码的设计》系列读书笔记（一、从第一个案例说起）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/22/iOS性能检测工具总结/" itemprop="url">
                  iOS性能检测工具总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-08-22T17:51:37+08:00" content="2019-08-22">
              2019-08-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/08/22/iOS性能检测工具总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/22/iOS性能检测工具总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个资深的iOS开发，除了专业能力要过硬，还应该具有一些产品scene,关注一些技术之外的内容，学会发现问题然后利用技术去解决这些问题。比如用户体验问题，用户在使用app的过程中，可能会遇到哪些体验不佳的问题，我们要做的就是利用技术手段找出这些问题，然后一一解决，尽我们所能为用户提供最后的用户体验。排除交互设计本身外，最可能出现用户体验问题的原因就是手机在性能上出现了一些瓶颈，因此，找出这些性能瓶颈的时间节点和当前实时数据能很大程度上帮助我们定位到最终原因。</p>
<p>基于以上的出发点，我们就需要开发一套自己的性能检测工具和上报机制，在app出现性能问题时拿到一手的数据，帮助我们定位问题和解决问题。</p>
<h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p>app的性能主要受两部分内容的影响，一个是手机本身的硬件设备，还有一个就是当前网络状况。这里分两部分分别介绍检测工具的功能点。</p>
<h4 id="设备性能"><a href="#设备性能" class="headerlink" title="设备性能"></a>设备性能</h4><h5 id="fps"><a href="#fps" class="headerlink" title="fps"></a>fps</h5><p>fps主要用来检测当前页面的卡顿情况，如果fps降到50帧以下，页面卡顿就会比较明显，这个时候就需要具体再去分析卡顿原因。</p>
<h5 id="cpu-usage"><a href="#cpu-usage" class="headerlink" title="cpu usage"></a>cpu usage</h5><p>cpu利用率主要有三个可以参考的指标，分别是用户使用率，系统使用率和空闲率。</p>
<h5 id="disk"><a href="#disk" class="headerlink" title="disk"></a>disk</h5><p>磁盘空间有已用空间和可用空间。</p>
<h5 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h5><p>内存使用情况有总内存，总可用内存和当前app已用内存。这里都是指的物理内存。因为虚拟内存的检测并没有什么意义。</p>
<h5 id="battery"><a href="#battery" class="headerlink" title="battery"></a>battery</h5><p>当前电量。</p>
<p>以上这些指标，大部分需要调用mach内核的相关api才能成功获取，而且需要轮询获取才能保证数据的时效性。</p>
<h4 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h4><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>包括当前域名对应的ip,解析总耗时和失败情况。</p>
<h5 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h5><p>当前网络延时，一个RTT时长。</p>
<h5 id="Reachability"><a href="#Reachability" class="headerlink" title="Reachability"></a>Reachability</h5><p>当前网络状态，包括wifi，4G或者无网。</p>
<h5 id="Metrics-iOS10"><a href="#Metrics-iOS10" class="headerlink" title="Metrics(iOS10)"></a>Metrics(iOS10)</h5><p>Metrics包括了下面这张图中的相关时长：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/iOS性能监控工具/zfgdZ.png" alt=""></p>
<p>iOS10以后，可以直接从URLSession的回调中拿到这些耗时指标。</p>
<h5 id="TraceRoute"><a href="#TraceRoute" class="headerlink" title="TraceRoute"></a>TraceRoute</h5><p>一个完整的请求的路径，包括数据经过的每一个节点和耗时。该数据可以完整反映出一个数据报的传输过程。</p>
<h5 id="Traffic-I-O"><a href="#Traffic-I-O" class="headerlink" title="Traffic(I/O)"></a>Traffic(I/O)</h5><p>网络I/O</p>
<h3 id="上报格式"><a href="#上报格式" class="headerlink" title="上报格式"></a>上报格式</h3><p>为了方便上报和数据分析，需要统一各项数据的上报格式，以上面的Metrics为例，将各项数据按统一的格式一同上报，定义格式如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/iOS性能监控工具/Metrics.png" alt=""></p>
<p>上报格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NetworkMetrics: 450,50,80,60,100,120,Network Load</div><div class="line">NetworkMetrics: 220,0,0,0,100,120,Loacl Cache</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/29/操作系统原理-内存管理/" itemprop="url">
                  操作系统原理--内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-29T10:56:23+08:00" content="2019-05-29">
              2019-05-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/29/操作系统原理-内存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/29/操作系统原理-内存管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h3 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h3><h3 id="内存的分配与回收"><a href="#内存的分配与回收" class="headerlink" title="内存的分配与回收"></a>内存的分配与回收</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/29/操作系统原理-线程/" itemprop="url">
                  操作系统原理--线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-29T10:56:14+08:00" content="2019-05-29">
              2019-05-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/29/操作系统原理-线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/29/操作系统原理-线程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><h3 id="线程的结构"><a href="#线程的结构" class="headerlink" title="线程的结构"></a>线程的结构</h3><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/29/操作系统原理-进程/" itemprop="url">
                  操作系统原理--进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-29T10:56:08+08:00" content="2019-05-29">
              2019-05-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/29/操作系统原理-进程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/29/操作系统原理-进程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><h3 id="进程的结构"><a href="#进程的结构" class="headerlink" title="进程的结构"></a>进程的结构</h3><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/04/一个网络请求的流程/" itemprop="url">
                  一个网络请求的流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-04-04T17:36:44+08:00" content="2019-04-04">
              2019-04-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/04/04/一个网络请求的流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/04/一个网络请求的流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最新在看《计算机网络–自顶向下方法》，把从应用层到链路层的所有网络协议都重新学习了一遍。这里借用这个标题，来梳理一下相关协议的工作原理和流程，以及各层的协议之间是如何协同工作的。</p>
<h3 id="首先-你得连上Internet吧"><a href="#首先-你得连上Internet吧" class="headerlink" title="首先 你得连上Internet吧"></a>首先 你得连上Internet吧</h3><p>当我们连接上一个路由器后，会得到一个ip地址，如果此时你的路由器已经连接到了ISP,那么恭喜你可以开始在网上🏄了。那么这个ip地址到底是咋分配到我们的机器的呢？！！！</p>
<h4 id="DHCP-dynamic-host-configuration-protocol"><a href="#DHCP-dynamic-host-configuration-protocol" class="headerlink" title="DHCP(dynamic host configuration protocol)"></a>DHCP(dynamic host configuration protocol)</h4><p>动态主机配置协议，运行在网卡，路由器和交换机等网络设备上，主要用来分配ip地址。和其他协议类似，也是以报文的形式进行通信。</p>
<p>当我们的主机发起一个网络连接请求时，DHCP协议会生成一个DHCP报文，并使用UDP传输协议进行传输，该UDP报文会包含一个组播ip(255.255.255.255)的目标地址,组播ip意味着该网段内所有设备都会收到这条UDP报文。此时因为本机还没有分配ip,所以源ip会是0.0.0.0。</p>
<p>上面的UDP报文会被包在以太网帧中进行传输，该以太网帧的目的地址也是一个组播mac地址（FF.FF.FF.FF.FF.FF）,所以该帧会被网段内所有设备接收。而该帧的原地址即为本机的mac地址（比如 28:cf:e9:14:d1:0f 这是我的设备的mac地址）。</p>
<p>路由器收到该以太网帧，一层层解析出DHCP报文，然后路由器决定分配一个ip地址给主机（10.236.142.22）,于是通过路由器上的DHCP服务器包装一个DHCP的响应报文，把包括了DNS服务器ip,路由器ip,子网掩码和分配给主机的ip一起发送给该主机。因为路由器已经知道了主机的mac地址，所以该报文会顺利的到达。</p>
<p>主机网卡在收到DHCP ACK报文后，解析出相关的ip并配置好网络组件。至此，主机连接Internet成功。</p>
<h3 id="只有域名是不可以的"><a href="#只有域名是不可以的" class="headerlink" title="只有域名是不可以的"></a>只有域名是不可以的</h3><p>连上Internet后，我们就可以上google了。于是我们在浏览器上输入www.google.com，也就是google的域名，不包括前面的www(www是一个网络应用，中文名叫万维网)。而google的主页应该是放在服务器上的，通过域名是如何访问到服务器上的google主页的呢?!!!</p>
<h4 id="DNS-domain-name-system"><a href="#DNS-domain-name-system" class="headerlink" title="DNS(domain name system)"></a>DNS(domain name system)</h4><p>DNS主要用来查询域名对应的ip地址。和DHCP一样，DNS报文使用UDP进行传输。DNS报文将www.google.com放入报文段，然后组装成UDP报文，在上面的DHCP ACK中，已经拿到了DNS的ip,所以在组装ip报文的时候目的ip直接使用dns的ip,源ip则为主机的ip。</p>
<p>之后，ip报文会被放到以太网帧中进行传输，想要将dns报文发送到dns服务器，首先第一个难题就是如何传送到所在网络的网关路由器，在上面的DHCP ACK报文中，已经拿到了网关路由器的ip了，但是ip只是作用在网络层，如果没有mac地址，链路层上是无法传输的。</p>
<h4 id="ARP-address-resolution-protocol"><a href="#ARP-address-resolution-protocol" class="headerlink" title="ARP(address resolution protocol)"></a>ARP(address resolution protocol)</h4><p>地址解析协议，通过一个ip地址获取mac地址。ARP使用网关路由器的ip地址生成一个ARP查询报文，然后将该报文放到目标地址为(FF.FF.FF.FF.FF.FF)的以太网帧上，因为是广播地址，所以网关路由器顺利收到该帧，并生成一个ARP的回答报文，报文中带上了网关路由器的mac地址。然后将回答报文放到目的地址为主机mac地址的以太网帧中，这样，我们就顺利的拿到了网关路由器的mac地址。</p>
<p>通过ARP,dns查询报文顺利的发送到了网关路由器。之后，又该何去何从？！！！</p>
<h4 id="BGP-broder-gateway-protocol"><a href="#BGP-broder-gateway-protocol" class="headerlink" title="BGP(broder gateway protocol)"></a>BGP(broder gateway protocol)</h4><p>边界网关协议，AS(自治系统)之间的路由选择协议，BGP极其复杂，许多专著致力于研究该主题，它的基本工作流程是：</p>
<ul>
<li>从相邻AS处获取子网可达性信息</li>
<li>向本AS内部的所有路由器传播这些可达性信息</li>
<li>基于可达性信息和AS策略，决定到达子网的最优路由</li>
</ul>
<p>我们还得回到最上面的DHCP ACK中去，因为DNS的ip地址是这个报文给返回的，那么它又是如何生成该ip的呢。其实这个ip并不是它生成的，是ISP提供的。当路由器连接上ISP以后，对应的路由转发表会进行更新，所以dns的ip对应的转发接口已经存在于路由转发表中（根据BGP边界网关协议），至此，dns查询报文被发送到对应的dns服务器上。</p>
<p>dns服务器接收到查询报文后，开始根据域名在缓存中查找对应的ip,如果缓存中没有找到，会去到ISP的权威dns服务器上查找，如何还找不到，会去到.com对应顶级dns服务器上查找，如果还是没有找到，会到跟域名服务器上查找，如果根域名上也没有找到，则返回查询失败。如果在其他dns服务器上成功找到对应的ip,该服务器会先缓存到本地，然后生成一个UDP的DNS回答报名，发送到对应的主机上，至此，我们终于拿到了google.com对应的ip地址。接下来我们要开始发送http的get请求了。</p>
<h3 id="顺理成章的http请求"><a href="#顺理成章的http请求" class="headerlink" title="顺理成章的http请求"></a>顺理成章的http请求</h3><p>拿到ip后，http客户端会生成一个get请求，然后封装到tcp的报文中。tcp在进行数据传输前，会有一个三次握手的过程，握手成功后，get请求的报文成功被google的服务器接收，然后服务器通过url找到对应的资源，生成一个http的响应报文并封装在tcp的报文中，然后发送给客户端。</p>
<p>因为已经建立了连接，所以响应报文不在需要握手的流程，客户端顺利收到响应报文，并解析出资源数据，将数据丢给浏览器进行显示（浏览器如何解析数据并渲染的流程不在这篇文章的讨论范围之内）。。。</p>
<p>因为http并不是长链接（1.1以后才支持），所以在一个http请求结束后，客户端还是发起一个断开链接的操作，也称四次挥手的过程。至于断开连接为啥会比建立连接多一次握手过程，就留给读者自己去比较和分析吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此 一个完整的网络请求就总结完毕了，当然，这只是一个大概的流程总结，重点介绍和DHCP和链路层相关的几个协议，tcp和ip协议因为之前已经总结过所以这里只是一笔带过。如果想要了解得更为深入的话，当然推荐大家看一下《TCP/IP详解》系列书籍和我正在看的这本《计算机网络–自顶向下方法》书了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/《架构整洁之道》学习笔记/" itemprop="url">
                  《架构整洁之道》学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-03-11T16:23:51+08:00" content="2019-03-11">
              2019-03-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/03/11/《架构整洁之道》学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/11/《架构整洁之道》学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一章-设计与架构究竟是什么"><a href="#第一章-设计与架构究竟是什么" class="headerlink" title="第一章 设计与架构究竟是什么"></a>第一章 设计与架构究竟是什么</h3><ul>
<li><p>软件架构的终极目标是,用最小的人力成本满足构建和维护该系统的需求.</p>
</li>
<li><p>慢但是稳,是成功的秘诀</p>
</li>
<li><p>程序员们总是用这句话来欺骗自己:<strong>我们可以未来再重构代码,产品上线最重要</strong>.但是结果大家都知道,产品上线后重构工作就再也没有人提起.所以重构的时机永远不会再有了…</p>
</li>
</ul>
<h3 id="第二章-两个价值维度"><a href="#第二章-两个价值维度" class="headerlink" title="第二章 两个价值维度"></a>第二章 两个价值维度</h3><p>架构价值比行为价值更重要</p>
<h4 id="行为价值-业务"><a href="#行为价值-业务" class="headerlink" title="行为价值(业务)"></a>行为价值(业务)</h4><p>行为价值并不是程序员工作的全部</p>
<h4 id="架构价值"><a href="#架构价值" class="headerlink" title="架构价值"></a>架构价值</h4><ul>
<li>software = 灵活的产品</li>
<li>软件变更的难度应该和变更的范畴成等比关系,而与变更的具体形状无关</li>
</ul>
<h4 id="艾森豪威尔矩阵"><a href="#艾森豪威尔矩阵" class="headerlink" title="艾森豪威尔矩阵"></a>艾森豪威尔矩阵</h4><ul>
<li>我有两种难题:紧急的和重要的,而紧急的难题永远是不重要的,重要的难题永远是不紧急的.</li>
<li>重要比紧急更应该被重视</li>
</ul>
<h4 id="为好的软件架构而持续斗争"><a href="#为好的软件架构而持续斗争" class="headerlink" title="为好的软件架构而持续斗争"></a>为好的软件架构而持续斗争</h4><ul>
<li>公司内部的抗争本来就是无止境的</li>
<li>如果你是架构师,这项工作就加倍重要</li>
</ul>
<h3 id="第四章-结构化编程"><a href="#第四章-结构化编程" class="headerlink" title="第四章 结构化编程"></a>第四章 结构化编程</h3><ul>
<li>编码的整个过程应该是可推导的</li>
<li>功能性降解拆分,将复杂的逻辑分解为一个个小的单元,以函数,分支,循环等的方式最终呈现.</li>
<li>结构化编程是对程序控制权的直接转移的限制</li>
</ul>
<h3 id="第五章-面向对象编程-OOD"><a href="#第五章-面向对象编程-OOD" class="headerlink" title="第五章 面向对象编程(OOD)"></a>第五章 面向对象编程(OOD)</h3><ul>
<li>面向对象编程是对程序控制权的间接转移的限制</li>
</ul>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li>类的private和public属性和方法</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承的作用是让我们可以在某个作用域内对外部定义的某一组变量与函数进行覆盖.</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li>多态是函数指针的应用</li>
<li>插件化是多态的一种实践</li>
<li>多态是实现依赖反转的一种好的选择</li>
</ul>
<h3 id="第六章-函数式编程"><a href="#第六章-函数式编程" class="headerlink" title="第六章 函数式编程"></a>第六章 函数式编程</h3><ul>
<li>函数式编程中变量是不可变的</li>
<li>原子操作只能保证当前线程下的线程安全问题</li>
<li>函数式编程是对程序中赋值操作的限制</li>
</ul>
<h3 id="设计原则-SOLID"><a href="#设计原则-SOLID" class="headerlink" title="设计原则(SOLID)"></a>设计原则(SOLID)</h3><p>设计目标:</p>
<ul>
<li>使软件可容忍被改动</li>
<li>使软件更容易被理解</li>
<li>构建可在多个软件系统中复用的组件</li>
</ul>
<h3 id="第七章-SRP单一职责原则"><a href="#第七章-SRP单一职责原则" class="headerlink" title="第七章 SRP单一职责原则"></a>第七章 SRP单一职责原则</h3><ul>
<li>函数设计也需要遵循SRP原则</li>
<li>任何一个软件模块都应该有且仅有一个被修改的原因</li>
<li>任何一个软件模块都应该只对某一类行为者负责</li>
<li>Employee类中各行为应该被分解</li>
</ul>
<h3 id="第八章-OCP开闭原则"><a href="#第八章-OCP开闭原则" class="headerlink" title="第八章 OCP开闭原则"></a>第八章 OCP开闭原则</h3><ul>
<li>良好的设计软件应该易于扩展,同时抗拒修改</li>
<li>如果A组件不想被B组件上发生的修改所影响,那么就应该让B组件依赖于A组件</li>
<li>利用SRP分解功能,利用DIP反转依赖</li>
<li>软件系统不应该依赖不直接使用的组件</li>
</ul>
<h3 id="第九章-LSP里氏替换原则"><a href="#第九章-LSP里氏替换原则" class="headerlink" title="第九章 LSP里氏替换原则"></a>第九章 LSP里氏替换原则</h3><ul>
<li>以接口的形式实现函数调用的可替换性</li>
</ul>
<h3 id="第十章-ISP接口隔离原则"><a href="#第十章-ISP接口隔离原则" class="headerlink" title="第十章 ISP接口隔离原则"></a>第十章 ISP接口隔离原则</h3><ul>
<li>利用接口隔离原则隔离掉不需要的依赖关系,因为不需要的依赖会导致不必要的重新编译和重新部署</li>
</ul>
<h3 id="第十一章-DIP依赖反转原则"><a href="#第十一章-DIP依赖反转原则" class="headerlink" title="第十一章 DIP依赖反转原则"></a>第十一章 DIP依赖反转原则</h3><ul>
<li>如果想要设计一个灵活的系统,在源代码层面的依赖关系中就应该多引用抽象类型而非具体实现</li>
<li>接口比具体实现更稳定,因为如果修改接口必须修改实现,但是反之则不一定.</li>
<li>不要在具体实现类上创建子类,具体实现应该放到子类去做,除非是比较稳定且通用的逻辑.</li>
<li>不要覆盖包含具体实现的函数,如果必须这样,请在覆盖方法中先调用父类方法.</li>
<li>源代码依赖方向永远是控制流方向的反转</li>
</ul>
<h3 id="第十二章-组件"><a href="#第十二章-组件" class="headerlink" title="第十二章 组件"></a>第十二章 组件</h3><ul>
<li>组件是软件部署的单元,是整个软件系统在部署过程中可以独立完成部署的最小实体.</li>
<li>重定位技术和链接器是组件的单独部署成为可能</li>
<li>墨菲定律:程序的规模会一直不断地增长下去,直到将有限的编译和链接时间填满为止</li>
<li>摩尔定律:硬件的更新周期为18个月</li>
</ul>
<h3 id="第十三章-组件聚合"><a href="#第十三章-组件聚合" class="headerlink" title="第十三章 组件聚合"></a>第十三章 组件聚合</h3><h4 id="复用-发布等同原则-REP"><a href="#复用-发布等同原则-REP" class="headerlink" title="复用/发布等同原则(REP)"></a>复用/发布等同原则(REP)</h4><ul>
<li>软件复用的最小粒度应等同于其发布的最小粒度</li>
<li>ERP原则就是指组件中的类与模块必须是彼此紧密相关的,一个组件不能由一组毫无关联的类和模块组成</li>
<li>一个组件中包含的类与模块还应该是可以同时发布的</li>
</ul>
<h4 id="共同闭包原则-CCP"><a href="#共同闭包原则-CCP" class="headerlink" title="共同闭包原则(CCP)"></a>共同闭包原则(CCP)</h4><ul>
<li>我们应该将那些会同时修改,并且为相同目的而修改的类放到同一个组件中,而将不会同时修改,并且不会为了相同目的而修改的那些类放到不同的组件中</li>
<li>CCP原则是SRP原则和OCP原则的组件版</li>
</ul>
<h4 id="共同复用原则-CRP"><a href="#共同复用原则-CRP" class="headerlink" title="共同复用原则(CRP)"></a>共同复用原则(CRP)</h4><ul>
<li>不要强迫一个组件的用户依赖他们不需要的东西</li>
<li>我们希望组件中的所有类是不可拆分的,不应该出现别人只需要依赖它的某几个类而不需要其他类的情况</li>
<li>CRP的作用不仅是告诉我们应该将哪些类放在一起,更重要的是要告诉我们应该将哪些类分开</li>
<li>CRP原则实际上是ISP原则的一个普适版,ISP建议我们不要依赖不需要的类,CRP建议我们不要依赖不需要的组件</li>
<li>优秀的架构师应该在REP,CCP和CRP原则间找到一个好的平衡点,一个项目的组件结构设计的重心是根据该项目的开发时间和成熟度不断变化的</li>
</ul>
<h3 id="第十四章-组件耦合"><a href="#第十四章-组件耦合" class="headerlink" title="第十四章 组件耦合"></a>第十四章 组件耦合</h3><h4 id="无依赖环原则"><a href="#无依赖环原则" class="headerlink" title="无依赖环原则"></a>无依赖环原则</h4><ul>
<li>组件依赖关系图中不应该出现环</li>
<li>依赖环会导致组件之间的发布和运行很难稳定下来</li>
<li>每周构建是指team每一周专门抽出一天来进行组件的构建调试工作,而其他时间则忽略组件的构建问题</li>
<li>消除循环依赖的一个解决办法是将研发项目划分成一些可单独发布的组件,这些组件独立完成构建和发布</li>
<li>DIP原则打破循环依赖好的选择</li>
</ul>
<h4 id="自上而下的设计"><a href="#自上而下的设计" class="headerlink" title="自上而下的设计"></a>自上而下的设计</h4><ul>
<li>组件结构图是不可能自上而下被设计出来的,它必须随着软件系统的变化而变化和扩张.</li>
<li>组件结构图并不是用来描述应用程序功能的,它更像是应用程序在构建性与维护性方面的一张地图</li>
<li>组件结构图的一个重要目的是如何隔离频繁的变更</li>
</ul>
<h4 id="稳定依赖原则"><a href="#稳定依赖原则" class="headerlink" title="稳定依赖原则"></a>稳定依赖原则</h4><ul>
<li>依赖关系必须要指向更稳定的方向</li>
<li>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖</li>
<li>稳定性指标的计算方法:出口依赖/(出口依赖+入口依赖). 0最稳定,1最不稳定.</li>
<li>组件并不是都需要稳定</li>
</ul>
<h4 id="稳定抽象原则"><a href="#稳定抽象原则" class="headerlink" title="稳定抽象原则"></a>稳定抽象原则</h4><ul>
<li>一个组件的抽象化程度应该与其稳定性保持一致</li>
<li>组件抽象化的计算方法:组件中的抽象类和接口/组件中类的个数 0表现没有抽象类 1表示全是抽象类</li>
<li>好的组件结构应该在抽象和稳定之间找到一个好的平衡点</li>
</ul>
<h3 id="第十五章-什么是软件架构"><a href="#第十五章-什么是软件架构" class="headerlink" title="第十五章 什么是软件架构"></a>第十五章 什么是软件架构</h3><ul>
<li>软件架构师自身需要是程序员,并且必须坚持一直做一线程序员,绝对不要听从那些说应该让软件架构师从代码中解放出来以专心解决高阶问题的伪建议</li>
<li>软件架构的实质就是规划如何将系统切分成组件,并安排好组件之间的排序关系,以及组件之间的通信方式</li>
<li>如果想设计一个便于推进各项工作的系统,其策略就是要在设计中尽可能长时间的保留尽可能多的可选项</li>
<li>开发,部署,运行和维护是软件架构的主要目标</li>
<li>哪些可选项应该保留:它们就是那些无关紧要的细节设计</li>
<li>策略是软件中所有的业务规则与操作过程,是系统真正的价值所在,而细节则是程序员们与策略交互的方式.</li>
<li>软件架构师的目标是创建一种系统形态,该形态会以策略为最基本的元素,并让细节与策略脱离关系,并允许在具体决策过程中推迟或延迟与细节相关的内容</li>
</ul>
<h3 id="第十六章-独立性"><a href="#第十六章-独立性" class="headerlink" title="第十六章 独立性"></a>第十六章 独立性</h3><p>所谓独立性是指一个良好的软件架构必须支持一下几点：</p>
<ul>
<li>支持系统所有用例的能力</li>
<li>独立的开发能力</li>
<li>独立的部署能力</li>
</ul>
<h4 id="再谈解耦模式"><a href="#再谈解耦模式" class="headerlink" title="再谈解耦模式"></a>再谈解耦模式</h4><ul>
<li>源码层次解耦，也叫单体结构</li>
<li>部署层次解耦</li>
<li>服务层次解耦（微服务）</li>
</ul>
<h3 id="第十七章-划分边界"><a href="#第十七章-划分边界" class="headerlink" title="第十七章 划分边界"></a>第十七章 划分边界</h3><p>软件设计本身就是一门划分边界的艺术。<strong>架构师追求的目标就是最大限度降低构建和维护一个系统所需要的人力，而一个系统最消耗人力资源的地方，就是系统中存在的耦合，尤其是那些过早做出的，不成熟的决策所导致的耦合（深以为然）！！！</strong></p>
<h4 id="边界线应该画在何处？"><a href="#边界线应该画在何处？" class="headerlink" title="边界线应该画在何处？"></a>边界线应该画在何处？</h4><p>边界线应该画在那些不相关的事情之间。比如UI与业务逻辑，UI与数据库，业务逻辑与数据库…</p>
<h4 id="插件式架构"><a href="#插件式架构" class="headerlink" title="插件式架构"></a>插件式架构</h4><ul>
<li>组件应该可以用插件的方式集成到其他系统中。</li>
<li>插件式的架构保证了组件的变更不会影响系统整体的业务逻辑。</li>
<li>插件式架构是SRP原则的具体实现。</li>
</ul>
<h3 id="第十九章-策略与层次"><a href="#第十九章-策略与层次" class="headerlink" title="第十九章 策略与层次"></a>第十九章 策略与层次</h3><p>软件就是策略语句的集合，软件设计的工作重点之一就是将这些策略彼此分离，然后将它们按照变更的方式进行重新分组。其中变更原因、时间和层次相同的策略应该被分到同一个组件中（OCP）。反之，变更原因、时间和层次不同策略则应该分属不用的组件。</p>
<p>架构设计的工作需要将组件重排组合成为一个有向无环图。图中的每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之间的依赖关系，他们将不同级别的组件链接起来。</p>
<p>在一个设计良好的架构中，依赖关系的方向通常取决于他们所关联的组件层次。依赖关系应该与数据流向脱钩，而与组件所在的层次挂钩。</p>
<h3 id="第二十章-业务逻辑"><a href="#第二十章-业务逻辑" class="headerlink" title="第二十章 业务逻辑"></a>第二十章 业务逻辑</h3><ul>
<li>关键业务逻辑，是指系统中真正用来赚钱或者省钱的部分。</li>
<li>关键业务数据，是指关键业务逻辑需要处理的数据。</li>
<li>物业实体（Entity）：关键业务逻辑+关键业务数据。</li>
</ul>
<h3 id="第二十二章-整洁架构"><a href="#第二十二章-整洁架构" class="headerlink" title="第二十二章 整洁架构"></a>第二十二章 整洁架构</h3><ul>
<li>六边形架构（端口与适配器架构）</li>
<li>DCI架构</li>
<li>BCE架构</li>
</ul>
<p>共同的设计目标：按照不同关注点对软件进行切割。即这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口，系统接口则属于其他层。</p>
<h4 id="整洁架构图："><a href="#整洁架构图：" class="headerlink" title="整洁架构图："></a>整洁架构图：</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/架构整洁之道/201507-CleanArchitecture.jpg" alt="整洁架构"></p>
<p>由内向外分别代表：</p>
<ul>
<li>业务实体</li>
<li>用例</li>
<li>接口适配器</li>
<li>框架和驱动程序</li>
</ul>
<h4 id="依赖关系规则"><a href="#依赖关系规则" class="headerlink" title="依赖关系规则"></a>依赖关系规则</h4><ul>
<li>越靠近中心，其所在的软件层级就越高。外层代表机制，内层代表策略。</li>
<li>依赖关系应该是外层依赖内层，低层依赖高层。</li>
<li>使用DIP原则控制依赖。</li>
<li>夸边界的数据处理，不直接使用业务实体数据对象，也不要违反依赖规则。</li>
</ul>
<h3 id="第二十三章-展示器和谦卑对象"><a href="#第二十三章-展示器和谦卑对象" class="headerlink" title="第二十三章 展示器和谦卑对象"></a>第二十三章 展示器和谦卑对象</h3><ul>
<li>谦卑对象是指系统中难以测试的部分,比如UI。</li>
<li>展示器则是可测试的对象，展示器的工作是将需要展示的数据按照规则进行处理，然后给UI层去展示。</li>
</ul>
<h3 id="第二十四章-不完全边界"><a href="#第二十四章-不完全边界" class="headerlink" title="第二十四章 不完全边界"></a>第二十四章 不完全边界</h3><p>构建不完全边界的一种方法就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把这些组件构建成一个新的组件。</p>
<ul>
<li>策略模式：不直接依赖实例，而是依赖一个由实例提供的抽象策略。</li>
<li>门户模式：类似抽象工厂的方式提供可替换的抽象方法。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/18/《程序员修炼之道-从小工到专家》读书笔记/" itemprop="url">
                  《程序员修炼之道-从小工到专家》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-18T11:25:21+08:00" content="2019-02-18">
              2019-02-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/18/《程序员修炼之道-从小工到专家》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/18/《程序员修炼之道-从小工到专家》读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="第一章-注重实效的哲学"><a href="#第一章-注重实效的哲学" class="headerlink" title="第一章 注重实效的哲学"></a>第一章 注重实效的哲学</h4><p>注重实效的程序员的特点:</p>
<ul>
<li>处理问题,寻求解决方案时的态度,风格,哲学. </li>
<li>越出直接的问题去思考,设法把问题放在更大的语境中.</li>
<li>对所做的事情负责</li>
<li>接受变化,注重交流</li>
</ul>
<h5 id="我的源码让猫吃了"><a href="#我的源码让猫吃了" class="headerlink" title="我的源码让猫吃了"></a>我的源码让猫吃了</h5><p>对所做的事情负责,如果项目未能按时交付或者出现严重bug,要提供各种选择,不要找蹩脚的借口(比如说我的源码被猫吃了…).</p>
<h5 id="软件的熵"><a href="#软件的熵" class="headerlink" title="软件的熵"></a>软件的熵</h5><p><strong>熵</strong>是一个物理概率,指的是一个系统中无序的总量,在软件中,称为<strong>软件腐烂</strong></p>
<p><strong>破窗户</strong>是导致软件腐烂的原因之一,破窗户指的是那些<strong>低劣设计,错误决策或是糟糕的代码</strong>.</p>
<p>破窗户应该发现一个修一个,如果没有足够的时间进行适当的修复,就用木板把它钉起来(注释,#warning,或者假数据替换)</p>
<p>破窗户会间接影响其他开发人员的代码质量,导致整体的项目质量下降…</p>
<h5 id="石头汤和煮青蛙"><a href="#石头汤和煮青蛙" class="headerlink" title="石头汤和煮青蛙"></a>石头汤和煮青蛙</h5><p>做变化的催化剂,写出高质量的代码,提供好的idea,侧面影响其他人…</p>
<p>大多数软件灾难都是从微不足道的小事情开始的,大多数项目的拖延都是一天一天发生的,系统一个特性一个特性的偏离起规范,一个又一个补丁被打到某段代码上,知道最初的代码一点没有留下.这就像<strong>温水煮青蛙</strong>.程序员不应该做一只温水里的青蛙.</p>
<h5 id="你的知识产权"><a href="#你的知识产权" class="headerlink" title="你的知识产权"></a>你的知识产权</h5><p>知识产权:程序员所知道的关于计算技术和他们所工作的应用领域的全部事实,以及他们的所有经验.</p>
<p>管理知识产权:</p>
<ul>
<li>严肃的投资者定期投资-作为习惯</li>
<li>多元化是长期成功的关键</li>
<li>聪明的投资者在保守的投资和高风险,高回报的投资之间平衡他们的资产</li>
<li>投资者设法低买高卖,以获取最大回报</li>
<li>应周期性的重新评估和平衡资产</li>
</ul>
<p>具体目标:</p>
<ul>
<li>每年至少学习一种新语言</li>
<li>每季度阅读一本技术书籍</li>
<li>也要阅读非技术</li>
<li>上课</li>
<li>参加线下活动</li>
<li>试验不同的环境</li>
<li>跟上潮流</li>
<li>上网</li>
</ul>
<p>学会抓住学习的机会</p>
<p>批判的思考:批判的分析你读到的听到的,要有自己的理解,不要人云亦云.</p>
<h5 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h5><p>知道你想要说什么,提前理好提纲或者打腹稿</p>
<p>了解你的听众,要知道对方期待听到什么内容</p>
<p>选择时机</p>
<p>选择风格(有点难,一般人都只有一种风格)</p>
<p>让文档美观(ppt大神)</p>
<p>让听众参与</p>
<p>学会做倾听者(但不要做垃圾桶)</p>
<p>回复他人</p>
<p><strong>除非你生活在真空中,你才不需要能交流.交流越有效,你就越有影响力</strong></p>
<h4 id="第二章-注重实效的途径"><a href="#第二章-注重实效的途径" class="headerlink" title="第二章 注重实效的途径"></a>第二章 注重实效的途径</h4><p>有些提示和诀窍可应用于软件开发的所有层面,有些想法几乎是公理,有些过程实际上普遍适用.但是,人们几乎没有为这些途径建立这样的文档,你可能会发现,它们作为零散的段落写在关于设计,项目管理或编码的讨论中…</p>
<h5 id="重复的危害"><a href="#重复的危害" class="headerlink" title="重复的危害"></a>重复的危害</h5><p><strong>DRY</strong>:系统中的每一项知识都必须具有单一,无歧义,权威的表示.</p>
<p>重复是怎样产生的:</p>
<ul>
<li>强加的重复,开发着觉得无可选择,环境要求.</li>
<li>无意的重复,开发者没有意识到他们在重复.</li>
<li>无耐性的重复,开发者偷懒,copy比较容易.</li>
<li>开发者之间的重复,几个人重复了同样的信息.</li>
</ul>
<h5 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h5><p>正交性是从几何学中借来的术语,如果两条直线相交成直角,它们就是正交的.沿着某一条直线移动,你投影到另一条直线上的位置不变.</p>
<p>正交性的好处:消除无关事物之间的影响(解耦不必要的依赖)</p>
<p><strong>分层设计</strong>是正交系统的强大方式..因为每层都只适用在其下面的层次提供的抽象,在改动底层实现,而又不影响其他代码方面,你拥有极大的灵活性.分层也降低了模块间依赖关系失控的风险.</p>
<p>正交性的简单测试方法:如果我显著的改变某个特定功能背后的需求,有多少模块会受影响?在正交系统中,答案是<strong>一个</strong></p>
<p>正交性在编码中的应用:</p>
<ul>
<li>让你的代码保持解耦</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数</li>
<li>养成不断批判对待自己代码的习惯.寻找任何重新进行组织,以改善其结构和正交性的机会,这个过程叫做重构,它非常重要.</li>
</ul>
<h5 id="曳光弹"><a href="#曳光弹" class="headerlink" title="曳光弹"></a>曳光弹</h5><p>顾名思义,再开始一个项目之前,眼前是一片黑暗的,看不到未来的样子,这时我们可以发射一枚曳光弹,用在软件开发上就是先写一个大概的demo,有一个前行的方向…</p>
<p>曳光代码的好处:</p>
<ul>
<li>用户能够及早看到能工作的东西</li>
<li>开发者构建了一个他们能在其中工作的结构</li>
<li>你有了一个集成平台</li>
<li>你有了可用于演示的东西</li>
<li>你将更能够感受到工作进展</li>
</ul>
<h4 id="第三章-基本工具"><a href="#第三章-基本工具" class="headerlink" title="第三章 基本工具"></a>第三章 基本工具</h4><h5 id="纯文本的威力"><a href="#纯文本的威力" class="headerlink" title="纯文本的威力"></a>纯文本的威力</h5><p>xml,html,sgml…</p>
<p>用纯文本保存知识的好处:</p>
<ul>
<li>保证不过时</li>
<li>杠杆作用</li>
<li>更易于测试</li>
</ul>
<h5 id="shell游戏"><a href="#shell游戏" class="headerlink" title="shell游戏"></a>shell游戏</h5><h5 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h5><p>vim,Emacs…</p>
<h5 id="源码控制"><a href="#源码控制" class="headerlink" title="源码控制"></a>源码控制</h5><p>svn,git…</p>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>调试的心理学:</p>
<ul>
<li>调试是解决问题,要据此发起进攻</li>
<li>要修正问题,而不是发出指责(bug是你的还是别人的,这不是真的很有关系.)</li>
<li>不要恐慌,如果你看到bug报告的第一反应是<strong>那不可能</strong>,你就完全错了.一个脑细胞都不要浪费在以<strong>“但那时不可能”</strong>起头的思路上,因为很明显,那不仅可能,而且已经发生.</li>
<li>小心近视,要抵制只修正你看到的症状的急迫愿望,更有可能的情况是,实际的故障离你正在观察的地方可能还有几步远,并且可能涉及许多其他的相关事物.</li>
</ul>
<p>调试策略:</p>
<ul>
<li>你需要与qa面谈,搜集比最初给你的数据更多的数据.</li>
<li>qa不可能全覆盖所有的case,你需要系统的进行这样的测试,比如分支语句,你可能需要自己造数据去覆盖所有的分支.</li>
<li>复现bug</li>
<li>是数据可视化(log)</li>
<li>堆栈和断点</li>
<li>橡皮鸭,把你的逻辑对着桌上的橡皮鸭描述一遍,看看有没有漏洞.</li>
<li>消除过程,二分调试</li>
<li>遇到自认为不可能的bug时,不要假定,要证明.</li>
</ul>
<h5 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h5><p>脚手架,代码块,模版工具…</p>
<h4 id="第四章-注重实效的偏执"><a href="#第四章-注重实效的偏执" class="headerlink" title="第四章 注重实效的偏执"></a>第四章 注重实效的偏执</h4><p>你不可能写出完美的软件</p>
<h5 id="按合约设计"><a href="#按合约设计" class="headerlink" title="按合约设计"></a>按合约设计</h5><p>DBC:通过合约进行设计</p>
<h5 id="死程序不说谎"><a href="#死程序不说谎" class="headerlink" title="死程序不说谎"></a>死程序不说谎</h5><p>尽早崩溃…</p>
<h5 id="断言式编程"><a href="#断言式编程" class="headerlink" title="断言式编程"></a>断言式编程</h5><p>如果它不可能发生,用断言确保它不会发生…</p>
<h5 id="何时使用异常"><a href="#何时使用异常" class="headerlink" title="何时使用异常"></a>何时使用异常</h5><p>将异常用于异常的问题…</p>
<h5 id="怎样配平资源"><a href="#怎样配平资源" class="headerlink" title="怎样配平资源"></a>怎样配平资源</h5><p>只要在编程,我们都要管理资源:内存,事务,线程,文件,定时器所有数量有限的事物.大多数时候,资源使用遵循一种可预测的模式,你分配资源,使用它,然后释放它.</p>
<p>要有始有终</p>
<h4 id="第五章-弯曲或折断"><a href="#第五章-弯曲或折断" class="headerlink" title="第五章 弯曲或折断"></a>第五章 弯曲或折断</h4><p>模块和组件的解耦方案</p>
<h5 id="解耦与得墨忒耳法则"><a href="#解耦与得墨忒耳法则" class="headerlink" title="解耦与得墨忒耳法则"></a>解耦与得墨忒耳法则</h5><p>多模块耦合的危害</p>
<ul>
<li>调用链冗长</li>
<li>对一个模块的简单改动会传遍系统中的一些无关模块</li>
<li>开发者害怕改动代码,因为他们不清楚哪些代码可能受影响</li>
</ul>
<p>函数的得墨忒耳法则规定,某个对象的任何方法都应该只调用以下情形的方法:</p>
<ul>
<li>它自身的方法</li>
<li>传入该方法的任何对象的方法</li>
<li>它创建的任何对象的方法</li>
<li>任何直接持有的组件的对象的方法(比如全局对象)</li>
</ul>
<h5 id="元程序设计"><a href="#元程序设计" class="headerlink" title="元程序设计"></a>元程序设计</h5><p>细节会弄乱我们整洁的代码,特别是如果它经常变化.所以我们必须把细节<strong>赶出去</strong>,让我们的代码容易适应变化.</p>
<p>动态配置:要配置,不要集成.要用元数据描述应用的配置选项:调谐参数,用户偏好,安装目录等…</p>
<p>元数据就是数据的数据.</p>
<h5 id="时间解耦"><a href="#时间解耦" class="headerlink" title="时间解耦"></a>时间解耦</h5><p>模块间的时间依赖…我们需要容许并发,并考虑解除任何时间或者次序上的依赖,这样我们才可以获取灵活性,并减少许多开发领域中的任何基于时间的依赖:工作流分析,架构,设计,还有部署.</p>
<p>工作流的改善:使用UML流程图优化工作流.</p>
<p>编写多线程代码,为并发设计.</p>
<h5 id="黑板"><a href="#黑板" class="headerlink" title="黑板"></a>黑板</h5><p>将模块细节画到黑板上,用黑板协调工作流.</p>
<h4 id="第六章-当你编码时"><a href="#第六章-当你编码时" class="headerlink" title="第六章 当你编码时"></a>第六章 当你编码时</h4><p>编码不是机械地把设计转换为可执行语句,这种态度是许多程序丑恶,低效,结构糟糕,不可维护和完全错误的最大一个原因.</p>
<h5 id="靠巧合编程"><a href="#靠巧合编程" class="headerlink" title="靠巧合编程"></a>靠巧合编程</h5><p>深思熟虑的编程,而不是靠运气和偶然的成功.</p>
<p>怎样深思熟虑的编程:</p>
<ul>
<li>总是意识到你在做什么</li>
<li>不要盲目的编程</li>
<li>按照计划行事</li>
<li>依靠可靠的事物,不要依靠巧合或假定</li>
<li>为你的假定建立文档</li>
<li>不要只是测试你的代码,还要测试你的假定</li>
<li>为你的工作划分优先级</li>
<li>不要做历史的奴隶,不要让已有的代码支配将来的代码,如果不再适用,所有的代码都可以被替换.</li>
</ul>
<h5 id="算法速率"><a href="#算法速率" class="headerlink" title="算法速率"></a>算法速率</h5><p>大O表示法</p>
<p>常识估算:</p>
<ul>
<li>简单循环 O(n)</li>
<li>嵌套循环 O(n<em>n || n</em>m)</li>
<li>二分法 O(log(n))</li>
<li>分而治之 O(nlog(n))</li>
<li>组合 O(n!)</li>
</ul>
<p>最快的并非是最好的…</p>
<h5 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h5><p>何时重构:</p>
<ul>
<li>重复,你发现了对DRY原则的违反</li>
<li>非正交的设计</li>
<li>过时的知识</li>
<li>性能问题</li>
</ul>
<p>早重构,常重构</p>
<p>如何重构:</p>
<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前,确保你拥有良好的测试.</li>
<li>采取短小,深思熟虑的步骤.</li>
</ul>
<h5 id="易于测试的代码"><a href="#易于测试的代码" class="headerlink" title="易于测试的代码"></a>易于测试的代码</h5><p>针对合约进行测试</p>
<p>编写单元测试</p>
<p>使用测试设备</p>
<h4 id="第七章-在项目开始之前"><a href="#第七章-在项目开始之前" class="headerlink" title="第七章 在项目开始之前"></a>第七章 在项目开始之前</h4><h5 id="需求之坑"><a href="#需求之坑" class="headerlink" title="需求之坑"></a>需求之坑</h5><p>完美,不是再没有什么需要增加,而是在没有什么需要去掉时到达.</p>
<p>与用户一同工作,以像用户一样思考.</p>
<p>抽象比细节活得更长久</p>
<h5 id="解开不可能解开的谜题"><a href="#解开不可能解开的谜题" class="headerlink" title="解开不可能解开的谜题"></a>解开不可能解开的谜题</h5><p>不要在盒子外面思考,要找到盒子.</p>
<p>不能可解决的问题:</p>
<ul>
<li>有更容易的方法吗</li>
<li>你是在设法解决真正的问题,还是被外围的技术问题转移了注意力</li>
<li>这件事情为什么是一个问题</li>
<li>是什么使它如此难以解决</li>
<li>它必须以这种方式完成吗</li>
<li>它真的必须完成吗</li>
</ul>
<h5 id="规范陷阱"><a href="#规范陷阱" class="headerlink" title="规范陷阱"></a>规范陷阱</h5><p>编写规范是一项重要职责,但每一个细节都被写在规范里的想法是错误的:</p>
<ul>
<li>规范将捕捉系统或其需求的每一处细节和细微差别这一想法是幼稚的</li>
<li>语言自身的表达能力存在问题</li>
<li>对有些事情,做胜于描述</li>
</ul>
<h4 id="第八章-注重实效的项目"><a href="#第八章-注重实效的项目" class="headerlink" title="第八章 注重实效的项目"></a>第八章 注重实效的项目</h4><h5 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h5><ul>
<li>不要留破窗户</li>
<li>不要做温水里的青蛙</li>
<li>交流的重要性</li>
<li>DRY</li>
<li>正交性</li>
</ul>
<h5 id="无处不在的自动化"><a href="#无处不在的自动化" class="headerlink" title="无处不在的自动化"></a>无处不在的自动化</h5><ul>
<li>项目编译</li>
<li>生成代码</li>
<li>回归测试</li>
<li>构建自动化</li>
</ul>
<h5 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h5><p>早测试,常测试,自动测试</p>
<p>要到通过全部测试,编码才算完成</p>
<p>测试什么:</p>
<ul>
<li><p>单元测试</p>
<p>  模块测试</p>
</li>
<li><p>集成测试</p>
<p>  子系统能很好的系统工作</p>
</li>
<li><p>验证和校验</p>
<p>  用户回归</p>
</li>
<li><p>资源耗尽,错误及恢复</p>
<p>  1.内存空间<br>  2.磁盘空间<br>  3.cpu带宽<br>  4.挂钟时间<br>  5.磁盘带宽<br>  6.网络带宽<br>  7.调色板<br>  8.视频分辨率<br>  9.fps</p>
</li>
<li><p>性能测试</p>
<p>  预期的用户数,连接数或每秒事务数</p>
</li>
<li><p>可用性测试</p>
<p>  qa,灰度…</p>
</li>
</ul>
<h5 id="全都是写"><a href="#全都是写" class="headerlink" title="全都是写"></a>全都是写</h5><p>把英语当作又一种编程语言</p>
<p>把文档建在里面,不要栓在外面</p>
<h5 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h5><p>在你的作品上签名,你的签名应该被视为质量的保证.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/08/iOS性能优化的一些套路/" itemprop="url">
                  iOS性能优化的一些套路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-08T17:56:56+08:00" content="2018-10-08">
              2018-10-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/08/iOS性能优化的一些套路/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/08/iOS性能优化的一些套路/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">程序优化第一法则：不要优化</div><div class="line">							————编程珠玑（续）</div><div class="line">							</div><div class="line">过早的优化是万恶之源</div><div class="line">							————Donald Knuth</div></pre></td></tr></table></figure>
<p>不要过早优化，也不要为了优化而优化，只有在项目真正需要优化的时候再优化。我们实际工作中，在开始一个项目时，应该也不会太多去考虑性能优化的问题。不过随着项目版本的不断迭代，模块和代码量不断增加，研发团队人员变动，以及其他各种原因，难免会出现一些实现不太友好的代码和方案，影响到app的用户体验，这个时候就需要相应的优化来提升app的性能。</p>
<p>iOS的性能优化是一个比较有挑战的工作，有一定的难度，需要着手优化的人有一定的姿势积累，能够分析出各方面可能出现的性能问题。所以一般也是进阶必须掌握的技能。当然，优化的过程和可优化的一些点也是有套路的，综合网上的方案和自身的一些经验，这里做一下简单的总结：</p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>这里说的启动优化指的是冷启动，根据启动的流程，可以分为2部分来分别优化，具体如下：</p>
<h4 id="main函数之前"><a href="#main函数之前" class="headerlink" title="main函数之前"></a>main函数之前</h4><p>ipa实际上就是一堆二进制文件（.o文件）的集合，而这堆二进制文件就是xcode编译我们的代码后生产的最终产物，文件头部会给操作系统留下入口（这个入口不是main，而是@start标识）。当应用被启动，系统首先找到程序入口，将二进制文件分页映射到虚拟内存（mmap），然后加载动态库（load image），然后对需要rel的符号的地址进行rebase和bind，之后就是对使用的oc类和分类的注册和初始化。至此，mian函数前的工作做完了。</p>
<h5 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h5><p>知道了具体流程，我们就可以对流程中各个环节进行有针对性的优化了：</p>
<ul>
<li>利用Xcode的DYLD_PRINT_STATISTICS环境变量监测mian函数前的耗时.</li>
<li>尽可能精简代码量，减少mmap次数。</li>
<li>动态库的使用，移除不必要的动态库依赖。</li>
<li>合并或者删除无用的oc类和分类。</li>
<li>删除没有被调用的方法,减少非唯一selector的个数。</li>
<li>将不必须的初始化方法从+load移到+initialize。</li>
</ul>
<h4 id="main函数之后"><a href="#main函数之后" class="headerlink" title="main函数之后"></a>main函数之后</h4><p>这部分内容就是业务相关的东西了，根据各自app的需求会有不同的优化方案，不像上面的部分具有通用性。启动优化的最终目的肯定都是最快的展示首页内容，这里列举一些常用的优化套路。</p>
<ul>
<li>能延迟执行的就延迟执行。比如SDK的注册，非首页UI的创建等。</li>
<li>不能延迟执行的，尽量放到后台执行。比如网络请求，数据读取，原始JSON数据转对象，日志发送等。</li>
<li>既不能延时又不能后台执行的尽量已懒加载的方式创建实例。</li>
<li>利用检测工具监测启动阶段函数调用的耗时情况，进行针对性优化。</li>
</ul>
<p>具体细节可参考<a href="https://techblog.toutiao.com/2018/05/29/untitled-24/" target="_blank" rel="noopener">今日头条这篇优化文章</a></p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>蒸米大大的<a href="https://mp.weixin.qq.com/s/WQ7rrTJm-cn3Cb6e_zZ4cA" target="_blank" rel="noopener">这一篇文章</a>比较详细的描述了iOS中的虚拟内存和物理内存相关的内容。我们一般说的在程序中分配和回收内存指的都是虚拟内存，程序员一般不直接和物理内存（cpu内存，不包括磁盘）打交道。更多虚拟内存和物理内存的内容可阅读操作系统相关的文章和书籍去学习。</p>
<p>在计算机发展的初期，程序员都是直接访问物理内存，随着计算机技术的飞速发展，这种内存访问方式不再满足程序员的需求，新的内存访问方式出现，这就是被沿用至今的<strong>虚拟内存</strong>。虚拟内存在程序员和物理内存之间提供了一个良好的中间环境，它隔离了程序员直接使用物理内存带来的各种危险操作，提高了物理内存的利用率，简化了内存管理方式，保证了进程的安全。所以有这样一句古话：<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>，看来不是没有道理的。</p>
<p>言归正传，下面我们从创建、复用、回收三个方面总结一下iOS在内存使用过程中的一些需要注意的点：</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>减少大图的使用。</li>
<li>weak strong dance保证self的生命周期。</li>
<li>weak替换unsafe_unretain，保证指针安全。</li>
<li>合理利用自动释放池，避免内存暴涨导致OOM。</li>
<li>尽量使用懒加载的方式创建对象，避免无用和重复创建，减少不必要的内存开销。</li>
<li>在子线程手动申请（malloc）大内存的的时候 ping 一下主线程，因为子线程无法收到内存警告的传递。</li>
</ul>
<h4 id="缓存和复用"><a href="#缓存和复用" class="headerlink" title="缓存和复用"></a>缓存和复用</h4><ul>
<li>合理使用缓存减轻CPU的计算压力。</li>
<li>复用UI对象内存，通过绑定model更新UI。</li>
<li>合理使用缓存数据结构（NSCache VS NSMapTable VS NSHashTable VS NSDictionary）。</li>
</ul>
<h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ul>
<li>保证使用的内存能够被正确的回收掉，避免内存泄露（timer,delegate,block）。</li>
<li>使用适当的工具对内存的回收进行检测，发生内存泄露及时抛出提示。</li>
<li>处理系统的内存警告。</li>
</ul>
<h3 id="UI优化"><a href="#UI优化" class="headerlink" title="UI优化"></a>UI优化</h3><p>先说一下iOS中UI展示的过程。iOS中的视图容器是CALayer,所有的显示在屏幕上的内容最终都是被渲染到CALayer上。CPU计算好需要渲染的内容放入渲染缓冲区，GPU从渲染缓冲区拿到数据，OpenGLES经过顶点着色，光栅化，片元着色，逐片段操作等一系列流程，将处理好的数据（bitmap）丢到后帧缓冲区，前帧缓冲区再从后帧缓冲区更新数据，最终渲染到CALayer。</p>
<p>从上面展示的流程可以看到，UI的展示分为两个部分，CPU处理部分和GPU处理部分。如果某一部分的处理被阻塞的话，UI显示就会出现卡顿。所以，可以从这两部分着手优化。</p>
<h4 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h4><ul>
<li>利用UI卡顿检测工具检测屏幕的fps。</li>
<li>懒加载方式创建UI对象，使用CALayer替换UIView。</li>
<li>减少视图相关属性的修改，避免视图层级的调整，尽量不要动态添加和移除视图。</li>
<li>文本的异步计算和渲染。</li>
<li>尽量提前计算好视图布局并缓存，避免动态计算和更新布局。</li>
<li>异步解码图片和绘制视图。</li>
</ul>
<h4 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h4><ul>
<li>将多个小图合并为一张大图显示，控制图片尺寸不要大于GPU处理上限。</li>
<li>避免带透明度的视图重叠显示，会产生像素的混合。</li>
<li>避免出现离屏渲染。</li>
</ul>
<p>具体细节参考<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">YY的这篇文章</a></p>
<h3 id="ipa包大小优化"><a href="#ipa包大小优化" class="headerlink" title="ipa包大小优化"></a>ipa包大小优化</h3><p>上面提到过，iOS的ipa包实际上就是一堆二进制文件的集合。而这堆二进制文件，就是我们的代码经过Xcode编译之后的产物。这里简单介绍一下Xcode点击run后的整个流程：</p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><ul>
<li>将所有的 <em>#deifne</em> 删除 并展开所有的宏定义。</li>
<li>处理所有的条件编译指令 比如#if #else #ifdef #endif 等等。</li>
<li>处理#include预编译指令 将所包含的文件插入到预编译指令的位置。</li>
<li>删除所有的注释 // /<em> </em>/ 等等。</li>
<li>添加行号和文件名标识。</li>
<li>保留所有#pragma编译器指令。</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译过程就是把预处理完成的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件（词法分析-&gt;语法分析-&gt;语义分析-&gt;源代码优化-&gt;代码生成&gt;目标代码优化）。</p>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul>
<li>利用有限状态机扫描源代码 生成一系列记号（Token）。</li>
<li>记号分类：关键字、标识符、字面量（包括数字，字符串）、特殊符号（+、=）。</li>
<li>每种记号存入对应的表内。</li>
<li>词法规则可以自定义。</li>
</ul>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><ul>
<li>对上面的词法表进行语法分析、生成语法树。</li>
<li>整个分析过程采用上下文无关语法。</li>
<li>语法树以表达式为节点。</li>
</ul>
<h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><ul>
<li>编译器所能分析的语义是静态语义。</li>
<li>静态语义通常包括声明和类型的匹配，类型的转换。</li>
<li>经过语义分析，语法树被标识了类型。</li>
<li>语义分析判断该语法是否合法。</li>
</ul>
<h5 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h5><ul>
<li>直接在语法树上面优化比较困难，所以源代码优化器会先将语法树转换为中间代码。</li>
<li>中间代码是设备无关的。</li>
<li>编译器前端负责产生机器无关的中间代码，后端负责将中间代码转换成目标机器代码。</li>
<li>跨平台编译器就是有一个前端和多个后端的组合。</li>
</ul>
<h5 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h5><ul>
<li>编译器后端主要包括代码生成器和目标代码优化器。</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul>
<li>链接的过程主要包括：地址和空间分配、符号决议、重定向。</li>
<li>目标文件和库一起链接生成可执行文件。</li>
<li>库其实是一种编译后的目标文件。</li>
<li>目标文件之间的函数和变量的访问在链接过程中被重定向。</li>
</ul>
<h4 id="可执行文件的装载（即上面提到的main函数前的部分）"><a href="#可执行文件的装载（即上面提到的main函数前的部分）" class="headerlink" title="可执行文件的装载（即上面提到的main函数前的部分）"></a>可执行文件的装载（即上面提到的main函数前的部分）</h4><p>了解了二进制文件的产生过程后，我们可以利用一些工具来对它们做一些针对性的优化工作：</p>
<h4 id="二进制文件的优化"><a href="#二进制文件的优化" class="headerlink" title="二进制文件的优化"></a>二进制文件的优化</h4><h5 id="查看mach-o文件的大小"><a href="#查看mach-o文件的大小" class="headerlink" title="查看mach.o文件的大小"></a>查看mach.o文件的大小</h5><p>首先，在Xcode（Debug下）中开启编译选项<strong>Write Link Map File</strong>，然后在这个目录下面（这里以OpenCourse为例）找到下面这个txt文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/DerivedData/OpenCourse-gyfdubhkhvixzvetgqbmqrzplarc/Build/Intermediates.noindex/OpenCourse.build/Debug2-iphoneos/OpenCourse.build/OpenCourse-LinkMap-normal-arm64.txt</div></pre></td></tr></table></figure>
<p>这个LinkMap里展示了整个可执行文件的全貌，列出了编译后的每一个.o目标文件的信息（包括静态链接库.a里的），以及每一个目标文件的代码段，数据段存储详情。对于比较大的文件，进行对应的优化即可。</p>
<p><a href="https://github.com/daheli/iOS-linkmap-tools" target="_blank" rel="noopener">查看mach.o文件大小的工具</a></p>
<h5 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h5><ul>
<li>Optimization Level release使用Fastest。</li>
<li>Strip Linked Product release设置为YES。</li>
<li>Symbols Hidden by Default release设置为YES。</li>
</ul>
<h4 id="资源文件的优化"><a href="#资源文件的优化" class="headerlink" title="资源文件的优化"></a>资源文件的优化</h4><ul>
<li>图片资源在打包过程中压缩比很低，基本是原图copy。减少图片数量和大小可以直接降低ipa的大小。</li>
<li>及时删除无用代码（包括无用的类，依赖，方法，测试用例等）。</li>
</ul>
<p><a href="https://tinypng.com" target="_blank" rel="noopener">压缩图片大小的工具</a></p>
<p><a href="https://github.com/tinymind/LSUnusedResource" target="_blank" rel="noopener">检测无用的图片的工具</a></p>
<p><a href="https://github.com/dblock/fui" target="_blank" rel="noopener">检测无用类和依赖的工具</a></p>
<h3 id="编码和架构优化"><a href="#编码和架构优化" class="headerlink" title="编码和架构优化"></a>编码和架构优化</h3><p>好的代码质量和架构设计是项目稳定运行和迭代的基石。而编码高手和低手之间很大一部分区别在于对细节的处理上，要养成良好的编码习惯非一朝一夕，需要时间的积累和大量的练习，同时，也需要一些理论上的支持。下面推荐几本经典书籍，平时编码过程中，需要经常提醒自己甚至强迫自己按照书中这些tips去做，养成良好的编码习惯，提升技术上的综合素质。</p>
<h4 id="代码的设计原则和架构方案《架构整理之道》"><a href="#代码的设计原则和架构方案《架构整理之道》" class="headerlink" title="代码的设计原则和架构方案《架构整理之道》"></a>代码的设计原则和架构方案《架构整理之道》</h4><p>总结一下本书中比较重要的几个章节：</p>
<h5 id="SRP单一职责原则"><a href="#SRP单一职责原则" class="headerlink" title="SRP单一职责原则"></a>SRP单一职责原则</h5><ul>
<li>函数设计也需要遵循SRP原则</li>
<li>任何一个软件模块都应该有且仅有一个被修改的原因</li>
<li>任何一个软件模块都应该只对某一类行为者负责</li>
<li>Employee类中各行为应该被分解</li>
</ul>
<h5 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h5><ul>
<li>良好的设计软件应该易于扩展,同时抗拒修改</li>
<li>如果A组件不想被B组件上发生的修改所影响,那么就应该让B组件依赖于A组件</li>
<li>利用SRP分解功能,利用DIP反转依赖</li>
<li>软件系统不应该依赖不直接使用的组件</li>
</ul>
<h5 id="LSP里氏替换原则"><a href="#LSP里氏替换原则" class="headerlink" title="LSP里氏替换原则"></a>LSP里氏替换原则</h5><ul>
<li>以接口或者多态的形式实现函数调用的可替换性</li>
</ul>
<h5 id="ISP接口隔离原则"><a href="#ISP接口隔离原则" class="headerlink" title="ISP接口隔离原则"></a>ISP接口隔离原则</h5><ul>
<li>利用接口隔离原则隔离掉不需要的依赖关系,因为不需要的依赖会导致不必要的重新编译和重新部署</li>
</ul>
<h5 id="DIP依赖反转原则"><a href="#DIP依赖反转原则" class="headerlink" title="DIP依赖反转原则"></a>DIP依赖反转原则</h5><ul>
<li>如果想要设计一个灵活的系统,在源代码层面的依赖关系中就应该多引用抽象类型而非具体实现</li>
<li>接口比具体实现更稳定,因为如果修改接口必须修改实现,但是反之则不一定.</li>
<li>不要在具体实现类上创建子类,具体实现应该放到子类去做,除非是比较稳定且通用的逻辑.</li>
<li>不要覆盖包含具体实现的函数,如果必须这样,请在覆盖方法中先调用父类方法.</li>
<li>源代码依赖方向永远是控制流方向的反转</li>
</ul>
<h5 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h5><h6 id="复用-发布等同原则-REP"><a href="#复用-发布等同原则-REP" class="headerlink" title="复用/发布等同原则(REP)"></a>复用/发布等同原则(REP)</h6><ul>
<li>软件复用的最小粒度应等同于其发布的最小粒度</li>
<li>ERP原则就是指组件中的类与模块必须是彼此紧密相关的,一个组件不能由一组毫无关联的类和模块组成</li>
<li>一个组件中包含的类与模块还应该是可以同时发布的</li>
</ul>
<h6 id="共同闭包原则-CCP"><a href="#共同闭包原则-CCP" class="headerlink" title="共同闭包原则(CCP)"></a>共同闭包原则(CCP)</h6><ul>
<li>我们应该将那些会同时修改,并且为相同目的而修改的类放到同一个组件中,而将不会同时修改,并且不会为了相同目的而修改的那些类放到不同的组件中</li>
<li>CCP原则是SRP原则和OCP原则的组件版</li>
</ul>
<h6 id="共同复用原则-CRP"><a href="#共同复用原则-CRP" class="headerlink" title="共同复用原则(CRP)"></a>共同复用原则(CRP)</h6><ul>
<li>不要强迫一个组件的用户依赖他们不需要的东西</li>
<li>我们希望组件中的所有类是不可拆分的,不应该出现别人只需要依赖它的某几个类而不需要其他类的情况</li>
<li>CRP的作用不仅是告诉我们应该将哪些类放在一起,更重要的是要告诉我们应该将哪些类分开</li>
<li>CRP原则实际上是ISP原则的一个普适版,ISP建议我们不要依赖不需要的类,CRP建议我们不要依赖不需要的组件</li>
<li>优秀的架构师应该在REP,CCP和CRP原则间找到一个好的平衡点,一个项目的组件结构设计的重心是根据该项目的开发时间和成熟度不断变化的</li>
</ul>
<h5 id="组件耦合"><a href="#组件耦合" class="headerlink" title="组件耦合"></a>组件耦合</h5><h6 id="无依赖环原则"><a href="#无依赖环原则" class="headerlink" title="无依赖环原则"></a>无依赖环原则</h6><ul>
<li>组件依赖关系图中不应该出现环</li>
<li>依赖环会导致组件之间的发布和运行很难稳定下来</li>
<li>每周构建是指team每一周专门抽出一天来进行组件的构建调试工作,而其他时间则忽略组件的构建问题</li>
<li>消除循环依赖的一个解决办法是将研发项目划分成一些可单独发布的组件,这些组件独立完成构建和发布</li>
<li>DIP原则打破循环依赖好的选择</li>
</ul>
<h6 id="自上而下的设计"><a href="#自上而下的设计" class="headerlink" title="自上而下的设计"></a>自上而下的设计</h6><ul>
<li>组件结构图是不可能自上而下被设计出来的,它必须随着软件系统的变化而变化和扩张.</li>
<li>组件结构图并不是用来描述应用程序功能的,它更像是应用程序在构建性与维护性方面的一张地图</li>
<li>组件结构图的一个重要目的是如何隔离频繁的变更</li>
</ul>
<h6 id="稳定依赖原则"><a href="#稳定依赖原则" class="headerlink" title="稳定依赖原则"></a>稳定依赖原则</h6><ul>
<li>依赖关系必须要指向更稳定的方向</li>
<li>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖</li>
<li>稳定性指标的计算方法:出口依赖/(出口依赖+入口依赖). 0最稳定,1最不稳定.</li>
<li>组件并不是都需要稳定</li>
</ul>
<h6 id="稳定抽象原则"><a href="#稳定抽象原则" class="headerlink" title="稳定抽象原则"></a>稳定抽象原则</h6><ul>
<li>一个组件的抽象化程度应该与其稳定性保持一致</li>
<li>组件抽象化的计算方法:组件中的抽象类和接口/组件中类的个数 0表现没有抽象类 1表示全是抽象类</li>
<li>好的组件结构应该在抽象和稳定之间找到一个好的平衡点</li>
</ul>
<h4 id="编码规范和原则《程序员修炼之道》"><a href="#编码规范和原则《程序员修炼之道》" class="headerlink" title="编码规范和原则《程序员修炼之道》"></a>编码规范和原则《程序员修炼之道》</h4><p>从小工到专家，你需要做到下面这些：</p>
<h5 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h5><p><strong>DRY</strong>:系统中的每一项知识都必须具有单一,无歧义,权威的表示.</p>
<p>重复是怎样产生的:</p>
<ul>
<li>强加的重复,开发着觉得无可选择,环境要求.</li>
<li>无意的重复,开发者没有意识到他们在重复.</li>
<li>无耐性的重复,开发者偷懒,copy比较容易.</li>
<li>开发者之间的重复,几个人重复了同样的信息.</li>
</ul>
<h5 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h5><p>正交性是从几何学中借来的术语,如果两条直线相交成直角,它们就是正交的.沿着某一条直线移动,你投影到另一条直线上的位置不变.</p>
<p>正交性的好处:消除无关事物之间的影响(解耦不必要的依赖)</p>
<p><strong>分层设计</strong>是正交系统的强大方式..因为每层都只适用在其下面的层次提供的抽象,在改动底层实现,而又不影响其他代码方面,你拥有极大的灵活性.分层也降低了模块间依赖关系失控的风险.</p>
<p>正交性的简单测试方法:如果我显著的改变某个特定功能背后的需求,有多少模块会受影响?在正交系统中,答案是<strong>一个</strong></p>
<p>正交性在编码中的应用:</p>
<ul>
<li>让你的代码保持解耦</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数</li>
<li>养成不断批判对待自己代码的习惯.寻找任何重新进行组织,以改善其结构和正交性的机会,这个过程叫做重构,它非常重要.</li>
</ul>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>调试的心理学:</p>
<ul>
<li>调试是解决问题,要据此发起进攻</li>
<li>要修正问题,而不是发出指责(bug是你的还是别人的,这不是真的很有关系.)</li>
<li>不要恐慌,如果你看到bug报告的第一反应是<strong>那不可能</strong>,你就完全错了.一个脑细胞都不要浪费在以<strong>“但那时不可能”</strong>起头的思路上,因为很明显,那不仅可能,而且已经发生.</li>
<li>小心近视,要抵制只修正你看到的症状的急迫愿望,更有可能的情况是,实际的故障离你正在观察的地方可能还有几步远,并且可能涉及许多其他的相关事物.</li>
</ul>
<p>调试策略:</p>
<ul>
<li>你需要与qa面谈,搜集比最初给你的数据更多的数据.</li>
<li>qa不可能全覆盖所有的case,你需要系统的进行这样的测试,比如分支语句,你可能需要自己造数据去覆盖所有的分支.</li>
<li>复现bug</li>
<li>数据可视化(log)</li>
<li>堆栈和断点</li>
<li>橡皮鸭,把你的逻辑对着桌上的橡皮鸭描述一遍,看看有没有漏洞.</li>
<li>消除过程,二分调试</li>
<li>遇到自认为不可能的bug时,不要假定,要证明.</li>
</ul>
<h5 id="解耦与得墨忒耳法则"><a href="#解耦与得墨忒耳法则" class="headerlink" title="解耦与得墨忒耳法则"></a>解耦与得墨忒耳法则</h5><p>多模块耦合的危害</p>
<ul>
<li>调用链冗长</li>
<li>对一个模块的简单改动会传遍系统中的一些无关模块</li>
<li>开发者害怕改动代码,因为他们不清楚哪些代码可能受影响</li>
</ul>
<p>函数的得墨忒耳法则规定,某个对象的任何方法都应该只调用以下情形的方法:</p>
<ul>
<li>它自身的方法</li>
<li>传入该方法的任何对象的方法</li>
<li>它创建的任何对象的方法</li>
<li>任何直接持有的组件的对象的方法(比如全局对象)</li>
</ul>
<h5 id="不要靠巧合编程"><a href="#不要靠巧合编程" class="headerlink" title="不要靠巧合编程"></a>不要靠巧合编程</h5><p>深思熟虑的编程,而不是靠运气和偶然的成功.</p>
<p>怎样深思熟虑的编程:</p>
<ul>
<li>总是意识到你在做什么</li>
<li>不要盲目的编程</li>
<li>按照计划行事</li>
<li>依靠可靠的事物,不要依靠巧合或假定</li>
<li>为你的假定建立文档</li>
<li>不要只是测试你的代码,还要测试你的假定</li>
<li>为你的工作划分优先级</li>
<li>不要做历史的奴隶,不要让已有的代码支配将来的代码,如果不再适用,所有的代码都可以被替换.</li>
</ul>
<h5 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h5><p>何时重构:</p>
<ul>
<li>重复,你发现了对DRY原则的违反</li>
<li>非正交的设计</li>
<li>过时的知识</li>
<li>性能问题</li>
</ul>
<p>早重构,常重构</p>
<p>如何重构:</p>
<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前,确保你拥有良好的测试.</li>
<li>采取短小,深思熟虑的步骤.</li>
</ul>
<h5 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h5><ul>
<li>不要留破窗户</li>
<li>不要做温水里的青蛙</li>
<li>交流的重要性</li>
<li>DRY</li>
<li>正交性</li>
</ul>
<h4 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h4><p>早测试,常测试,自动测试</p>
<p>要到通过全部测试,编码才算完成</p>
<p>测试什么:</p>
<ul>
<li><p>单元测试</p>
<p>  模块测试</p>
</li>
<li><p>集成测试</p>
<p>  子系统能很好的系统工作</p>
</li>
<li><p>验证和校验</p>
<p>  用户回归</p>
</li>
<li><p>资源耗尽,错误及恢复</p>
<p>  1.内存空间<br>  2.磁盘空间<br>  3.cpu带宽<br>  4.挂钟时间<br>  5.磁盘带宽<br>  6.网络带宽<br>  7.调色板<br>  8.视频分辨率<br>  9.fps</p>
</li>
<li><p>性能测试</p>
<p>  预期的用户数,连接数或每秒事务数</p>
</li>
<li><p>可用性测试</p>
<p>  qa,灰度…</p>
</li>
</ul>
<h5 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h5><p>在你的作品上签名,你的签名应该被视为质量的保证，如果有一天你离开了网易，是否会因为代码质量问题而把自己的签名换成netease呢？（手动@学姐😁）。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上是一个iOSer项目优化的简单总结，一部分可能是iOS特有的优化项目，还有一部分则具有普适性，因为不管什么技术方向，最终它们的产物都会是二进制。技术的深度和广度这两个方向的发展问题也一直都是程序员们讨论的话题，其实不管是深度和广度，只要找准一个方向一直走下去，就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">53</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
