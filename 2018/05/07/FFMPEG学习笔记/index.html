<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="想要从事音视频相关的工作，FFMPEG是绕不开的一道坎，就像吉他里面的大横按，既然我能给征服大横按，相信我也能征服你，FFMPEG！！！ 自学音视频相关的内容也有一段时间啦，比如之前的H264,RTMP,FLV,还有最近的AudioUint和AudioQueue，通过这段时间的学习，我总结出来的方法就是，先将他们的数据结构分析清楚，了解主要的api，然后从简单的api开始实践。 所以我们先来看一下">
<meta property="og:type" content="article">
<meta property="og:title" content="FFMPEG学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/05/07/FFMPEG学习笔记/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="想要从事音视频相关的工作，FFMPEG是绕不开的一道坎，就像吉他里面的大横按，既然我能给征服大横按，相信我也能征服你，FFMPEG！！！ 自学音视频相关的内容也有一段时间啦，比如之前的H264,RTMP,FLV,还有最近的AudioUint和AudioQueue，通过这段时间的学习，我总结出来的方法就是，先将他们的数据结构分析清楚，了解主要的api，然后从简单的api开始实践。 所以我们先来看一下">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/FFMPEG/20130914204051125.jpg">
<meta property="og:updated_time" content="2019-02-20T02:13:39.286Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FFMPEG学习笔记">
<meta name="twitter:description" content="想要从事音视频相关的工作，FFMPEG是绕不开的一道坎，就像吉他里面的大横按，既然我能给征服大横按，相信我也能征服你，FFMPEG！！！ 自学音视频相关的内容也有一段时间啦，比如之前的H264,RTMP,FLV,还有最近的AudioUint和AudioQueue，通过这段时间的学习，我总结出来的方法就是，先将他们的数据结构分析清楚，了解主要的api，然后从简单的api开始实践。 所以我们先来看一下">
<meta name="twitter:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/FFMPEG/20130914204051125.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2018/05/07/FFMPEG学习笔记/"/>

  <title> FFMPEG学习笔记 | lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                FFMPEG学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-07T17:52:01+08:00" content="2018-05-07">
              2018-05-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/07/FFMPEG学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/FFMPEG学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>想要从事音视频相关的工作，FFMPEG是绕不开的一道坎，就像吉他里面的大横按，既然我能给征服大横按，相信我也能征服你，FFMPEG！！！</p>
<p>自学音视频相关的内容也有一段时间啦，比如之前的H264,RTMP,FLV,还有最近的AudioUint和AudioQueue，通过这段时间的学习，我总结出来的方法就是，先将他们的数据结构分析清楚，了解主要的api，然后从简单的api开始实践。</p>
<p>所以我们先来看一下FFMPEG的主要数据结构和api…</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="文件读取相关"><a href="#文件读取相关" class="headerlink" title="文件读取相关"></a>文件读取相关</h4><h5 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h5><p>AVIOContext是FFMPEG管理输入输出数据的结构体</p>
<p>比较重要的属性：</p>
<ul>
<li><p>unsigned char *buffer：缓存读取的数据</p>
</li>
<li><p>int buffer_size：缓存大小（默认32768）</p>
</li>
<li><p>unsigned char *buf_ptr：当前指针读取到的位置</p>
</li>
<li><p>unsigned char *buf_end：缓存结束的位置</p>
</li>
<li><p>void *opaque：URLContext结构体</p>
</li>
</ul>
<h4 id="协议相关"><a href="#协议相关" class="headerlink" title="协议相关"></a>协议相关</h4><h5 id="URLContext、URLProtocol"><a href="#URLContext、URLProtocol" class="headerlink" title="URLContext、URLProtocol"></a>URLContext、URLProtocol</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">typedef struct URLContext &#123;  </div><div class="line">    const AVClass *av_class; ///&lt; information for av_log(). Set by url_open().  </div><div class="line">    struct URLProtocol *prot;  </div><div class="line">    int flags;  </div><div class="line">    int is_streamed;  /**&lt; true if streamed (no seek possible), default = false */  </div><div class="line">    int max_packet_size;  /**&lt; if non zero, the stream is packetized with this max packet size */  </div><div class="line">    void *priv_data;  </div><div class="line">    char *filename; /**&lt; specified URL */  </div><div class="line">    int is_connected;  </div><div class="line">    AVIOInterruptCB interrupt_callback;  </div><div class="line">&#125; URLContext;  </div><div class="line"></div><div class="line">typedef struct URLProtocol &#123;  </div><div class="line">    const char *name;  </div><div class="line">    int (*url_open)(URLContext *h, const char *url, int flags);  </div><div class="line">    int (*url_read)(URLContext *h, unsigned char *buf, int size);  </div><div class="line">    int (*url_write)(URLContext *h, const unsigned char *buf, int size);  </div><div class="line">    int64_t (*url_seek)(URLContext *h, int64_t pos, int whence);  </div><div class="line">    int (*url_close)(URLContext *h);  </div><div class="line">    struct URLProtocol *next;  </div><div class="line">    int (*url_read_pause)(URLContext *h, int pause);  </div><div class="line">    int64_t (*url_read_seek)(URLContext *h, int stream_index,  </div><div class="line">        int64_t timestamp, int flags);  </div><div class="line">    int (*url_get_file_handle)(URLContext *h);  </div><div class="line">    int priv_data_size;  </div><div class="line">    const AVClass *priv_data_class;  </div><div class="line">    int flags;  </div><div class="line">    int (*url_check)(URLContext *h, int mask);  </div><div class="line">&#125; URLProtocol;</div></pre></td></tr></table></figure>
<p>URLContext结构体中还有一个结构体URLProtocol,每种协议（rtp，rtmp，file等）对应一个URLProtocol。</p>
<h4 id="封装格式相关"><a href="#封装格式相关" class="headerlink" title="封装格式相关"></a>封装格式相关</h4><h5 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h5><p>这个结构体描述了一个媒体文件或媒体流的构成和基本信息</p>
<p>在使用FFMPEG进行开发的时候，AVFormatContext是一个贯穿始终的数据结构，很多函数都要用到它作为参数。</p>
<p>看几个主要变量的作用:</p>
<ul>
<li><p>struct AVInputFormat *iformat：输入数据的封装格式</p>
</li>
<li><p>AVIOContext *pb：输入数据的缓存</p>
</li>
<li><p>unsigned int nb_streams：视音频流的个数</p>
</li>
<li><p>AVStream **streams：音视频流</p>
</li>
<li><p>char filename[1024]：文件名</p>
</li>
<li><p>int64_t duration：时长（单位：微秒us，转换为秒需要除以1000000）</p>
</li>
<li><p>int bit_rate：比特率（单位bps，转换为kbps需要除以1000）</p>
</li>
<li><p>AVDictionary *metadata：元数据</p>
</li>
</ul>
<h5 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h5><p>作为输入容器，包含了输入文件的音视频流信息,程序从输入容器从读出音视频包进行解码处理</p>
<h5 id="AVOutputFormat"><a href="#AVOutputFormat" class="headerlink" title="AVOutputFormat"></a>AVOutputFormat</h5><p>作为输出容器，程序把编码好的音视频包写入到输出容器中</p>
<h4 id="编解码相关"><a href="#编解码相关" class="headerlink" title="编解码相关"></a>编解码相关</h4><h5 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h5><p>这是一个描述编解码器上下文的数据结构，包含了众多编解码器需要的参数信息</p>
<p>看一下关键属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">enum AVMediaType codec_type：编解码器的类型（视频，音频...）</div><div class="line"></div><div class="line">struct AVCodec  *codec：采用的解码器AVCodec（H.264,MPEG2...）</div><div class="line"></div><div class="line">int bit_rate：平均比特率</div><div class="line"></div><div class="line">uint8_t *extradata; int extradata_size：针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</div><div class="line"></div><div class="line">AVRational time_base：根据该参数，可以把PTS转化为实际的时间（单位为秒s）</div><div class="line"></div><div class="line">int width, height：如果是视频的话，代表宽和高</div><div class="line"></div><div class="line">int refs：运动估计参考帧的个数（H.264的话会有多帧，MPEG2这类的一般就没有了）</div><div class="line"></div><div class="line">int sample_rate：采样率（音频）</div><div class="line"></div><div class="line">int channels：声道数（音频）</div><div class="line"></div><div class="line">enum AVSampleFormat sample_fmt：采样格式</div><div class="line"></div><div class="line">int profile：型（H.264里面就有，其他编码标准应该也有）</div><div class="line"></div><div class="line">int level：级（和profile差不太多）</div></pre></td></tr></table></figure>
<h5 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h5><p>AVCodec是存储编解码器信息的结构体，每一个编解码器对应一个该结构体。</p>
<p>下面说一下最主要的几个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const char *name：编解码器的名字，比较短</div><div class="line"></div><div class="line">const char *long_name：编解码器的名字，全称，比较长</div><div class="line"></div><div class="line">enum AVMediaType type：指明了类型，是视频，音频，还是字幕</div><div class="line"></div><div class="line">enum AVCodecID id：ID，不重复</div><div class="line"></div><div class="line">const AVRational *supported_framerates：支持的帧率（仅视频）</div><div class="line"></div><div class="line">const enum AVPixelFormat *pix_fmts：支持的像素格式（仅视频）</div><div class="line"></div><div class="line">const int *supported_samplerates：支持的采样率（仅音频）</div><div class="line"></div><div class="line">const enum AVSampleFormat *sample_fmts：支持的采样格式（仅音频）</div><div class="line"></div><div class="line">const uint64_t *channel_layouts：支持的声道数（仅音频）</div><div class="line"></div><div class="line">int priv_data_size：私有数据的大小</div></pre></td></tr></table></figure>
<h5 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h5><p>AVStream是存储每一个视频/音频流信息的结构体</p>
<p>AVStream重要的变量如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int index：标识该视频/音频流</div><div class="line"></div><div class="line">AVCodecContext *codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）</div><div class="line"></div><div class="line">AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。FFMPEG其他结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。PTS*time_base=真正的时间</div><div class="line"></div><div class="line">int64_t duration：该视频/音频流长度</div><div class="line"></div><div class="line">AVDictionary *metadata：元数据信息</div><div class="line"></div><div class="line">AVRational avg_frame_rate：帧率（注：对视频来说，这个挺重要的）</div><div class="line"></div><div class="line">AVPacket attached_pic：附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面。</div></pre></td></tr></table></figure>
<h5 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h5><p>AVPacket是存储压缩编码数据相关信息的结构体</p>
<p>重要的变量有以下几个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!--例如对于H.264来说。1个AVPacket的data通常对应一个NAL。</div><div class="line"></div><div class="line">注意：在这里只是对应，而不是一模一样。他们之间有微小的差别：使用FFMPEG类库分离出多媒体文件中的H.264码流</div><div class="line"></div><div class="line">因此在使用FFMPEG进行视音频处理的时候，常常可以将得到的AVPacket的data数据直接写成文件，从而得到视音频的码流文件。</div><div class="line">--&gt;</div><div class="line"></div><div class="line">uint8_t *data：压缩编码的数据。</div><div class="line"></div><div class="line">int   size：data的大小</div><div class="line"></div><div class="line">int64_t pts：显示时间戳</div><div class="line"></div><div class="line">int64_t dts：解码时间戳</div><div class="line"></div><div class="line">int   stream_index：标识该AVPacket所属的视频/音频流。</div></pre></td></tr></table></figure>
<h5 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h5><p>AVFrame结构体一般用于存储原始数据（即非压缩数据，例如对视频来说是YUV，RGB，对音频来说是PCM），此外还包含了一些相关的信息。比如说，解码的时候存储了宏块类型表，QP表，运动矢量表等数据。编码的时候也存储了相关的数据。因此在使用FFMPEG进行码流分析的时候，AVFrame是一个很重要的结构体。</p>
<p>下面看几个主要变量的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uint8_t *data[AV_NUM_DATA_POINTERS]：解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）</div><div class="line"></div><div class="line">int linesize[AV_NUM_DATA_POINTERS]：data中“一行”数据的大小。注意：未必等于图像的宽，一般大于图像的宽。</div><div class="line"></div><div class="line">int width, height：视频帧宽和高（1920x1080,1280x720...）</div><div class="line"></div><div class="line">int nb_samples：音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个</div><div class="line"></div><div class="line">int format：解码后原始数据类型（YUV420，YUV422，RGB24...）</div><div class="line"></div><div class="line">int key_frame：是否是关键帧</div><div class="line"></div><div class="line">enum AVPictureType pict_type：帧类型（I,B,P...）</div><div class="line"></div><div class="line">AVRational sample_aspect_ratio：宽高比（16:9，4:3...）</div><div class="line"></div><div class="line">int64_t pts：显示时间戳</div><div class="line"></div><div class="line">int coded_picture_number：编码帧序号</div><div class="line"></div><div class="line">int display_picture_number：显示帧序号</div><div class="line"></div><div class="line">int8_t *qscale_table：QP表</div><div class="line"></div><div class="line">uint8_t *mbskip_table：跳过宏块表</div><div class="line"></div><div class="line">int16_t (*motion_val[2])[2]：运动矢量表</div><div class="line"></div><div class="line">uint32_t *mb_type：宏块类型表</div><div class="line"></div><div class="line">short *dct_coeff：DCT系数，这个没有提取过</div><div class="line"></div><div class="line">int8_t *ref_index[2]：运动估计参考帧列表（貌似H.264这种比较新的标准才会涉及到多参考帧）</div><div class="line"></div><div class="line">int interlaced_frame：是否是隔行扫描</div><div class="line"></div><div class="line">uint8_t motion_subsample_log2：一个宏块中的运动矢量采样个数，取log的</div></pre></td></tr></table></figure>
<p>结构体之间的关系可以参考下图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/FFMPEG/20130914204051125.jpg" alt=""></p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="avcodec-init"><a href="#avcodec-init" class="headerlink" title="avcodec_init()"></a>avcodec_init()</h4><p>初始化libavcodec,一般最先调用该函数</p>
<p>该函数必须在调用libavcodec里的其它函数前调用,一般在程序启动或模块初始化时调用,如果你调用了多次也无所谓,因为后面的调用不会做任何事情.从函数的实现里你可以发现,代码中对多次调用进行了控制.</p>
<h4 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all()"></a>av_register_all()</h4><p>初始化 libavformat和注册所有的muxers、demuxers和protocols，</p>
<p>一般在调用avcodec_init后调用该方法</p>
<p>其中会调用avcodec_register_all()注册多种音视频格式的编解码器,并注册各种文件的编解复用器</p>
<h4 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context()"></a>avformat_alloc_context()</h4><p>分配一个AVFormatContext结构，负责申请一个AVFormatContext结构的内存,并进行简单初始化</p>
<h4 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input()"></a>avformat_open_input()</h4><p>打开一个流媒体文件</p>
<h4 id="avformat-close-input"><a href="#avformat-close-input" class="headerlink" title="avformat_close_input()"></a>avformat_close_input()</h4><p>关闭一个流媒体文件</p>
<h4 id="avformat-free-context"><a href="#avformat-free-context" class="headerlink" title="avformat_free_context()"></a>avformat_free_context()</h4><p>释放一个AVFormatContext结构</p>
<p>使用 avformat_alloc_context()分配的结构,采用该函数进行释放,除释放AVFormatContext结构本身内存之外,AVFormatContext中指针所指向的内存也会一并释放</p>
<h4 id="avio-alloc-context"><a href="#avio-alloc-context" class="headerlink" title="avio_alloc_context()"></a>avio_alloc_context()</h4><p>为I/0缓存申请并初始化一个AVIOContext结构,结束使用时必须使用av_free()进行释放</p>
<h4 id="av-open-input-file"><a href="#av-open-input-file" class="headerlink" title="av_open_input_file()"></a>av_open_input_file()</h4><p>以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息.</p>
<h4 id="av-close-input-file"><a href="#av-close-input-file" class="headerlink" title="av_close_input_file()"></a>av_close_input_file()</h4><p>关闭使用avformat_close_input()打开的输入文件容器,但并不关系它的codecs</p>
<p>使用 av_close_input_file 关闭后,就不再需要使用avformat_free_context 进行释放了</p>
<h4 id="av-find-stream-info-AVFormatContext-ic"><a href="#av-find-stream-info-AVFormatContext-ic" class="headerlink" title="av_find_stream_info(AVFormatContext *ic)"></a>av_find_stream_info(AVFormatContext *ic)</h4><p>通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的</p>
<h4 id="AVCodec-avcodec-find-decoder-enum-CodecID-id"><a href="#AVCodec-avcodec-find-decoder-enum-CodecID-id" class="headerlink" title="AVCodec *avcodec_find_decoder(enum CodecID id)"></a>AVCodec *avcodec_find_decoder(enum CodecID id)</h4><p>通过code ID查找一个已经注册的音视频解码器</p>
<p>查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p>音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的ID来查找</p>
<h4 id="AVCodec-avcodec-find-decoder-by-name-constchar-name"><a href="#AVCodec-avcodec-find-decoder-by-name-constchar-name" class="headerlink" title="AVCodec  avcodec_find_decoder_by_name (constchar  name)"></a>AVCodec <em> avcodec_find_decoder_by_name (constchar </em> name)</h4><p>通过一个指定的名称查找一个已经注册的音视频解码器</p>
<p>查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p>音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的name来查找</p>
<h4 id="avcodec-find-encoder"><a href="#avcodec-find-encoder" class="headerlink" title="avcodec_find_encoder()"></a>avcodec_find_encoder()</h4><h4 id="avcodec-find-encoder-by-name"><a href="#avcodec-find-encoder-by-name" class="headerlink" title="avcodec_find_encoder_by_name()"></a>avcodec_find_encoder_by_name()</h4><p>同上。。。</p>
<h4 id="int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2"><a href="#int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2" class="headerlink" title="int avcodec_open(AVCodecContext  avctx, AVCodec  codec) / avcodec_open2()"></a>int avcodec_open(AVCodecContext <em> avctx, AVCodec </em> codec) / avcodec_open2()</h4><p>使用给定的AVCodec初始化AVCodecContext</p>
<h4 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format()"></a>av_guess_format()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AVOutputFormat *av_guess_format(constchar *short_name,</div><div class="line"></div><div class="line">                                constchar *filename,</div><div class="line"></div><div class="line">                                constchar *mime_type);</div></pre></td></tr></table></figure>
<p>返回一个已经注册的最合适的输出格式</p>
<h4 id="void-av-init-packet-AVPacket-pkt"><a href="#void-av-init-packet-AVPacket-pkt" class="headerlink" title="void av_init_packet(AVPacket *pkt);"></a>void av_init_packet(AVPacket *pkt);</h4><p>使用默认值初始化AVPacket</p>
<p>定义AVPacket对象后,请使用av_init_packet进行初始化</p>
<h4 id="int-av-read-frame-AVFormatContext-s-AVPacket-pkt"><a href="#int-av-read-frame-AVFormatContext-s-AVPacket-pkt" class="headerlink" title="int av_read_frame(AVFormatContext  s, AVPacket  pkt)"></a>int av_read_frame(AVFormatContext <em> s, AVPacket </em> pkt)</h4><p>从输入源文件容器中读取一个AVPacket数据包</p>
<p>该函数读出的包并不每次都是有效的,对于读出的包我们都应该进行相应的解码(视频解码/音频解码),</p>
<p>在返回值&gt;=0时,循环调用该函数进行读取,循环调用之前请调用av_free_packet函数清理AVPacket</p>
<h4 id="avcodec-decode-video2"><a href="#avcodec-decode-video2" class="headerlink" title="avcodec_decode_video2()"></a>avcodec_decode_video2()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int avcodec_decode_video2(AVCodecContext *avctx, 										AVFrame *picture,</div><div class="line">                         int *got_picture_ptr,</div><div class="line">                         AVPacket *avpkt);</div><div class="line">                         </div><div class="line">                         </div><div class="line">// 解码视频流AVPacket</div><div class="line">// 使用av_read_frame读取媒体流后需要进行判断,如果为视频流则调用该函数解码</div><div class="line">// 返回结果&lt;0时失败,此时程序应该退出检查原因</div><div class="line">// 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做</div><div class="line">// 如下处理:</div><div class="line">//   vPacket.size -= vLen;</div><div class="line">//   vPacket.data += vLen;</div><div class="line">// 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</div><div class="line">// 返回 got_picture_ptr &gt; 0 时,表示解码到了AVFrame *picture,其后可以对picture进程处理</div></pre></td></tr></table></figure>
<h4 id="avcodec-decode-audio3-avcodec-decode-audio4"><a href="#avcodec-decode-audio3-avcodec-decode-audio4" class="headerlink" title="avcodec_decode_audio3()/avcodec_decode_audio4()"></a>avcodec_decode_audio3()/avcodec_decode_audio4()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples,</div><div class="line"></div><div class="line">                         int *frame_size_ptr,</div><div class="line"></div><div class="line">                         AVPacket *avpkt);</div><div class="line">                         </div><div class="line">int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,</div><div class="line">int *got_frame_ptr, </div><div class="line">const AVPacket *avpkt);</div><div class="line"></div><div class="line"></div><div class="line">// 解码音频流AVPacket</div><div class="line">// 使用av_read_frame读取媒体流后需要进行判断,如果为音频流则调用该函数解码</div><div class="line">// 返回结果&lt;0时失败,此时程序应该退出检查原因</div><div class="line">// 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做</div><div class="line">// 如下处理:</div><div class="line">//   vPacket.size -= vLen;</div><div class="line">//   vPacket.data += vLen;</div><div class="line">// 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/07/使用AudioQueue实现一个音频播放器/" rel="next" title="使用AudioQueue实现一个音频播放器">
                <i class="fa fa-chevron-left"></i> 使用AudioQueue实现一个音频播放器
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/15/使用FFMPEG解码之-音频解码/" rel="prev" title="使用FFMPEG解码之--音频解码">
                使用FFMPEG解码之--音频解码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/05/07/FFMPEG学习笔记/"
           data-title="FFMPEG学习笔记" data-url="http://yoursite.com/2018/05/07/FFMPEG学习笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">63</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件读取相关"><span class="nav-number">1.1.</span> <span class="nav-text">文件读取相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVIOContext"><span class="nav-number">1.1.1.</span> <span class="nav-text">AVIOContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议相关"><span class="nav-number">1.2.</span> <span class="nav-text">协议相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URLContext、URLProtocol"><span class="nav-number">1.2.1.</span> <span class="nav-text">URLContext、URLProtocol</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装格式相关"><span class="nav-number">1.3.</span> <span class="nav-text">封装格式相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVFormatContext"><span class="nav-number">1.3.1.</span> <span class="nav-text">AVFormatContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVInputFormat"><span class="nav-number">1.3.2.</span> <span class="nav-text">AVInputFormat</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVOutputFormat"><span class="nav-number">1.3.3.</span> <span class="nav-text">AVOutputFormat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编解码相关"><span class="nav-number">1.4.</span> <span class="nav-text">编解码相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVCodecContext"><span class="nav-number">1.4.1.</span> <span class="nav-text">AVCodecContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVCodec"><span class="nav-number">1.4.2.</span> <span class="nav-text">AVCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVStream"><span class="nav-number">1.4.3.</span> <span class="nav-text">AVStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVPacket"><span class="nav-number">1.4.4.</span> <span class="nav-text">AVPacket</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVFrame"><span class="nav-number">1.4.5.</span> <span class="nav-text">AVFrame</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#api"><span class="nav-number">2.</span> <span class="nav-text">api</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#avcodec-init"><span class="nav-number">2.1.</span> <span class="nav-text">avcodec_init()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#av-register-all"><span class="nav-number">2.2.</span> <span class="nav-text">av_register_all()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avformat-alloc-context"><span class="nav-number">2.3.</span> <span class="nav-text">avformat_alloc_context()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avformat-open-input"><span class="nav-number">2.4.</span> <span class="nav-text">avformat_open_input()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avformat-close-input"><span class="nav-number">2.5.</span> <span class="nav-text">avformat_close_input()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avformat-free-context"><span class="nav-number">2.6.</span> <span class="nav-text">avformat_free_context()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avio-alloc-context"><span class="nav-number">2.7.</span> <span class="nav-text">avio_alloc_context()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#av-open-input-file"><span class="nav-number">2.8.</span> <span class="nav-text">av_open_input_file()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#av-close-input-file"><span class="nav-number">2.9.</span> <span class="nav-text">av_close_input_file()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#av-find-stream-info-AVFormatContext-ic"><span class="nav-number">2.10.</span> <span class="nav-text">av_find_stream_info(AVFormatContext *ic)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVCodec-avcodec-find-decoder-enum-CodecID-id"><span class="nav-number">2.11.</span> <span class="nav-text">AVCodec *avcodec_find_decoder(enum CodecID id)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVCodec-avcodec-find-decoder-by-name-constchar-name"><span class="nav-number">2.12.</span> <span class="nav-text">AVCodec  avcodec_find_decoder_by_name (constchar  name)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avcodec-find-encoder"><span class="nav-number">2.13.</span> <span class="nav-text">avcodec_find_encoder()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avcodec-find-encoder-by-name"><span class="nav-number">2.14.</span> <span class="nav-text">avcodec_find_encoder_by_name()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2"><span class="nav-number">2.15.</span> <span class="nav-text">int avcodec_open(AVCodecContext  avctx, AVCodec  codec) / avcodec_open2()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#av-guess-format"><span class="nav-number">2.16.</span> <span class="nav-text">av_guess_format()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-av-init-packet-AVPacket-pkt"><span class="nav-number">2.17.</span> <span class="nav-text">void av_init_packet(AVPacket *pkt);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-av-read-frame-AVFormatContext-s-AVPacket-pkt"><span class="nav-number">2.18.</span> <span class="nav-text">int av_read_frame(AVFormatContext  s, AVPacket  pkt)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avcodec-decode-video2"><span class="nav-number">2.19.</span> <span class="nav-text">avcodec_decode_video2()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avcodec-decode-audio3-avcodec-decode-audio4"><span class="nav-number">2.20.</span> <span class="nav-text">avcodec_decode_audio3()/avcodec_decode_audio4()</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
