<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="上图按模块整理了sd各模块的类  上图则表示了各模块和类在整理项目中的层级关系。 根据上面的模块图，我这里先按照模块对源码进行学习和分析。 下载模块因为之前看了af，sd的下载模块应该也是基于NSUrlSession封装的，所以先看下载模块。 SDWebImageDownloaderOperationSDWebImageDownloaderOperation是继承自系统的NSOperation,">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/06/19/SDWebImage学习笔记/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="上图按模块整理了sd各模块的类  上图则表示了各模块和类在整理项目中的层级关系。 根据上面的模块图，我这里先按照模块对源码进行学习和分析。 下载模块因为之前看了af，sd的下载模块应该也是基于NSUrlSession封装的，所以先看下载模块。 SDWebImageDownloaderOperationSDWebImageDownloaderOperation是继承自系统的NSOperation,">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ofy1hyquv.bkt.clouddn.com/sd1.png">
<meta property="og:image" content="http://ofy1hyquv.bkt.clouddn.com/sd2.png">
<meta property="og:updated_time" content="2018-06-22T07:15:40.848Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDWebImage学习笔记">
<meta name="twitter:description" content="上图按模块整理了sd各模块的类  上图则表示了各模块和类在整理项目中的层级关系。 根据上面的模块图，我这里先按照模块对源码进行学习和分析。 下载模块因为之前看了af，sd的下载模块应该也是基于NSUrlSession封装的，所以先看下载模块。 SDWebImageDownloaderOperationSDWebImageDownloaderOperation是继承自系统的NSOperation,">
<meta name="twitter:image" content="http://ofy1hyquv.bkt.clouddn.com/sd1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2018/06/19/SDWebImage学习笔记/"/>

  <title> SDWebImage学习笔记 | lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SDWebImage学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-19T11:09:20+08:00" content="2018-06-19">
              2018-06-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/19/SDWebImage学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/19/SDWebImage学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://ofy1hyquv.bkt.clouddn.com/sd1.png" alt=""></p>
<p>上图按模块整理了sd各模块的类</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/sd2.png" alt=""></p>
<p>上图则表示了各模块和类在整理项目中的层级关系。</p>
<p>根据上面的模块图，我这里先按照模块对源码进行学习和分析。</p>
<h3 id="下载模块"><a href="#下载模块" class="headerlink" title="下载模块"></a>下载模块</h3><p>因为之前看了af，sd的下载模块应该也是基于NSUrlSession封装的，所以先看下载模块。</p>
<h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>SDWebImageDownloaderOperation是继承自系统的NSOperation,然后自己实现了一套异步操作的相关操作。这里不展开讲自定义NSOpration需要做哪些事情，网上应该有很多相关demo和文章。</p>
<p>SDWebImageDownloaderOperation的内部通过NSUrlSession创建task进行图片的下载，每个request的httpmethod默认为GET方式，这也方便拿到下载过程中的图片数据。</p>
<p>SDWebImageDownloaderOperation里面使用NSURLCache对URL的resopne进行缓存，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">    // Grab the cached data for later check</div><div class="line">    NSURLCache *URLCache = session.configuration.URLCache;</div><div class="line">    if (!URLCache) &#123;</div><div class="line">        URLCache = [NSURLCache sharedURLCache];</div><div class="line">    &#125;</div><div class="line">    NSCachedURLResponse *cachedResponse;</div><div class="line">    // NSURLCache&apos;s `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483</div><div class="line">    @synchronized (URLCache) &#123;</div><div class="line">        cachedResponse = [URLCache cachedResponseForRequest:self.request];</div><div class="line">    &#125;</div><div class="line">    if (cachedResponse) &#123;</div><div class="line">        self.cachedData = cachedResponse.data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>URLCache相关内容可以<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="noopener">参考这一篇文章</a></p>
<p>SDWebImageDownloaderOperation同时支持了后台下载，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</div><div class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">    __weak __typeof__ (self) wself = self;</div><div class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</div><div class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">        __strong __typeof (wself) sself = wself;</div><div class="line"></div><div class="line">        if (sself) &#123;</div><div class="line">            [sself cancel];</div><div class="line"></div><div class="line">            [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">            sself.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SDWebImageDownloaderOperation将每个task的progress回调和Complete回调存放在一个 <em>callbackBlocks</em> 的数组中，方便在收到NSURLSessionDelegate的代理时调用相对应的block,将数据传出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//添加了查找block</div><div class="line"></div><div class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</div><div class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</div><div class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</div><div class="line">    LOCK(self.callbacksLock);</div><div class="line">    [self.callbackBlocks addObject:callbacks];</div><div class="line">    UNLOCK(self.callbacksLock);</div><div class="line">    return callbacks;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123;</div><div class="line">    LOCK(self.callbacksLock);</div><div class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</div><div class="line">    UNLOCK(self.callbacksLock);</div><div class="line">    // We need to remove [NSNull null] because there might not always be a progress block for each callback</div><div class="line">    [callbacks removeObjectIdenticalTo:[NSNull null]];</div><div class="line">    return [callbacks copy]; // strip mutability here</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用Progress block</div><div class="line">for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">    progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用Complete block</div><div class="line"></div><div class="line">[self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</div><div class="line"></div><div class="line">- (void)callCompletionBlocksWithImage:(nullable UIImage *)image</div><div class="line">                            imageData:(nullable NSData *)imageData</div><div class="line">                                error:(nullable NSError *)error</div><div class="line">                             finished:(BOOL)finished &#123;</div><div class="line">    NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey];</div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123;</div><div class="line">            completedBlock(image, imageData, error, finished);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在收到didReceiveData回调后，如果当前options为SDWebImageDownloaderProgressiveDownload的话，还需要将收到的这部分图片数据进行解码后显示，显然这不是完整的数据，不过这部分数据也是可以正常显示的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if (!self.progressiveCoder) &#123;</div><div class="line">    // We need to create a new instance for progressive decoding to avoid conflicts</div><div class="line">    for (id&lt;SDWebImageCoder&gt;coder in [SDWebImageCodersManager sharedInstance].coders) &#123;</div><div class="line">        if ([coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)] &amp;&amp;</div><div class="line">            [((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</div><div class="line">            self.progressiveCoder = [[[coder class] alloc] init];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">// progressive decode the image in coder queue</div><div class="line">dispatch_async(self.coderQueue, ^&#123;</div><div class="line">    UIImage *image = [self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</div><div class="line">    if (image) &#123;</div><div class="line">        NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">        image = [self scaledImageForKey:key image:image];</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</div><div class="line">        </div><div class="line">        [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在收到didCompleteWithError回调后，会异步解码收到的image数据,gif和webp除外，这两会走另外的解码接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// decode the image in coder queue</div><div class="line">dispatch_async(self.coderQueue, ^&#123;</div><div class="line">    UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</div><div class="line">    NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">    image = [self scaledImageForKey:key image:image];</div><div class="line">    </div><div class="line">    BOOL shouldDecode = YES;</div><div class="line">    // Do not force decoding animated GIFs and WebPs</div><div class="line">    if (image.images) &#123;</div><div class="line">        shouldDecode = NO;</div><div class="line">    &#125; else &#123;</div><div class="line">#ifdef SD_WEBP</div><div class="line">        SDImageFormat imageFormat = [NSData sd_imageFormatForImageData:imageData];</div><div class="line">        if (imageFormat == SDImageFormatWebP) &#123;</div><div class="line">            shouldDecode = NO;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (shouldDecode) &#123;</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            BOOL shouldScaleDown = self.options &amp; SDWebImageDownloaderScaleDownLargeImages;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    CGSize imageSize = image.size;</div><div class="line">    if (imageSize.width == 0 || imageSize.height == 0) &#123;</div><div class="line">        [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];</div><div class="line">    &#125;</div><div class="line">    [self done];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>sd做https的证书验证方法很简单，如果自定义的证书不为空，则返回自定义的证书，为空的话，直接将服务器的证书返回并标识验证成功，所以实际上它这里只是简单的返回证书，并没有对证书做一个校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</div><div class="line">    </div><div class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">    __block NSURLCredential *credential = nil;</div><div class="line">    </div><div class="line">    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">        if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125; else &#123;</div><div class="line">            credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">            disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (challenge.previousFailureCount == 0) &#123;</div><div class="line">            if (self.credential) &#123;</div><div class="line">                credential = self.credential;</div><div class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p>SDWebImageDownloader是SDWebImageDownloaderOperation的管理类，和af不同的是，SDWebImageDownloader创建了一个NSOperationQueue，管理每个nsoperation。当nsoperation被标记为finish或者cancel后，会自动从Queue中移除。</p>
<p>看一下SDWebImageDownloader是如何管理operation的，比较重要的就是下面这一段代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(nullable NSURL *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</div><div class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</div><div class="line">    if (url == nil) &#123;</div><div class="line">        if (completedBlock != nil) &#123;</div><div class="line">            completedBlock(nil, nil, nil, NO);</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LOCK(self.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</div><div class="line">    // There is a case that the operation may be marked as finished, but not been removed from `self.URLOperations`.</div><div class="line">    if (!operation || operation.isFinished) &#123;</div><div class="line">        operation = createCallback();</div><div class="line">        __weak typeof(self) wself = self;</div><div class="line">        operation.completionBlock = ^&#123;</div><div class="line">            __strong typeof(wself) sself = wself;</div><div class="line">            if (!sself) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            LOCK(sself.operationsLock);</div><div class="line">            [sself.URLOperations removeObjectForKey:url];</div><div class="line">            UNLOCK(sself.operationsLock);</div><div class="line">        &#125;;</div><div class="line">        [self.URLOperations setObject:operation forKey:url];</div><div class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</div><div class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</div><div class="line">        [self.downloadQueue addOperation:operation];</div><div class="line">    &#125;</div><div class="line">    UNLOCK(self.operationsLock);</div><div class="line"></div><div class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">    </div><div class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</div><div class="line">    token.downloadOperation = operation;</div><div class="line">    token.url = url;</div><div class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line"></div><div class="line">    return token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sd将每一个operation存在URLOperations里面，key是url，value是operation,当需要创建一个下载任务时，先从这个URLOperations的字典中查找是否已经有对应的下载任务，如果没有的话，将createCallback（）这个block的返回值赋值给一个新的operation对象（并在opration的完成块中将它从URLOperations字典中移除），给opration添加相应的progressBlock和completeBlock,后将它存入URLOperations中，并创建opration对应的SDWebImageDownloadToken对象，再将该token对象返回。</p>
<p>上面这段描述中有2个地方需要注意下：</p>
<p>第一个是createCallback（）这个是个啥？看看下面这段代码就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __weak SDWebImageDownloader *wself = self;</div><div class="line"></div><div class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        __strong __typeof (wself) sself = wself;</div><div class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</div><div class="line">        if (timeoutInterval == 0.0) &#123;</div><div class="line">            timeoutInterval = 15.0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</div><div class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</div><div class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</div><div class="line">                                                                    cachePolicy:cachePolicy</div><div class="line">                                                                timeoutInterval:timeoutInterval];</div><div class="line">        </div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = YES;</div><div class="line">        if (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</div><div class="line">        &#125;</div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        if (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>createCallback其实就是创建一个新的downloadoperation，然后将这个downloadoperation返回。</p>
<p>第二个问题是SDWebImageDownloadToken这个类是用来干嘛的，也是看一下下面这个方法应该就清楚了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token &#123;</div><div class="line">    NSURL *url = token.url;</div><div class="line">    if (!url) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</div><div class="line">    if (operation) &#123;</div><div class="line">        BOOL canceled = [operation cancel:token.downloadOperationCancelToken];</div><div class="line">        if (canceled) &#123;</div><div class="line">            [self.URLOperations removeObjectForKey:url];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    UNLOCK(self.operationsLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>token.url为下载的文件url,operation为当前下载这个文件的任务，downloadOperationCancelToken实际上是一个字典，里面存了这个任务的progressBlock和completedBlock，保存这个主要是为了取消的时候把operation中保存的这两block给移除掉。</p>
<p>总结一下就是，这个SDWebImageDownloadToken对象其实就是用在cancel的时候移除之前保存在相关字典中的数据的。在SDWebImageManager中也是这么用的。</p>
<h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>看完下载模块，再来看一下缓存模块。大家都知道sd里面的缓存用到了NSCache,那它到底是咋用的呢，我们具体看一下吧。</p>
<h4 id="SDImageCacheConfig"><a href="#SDImageCacheConfig" class="headerlink" title="SDImageCacheConfig"></a>SDImageCacheConfig</h4><p>先来看一下这个config类中都定义了哪些变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</div><div class="line"></div><div class="line">@implementation SDImageCacheConfig</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">    	//需要解码</div><div class="line">        _shouldDecompressImages = YES;</div><div class="line">        //不适用iCloud存储</div><div class="line">        _shouldDisableiCloud = YES;</div><div class="line">        //存到内存</div><div class="line">        _shouldCacheImagesInMemory = YES;</div><div class="line">        //系统读写相关属性</div><div class="line">        _diskCacheReadingOptions = 0;</div><div class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</div><div class="line">        //过期时间</div><div class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</div><div class="line">        //最大存储空间 0则为没有限制</div><div class="line">        _maxCacheSize = 0;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>NSCache相关内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// A memory cache which auto purge the cache on memory warning and support weak cache.</div><div class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// Private</div><div class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</div><div class="line"></div><div class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</div><div class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可以看到sd自定义了一个继承自NSCache的类，并申明了一个NSMapTable类型的属性weakCache，直接用NSCache不就可以存储变量到内存了吗，这里为啥还要加一个NSMapTable呢。我们先看一下这个NSMapTable的初始化（<a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">NSMapTable相关内容参考这里</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</div></pre></td></tr></table></figure>
<p>可以看到，NSMapTable中存在值都是weak的，如果value被释放，则存的值将变为空，然后我们看一下自定义的SDMemoryCache类的get和set方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// `setObject:forKey:` just call this with 0 cost. Override this is enough</div><div class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</div><div class="line">    [super setObject:obj forKey:key cost:g];</div><div class="line">    if (key &amp;&amp; obj) &#123;</div><div class="line">        // Store weak cache</div><div class="line">        LOCK(self.weakCacheLock);</div><div class="line">        [self.weakCache setObject:obj forKey:key];</div><div class="line">        UNLOCK(self.weakCacheLock);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)objectForKey:(id)key &#123;</div><div class="line">    id obj = [super objectForKey:key];</div><div class="line">    if (key &amp;&amp; !obj) &#123;</div><div class="line">        // Check weak cache</div><div class="line">        LOCK(self.weakCacheLock);</div><div class="line">        obj = [self.weakCache objectForKey:key];</div><div class="line">        UNLOCK(self.weakCacheLock);</div><div class="line">        if (obj) &#123;</div><div class="line">            // Sync cache</div><div class="line">            NSUInteger cost = 0;</div><div class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</div><div class="line">                cost = SDCacheCostForImage(obj);</div><div class="line">            &#125;</div><div class="line">            [super setObject:obj forKey:key cost:cost];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对内存中图片的存取都是做了2次操作，一次是存到NSCache中，一次是存到NSMapTable中，大家都知道NSCache有一个特性就是当系统内存不足的时候会首先回收NSCache的内存，看这段get的代码，这里作者应该是考虑如果NSCache中内存被回收了可以从NSMapTable中继续找到该图片数据，不用去读磁盘数据或者重新下载。</p>
<p>然后我们来看一下存储到disk的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">if (toDisk) &#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            NSData *data = imageData;</div><div class="line">            if (!data &amp;&amp; image) &#123;</div><div class="line">                // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format</div><div class="line">                SDImageFormat format;</div><div class="line">                if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</div><div class="line">                    format = SDImageFormatPNG;</div><div class="line">                &#125; else &#123;</div><div class="line">                    format = SDImageFormatJPEG;</div><div class="line">                &#125;</div><div class="line">                data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</div><div class="line">            &#125;</div><div class="line">            [self _storeImageDataToDisk:data forKey:key];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的图片data不为空则直接存在磁盘，如果为空而且图片对象不为空，则需要先对图片进行编码处理转为data在存到磁盘中,这是因为data是直接从服务器拿到的数据，是编码过的，而image则是已经解码了的，是原始数据，数据量会比较大，所以需要先编码在存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</div><div class="line">    if (!imageData || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // get cache Path for image key</div><div class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">    // transform to NSUrl</div><div class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line">    </div><div class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</div><div class="line">    </div><div class="line">    // disable iCloud backup</div><div class="line">    if (self.config.shouldDisableiCloud) &#123;</div><div class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>存储过程很简单，就是一个文件写入就OK了。写入前先判断一下文件夹是否存在，不存在的话先创建一个。</p>
<p>然后我们看一下比较重要的一个方法，图片的查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">// First check the in-memory cache...</div><div class="line">UIImage *image = [self imageFromMemoryCacheForKey:key];</div><div class="line">BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</div><div class="line">if (shouldQueryMemoryOnly) &#123;</div><div class="line">    if (doneBlock) &#123;</div><div class="line">        doneBlock(image, nil, SDImageCacheTypeMemory);</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">NSOperation *operation = [NSOperation new];</div><div class="line">void(^queryDiskBlock)(void) =  ^&#123;</div><div class="line">    if (operation.isCancelled) &#123;</div><div class="line">        // do not call the completion if cancelled</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        UIImage *diskImage;</div><div class="line">        SDImageCacheType cacheType = SDImageCacheTypeDisk;</div><div class="line">        if (image) &#123;</div><div class="line">            // the image is from in-memory cache</div><div class="line">            diskImage = image;</div><div class="line">            cacheType = SDImageCacheTypeMemory;</div><div class="line">        &#125; else if (diskData) &#123;</div><div class="line">            // decode image data only if in-memory cache missed</div><div class="line">            diskImage = [self diskImageForKey:key data:diskData options:options];</div><div class="line">            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (doneBlock) &#123;</div><div class="line">            if (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">                doneBlock(diskImage, diskData, cacheType);</div><div class="line">            &#125; else &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, cacheType);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">if (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">    queryDiskBlock();</div><div class="line">&#125; else &#123;</div><div class="line">    dispatch_async(self.ioQueue, queryDiskBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先从nscache中查找，如果查找成功且options为SDImageCacheQueryDataWhenInMemory，则返回nscache中的结果<br>如果nscache查找失败，则查找disk中的data,并解码该data同时将解码后的image塞到nscache中,然后返回。</p>
<p>sd还提供了一个删除缓存文件的方法，在该方法中，一共使用了2种删除策略，第一种是按过期时间删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</div><div class="line">NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</div><div class="line">NSUInteger currentCacheSize = 0;</div><div class="line"></div><div class="line">// Enumerate all of the files in the cache directory.  This loop has two purposes:</div><div class="line">//</div><div class="line">//  1. Removing files that are older than the expiration date.</div><div class="line">//  2. Storing file attributes for the size-based cleanup pass.</div><div class="line">NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</div><div class="line">for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">    NSError *error;</div><div class="line">    NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</div><div class="line"></div><div class="line">    // Skip directories and errors.</div><div class="line">    if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Remove files that are older than the expiration date;</div><div class="line">    NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</div><div class="line">    if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">        [urlsToDelete addObject:fileURL];</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Store a reference to this file and account for its total size.</div><div class="line">    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">    currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</div><div class="line">    cacheFiles[fileURL] = resourceValues;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">for (NSURL *fileURL in urlsToDelete) &#123;</div><div class="line">    [self.fileManager removeItemAtURL:fileURL error:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果按过期时间删除后的文件大小还是大于最大缓存空间（maxCacheSize）的话，还有一种删除策略，就是删除现有文件大小的一半的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// If our remaining disk cache exceeds a configured maximum size, perform a second</div><div class="line">// size-based cleanup pass.  We delete the oldest files first.</div><div class="line">if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</div><div class="line">    // Target half of our maximum cache size for this cleanup pass.</div><div class="line">    const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</div><div class="line"></div><div class="line">    // Sort the remaining cache files by their last modification time (oldest first).</div><div class="line">    NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</div><div class="line">                                                             usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</div><div class="line">                                                                 return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</div><div class="line">                                                             &#125;];</div><div class="line"></div><div class="line">    // Delete files until we fall below our desired cache size.</div><div class="line">    for (NSURL *fileURL in sortedFiles) &#123;</div><div class="line">        if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</div><div class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</div><div class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">            currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</div><div class="line"></div><div class="line">            if (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="图片编解码模块"><a href="#图片编解码模块" class="headerlink" title="图片编解码模块"></a>图片编解码模块</h3><p>图片的编解码模块也是sd中比较重要也比较难吃透的模块，涉及到一些图片相关的姿势，需要慢慢学习理解。</p>
<h4 id="SDWebImageCoder"><a href="#SDWebImageCoder" class="headerlink" title="SDWebImageCoder"></a>SDWebImageCoder</h4><p>先来看一下这个协议类，这个类中定义了一些编解码的协议和几个静态函数。</p>
<p>静态函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//返回图片的颜色空间，这里返回RGB</div><div class="line">CGColorSpaceRef SDCGColorSpaceGetDeviceRGB(void) &#123;</div><div class="line">    static CGColorSpaceRef colorSpace;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    &#125;);</div><div class="line">    return colorSpace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//判断图片是否有透明度</div><div class="line">BOOL SDCGImageRefContainsAlpha(CGImageRef imageRef) &#123;</div><div class="line">    if (!imageRef) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef);</div><div class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    return hasAlpha;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageImageIOCoder"><a href="#SDWebImageImageIOCoder" class="headerlink" title="SDWebImageImageIOCoder"></a>SDWebImageImageIOCoder</h4><p>这个是图片编解码的核心类，相关方法和协议都在这个类中实现。看头文件的注释，sd支持PNG,JPEG,TIFF和HEIC(需要判断设备是否支持)这几种图片格式的编解码。gif和webp有单独的编解码类。</p>
<p>因为sd是支持图片边下载边显示的，而这个显示操作需要先将接受到的部分图片解码后才可以显示，这里看一下这个解码部分图片是如何实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</div><div class="line">    if (!_imageSource) &#123;</div><div class="line">        _imageSource = CGImageSourceCreateIncremental(NULL);</div><div class="line">    &#125;</div><div class="line">    UIImage *image;</div><div class="line">    </div><div class="line">    // The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/</div><div class="line">    // Thanks to the author @Nyx0uf</div><div class="line">    </div><div class="line">    // Update the data source, we must pass ALL the data, not just the new bytes</div><div class="line">    CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished);</div><div class="line">    </div><div class="line">    if (_width + _height == 0) &#123;</div><div class="line">        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</div><div class="line">        if (properties) &#123;</div><div class="line">            NSInteger orientationValue = 1;</div><div class="line">            CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height);</div><div class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width);</div><div class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">            CFRelease(properties);</div><div class="line">            </div><div class="line">            // When we draw to Core Graphics, we lose orientation information,</div><div class="line">            // which means the image below born of initWithCGIImage will be</div><div class="line">            // oriented incorrectly sometimes. (Unlike the image born of initWithData</div><div class="line">            // in didCompleteWithError.) So save it here and pass it on later.</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_width + _height &gt; 0) &#123;</div><div class="line">        // Create the image</div><div class="line">        CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL);</div><div class="line">        </div><div class="line">        if (partialImageRef) &#123;</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef scale:1 orientation:_orientation];</div><div class="line">#elif SD_MAC</div><div class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">            CGImageRelease(partialImageRef);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (finished) &#123;</div><div class="line">        if (_imageSource) &#123;</div><div class="line">            CFRelease(_imageSource);</div><div class="line">            _imageSource = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先创建一个imagesource,然后更新imagesource的data，注意这里的data是目前接收到的图片的所有数据，不止是新增的部分，这里在下载的图片的时候sd已经处理好了，保存了之前下载的那部分数据。然后获取图片宽高属性和方向，最后生成图片后返回。</p>
<p>接着看正常图片的解码过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</div><div class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</div><div class="line">#if SD_MAC</div><div class="line">    return image;</div><div class="line">#endif</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    BOOL shouldScaleDown = NO;</div><div class="line">    if (optionsDict != nil) &#123;</div><div class="line">        NSNumber *scaleDownLargeImagesOption = nil;</div><div class="line">        if ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[NSNumber class]]) &#123;</div><div class="line">            scaleDownLargeImagesOption = (NSNumber *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</div><div class="line">        &#125;</div><div class="line">        if (scaleDownLargeImagesOption != nil) &#123;</div><div class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!shouldScaleDown) &#123;</div><div class="line">        return [self sd_decompressedImageWithImage:image];</div><div class="line">    &#125; else &#123;</div><div class="line">        UIImage *scaledDownImage = [self sd_decompressedAndScaledDownImageWithImage:image];</div><div class="line">        if (scaledDownImage &amp;&amp; !CGSizeEqualToSize(scaledDownImage.size, image.size)) &#123;</div><div class="line">            // if the image is scaled down, need to modify the data pointer as well</div><div class="line">            SDImageFormat format = [NSData sd_imageFormatForImageData:*data];</div><div class="line">            NSData *imageData = [self encodedDataWithImage:scaledDownImage format:format];</div><div class="line">            if (imageData) &#123;</div><div class="line">                *data = imageData;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return scaledDownImage;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要判断一下图片是否需要被缩放，因为在下载完以后的图片也是根据图片后缀是否带@2x@3x这种标识进行过缩放的，并不是图片的实际尺寸。</p>
<p>如果不需要缩放，直接调用下面的解码方法解码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</div><div class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</div><div class="line">    @autoreleasepool&#123;</div><div class="line">        </div><div class="line">        CGImageRef imageRef = image.CGImage;</div><div class="line">        // device color space</div><div class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef);</div><div class="line">        // iOS display alpha info (BRGA8888/BGRX8888)</div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        size_t width = CGImageGetWidth(imageRef);</div><div class="line">        size_t height = CGImageGetHeight(imageRef);</div><div class="line">        </div><div class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</div><div class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</div><div class="line">        // to create bitmap graphics contexts without alpha info.</div><div class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</div><div class="line">                                                     width,</div><div class="line">                                                     height,</div><div class="line">                                                     kBitsPerComponent,</div><div class="line">                                                     0,</div><div class="line">                                                     colorspaceRef,</div><div class="line">                                                     bitmapInfo);</div><div class="line">        if (context == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Draw the image into the context and retrieve the new bitmap image without alpha</div><div class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</div><div class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</div><div class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</div><div class="line">        CGContextRelease(context);</div><div class="line">        CGImageRelease(imageRefWithoutAlpha);</div><div class="line">        </div><div class="line">        return imageWithoutAlpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码很经典，很多图片解码相关的库都会用到，如果你想自己写一个异步的图片解码函数，也可以直接拿去用。这里用的参数及相关解释网上有很多文章分析过，<a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="noopener">比如这篇就解释的挺清楚</a>。</p>
<p>如果是需要缩放的图片，则走下面这个方法解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (![[self class] shouldScaleDownImage:image]) &#123;</div><div class="line">        return [self sd_decompressedImageWithImage:image];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CGContextRef destContext;</div><div class="line">    </div><div class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</div><div class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        CGImageRef sourceImageRef = image.CGImage;</div><div class="line">        </div><div class="line">        CGSize sourceResolution = CGSizeZero;</div><div class="line">        sourceResolution.width = CGImageGetWidth(sourceImageRef);</div><div class="line">        sourceResolution.height = CGImageGetHeight(sourceImageRef);</div><div class="line">        float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">        // Determine the scale ratio to apply to the input image</div><div class="line">        // that results in an output image of the defined size.</div><div class="line">        // see kDestImageSizeMB, and how it relates to destTotalPixels.</div><div class="line">        float imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">        CGSize destResolution = CGSizeZero;</div><div class="line">        destResolution.width = (int)(sourceResolution.width*imageScale);</div><div class="line">        destResolution.height = (int)(sourceResolution.height*imageScale);</div><div class="line">        </div><div class="line">        // device color space</div><div class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</div><div class="line">        // iOS display alpha info (BGRA8888/BGRX8888)</div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</div><div class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</div><div class="line">        // to create bitmap graphics contexts without alpha info.</div><div class="line">        destContext = CGBitmapContextCreate(NULL,</div><div class="line">                                            destResolution.width,</div><div class="line">                                            destResolution.height,</div><div class="line">                                            kBitsPerComponent,</div><div class="line">                                            0,</div><div class="line">                                            colorspaceRef,</div><div class="line">                                            bitmapInfo);</div><div class="line">        </div><div class="line">        if (destContext == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</div><div class="line">        </div><div class="line">        // Now define the size of the rectangle to be used for the</div><div class="line">        // incremental blits from the input image to the output image.</div><div class="line">        // we use a source tile width equal to the width of the source</div><div class="line">        // image due to the way that iOS retrieves image data from disk.</div><div class="line">        // iOS must decode an image from disk in full width &apos;bands&apos;, even</div><div class="line">        // if current graphics context is clipped to a subrect within that</div><div class="line">        // band. Therefore we fully utilize all of the pixel data that results</div><div class="line">        // from a decoding opertion by achnoring our tile size to the full</div><div class="line">        // width of the input image.</div><div class="line">        CGRect sourceTile = CGRectZero;</div><div class="line">        sourceTile.size.width = sourceResolution.width;</div><div class="line">        // The source tile height is dynamic. Since we specified the size</div><div class="line">        // of the source tile in MB, see how many rows of pixels high it</div><div class="line">        // can be given the input image width.</div><div class="line">        sourceTile.size.height = (int)(kTileTotalPixels / sourceTile.size.width );</div><div class="line">        sourceTile.origin.x = 0.0f;</div><div class="line">        // The output tile is the same proportions as the input tile, but</div><div class="line">        // scaled to image scale.</div><div class="line">        CGRect destTile;</div><div class="line">        destTile.size.width = destResolution.width;</div><div class="line">        destTile.size.height = sourceTile.size.height * imageScale;</div><div class="line">        destTile.origin.x = 0.0f;</div><div class="line">        // The source seem overlap is proportionate to the destination seem overlap.</div><div class="line">        // this is the amount of pixels to overlap each tile as we assemble the ouput image.</div><div class="line">        float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</div><div class="line">        CGImageRef sourceTileImageRef;</div><div class="line">        // calculate the number of read/write operations required to assemble the</div><div class="line">        // output image.</div><div class="line">        int iterations = (int)( sourceResolution.height / sourceTile.size.height );</div><div class="line">        // If tile height doesn&apos;t divide the image height evenly, add another iteration</div><div class="line">        // to account for the remaining pixels.</div><div class="line">        int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;</div><div class="line">        if(remainder) &#123;</div><div class="line">            iterations++;</div><div class="line">        &#125;</div><div class="line">        // Add seem overlaps to the tiles, but save the original tile height for y coordinate calculations.</div><div class="line">        float sourceTileHeightMinusOverlap = sourceTile.size.height;</div><div class="line">        sourceTile.size.height += sourceSeemOverlap;</div><div class="line">        destTile.size.height += kDestSeemOverlap;</div><div class="line">        for( int y = 0; y &lt; iterations; ++y ) &#123;</div><div class="line">            @autoreleasepool &#123;</div><div class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</div><div class="line">                destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</div><div class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</div><div class="line">                if( y == iterations - 1 &amp;&amp; remainder ) &#123;</div><div class="line">                    float dify = destTile.size.height;</div><div class="line">                    destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale;</div><div class="line">                    dify -= destTile.size.height;</div><div class="line">                    destTile.origin.y += dify;</div><div class="line">                &#125;</div><div class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</div><div class="line">                CGImageRelease( sourceTileImageRef );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</div><div class="line">        CGContextRelease(destContext);</div><div class="line">        if (destImageRef == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</div><div class="line">        CGImageRelease(destImageRef);</div><div class="line">        if (destImage == nil) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        return destImage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里先判断图片的总像素是否比sd设置的最大像素值大，如果总像素超出了设置的最大像素值，则需要先缩放图片再解码，不然解码需要的内存空间太大，可能造成内存暴涨等问题。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</div><div class="line">    BOOL shouldScaleDown = YES;</div><div class="line">    </div><div class="line">    CGImageRef sourceImageRef = image.CGImage;</div><div class="line">    CGSize sourceResolution = CGSizeZero;</div><div class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</div><div class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</div><div class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">    if (imageScale &lt; 1) &#123;</div><div class="line">        shouldScaleDown = YES;</div><div class="line">    &#125; else &#123;</div><div class="line">        shouldScaleDown = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return shouldScaleDown;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sd这里应该也是用了帧内压缩算法去压缩图片的尺寸，通过计算像素差值的方式将多余的像素剔除，然后sd使用了一个tile的东东去存储每次计算出来的数据，并将这些数据写入到设备上下文中。计算完成后再从上下文中取出一张位图。这个压缩解码函数的详细注释可以<a href="https://www.jianshu.com/p/dfa47380fc05" target="_blank" rel="noopener">参考这一篇文章</a>.</p>
<p>然后就是编码部分，什么时候需要编码呢？就是在存入disk的时候，因为之前用到的image可能是解码之后的图片，直接存入的话会占用比较大的内存空间，所以sd这里都是先将image编码后再存的。</p>
<p>编码的函数和解码相比还是比较简单的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (format == SDImageFormatUndefined) &#123;</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</div><div class="line">        if (hasAlpha) &#123;</div><div class="line">            format = SDImageFormatPNG;</div><div class="line">        &#125; else &#123;</div><div class="line">            format = SDImageFormatJPEG;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:format];</div><div class="line">    </div><div class="line">    // Create an image destination.</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableDictionary *properties = [NSMutableDictionary dictionary];</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSInteger exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</div><div class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge_transfer NSString *)kCGImagePropertyOrientation];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    // Add your image to the destination.</div><div class="line">    CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties);</div><div class="line">    </div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        imageData = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(imageDestination);</div><div class="line">    </div><div class="line">    return [imageData copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先创建一个CGImageDestinationRef，并绑定一个imagedata,然后获取图片的相关属性，然后将图片数据和相关属性一起add到CGImageDestinationRef中，获取之前绑定的imagedata并返回，整个编码过程结束。</p>
<h4 id="SDWebImageGIFCoder"><a href="#SDWebImageGIFCoder" class="headerlink" title="SDWebImageGIFCoder"></a>SDWebImageGIFCoder</h4><p>这个类主要做gif的编解码。直接看解码函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">#if SD_MAC</div><div class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</div><div class="line">    NSImage *animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</div><div class="line">    [animatedImage addRepresentation:imageRep];</div><div class="line">    return animatedImage;</div><div class="line">#else</div><div class="line">    </div><div class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</div><div class="line">    if (!source) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    size_t count = CGImageSourceGetCount(source);</div><div class="line">    </div><div class="line">    UIImage *animatedImage;</div><div class="line">    </div><div class="line">    if (count &lt;= 1) &#123;</div><div class="line">        animatedImage = [[UIImage alloc] initWithData:data];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</div><div class="line">            CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);</div><div class="line">            if (!imageRef) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            float duration = [self sd_frameDurationAtIndex:i source:source];</div><div class="line">            UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</div><div class="line">            CGImageRelease(imageRef);</div><div class="line">            </div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSUInteger loopCount = 1;</div><div class="line">        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(source, nil);</div><div class="line">        NSDictionary *gifProperties = [imageProperties valueForKey:(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">        if (gifProperties) &#123;</div><div class="line">            NSNumber *gifLoopCount = [gifProperties valueForKey:(__bridge_transfer NSString *)kCGImagePropertyGIFLoopCount];</div><div class="line">            if (gifLoopCount != nil) &#123;</div><div class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">        animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(source);</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sd这里自定义了一个SDWebImageFrame类用来存放每一帧图片的数据，然后将所有帧存放在一个数组中，然后通过下面这个方法将帧数组转为一个image对象,这个方法等下在分析helper类的时候再一起分析一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div></pre></td></tr></table></figure>
<p>上面还用到一个方法是如何获取每一帧的时长方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source &#123;</div><div class="line">    float frameDuration = 0.1f;</div><div class="line">    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);</div><div class="line">    if (!cfFrameProperties) &#123;</div><div class="line">        return frameDuration;</div><div class="line">    &#125;</div><div class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;</div><div class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">    </div><div class="line">    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];</div><div class="line">    if (delayTimeUnclampedProp != nil) &#123;</div><div class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];</div><div class="line">        if (delayTimeProp != nil) &#123;</div><div class="line">            frameDuration = [delayTimeProp floatValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.</div><div class="line">    // We follow Firefox&apos;s behavior and use a duration of 100 ms for any frames that specify</div><div class="line">    // a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;</div><div class="line">    // for more information.</div><div class="line">    </div><div class="line">    if (frameDuration &lt; 0.011f) &#123;</div><div class="line">        frameDuration = 0.100f;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(cfFrameProperties);</div><div class="line">    return frameDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认每一帧的时长是0.1，如果获取propertydic失败直接返回默认值，否则的话从propertydic取对应的value。</p>
<p>然后看一下gif的编码过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (format != SDImageFormatGIF) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</div><div class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</div><div class="line">    </div><div class="line">    // Create an image destination. GIF does not support EXIF image orientation</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (frames.count == 0) &#123;</div><div class="line">        // for static single GIF images</div><div class="line">        CGImageDestinationAddImage(imageDestination, image.CGImage, nil);</div><div class="line">    &#125; else &#123;</div><div class="line">        // for animated GIF images</div><div class="line">        NSUInteger loopCount = image.sd_imageLoopCount;</div><div class="line">        NSDictionary *gifProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary: @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</div><div class="line">        CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties);</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</div><div class="line">            SDWebImageFrame *frame = frames[i];</div><div class="line">            float frameDuration = frame.duration;</div><div class="line">            CGImageRef frameImageRef = frame.image.CGImage;</div><div class="line">            NSDictionary *frameProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</div><div class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        imageData = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(imageDestination);</div><div class="line">    </div><div class="line">    return [imageData copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码的时候也是需要先获取到SDWebImageFrame数组，然后和普通图片编码过程一样，也是创建一个CGImageDestinationRef，绑定imagedata,然后遍历SDWebImageFrame数组将每一帧写入CGImageDestinationRef中，然后获取imagedata并返回。</p>
<h4 id="SDWebImageWebPCoder"><a href="#SDWebImageWebPCoder" class="headerlink" title="SDWebImageWebPCoder"></a>SDWebImageWebPCoder</h4><p><a href="https://developers.google.com/speed/webp/docs/compression" target="_blank" rel="noopener">这篇文章介绍了webp的压缩算法</a></p>
<p>使用webp相关的编解码方法，需要pod中添加一个依赖仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;SDWebImage/WebP&apos;</div></pre></td></tr></table></figure>
<p>sd为webp提供了2种解码方法，分别是部分数据的解码和完整数据的解码。</p>
<p>先看完整的数据解码函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    WebPData webpData;</div><div class="line">    WebPDataInit(&amp;webpData);</div><div class="line">    webpData.bytes = data.bytes;</div><div class="line">    webpData.size = data.length;</div><div class="line">    WebPDemuxer *demuxer = WebPDemux(&amp;webpData);</div><div class="line">    if (!demuxer) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint32_t flags = WebPDemuxGetI(demuxer, WEBP_FF_FORMAT_FLAGS);</div><div class="line">    int loopCount = WebPDemuxGetI(demuxer, WEBP_FF_LOOP_COUNT);</div><div class="line">    int canvasWidth = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_WIDTH);</div><div class="line">    int canvasHeight = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_HEIGHT);</div><div class="line">    CGBitmapInfo bitmapInfo;</div><div class="line">    // `CGBitmapContextCreate` does not support RGB888 on iOS. Where `CGImageCreate` supports.</div><div class="line">    if (!(flags &amp; ALPHA_FLAG)) &#123;</div><div class="line">        // RGBX8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;</div><div class="line">    &#125; else &#123;</div><div class="line">        // RGBA8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    CGContextRef canvas = CGBitmapContextCreate(NULL, canvasWidth, canvasHeight, 8, 0, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">    if (!canvas) &#123;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!(flags &amp; ANIMATION_FLAG)) &#123;</div><div class="line">        // for static single webp image</div><div class="line">        UIImage *staticImage = [self sd_rawWebpImageWithData:webpData];</div><div class="line">        if (staticImage) &#123;</div><div class="line">            // draw on CGBitmapContext can reduce memory usage</div><div class="line">            CGImageRef imageRef = staticImage.CGImage;</div><div class="line">            size_t width = CGImageGetWidth(imageRef);</div><div class="line">            size_t height = CGImageGetHeight(imageRef);</div><div class="line">            CGContextDrawImage(canvas, CGRectMake(0, 0, width, height), imageRef);</div><div class="line">            CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            staticImage = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#else</div><div class="line">            staticImage = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">            CGImageRelease(newImageRef);</div><div class="line">        &#125;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">        return staticImage;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // for animated webp image</div><div class="line">    WebPIterator iter;</div><div class="line">    if (!WebPDemuxGetFrame(demuxer, 1, &amp;iter)) &#123;</div><div class="line">        WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">    </div><div class="line">    do &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            UIImage *image = [self sd_drawnWebpImageWithCanvas:canvas iterator:iter];</div><div class="line">            if (!image) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            int duration = iter.duration;</div><div class="line">            if (duration &lt;= 10) &#123;</div><div class="line">                // WebP standard says 0 duration is used for canvas updating but not showing image, but actually Chrome and other implementations set it to 100ms if duration is lower or equal than 10ms</div><div class="line">                // Some animated WebP images also created without duration, we should keep compatibility</div><div class="line">                duration = 100;</div><div class="line">            &#125;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration / 1000.f];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; while (WebPDemuxNextFrame(&amp;iter));</div><div class="line">    </div><div class="line">    WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">    WebPDemuxDelete(demuxer);</div><div class="line">    CGContextRelease(canvas);</div><div class="line">    </div><div class="line">    UIImage *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">    animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也是分了2种类型去解码，一种是静态图片，直接使用下面这个方法或者静态图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_rawWebpImageWithData:(WebPData)webpData &#123;</div><div class="line">    WebPDecoderConfig config;</div><div class="line">    if (!WebPInitDecoderConfig(&amp;config)) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (WebPGetFeatures(webpData.bytes, webpData.size, &amp;config.input) != VP8_STATUS_OK) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    config.output.colorspace = config.input.has_alpha ? MODE_rgbA : MODE_RGB;</div><div class="line">    config.options.use_threads = 1;</div><div class="line">    </div><div class="line">    // Decode the WebP image data into a RGBA value array</div><div class="line">    if (WebPDecode(webpData.bytes, webpData.size, &amp;config) != VP8_STATUS_OK) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int width = config.input.width;</div><div class="line">    int height = config.input.height;</div><div class="line">    if (config.options.use_scaling) &#123;</div><div class="line">        width = config.options.scaled_width;</div><div class="line">        height = config.options.scaled_height;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Construct a UIImage from the decoded RGBA value array</div><div class="line">    CGDataProviderRef provider =</div><div class="line">    CGDataProviderCreateWithData(NULL, config.output.u.RGBA.rgba, config.output.u.RGBA.size, FreeImageData);</div><div class="line">    CGColorSpaceRef colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">    CGBitmapInfo bitmapInfo;</div><div class="line">    // `CGBitmapContextCreate` does not support RGB888 on iOS. Where `CGImageCreate` supports.</div><div class="line">    if (!config.input.has_alpha) &#123;</div><div class="line">        // RGB888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNone;</div><div class="line">    &#125; else &#123;</div><div class="line">        // RGBA8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    size_t components = config.input.has_alpha ? 4 : 3;</div><div class="line">    CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;</div><div class="line">    CGImageRef imageRef = CGImageCreate(width, height, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</div><div class="line">    </div><div class="line">    CGDataProviderRelease(provider);</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</div><div class="line">#else</div><div class="line">    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">    CGImageRelease(imageRef);</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是动图的话，和GIF的解码一样，需要获取一个SDWebImageFrame的数组，先使用下面这个函数获取每一帧的图片数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_drawnWebpImageWithCanvas:(CGContextRef)canvas iterator:(WebPIterator)iter &#123;</div><div class="line">    UIImage *image = [self sd_rawWebpImageWithData:iter.fragment];</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t canvasWidth = CGBitmapContextGetWidth(canvas);</div><div class="line">    size_t canvasHeight = CGBitmapContextGetHeight(canvas);</div><div class="line">    CGSize size = CGSizeMake(canvasWidth, canvasHeight);</div><div class="line">    CGFloat tmpX = iter.x_offset;</div><div class="line">    CGFloat tmpY = size.height - iter.height - iter.y_offset;</div><div class="line">    CGRect imageRect = CGRectMake(tmpX, tmpY, iter.width, iter.height);</div><div class="line">    BOOL shouldBlend = iter.blend_method == WEBP_MUX_BLEND;</div><div class="line">    </div><div class="line">    // If not blend, cover the target image rect. (firstly clear then draw)</div><div class="line">    if (!shouldBlend) &#123;</div><div class="line">        CGContextClearRect(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    CGContextDrawImage(canvas, imageRect, image.CGImage);</div><div class="line">    CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    image = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#elif SD_MAC</div><div class="line">    image = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    CGImageRelease(newImageRef);</div><div class="line">    </div><div class="line">    if (iter.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) &#123;</div><div class="line">        CGContextClearRect(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数里面先调用静态获取图片的方法生成一张图片，然后判断是否需要混合当前上下文中的内容，如果不需要就清空之前的内容，如果需要的话将刚生成的图片再写入之前的上下文中混合成一张新的图。</p>
<p>然后使用之前gif中使用过的下面这个函数将帧数组转为一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIImage *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div></pre></td></tr></table></figure>
<p>部分数据的解码函数如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</div><div class="line">    if (!_idec) &#123;</div><div class="line">        // Progressive images need transparent, so always use premultiplied RGBA</div><div class="line">        _idec = WebPINewRGB(MODE_rgbA, NULL, 0, 0);</div><div class="line">        if (!_idec) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIImage *image;</div><div class="line">    </div><div class="line">    VP8StatusCode status = WebPIUpdate(_idec, data.bytes, data.length);</div><div class="line">    if (status != VP8_STATUS_OK &amp;&amp; status != VP8_STATUS_SUSPENDED) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int width = 0;</div><div class="line">    int height = 0;</div><div class="line">    int last_y = 0;</div><div class="line">    int stride = 0;</div><div class="line">    uint8_t *rgba = WebPIDecGetRGB(_idec, &amp;last_y, &amp;width, &amp;height, &amp;stride);</div><div class="line">    // last_y may be 0, means no enough bitmap data to decode, ignore this</div><div class="line">    if (width + height &gt; 0 &amp;&amp; last_y &gt; 0 &amp;&amp; height &gt;= last_y) &#123;</div><div class="line">        // Construct a UIImage from the decoded RGBA value array</div><div class="line">        size_t rgbaSize = last_y * stride;</div><div class="line">        CGDataProviderRef provider =</div><div class="line">        CGDataProviderCreateWithData(NULL, rgba, rgbaSize, NULL);</div><div class="line">        CGColorSpaceRef colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        </div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">        size_t components = 4;</div><div class="line">        CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;</div><div class="line">        // Why to use last_y for image height is because of libwebp&apos;s bug (https://bugs.chromium.org/p/webp/issues/detail?id=362)</div><div class="line">        // It will not keep memory barrier safe on x86 architechure (macOS &amp; iPhone simulator) but on ARM architecture (iPhone &amp; iPad &amp; tv &amp; watch) it works great</div><div class="line">        // If different threads use WebPIDecGetRGB to grab rgba bitmap, it will contain the previous decoded bitmap data</div><div class="line">        // So this will cause our drawed image looks strange(above is the current part but below is the previous part)</div><div class="line">        // We only grab the last_y height and draw the last_y heigh instead of total height image</div><div class="line">        // Besides fix, this can enhance performance since we do not need to create extra bitmap</div><div class="line">        CGImageRef imageRef = CGImageCreate(width, last_y, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</div><div class="line">        </div><div class="line">        CGDataProviderRelease(provider);</div><div class="line">        </div><div class="line">        if (!imageRef) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGContextRef canvas = CGBitmapContextCreate(NULL, width, height, 8, 0, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">        if (!canvas) &#123;</div><div class="line">            CGImageRelease(imageRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Only draw the last_y image height, keep remains transparent, in Core Graphics coordinate system</div><div class="line">        CGContextDrawImage(canvas, CGRectMake(0, height - last_y, width, last_y), imageRef);</div><div class="line">        CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">        CGImageRelease(imageRef);</div><div class="line">        if (!newImageRef) &#123;</div><div class="line">            CGContextRelease(canvas);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">        image = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#else</div><div class="line">        image = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">        CGImageRelease(newImageRef);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (finished) &#123;</div><div class="line">        if (_idec) &#123;</div><div class="line">            WebPIDelete(_idec);</div><div class="line">            _idec = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>流程都和之前的其他格式部分解码函数差不多吧，只是有写api的小差异。</p>
<p>解码的部分差不多就这些，接着看一下编码的部分是如何实现的，直接上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSData *data;</div><div class="line">    </div><div class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</div><div class="line">    if (frames.count == 0) &#123;</div><div class="line">        // for static single webp image</div><div class="line">        data = [self sd_encodedWebpDataWithImage:image];</div><div class="line">    &#125; else &#123;</div><div class="line">        // for animated webp image</div><div class="line">        WebPMux *mux = WebPMuxNew();</div><div class="line">        if (!mux) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</div><div class="line">            SDWebImageFrame *currentFrame = frames[i];</div><div class="line">            NSData *webpData = [self sd_encodedWebpDataWithImage:currentFrame.image];</div><div class="line">            int duration = currentFrame.duration * 1000;</div><div class="line">            WebPMuxFrameInfo frame = &#123; .bitstream.bytes = webpData.bytes,</div><div class="line">                .bitstream.size = webpData.length,</div><div class="line">                .duration = duration,</div><div class="line">                .id = WEBP_CHUNK_ANMF,</div><div class="line">                .dispose_method = WEBP_MUX_DISPOSE_BACKGROUND, // each frame will clear canvas</div><div class="line">                .blend_method = WEBP_MUX_NO_BLEND</div><div class="line">            &#125;;</div><div class="line">            if (WebPMuxPushFrame(mux, &amp;frame, 0) != WEBP_MUX_OK) &#123;</div><div class="line">                WebPMuxDelete(mux);</div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        int loopCount = (int)image.sd_imageLoopCount;</div><div class="line">        WebPMuxAnimParams params = &#123; .bgcolor = 0,</div><div class="line">            .loop_count = loopCount</div><div class="line">        &#125;;</div><div class="line">        if (WebPMuxSetAnimationParams(mux, &amp;params) != WEBP_MUX_OK) &#123;</div><div class="line">            WebPMuxDelete(mux);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        WebPData outputData;</div><div class="line">        WebPMuxError error = WebPMuxAssemble(mux, &amp;outputData);</div><div class="line">        WebPMuxDelete(mux);</div><div class="line">        if (error != WEBP_MUX_OK) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        data = [NSData dataWithBytes:outputData.bytes length:outputData.size];</div><div class="line">        WebPDataClear(&amp;outputData);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和gif的编码流程相似，先获取到这张图的所有帧，（静态图片只有一帧，直接调用处理每一帧的编码函数进行处理），然后循环处理每一帧的数据，然后将处理完的每一帧数据存放到WebPMuxFrameInfo这个结构体，再将每个结构体add到WebPMux这个类里面，循环结束从WebPMux这个类中取出数据并返回。</p>
<p>下面这个函数是具体处理每一帧的数据的编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">- (nullable NSData *)sd_encodedWebpDataWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSData *webpData;</div><div class="line">    CGImageRef imageRef = image.CGImage;</div><div class="line">    </div><div class="line">    size_t width = CGImageGetWidth(imageRef);</div><div class="line">    size_t height = CGImageGetHeight(imageRef);</div><div class="line">    if (width == 0 || width &gt; WEBP_MAX_DIMENSION) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (height == 0 || height &gt; WEBP_MAX_DIMENSION) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t bytesPerRow = CGImageGetBytesPerRow(imageRef);</div><div class="line">    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</div><div class="line">    CGImageAlphaInfo alphaInfo = bitmapInfo &amp; kCGBitmapAlphaInfoMask;</div><div class="line">    CGBitmapInfo byteOrderInfo = bitmapInfo &amp; kCGBitmapByteOrderMask;</div><div class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    BOOL byteOrderNormal = NO;</div><div class="line">    switch (byteOrderInfo) &#123;</div><div class="line">        case kCGBitmapByteOrderDefault: &#123;</div><div class="line">            byteOrderNormal = YES;</div><div class="line">        &#125; break;</div><div class="line">        case kCGBitmapByteOrder32Little: &#123;</div><div class="line">        &#125; break;</div><div class="line">        case kCGBitmapByteOrder32Big: &#123;</div><div class="line">            byteOrderNormal = YES;</div><div class="line">        &#125; break;</div><div class="line">        default: break;</div><div class="line">    &#125;</div><div class="line">    // If we can not get bitmap buffer, early return</div><div class="line">    CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);</div><div class="line">    if (!dataProvider) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CFDataRef dataRef = CGDataProviderCopyData(dataProvider);</div><div class="line">    if (!dataRef) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint8_t *rgba = NULL;</div><div class="line">    // We could not assume that input CGImage&apos;s color mode is always RGB888/RGBA8888. Convert all other cases to target color mode using vImage</div><div class="line">    if (byteOrderNormal &amp;&amp; ((alphaInfo == kCGImageAlphaNone) || (alphaInfo == kCGImageAlphaLast))) &#123;</div><div class="line">        // If the input CGImage is already RGB888/RGBA8888</div><div class="line">        rgba = (uint8_t *)CFDataGetBytePtr(dataRef);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Convert all other cases to target color mode using vImage</div><div class="line">        vImageConverterRef convertor = NULL;</div><div class="line">        vImage_Error error = kvImageNoError;</div><div class="line">        </div><div class="line">        vImage_CGImageFormat srcFormat = &#123;</div><div class="line">            .bitsPerComponent = (uint32_t)CGImageGetBitsPerComponent(imageRef),</div><div class="line">            .bitsPerPixel = (uint32_t)CGImageGetBitsPerPixel(imageRef),</div><div class="line">            .colorSpace = CGImageGetColorSpace(imageRef),</div><div class="line">            .bitmapInfo = bitmapInfo</div><div class="line">        &#125;;</div><div class="line">        vImage_CGImageFormat destFormat = &#123;</div><div class="line">            .bitsPerComponent = 8,</div><div class="line">            .bitsPerPixel = hasAlpha ? 32 : 24,</div><div class="line">            .colorSpace = SDCGColorSpaceGetDeviceRGB(),</div><div class="line">            .bitmapInfo = hasAlpha ? kCGImageAlphaLast | kCGBitmapByteOrderDefault : kCGImageAlphaNone | kCGBitmapByteOrderDefault // RGB888/RGBA8888 (Non-premultiplied to works for libwebp)</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        convertor = vImageConverter_CreateWithCGImageFormat(&amp;srcFormat, &amp;destFormat, NULL, kvImageNoFlags, &amp;error);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        vImage_Buffer src = &#123;</div><div class="line">            .data = (uint8_t *)CFDataGetBytePtr(dataRef),</div><div class="line">            .width = width,</div><div class="line">            .height = height,</div><div class="line">            .rowBytes = bytesPerRow</div><div class="line">        &#125;;</div><div class="line">        vImage_Buffer dest;</div><div class="line">        </div><div class="line">        error = vImageBuffer_Init(&amp;dest, height, width, destFormat.bitsPerPixel, kvImageNoFlags);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Convert input color mode to RGB888/RGBA8888</div><div class="line">        error = vImageConvert_AnyToAny(convertor, &amp;src, &amp;dest, NULL, kvImageNoFlags);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        rgba = dest.data; // Converted buffer</div><div class="line">        bytesPerRow = dest.rowBytes; // Converted bytePerRow</div><div class="line">        CFRelease(dataRef);</div><div class="line">        dataRef = NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint8_t *data = NULL; // Output WebP data</div><div class="line">    float qualityFactor = 100; // WebP quality is 0-100</div><div class="line">    // Encode RGB888/RGBA8888 buffer to WebP data</div><div class="line">    size_t size;</div><div class="line">    if (hasAlpha) &#123;</div><div class="line">        size = WebPEncodeRGBA(rgba, (int)width, (int)height, (int)bytesPerRow, qualityFactor, &amp;data);</div><div class="line">    &#125; else &#123;</div><div class="line">        size = WebPEncodeRGB(rgba, (int)width, (int)height, (int)bytesPerRow, qualityFactor, &amp;data);</div><div class="line">    &#125;</div><div class="line">    if (dataRef) &#123;</div><div class="line">        CFRelease(dataRef); // free non-converted rgba buffer</div><div class="line">        dataRef = NULL;</div><div class="line">    &#125; else &#123;</div><div class="line">        free(rgba); // free converted rgba buffer</div><div class="line">        rgba = NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (size) &#123;</div><div class="line">        // success</div><div class="line">        webpData = [NSData dataWithBytes:data length:size];</div><div class="line">    &#125;</div><div class="line">    if (data) &#123;</div><div class="line">        WebPFree(data);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return webpData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和之前的其他图片的编码不一样，它这里没有使用CGImageDestinationRef这个结构处理编码，而是使用的webp库提供的编码方法。先创建vImageConverterRef这个对象，然后设置编码前的格式和编码后的格式，然后初始化vImageConverterRef对象，然后初始化vImage_Buffer，最后调用vImageConvert_AnyToAny方法进行格式转换，最后调用WebPEncodeRGBA生成最终需要返回的数据。<br>整个过程和使用AudioUnit进行音频格式转换很相似。</p>
<h4 id="SDWebImageCodersManager"><a href="#SDWebImageCodersManager" class="headerlink" title="SDWebImageCodersManager"></a>SDWebImageCodersManager</h4><p>这个类就是对上面这几个编解码类的使用的一个封装，看初始化函数默认只使用了SDWebImageImageIOCoder这个类作为当前编解码类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        // initialize with default coders</div><div class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</div><div class="line">#ifdef SD_WEBP</div><div class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</div><div class="line">#endif</div><div class="line">        _coders = [mutableCoders copy];</div><div class="line">        _codersLock = dispatch_semaphore_create(1);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你可以通过下面这个方法手动的添加和移除你需要的编解码类，比如gif的Coder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</div><div class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</div><div class="line">    if (!mutableCoders) &#123;</div><div class="line">        mutableCoders = [NSMutableArray array];</div><div class="line">    &#125;</div><div class="line">    [mutableCoders addObject:coder];</div><div class="line">    self.coders = [mutableCoders copy];</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</div><div class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</div><div class="line">    [mutableCoders removeObject:coder];</div><div class="line">    self.coders = [mutableCoders copy];</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后它提供了直接对数据进行编解码的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canDecodeFromData:data]) &#123;</div><div class="line">            return [coder decodedImageWithData:data];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</div><div class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canDecodeFromData:*data]) &#123;</div><div class="line">            return [coder decompressedImageWithImage:image data:data options:optionsDict];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canEncodeToFormat:format]) &#123;</div><div class="line">            return [coder encodedDataWithImage:image format:format];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过判断传入的数据是否支持编解码，如果支持就调用对应的编解码函数，如果不支持直接返回空。</p>
<h4 id="SDWebImageCoderHelper"><a href="#SDWebImageCoderHelper" class="headerlink" title="SDWebImageCoderHelper"></a>SDWebImageCoderHelper</h4><p>最后来看一下这个Helper,该类提供了几个通用的方法，主要有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//使用SDWebImageFrame帧序列创建图片</div><div class="line">+ (UIImage * _Nullable)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; * _Nullable)frames;</div><div class="line">//获取图片的所有帧数据</div><div class="line">+ (NSArray&lt;SDWebImageFrame *&gt; * _Nullable)framesFromAnimatedImage:(UIImage * _Nullable)animatedImage;</div><div class="line">//判断图片的朝向</div><div class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation;</div><div class="line">//将sd的朝向转为文件中应该的值</div><div class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation;</div></pre></td></tr></table></figure>
<p>看一下具体实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; *)frames &#123;</div><div class="line">    NSUInteger frameCount = frames.count;</div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIImage *animatedImage;</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSUInteger durations[frameCount];</div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        durations[i] = frames[i].duration * 1000;</div><div class="line">    &#125;</div><div class="line">    NSUInteger const gcd = gcdArray(frameCount, durations);</div><div class="line">    __block NSUInteger totalDuration = 0;</div><div class="line">    NSMutableArray&lt;UIImage *&gt; *animatedImages = [NSMutableArray arrayWithCapacity:frameCount];</div><div class="line">    [frames enumerateObjectsUsingBlock:^(SDWebImageFrame * _Nonnull frame, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        UIImage *image = frame.image;</div><div class="line">        NSUInteger duration = frame.duration * 1000;</div><div class="line">        totalDuration += duration;</div><div class="line">        NSUInteger repeatCount;</div><div class="line">        if (gcd) &#123;</div><div class="line">            repeatCount = duration / gcd;</div><div class="line">        &#125; else &#123;</div><div class="line">            repeatCount = 1;</div><div class="line">        &#125;</div><div class="line">        for (size_t i = 0; i &lt; repeatCount; ++i) &#123;</div><div class="line">            [animatedImages addObject:image];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    animatedImage = [UIImage animatedImageWithImages:animatedImages duration:totalDuration / 1000.f];</div><div class="line">    </div><div class="line">#else</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</div><div class="line">    // Create an image destination. GIF does not support EXIF image orientation</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frameCount, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            SDWebImageFrame *frame = frames[i];</div><div class="line">            float frameDuration = frame.duration;</div><div class="line">            CGImageRef frameImageRef = frame.image.CGImage;</div><div class="line">            NSDictionary *frameProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</div><div class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        CFRelease(imageDestination);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CFRelease(imageDestination);</div><div class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:imageData];</div><div class="line">    animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</div><div class="line">    [animatedImage addRepresentation:imageRep];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>帧数组转图片，如果是iOS平台，主要调用UIImage的<strong>animatedImageWithImages:duration</strong>方法创建，mac平台上我们看到了熟悉的身影CGImageDestinationRef，这个之前在做编码的时候用到过。</p>
<p>然后是图片转帧数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">+ (NSArray&lt;SDWebImageFrame *&gt; *)framesFromAnimatedImage:(UIImage *)animatedImage &#123;</div><div class="line">    if (!animatedImage) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">    NSUInteger frameCount = 0;</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSArray&lt;UIImage *&gt; *animatedImages = animatedImage.images;</div><div class="line">    frameCount = animatedImages.count;</div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSTimeInterval avgDuration = animatedImage.duration / frameCount;</div><div class="line">    if (avgDuration == 0) &#123;</div><div class="line">        avgDuration = 0.1; // if it&apos;s a animated image but no duration, set it to default 100ms (this do not have that 10ms limit like GIF or WebP to allow custom coder provide the limit)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block NSUInteger index = 0;</div><div class="line">    __block NSUInteger repeatCount = 1;</div><div class="line">    __block UIImage *previousImage = animatedImages.firstObject;</div><div class="line">    [animatedImages enumerateObjectsUsingBlock:^(UIImage * _Nonnull image, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        // ignore first</div><div class="line">        if (idx == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if ([image isEqual:previousImage]) &#123;</div><div class="line">            repeatCount++;</div><div class="line">        &#125; else &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">            repeatCount = 1;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        previousImage = image;</div><div class="line">        // last one</div><div class="line">        if (idx == frameCount - 1) &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">#else</div><div class="line">    </div><div class="line">    NSBitmapImageRep *bitmapRep;</div><div class="line">    for (NSImageRep *imageRep in animatedImage.representations) &#123;</div><div class="line">        if ([imageRep isKindOfClass:[NSBitmapImageRep class]]) &#123;</div><div class="line">            bitmapRep = (NSBitmapImageRep *)imageRep;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (bitmapRep) &#123;</div><div class="line">        frameCount = [[bitmapRep valueForProperty:NSImageFrameCount] unsignedIntegerValue];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            // NSBitmapImageRep need to manually change frame. &quot;Good taste&quot; API</div><div class="line">            [bitmapRep setProperty:NSImageCurrentFrame withValue:@(i)];</div><div class="line">            float frameDuration = [[bitmapRep valueForProperty:NSImageCurrentFrameDuration] floatValue];</div><div class="line">            NSImage *frameImage = [[NSImage alloc] initWithCGImage:bitmapRep.CGImage size:CGSizeZero];</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:frameImage duration:frameDuration];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return frames;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也是分了iOS和mac2个平台，iOS上直接去UIImage的images属性遍历一遍，mac上使用了NSBitmapImageRep这个对象获取图片的所有帧数据，然后在循环中从这个对象中取出所有的帧数据。</p>
<p>下面这2个是朝向转换的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">// Convert an EXIF image orientation to an iOS one.</div><div class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation &#123;</div><div class="line">    // CGImagePropertyOrientation is available on iOS 8 above. Currently kept for compatibility</div><div class="line">    UIImageOrientation imageOrientation = UIImageOrientationUp;</div><div class="line">    switch (exifOrientation) &#123;</div><div class="line">        case 1:</div><div class="line">            imageOrientation = UIImageOrientationUp;</div><div class="line">            break;</div><div class="line">        case 3:</div><div class="line">            imageOrientation = UIImageOrientationDown;</div><div class="line">            break;</div><div class="line">        case 8:</div><div class="line">            imageOrientation = UIImageOrientationLeft;</div><div class="line">            break;</div><div class="line">        case 6:</div><div class="line">            imageOrientation = UIImageOrientationRight;</div><div class="line">            break;</div><div class="line">        case 2:</div><div class="line">            imageOrientation = UIImageOrientationUpMirrored;</div><div class="line">            break;</div><div class="line">        case 4:</div><div class="line">            imageOrientation = UIImageOrientationDownMirrored;</div><div class="line">            break;</div><div class="line">        case 5:</div><div class="line">            imageOrientation = UIImageOrientationLeftMirrored;</div><div class="line">            break;</div><div class="line">        case 7:</div><div class="line">            imageOrientation = UIImageOrientationRightMirrored;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return imageOrientation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Convert an iOS orientation to an EXIF image orientation.</div><div class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation &#123;</div><div class="line">    // CGImagePropertyOrientation is available on iOS 8 above. Currently kept for compatibility</div><div class="line">    NSInteger exifOrientation = 1;</div><div class="line">    switch (imageOrientation) &#123;</div><div class="line">        case UIImageOrientationUp:</div><div class="line">            exifOrientation = 1;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationDown:</div><div class="line">            exifOrientation = 3;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationLeft:</div><div class="line">            exifOrientation = 8;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationRight:</div><div class="line">            exifOrientation = 6;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationUpMirrored:</div><div class="line">            exifOrientation = 2;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationDownMirrored:</div><div class="line">            exifOrientation = 4;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationLeftMirrored:</div><div class="line">            exifOrientation = 5;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationRightMirrored:</div><div class="line">            exifOrientation = 7;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return exifOrientation;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sd中是使用下面的代码拿到在图片数据中朝向的值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</div><div class="line">NSInteger orientationValue = 1;</div><div class="line">CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</div></pre></td></tr></table></figure>
<p>以上所有编解码相关的类就分析完毕了。这里我们在设计模块的时候可应该参考sd里面的做法，首先通过协议的方式放开需要的接口，各模块按根据需求决定是否实现对应协议，虽然都是编解码，但是针对不同的格式创建不同的类去实现，然后在manager中通过判断不同的格式调用不同的模块去做具体的事情，减少逻辑的耦合。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" rel="next" title="使用AudioQueue实现一个音频播放(二)--边播边缓存">
                <i class="fa fa-chevron-left"></i> 使用AudioQueue实现一个音频播放(二)--边播边缓存
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/06/19/SDWebImage学习笔记/"
           data-title="SDWebImage学习笔记" data-url="http://yoursite.com/2018/06/19/SDWebImage学习笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载模块"><span class="nav-number">1.</span> <span class="nav-text">下载模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageDownloaderOperation"><span class="nav-number">1.1.</span> <span class="nav-text">SDWebImageDownloaderOperation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageDownloader"><span class="nav-number">1.2.</span> <span class="nav-text">SDWebImageDownloader</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存模块"><span class="nav-number">2.</span> <span class="nav-text">缓存模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDImageCacheConfig"><span class="nav-number">2.1.</span> <span class="nav-text">SDImageCacheConfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDImageCache"><span class="nav-number">2.2.</span> <span class="nav-text">SDImageCache</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图片编解码模块"><span class="nav-number">3.</span> <span class="nav-text">图片编解码模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageCoder"><span class="nav-number">3.1.</span> <span class="nav-text">SDWebImageCoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageImageIOCoder"><span class="nav-number">3.2.</span> <span class="nav-text">SDWebImageImageIOCoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageGIFCoder"><span class="nav-number">3.3.</span> <span class="nav-text">SDWebImageGIFCoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageWebPCoder"><span class="nav-number">3.4.</span> <span class="nav-text">SDWebImageWebPCoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageCodersManager"><span class="nav-number">3.5.</span> <span class="nav-text">SDWebImageCodersManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDWebImageCoderHelper"><span class="nav-number">3.6.</span> <span class="nav-text">SDWebImageCoderHelper</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
