<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="RunLoop是干啥的官翻： Run loops是与线程相关的基础设施的一部分，一个Runloop就是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。 疑问？？？ Runloop的运行机制 Runloop是如何唤醒和睡眠线程的，与线程到底是什么关系 Runloop的Source、Timer、Observer和Mode与Runloop到底是什么关系">
<meta property="og:type" content="article">
<meta property="og:title" content="Runloop源码解析和实践">
<meta property="og:url" content="http://yoursite.com/2018/09/10/Runloop源码解析和实践/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="RunLoop是干啥的官翻： Run loops是与线程相关的基础设施的一部分，一个Runloop就是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。 疑问？？？ Runloop的运行机制 Runloop是如何唤醒和睡眠线程的，与线程到底是什么关系 Runloop的Source、Timer、Observer和Mode与Runloop到底是什么关系">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop001.png">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop003.png">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop004.png">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop005.png">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop007.png">
<meta property="og:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop008.png">
<meta property="og:updated_time" content="2019-04-03T04:22:15.023Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runloop源码解析和实践">
<meta name="twitter:description" content="RunLoop是干啥的官翻： Run loops是与线程相关的基础设施的一部分，一个Runloop就是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。 疑问？？？ Runloop的运行机制 Runloop是如何唤醒和睡眠线程的，与线程到底是什么关系 Runloop的Source、Timer、Observer和Mode与Runloop到底是什么关系">
<meta name="twitter:image" content="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop001.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2018/09/10/Runloop源码解析和实践/"/>

  <title> Runloop源码解析和实践 | lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Runloop源码解析和实践
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-09-10T21:20:28+08:00" content="2018-09-10">
              2018-09-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/09/10/Runloop源码解析和实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/10/Runloop源码解析和实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="RunLoop是干啥的"><a href="#RunLoop是干啥的" class="headerlink" title="RunLoop是干啥的"></a>RunLoop是干啥的</h4><p><strong>官翻：</strong> Run loops是与线程相关的基础设施的一部分，一个Runloop就是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。</p>
<h4 id="疑问？？？"><a href="#疑问？？？" class="headerlink" title="疑问？？？"></a>疑问？？？</h4><ul>
<li>Runloop的运行机制</li>
<li>Runloop是如何唤醒和睡眠线程的，与线程到底是什么关系</li>
<li>Runloop的Source、Timer、Observer和Mode与Runloop到底是什么关系</li>
<li>iOS系统怎么使用Runloop的</li>
<li>如何自定义</li>
</ul>
<h3 id="庖丁解🐂"><a href="#庖丁解🐂" class="headerlink" title="庖丁解🐂"></a>庖丁解🐂</h3><p>一个Runloop接收2中不同类型的sources.<strong>Input source</strong> 发送异步事件，一般是来自其他线程或者是其他应用的；<strong>Timer source</strong>发送同步事件，会在预设好的时间或者重复间隔内触发。这2种source都会通过特殊的处理程序处理事件。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop001.png" alt=""></p>
<p>Input source发送异步事件，这种source runloop在处理的时候会调用runUnitlDate：方法开启一个runloop,并且在运行date时间后退出。Timer source则不会使runloop退出。</p>
<p>在处理input source时，runloops 也会生成相关的通知，你可以注册成为观察者在当前线程来处理其他时间。</p>
<p>#####（补充） runloop 的运行方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)run; </div><div class="line">- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</div><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure>
<ul>
<li><p>run方法对应CFRunloopRef中的CFRunLoopRun并不会退出，除非手动调用CFRunLoopStop();通常如果想要永远不会退出RunLoop才会使用此方法，否则可以使用runUntilDate。</p>
</li>
<li><p>runMode:beforeDate:则对应CFRunLoopRunInMode(mode,limiteDate,true)方法,只执行一次，执行完就退出；通常用于手动控制RunLoop（例如在while循环中）。</p>
</li>
<li><p>runUntilDate:方法其实是CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)，执行完并不会退出，继续下一次RunLoop直到timeout。</p>
</li>
</ul>
<h4 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h4><p>一个runloop mode是input source和timer sources的集合，同时包含一个runloop观察者的合集。每次运行一个runloop时，需要指定一个特别的mode。在runloop 运行的过程中，只有和这个mode相关联source才能发送事件（同样，只有和这个mode关联的观察者才能收到通知）。关联了其他mode的source会被暂停一切新事件的发送直到runloop运行在该mode上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</div><div class="line">    CFMutableSetRef _sources0;    // Set</div><div class="line">    CFMutableSetRef _sources1;    // Set</div><div class="line">    CFMutableArrayRef _observers; // Array</div><div class="line">    CFMutableArrayRef _timers;    // Array</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>modes通过name来区分，可用通过指定mode的name来自定义一个mode,虽然name在自定义的时候可以任意指定，但是其他内容却不行，当你自定义一个mode的时候，必须添加一个或者多个source(input source 或 timer source) ,或者观察者。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop003.png" alt=""></p>
<h4 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h4><p>Input sources 给线程发送异步事件，事件的类型和input source的类型相关。一般有2种:<strong>Port-based input sources 用来监控Mach ports</strong>和<strong>自定义 input sources 用来监控自定义事件</strong>。2者的唯一不同在于如何发送信号：Port-based input sources是kernel内核自动发送信号；自定义 input sources是从其他线程手动发送信号。</p>
<h5 id="Port-Based-Sources"><a href="#Port-Based-Sources" class="headerlink" title="Port-Based Sources"></a>Port-Based Sources</h5><ul>
<li>NSMachPort</li>
<li>NSMessagePort</li>
</ul>
<p>mach 操作系统微内核 在mac os和ios系统中采用。虚拟内存的分配，进程间的通信（基于port）。</p>
<p>每一种服务都是一个进程（http 8080 https 443 ftp 20 21 rtmp 1935），每一个进程都分配一个port(虚拟端口)， </p>
<h5 id="Custom-Input-Sources"><a href="#Custom-Input-Sources" class="headerlink" title="Custom Input Sources"></a>Custom Input Sources</h5><p>自定义一个Input source需要满足如下定义：</p>
<ul>
<li>需要input source处理的信息</li>
<li>让感兴趣的客户端知道怎么联系你的input source</li>
<li>一个处理程序例程来执行任何客户端的发送请求</li>
<li>取消程序</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop004.png" alt=""></p>
<h5 id="Cocoa-Perform-Selector-Sources"><a href="#Cocoa-Perform-Selector-Sources" class="headerlink" title="Cocoa Perform Selector Sources"></a>Cocoa Perform Selector Sources</h5><p>Perform Selector Sources 在执行完以后会从runloop的mode中移除。</p>
<p>当调用这个方法时，target线程必须包含一个活跃的runloop，runloop会在一次loop中处理所有的排队Perform事件而不是只处理一个。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop005.png" alt=""></p>
<h4 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h4><p>timer需要关联一个mode，如果timer不在当前活动的mode上，则不会被触发。如果timer所在的mode执行过程中被切换，则该timer也不会暂停直到mode重新切换回来，这就决定了NSTimer的触发并不是十分可靠的。</p>
<h4 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> /* Run Loop Observer Activities */</div><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),// 即将进入Loop  0x1</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),// 即将处理 Timer </div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source </div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠 0x20</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 </div><div class="line">    </div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出Loop </div><div class="line">    </div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Runloop使用场景"><a href="#Runloop使用场景" class="headerlink" title="Runloop使用场景"></a>Runloop使用场景</h4><ul>
<li>使用mach port或者自定义input source 来与其他线程通信</li>
<li>使用NSTimer</li>
<li>使用performSelector</li>
<li>线程保活</li>
<li>系统默认使用</li>
</ul>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>源码下载<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></p>
<h5 id="Input-Source-amp-amp-CFRunLoopSource-的结构"><a href="#Input-Source-amp-amp-CFRunLoopSource-的结构" class="headerlink" title="Input Source &amp;&amp; CFRunLoopSource 的结构"></a>Input Source &amp;&amp; CFRunLoopSource 的结构</h5><ul>
<li>source0/自定义 source</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">    Boolean	(*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode	(*hash)(const void *info);</div><div class="line">    void	(*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void	(*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void	(*perform)(void *info);</div><div class="line">&#125; CFRunLoopSourceContext;</div></pre></td></tr></table></figure>
<ul>
<li>source1/(mach port source+自定义 source)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">    Boolean	(*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode	(*hash)(const void *info);</div><div class="line">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</div><div class="line">    mach_port_t	(*getPort)(void *info);</div><div class="line">    void *	(*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);</div><div class="line">#else</div><div class="line">    void *	(*getPort)(void *info);</div><div class="line">    void	(*perform)(void *info);</div><div class="line">#endif</div><div class="line">&#125; CFRunLoopSourceContext1;</div></pre></td></tr></table></figure>
<ul>
<li>CFRunLoopSource</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopSource &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint32_t _bits;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFMutableBagRef _runLoops;</div><div class="line">    union &#123;</div><div class="line">	CFRunLoopSourceContext version0;	/* immutable, except invalidation */</div><div class="line">        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */</div><div class="line">    &#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="observer-amp-amp-CFRunLoopObserver-的结构"><a href="#observer-amp-amp-CFRunLoopObserver-的结构" class="headerlink" title="observer &amp;&amp; CFRunLoopObserver 的结构"></a>observer &amp;&amp; CFRunLoopObserver 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">&#125; CFRunLoopObserverContext;</div><div class="line"></div><div class="line">struct __CFRunLoopObserver &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFIndex _rlCount;</div><div class="line">    CFOptionFlags _activities;		/* immutable */</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFRunLoopObserverCallBack _callout;	/* immutable */</div><div class="line">    CFRunLoopObserverContext _context;	/* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="NSTimer-amp-amp-CFRunloopTimer-的结构"><a href="#NSTimer-amp-amp-CFRunloopTimer-的结构" class="headerlink" title="NSTimer &amp;&amp; CFRunloopTimer 的结构"></a>NSTimer &amp;&amp; CFRunloopTimer 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">&#125; CFRunLoopTimerContext;</div><div class="line"></div><div class="line">struct __CFRunLoopTimer &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint16_t _bits;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFMutableSetRef _rlModes;</div><div class="line">    CFAbsoluteTime _nextFireDate;</div><div class="line">    CFTimeInterval _interval;		/* immutable */</div><div class="line">    CFTimeInterval _tolerance;          /* mutable */</div><div class="line">    uint64_t _fireTSR;			/* TSR units */</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFRunLoopTimerCallBack _callout;	/* immutable */</div><div class="line">    CFRunLoopTimerContext _context;	/* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Mode-的结构"><a href="#Mode-的结构" class="headerlink" title="Mode 的结构"></a>Mode 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;//如果是MK_TIMER的话，会通过这个端口唤醒线程</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="runloop-的结构"><a href="#runloop-的结构" class="headerlink" title="runloop 的结构"></a>runloop 的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct _block_item &#123;</div><div class="line">    struct _block_item *_next;</div><div class="line">    CFTypeRef _mode;	// CFString or CFSet</div><div class="line">    void (^_block)(void);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef struct _per_run_data &#123;</div><div class="line">    uint32_t a;</div><div class="line">    uint32_t b;</div><div class="line">    uint32_t stopped;</div><div class="line">    uint32_t ignoreWakeUps;</div><div class="line">&#125; _per_run_data;</div><div class="line"></div><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;			/* locked for accessing mode list */</div><div class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp source0的手动唤醒就是通过给这个端口发消息实现的。</div><div class="line">    Boolean _unused;</div><div class="line">    </div><div class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run  loop 个人理解为runloop的一个配置文件</div><div class="line">    </div><div class="line">    pthread_t _pthread;</div><div class="line">    uint32_t _winthread;</div><div class="line">    </div><div class="line">    CFMutableSetRef _commonModes;//存放 common mode 的集合</div><div class="line">    CFMutableSetRef _commonModeItems;//每个 common mode 都有的 item (source, timer and observer) 集合</div><div class="line">    </div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;//这个 run loop 所有的 mode 集合</div><div class="line">    </div><div class="line">    struct _block_item *_blocks_head;</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    </div><div class="line">    </div><div class="line">    CFAbsoluteTime _runTime;</div><div class="line">    CFAbsoluteTime _sleepTime;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop"><a href="#Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop" class="headerlink" title="Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()"></a>Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//获取主线程runloop</div><div class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class="line">    return __main;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取当前线程runloop</div><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div><div class="line"></div><div class="line">//保存runloop和pthread的全局字典。key = pthreadPointer(t); value = runloop.</div><div class="line">static CFMutableDictionaryRef __CFRunLoops = NULL;</div><div class="line">static CFLock_t loopsLock = CFLockInit;</div><div class="line"></div><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class="line"></div><div class="line">	//如果当前线程为0 则取主线程.</div><div class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">	t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __CFLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    //全局字典为空，则创建字典</div><div class="line">    if (!__CFRunLoops) &#123;</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line"></div><div class="line">	//创建主线程的runloop</div><div class="line">	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line"></div><div class="line">	//将runloop和pthread set到一个临时字典中</div><div class="line">	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">	</div><div class="line">	//将临时字典复制到全局字典，这个是一个原子操作。</div><div class="line">	if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class="line">	    CFRelease(dict);</div><div class="line">	&#125;</div><div class="line">	CFRelease(mainLoop);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //从全局字典中取出当前线程对应的runloop</div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">    __CFUnlock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    //如果runloop为空，新建runloop,并保存到全局字典中</div><div class="line">    if (!loop) &#123;</div><div class="line">	CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">	if (!loop) &#123;</div><div class="line">	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">	    loop = newLoop;</div><div class="line">	&#125;</div><div class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">	CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    if (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//入参为一个线程</div><div class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</div><div class="line">    CFRunLoopRef loop = NULL;</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</div><div class="line">    </div><div class="line">    //创建runloop实例</div><div class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, CFRunLoopGetTypeID(), size, NULL);</div><div class="line">    if (NULL == loop) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //初始化配置</div><div class="line">    (void)__CFRunLoopPushPerRunData(loop);</div><div class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</div><div class="line"></div><div class="line">	//初始化唤醒port</div><div class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</div><div class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</div><div class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</div><div class="line">    </div><div class="line">    //初始化commonModes 并 add kCFRunLoopDefaultMode</div><div class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</div><div class="line">    </div><div class="line">    //初始化其他变量</div><div class="line">    loop-&gt;_commonModeItems = NULL;</div><div class="line">    loop-&gt;_currentMode = NULL;</div><div class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    loop-&gt;_blocks_head = NULL;</div><div class="line">    loop-&gt;_blocks_tail = NULL;</div><div class="line">    loop-&gt;_counterpart = NULL;</div><div class="line">    </div><div class="line">    //绑定线程</div><div class="line">    loop-&gt;_pthread = t;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    loop-&gt;_winthread = GetCurrentThreadId();</div><div class="line">#else</div><div class="line">    loop-&gt;_winthread = 0;</div><div class="line">#endif</div><div class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</div><div class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</div><div class="line">    return loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 线程退出时调用</div><div class="line">CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) &#123;</div><div class="line">    CFRunLoopRef rl = NULL;</div><div class="line">    if (data &lt;= 1) &#123;</div><div class="line">	__CFLock(&amp;loopsLock);</div><div class="line">	if (__CFRunLoops) &#123;</div><div class="line">		</div><div class="line">		//在全局字典中移除该runloop</div><div class="line">	    rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));</div><div class="line">	    if (rl) CFRetain(rl);</div><div class="line">	    CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));</div><div class="line">	&#125;</div><div class="line">	__CFUnlock(&amp;loopsLock);</div><div class="line">    &#125; else &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    if (rl &amp;&amp; CFRunLoopGetMain() != rl) &#123; // protect against cooperative threads</div><div class="line">        if (NULL != rl-&gt;_counterpart) &#123;</div><div class="line">            CFRelease(rl-&gt;_counterpart);</div><div class="line">	    rl-&gt;_counterpart = NULL;</div><div class="line">        &#125;</div><div class="line">	// purge all sources before deallocation</div><div class="line">        CFArrayRef array = CFRunLoopCopyAllModes(rl);</div><div class="line">        </div><div class="line">        //移除该runloop的所有source</div><div class="line">        for (CFIndex idx = CFArrayGetCount(array); idx--;) &#123;</div><div class="line">            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);</div><div class="line">            __CFRunLoopRemoveAllSources(rl, modeName);</div><div class="line">        &#125;</div><div class="line">        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);</div><div class="line">        CFRelease(array);</div><div class="line">    &#125;</div><div class="line">    if (rl) CFRelease(rl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>runloop的创建是懒加载的方式创建，在第一次获取该runloop的时候才会去创建，所以子线程如果没有手动的去获取并运行runloop,是不会自动创建的。</li>
<li>runloop和线程是一一对应的关系，保存在一个全局的字典中。key是线程的指针，value是对应的runloop.</li>
<li>runloop的销毁发生在线程退出时。</li>
</ul>
<h4 id="Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun"><a href="#Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun" class="headerlink" title="Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun"></a>Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div></pre></td><td class="code"><pre><div class="line">struct __timeout_context &#123;</div><div class="line">    dispatch_source_t ds;</div><div class="line">    CFRunLoopRef rl;</div><div class="line">    uint64_t termTSR;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __CFRunLoopTimeoutCancel(void *arg) &#123;</div><div class="line">    struct __timeout_context *context = (struct __timeout_context *)arg;</div><div class="line">    CFRelease(context-&gt;rl);</div><div class="line">    dispatch_release(context-&gt;ds);</div><div class="line">    free(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopTimeout(void *arg) &#123;</div><div class="line">    struct __timeout_context *context = (struct __timeout_context *)arg;</div><div class="line">    context-&gt;termTSR = 0ULL;</div><div class="line">    CFRUNLOOP_WAKEUP_FOR_TIMEOUT();</div><div class="line">    CFRunLoopWakeUp(context-&gt;rl);</div><div class="line">    // The interval is DISPATCH_TIME_FOREVER, so this won&apos;t fire again</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CFRunLoopRun(void) &#123;	/* DOES CALLOUT */</div><div class="line">    int32_t result;</div><div class="line">    do &#123;</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">	Boolean did = false;</div><div class="line">	if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">	// 1.通知观察者runloop即将进入loop</div><div class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">	</div><div class="line">	//run</div><div class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">	</div><div class="line">	// 10. 通知观察者runLoop即将退出</div><div class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">	rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> *  运行run loop</div><div class="line"> *</div><div class="line"> *  @param rl              运行的RunLoop对象</div><div class="line"> *  @param rlm             运行的mode</div><div class="line"> *  @param seconds         run loop超时时间</div><div class="line"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</div><div class="line"> *  @param previousMode    上一次运行的mode</div><div class="line"> *</div><div class="line"> *  @return 返回4种状态</div><div class="line"> */</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line"></div><div class="line">	</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line">    </div><div class="line">    //如果该runloop已停止，直接退出。</div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    //获取GCD的消息端口</div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    </div><div class="line">    //看判断条件，只有当前是主线程，才获取端口。（GCD只能唤醒主线程的runloop）</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">    //使用GCD的source来实现NSTimer</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    //设置runloop的超时时间，second是参数。</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">	timeout_context-&gt;ds = timeout_timer;</div><div class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">	</div><div class="line">	//调用__CFRunLoopTimeout</div><div class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//初始化为true</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;//返回状态</div><div class="line">    </div><div class="line">    //do while循环</div><div class="line">    do &#123;</div><div class="line">    </div><div class="line">    //runloop睡眠的时候会注册这个端口用来接口消息    </div><div class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line"></div><div class="line">	// 设置RunLoop为可以被唤醒状态</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">	// 2.通知observer，即将触发timer回调，处理timer事件</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        </div><div class="line">   	// 3.通知observer，即将触发Source0回调</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line"></div><div class="line"></div><div class="line">	// 执行加入当前 runloop 的 block</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	</div><div class="line">	 	 // 4.处理 source0 事件 有事件处理返回 true，没有事件返回 false</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        </div><div class="line">        // 如果实际处理了 sources 0，再一次处理 blocks（有可能是source0的回调中又给runloop添加了block）</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		 // 如果没有 Sources0 事件处理 并且 没有超时，poll 为 false</div><div class="line">        // 如果有 Sources0 事件处理 或者 超时，poll 都为 true</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line">        </div><div class="line">         if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line"></div><div class="line">         //如果收到source1的消息</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">                goto handle_msg;    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        didDispatchPortLastTime = false;</div><div class="line"></div><div class="line">	// 6.通知观察者RunLoop即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	</div><div class="line">	 // 7.设置RunLoop为休眠状态</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line">	</div><div class="line">	// do not do any user callouts after this point (after notifying of sleeping)</div><div class="line"></div><div class="line">        // Must push the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced.</div><div class="line"></div><div class="line">	//将睡眠等待端口添加到当前mach port活跃列表</div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">		//记录开始睡眠时间</div><div class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class="line"></div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">		// 等待被唤醒，可以被 sources0、source1、Mach port source,timers、CFRunLoopWakeUp 函数和 GCD 事件（如果在主线程）</div><div class="line">        do &#123;</div><div class="line">        </div><div class="line">        	  //清理消息缓存区</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                // objc_clear_stack(0);</div><div class="line">                // &lt;rdar://problem/16393959&gt;</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            </div><div class="line">            // 接收waitSet端口的消息 </div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">            </div><div class="line">			  // 如果是 timer 端口唤醒的，进行一下善后处理，之后再处理 timer</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    // Leave livePort as the queue port, and service timers below</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">            </div><div class="line">            	   // 不是 timer 端口唤醒的，跳出循环，进行接下来的处理</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line"></div><div class="line">		 // 不使用 GCD timer 作为 timer 实现的情况</div><div class="line">		 </div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            // objc_clear_stack(0);</div><div class="line">            // &lt;rdar://problem/16393959&gt;</div><div class="line">            </div><div class="line">            //清理消息缓存区</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">        </div><div class="line">#endif</div><div class="line">      </div><div class="line">      	 //被唤醒了。。。</div><div class="line">      	 </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">		  // 记录增加的睡眠时间</div><div class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class="line"></div><div class="line">        // Must remove the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class="line">        // in there if this function returns.</div><div class="line"></div><div class="line">		 //将等待唤醒的端口从mach port活跃端口列表移除</div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        //设置为忽略唤醒状态</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">		 // 取消runloop的休眠状态</div><div class="line">        // user callouts now OK again</div><div class="line">	__CFRunLoopUnsetSleeping(rl);</div><div class="line">	</div><div class="line">		 // 8.通知观察者runloop被唤醒</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line"></div><div class="line">		 // 9.处理通过端口收到的消息</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">		</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">        	  </div><div class="line">        	  // 不知道哪个端口唤醒的（或者根本没睡），啥也不干</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">            </div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">        		</div><div class="line">        	  // 被 CFRunLoopWakeUp 函数唤醒的，啥也不干</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            // do nothing on Mac OS</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">        	  </div><div class="line">        	  // 被 timers 唤醒，处理 timers</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class="line">            </div><div class="line">            // 被 timers 唤醒，处理 timers</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">			//被GCD唤醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">           __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">        	//以上都不是则是被source1唤醒的</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            </div><div class="line">            // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</div><div class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class="line"></div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            </div><div class="line"></div><div class="line">	        mach_msg_header_t *reply = NULL;</div><div class="line"></div><div class="line">	        //处理source1</div><div class="line">	        sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">	        if (NULL != reply) &#123;</div><div class="line">	            (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">	            CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">	        &#125;</div><div class="line">	            </div><div class="line">	            // Restore the previous voucher</div><div class="line">	            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">            </div><div class="line">        &#125; </div><div class="line">               </div><div class="line">   // 再一次处理 blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">	// 善后</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	</div><div class="line">	// 处理完当前事件 &amp; runloop 执行完就退出</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">	    </div><div class="line">	&#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">        </div><div class="line">        // run loop超时</div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">            </div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">	</div><div class="line">		 // run loop被手动终止</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	    </div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">		</div><div class="line">		// mode被终止</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	    </div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	</div><div class="line">		// mode中的Items都为空，退出。</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">        </div><div class="line">    &#125; while (0 == retVal);</div><div class="line"></div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return retVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//接收mach port消息</div><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *voucherState, voucher_t *voucherCopy) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;		/* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;</div><div class="line">        msg-&gt;msgh_local_port = port;</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class="line">        msg-&gt;msgh_size = buffer_size;</div><div class="line">        msg-&gt;msgh_id = 0;</div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        </div><div class="line">        //接收或发送消息</div><div class="line">        ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class="line"></div><div class="line">        // Take care of all voucher-related work right after mach_msg.</div><div class="line">        // If we don&apos;t release the previous voucher we&apos;re going to leak it.</div><div class="line">        voucher_mach_msg_revert(*voucherState);</div><div class="line">        </div><div class="line">        // Someone will be responsible for calling voucher_mach_msg_revert. This call makes the received voucher the current one.</div><div class="line">        *voucherState = voucher_mach_msg_adopt(msg);</div><div class="line">        </div><div class="line">        if (voucherCopy) &#123;</div><div class="line">            if (*voucherState != VOUCHER_MACH_MSG_STATE_UNCHANGED) &#123;</div><div class="line">                // Caller requested a copy of the voucher at this point. By doing this right next to mach_msg we make sure that no voucher has been set in between the return of mach_msg and the use of the voucher copy.</div><div class="line">                // CFMachPortBoost uses the voucher to drop importance explicitly. However, we want to make sure we only drop importance for a new voucher (not unchanged), so we only set the TSD when the voucher is not state_unchanged.</div><div class="line">                *voucherCopy = voucher_copy();</div><div class="line">            &#125; else &#123;</div><div class="line">                *voucherCopy = NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        CFRUNLOOP_WAKEUP(ret);</div><div class="line">        </div><div class="line">        //接收消息成功</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="runloop运行流程总结入下图"><a href="#runloop运行流程总结入下图" class="headerlink" title="runloop运行流程总结入下图"></a>runloop运行流程总结入下图</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop007.png" alt=""></p>
<p>runloop内部其实就是一个do while()的循环。只是在没有事件需要处理的时候，runloop会调用<strong>__CFRunLoopSetSleeping</strong> 方法将当前线程置为睡眠状态，同时会调用 <strong>__CFRunLoopServiceMachPort</strong> 方法来睡眠线程并等待接收mach发来的唤醒消息。收到消息后，该线程会被唤醒，唤醒后runloop除了处理唤醒它的事件，还需要处理一遍所有等待处理的事件，包括（timer,observer,source,block）。</p>
<h5 id="runloop唤醒事件总结"><a href="#runloop唤醒事件总结" class="headerlink" title="runloop唤醒事件总结"></a>runloop唤醒事件总结</h5><ul>
<li>mach port source</li>
<li>手动唤醒Custom Input Source（CFRunLoopSourceSignal(source)/CFRunLoopWakeUp(runloop)）</li>
<li>dispatch_async(dispatch_get_main_queue)/dispatch_sync(dispatch_get_main_queue)(不要在主线程同步任务，会死锁);</li>
<li>timer</li>
</ul>
<h4 id="Mode和它的四大大王-Source-Timer-Observer-Block"><a href="#Mode和它的四大大王-Source-Timer-Observer-Block" class="headerlink" title="Mode和它的四大大王(Source,Timer,Observer,Block)"></a>Mode和它的四大大王(Source,Timer,Observer,Block)</h4><h5 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h5><p>Mode的创建也是懒加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    struct __CFRunLoopMode srlm;</div><div class="line">    memset(&amp;srlm, 0, sizeof(srlm));</div><div class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, __kCFRunLoopModeTypeID);</div><div class="line">    srlm._name = modeName;</div><div class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</div><div class="line">    </div><div class="line">    //mode不为空直接返回，为空则创建新的</div><div class="line">    if (NULL != rlm) &#123;</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">	return rlm;</div><div class="line">    &#125;</div><div class="line">    if (!create) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);</div><div class="line">    if (NULL == rlm) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //参数的初始化</div><div class="line">    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);</div><div class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    rlm-&gt;_portToV1SourceMap = NULL;</div><div class="line">    rlm-&gt;_sources0 = NULL;</div><div class="line">    rlm-&gt;_sources1 = NULL;</div><div class="line">    rlm-&gt;_observers = NULL;</div><div class="line">    rlm-&gt;_timers = NULL;</div><div class="line">    rlm-&gt;_observerMask = 0;</div><div class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</div><div class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</div><div class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</div><div class="line">    </div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    </div><div class="line">    //初始化timer相关内容</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    rlm-&gt;_timerFired = false;</div><div class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0);</div><div class="line">    </div><div class="line">    //用来唤醒的端口</div><div class="line">    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">    if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1);</div><div class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue);</div><div class="line">    </div><div class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</div><div class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</div><div class="line">        *timerFiredPointer = true;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</div><div class="line">    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);</div><div class="line">    dispatch_resume(rlm-&gt;_timerSource);</div><div class="line">    </div><div class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</div><div class="line">    </div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line"></div><div class="line">    //用来唤醒的端口</div><div class="line">    rlm-&gt;_timerPort = mk_timer_create();</div><div class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</div><div class="line">#endif</div><div class="line">    </div><div class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret);</div><div class="line">    </div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    rlm-&gt;_msgQMask = 0;</div><div class="line">    rlm-&gt;_msgPump = NULL;</div><div class="line">#endif</div><div class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</div><div class="line">    CFRelease(rlm);</div><div class="line">    __CFRunLoopModeLock(rlm);	/* return mode locked */</div><div class="line">    return rlm;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//判断mode是否为空 通过这个函数可以看到，只有当source0、source1、timer和block都为空，mode才会被标记为空（这么看observer应该是低等屁民了，没有什么存在感）</div><div class="line"></div><div class="line">static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (NULL == rlm) return true;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    if (0 != rlm-&gt;_msgQMask) return false;</div><div class="line">#endif</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    </div><div class="line">	//主线程且当前Mode也在CommonMode中，不可能为空，应该是系统有往CommonMode里面添加了东西，会被同步到该Mode中。</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) return false; // represents the libdispatch main queue</div><div class="line">    </div><div class="line">    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false;</div><div class="line">    if (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false;</div><div class="line">    if (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false;</div><div class="line">    struct _block_item *item = rl-&gt;_blocks_head;</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">        Boolean doit = false;</div><div class="line">        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">            doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));</div><div class="line">        &#125; else &#123;</div><div class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));</div><div class="line">        &#125;</div><div class="line">        if (doit) return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line">//source的创建</div><div class="line"></div><div class="line">CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopSourceRef memory;</div><div class="line">    uint32_t size;</div><div class="line">    if (NULL == context) CRASH(&quot;*** NULL context value passed to CFRunLoopSourceCreate(). (%d) ***&quot;, -1);</div><div class="line">    </div><div class="line">    size = sizeof(struct __CFRunLoopSource) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopSourceRef)_CFRuntimeCreateInstance(allocator, CFRunLoopSourceGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopSourceUnsetSignaled(memory);</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_bits = 0;</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    memory-&gt;_runLoops = NULL;</div><div class="line">    size = 0;</div><div class="line">    switch (context-&gt;version) &#123;</div><div class="line">    case 0:</div><div class="line">	size = sizeof(CFRunLoopSourceContext);</div><div class="line">	break;</div><div class="line">    case 1:</div><div class="line">	size = sizeof(CFRunLoopSourceContext1);</div><div class="line">	break;</div><div class="line">    &#125;</div><div class="line">    objc_memmove_collectable(&amp;memory-&gt;_context, context, size);</div><div class="line">    if (context-&gt;retain) &#123;</div><div class="line">	memory-&gt;_context.version0.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//给mode添加source</div><div class="line"></div><div class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;	/* DOES CALLOUT */</div><div class="line"></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rls)) return;</div><div class="line">    Boolean doVer0Callout = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    //如果是common 直接添加到_commonModeItems数组</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rls);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rls&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建source0和source1的集合</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) &#123;</div><div class="line">	    rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	    rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	    rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);</div><div class="line">	&#125;</div><div class="line">	if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</div><div class="line">	</div><div class="line">		//按source类型添加到不同的集合中</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        CFSetAddValue(rlm-&gt;_sources0, rls);</div><div class="line">	    &#125; else if (1 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        CFSetAddValue(rlm-&gt;_sources1, rls);</div><div class="line">		__CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</div><div class="line">		</div><div class="line">		//如果是source1 还需要把source1对应的port添加到mach port的列表中</div><div class="line">		if (CFPORT_NULL != src_port) &#123;</div><div class="line">		    CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</div><div class="line">		    __CFPortSetInsert(src_port, rlm-&gt;_portSet);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    __CFRunLoopSourceLock(rls);</div><div class="line">	    if (NULL == rls-&gt;_runLoops) &#123;</div><div class="line">	        rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); // sources retain run loops!</div><div class="line">	    &#125;</div><div class="line">	    CFBagAddValue(rls-&gt;_runLoops, rl);</div><div class="line">	    __CFRunLoopSourceUnlock(rls);</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        if (NULL != rls-&gt;_context.version0.schedule) &#123;</div><div class="line">	            doVer0Callout = true;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">	rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);	/* CALLOUT */</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理source0</div><div class="line">static Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFTypeRef sources = NULL;</div><div class="line">    Boolean sourceHandled = false;</div><div class="line"></div><div class="line">    /* Fire the version 0 sources */</div><div class="line">    </div><div class="line">    //获取当前mode的source0集合</div><div class="line">    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) &#123;</div><div class="line">	CFSetApplyFunction(rlm-&gt;_sources0, (__CFRunLoopCollectSources0), &amp;sources);</div><div class="line">    &#125;</div><div class="line">    if (NULL != sources) &#123;</div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	// sources is either a single (retained) CFRunLoopSourceRef or an array of (retained) CFRunLoopSourceRef</div><div class="line">	</div><div class="line">	//如果是单个事件</div><div class="line">	if (CFGetTypeID(sources) == CFRunLoopSourceGetTypeID()) &#123;</div><div class="line">	    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;</div><div class="line">	    __CFRunLoopSourceLock(rls);</div><div class="line">	    </div><div class="line">	    //这里在处理完这个source之后，会把这个source标记为不再处理！！！！后面demo里有应用。</div><div class="line">            if (__CFRunLoopSourceIsSignaled(rls)) &#123;</div><div class="line">	        __CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">	        if (__CFIsValid(rls)) &#123;</div><div class="line">	            __CFRunLoopSourceUnlock(rls);</div><div class="line"></div><div class="line">                    //调用source0对应的回调</div><div class="line">                    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</div><div class="line">	            CHECK_FOR_FORK();</div><div class="line">	            sourceHandled = true;</div><div class="line">	        &#125; else &#123;</div><div class="line">	            __CFRunLoopSourceUnlock(rls);</div><div class="line">	        &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                __CFRunLoopSourceUnlock(rls);</div><div class="line">            &#125;</div><div class="line">	&#125; else &#123;</div><div class="line">	</div><div class="line">	//如果是一个事件列表</div><div class="line">	    CFIndex cnt = CFArrayGetCount((CFArrayRef)sources);</div><div class="line">	    CFArraySortValues((CFMutableArrayRef)sources, CFRangeMake(0, cnt), (__CFRunLoopSourceComparator), NULL);</div><div class="line">	    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		CFRunLoopSourceRef rls = (CFRunLoopSourceRef)CFArrayGetValueAtIndex((CFArrayRef)sources, idx);</div><div class="line">		__CFRunLoopSourceLock(rls);</div><div class="line">                if (__CFRunLoopSourceIsSignaled(rls)) &#123;</div><div class="line">		    __CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">		    if (__CFIsValid(rls)) &#123;</div><div class="line">		        __CFRunLoopSourceUnlock(rls);</div><div class="line">                        </div><div class="line">                        //调用source0对应的回调                       __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</div><div class="line">		        CHECK_FOR_FORK();</div><div class="line">		        sourceHandled = true;</div><div class="line">		    &#125; else &#123;</div><div class="line">		        __CFRunLoopSourceUnlock(rls);</div><div class="line">		    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    __CFRunLoopSourceUnlock(rls);</div><div class="line">                &#125;</div><div class="line">		if (stopAfterHandle &amp;&amp; sourceHandled) &#123;</div><div class="line">		    break;</div><div class="line">		&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	CFRelease(sources);</div><div class="line">	__CFRunLoopLock(rl);</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">    &#125;</div><div class="line">    return sourceHandled;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理source1</div><div class="line">static Boolean __CFRunLoopDoSource1(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">                                    , mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply</div><div class="line">#endif</div><div class="line">                                    ) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    Boolean sourceHandled = false;</div><div class="line"></div><div class="line">    /* Fire a version 1 source */</div><div class="line">    CFRetain(rls);</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    __CFRunLoopSourceLock(rls);</div><div class="line">    if (__CFIsValid(rls)) &#123;</div><div class="line">	__CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">	__CFRunLoopSourceUnlock(rls);</div><div class="line">        __CFRunLoopDebugInfoForRunLoopSource(rls);</div><div class="line">        </div><div class="line">        //调用source1对应的回调</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls-&gt;_context.version1.perform,</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            msg, size, reply,</div><div class="line">#endif</div><div class="line">            rls-&gt;_context.version1.info);</div><div class="line">	CHECK_FOR_FORK();</div><div class="line">	sourceHandled = true;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (_LogCFRunLoop) &#123; CFLog(kCFLogLevelDebug, CFSTR(&quot;%p (%s) __CFRunLoopDoSource1 rls %p is invalid&quot;), CFRunLoopGetCurrent(), *_CFGetProgname(), rls); &#125;</div><div class="line">	__CFRunLoopSourceUnlock(rls);</div><div class="line">    &#125;</div><div class="line">    CFRelease(rls);</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line">    return sourceHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="source总结"><a href="#source总结" class="headerlink" title="source总结"></a>source总结</h5><p>通过对比source0和source1的处理函数发现，source0有2种情况，单个事件和事件列表，而source1只有单个事件的处理，个人理解是因为source1的事件是即时处理的，因为source1可以唤醒runloop,只要有source1事件runloop就会去处理，所有不存在处理事件列表的情况，而source0有可能只是标记为待处理而没有手动唤醒runloop,当标记为待处理source0事件后，只会被添加到mode的source0集合中，在runloop被唤醒后统一处理。</p>
<h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (isnan(interval)) &#123;</div><div class="line">        CRSetCrashLogMessage(&quot;NaN was used as an interval for a CFRunLoopTimer&quot;);</div><div class="line">        HALT;</div><div class="line">    &#125;</div><div class="line">    CFRunLoopTimerRef memory;</div><div class="line">    UInt32 size;</div><div class="line">    size = sizeof(struct __CFRunLoopTimer) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopTimerRef)_CFRuntimeCreateInstance(allocator, CFRunLoopTimerGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopTimerUnsetFiring(memory);</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_runLoop = NULL;</div><div class="line">    memory-&gt;_rlModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    if (interval &lt; 0.0) interval = 0.0;</div><div class="line">    memory-&gt;_interval = interval;</div><div class="line">    memory-&gt;_tolerance = 0.0;</div><div class="line">    </div><div class="line">    //fireDate 首次触发的绝对时间</div><div class="line">    if (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;</div><div class="line">    memory-&gt;_nextFireDate = fireDate;</div><div class="line">    memory-&gt;_fireTSR = 0ULL;</div><div class="line">    </div><div class="line">    //获取mach内核和CF内核的绝对时间</div><div class="line">    uint64_t now2 = mach_absolute_time();</div><div class="line">    CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();</div><div class="line">    </div><div class="line">    //_fireTSR为本次应触发的绝对时间点</div><div class="line">    if (fireDate &lt; now1) &#123;</div><div class="line">		memory-&gt;_fireTSR = now2;</div><div class="line">    &#125; else if (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) &#123;</div><div class="line">		memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</div><div class="line">    &#125; else &#123;</div><div class="line">		memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    memory-&gt;_callout = callout;</div><div class="line">    if (NULL != context) &#123;</div><div class="line">	if (context-&gt;retain) &#123;</div><div class="line">	    memory-&gt;_context.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">	&#125; else &#123;</div><div class="line">	    memory-&gt;_context.info = context-&gt;info;</div><div class="line">	&#125;</div><div class="line">	memory-&gt;_context.retain = context-&gt;retain;</div><div class="line">	memory-&gt;_context.release = context-&gt;release;</div><div class="line">	memory-&gt;_context.copyDescription = context-&gt;copyDescription;</div><div class="line">    &#125; else &#123;</div><div class="line">	memory-&gt;_context.info = 0;</div><div class="line">	memory-&gt;_context.retain = 0;</div><div class="line">	memory-&gt;_context.release = 0;</div><div class="line">	memory-&gt;_context.copyDescription = 0;</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    //如果是common mode直接加到_commonModeItems</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rlt);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rlt&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建timers的数组</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm) &#123;</div><div class="line">            if (NULL == rlm-&gt;_timers) &#123;</div><div class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</div><div class="line">                cb.equal = NULL;</div><div class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</div><div class="line">            &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//判断timer是否被添加到当前mode</div><div class="line">	if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</div><div class="line">            __CFRunLoopTimerLock(rlt);</div><div class="line">            if (NULL == rlt-&gt;_runLoop) &#123;</div><div class="line">		rlt-&gt;_runLoop = rl;</div><div class="line">  	    &#125; else if (rl != rlt-&gt;_runLoop) &#123;</div><div class="line">                __CFRunLoopTimerUnlock(rlt);</div><div class="line">	        __CFRunLoopModeUnlock(rlm);</div><div class="line">                __CFRunLoopUnlock(rl);</div><div class="line">		return;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    //timer将当前mode标记为已添加</div><div class="line">  	    CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            __CFRunLoopTimerFireTSRLock();</div><div class="line">            </div><div class="line">            //添加timer到mode</div><div class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</div><div class="line">            __CFRunLoopTimerFireTSRUnlock();</div><div class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</div><div class="line">                // Normally we don&apos;t do this on behalf of clients, but for</div><div class="line">                // backwards compatibility due to the change in timer handling...</div><div class="line">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</div><div class="line">            &#125;</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重新排列这个mode中的所有timer触发时刻</div><div class="line">static void __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) &#123;</div><div class="line">    if (!rlt) return;</div><div class="line">    CFMutableArrayRef timerArray = rlm-&gt;_timers;</div><div class="line">    if (!timerArray) return;</div><div class="line">    Boolean found = false;</div><div class="line">    // If we know in advance that the timer is not in the array (just being added now) then we can skip this search</div><div class="line">    if (isInArray) &#123;</div><div class="line">        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(0, CFArrayGetCount(timerArray)), rlt);</div><div class="line">        if (kCFNotFound != idx) &#123;</div><div class="line">            CFRetain(rlt);</div><div class="line">            CFArrayRemoveValueAtIndex(timerArray, idx);</div><div class="line">            found = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!found &amp;&amp; isInArray) return;</div><div class="line">    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);</div><div class="line">    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);</div><div class="line">    __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop);</div><div class="line">    if (isInArray) CFRelease(rlt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回timer需要插入的索引</div><div class="line">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) &#123;</div><div class="line">    CFIndex cnt = CFArrayGetCount(array);</div><div class="line">    if (cnt &lt;= 0) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //timer大于256 如果最后一个item的fireTSR小于待插入的timer，直接插入到最后一个位置否则如果第一个item的fireTSR大于带插入的timer,直接插入第一个位置。</div><div class="line">    if (256 &lt; cnt) &#123;</div><div class="line">        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);</div><div class="line">        if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</div><div class="line">            return cnt;</div><div class="line">        &#125;</div><div class="line">        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);</div><div class="line">        if (rlt-&gt;_fireTSR &lt; item-&gt;_fireTSR) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//二分查找一个合适的位置。</div><div class="line">    CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</div><div class="line">    CFIndex idx = 0;</div><div class="line">    Boolean lastTestLEQ;</div><div class="line">    do &#123;</div><div class="line">        add = add / 2;</div><div class="line">	lastTestLEQ = false;</div><div class="line">        CFIndex testIdx = idx + add;</div><div class="line">        if (testIdx &lt; cnt) &#123;</div><div class="line">            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);</div><div class="line">            if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</div><div class="line">                idx = testIdx;</div><div class="line">		lastTestLEQ = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; while (0 &lt; add);</div><div class="line"></div><div class="line">    return lastTestLEQ ? idx + 1 : idx;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) &#123;  </div><div class="line">  </div><div class="line">    uint64_t nextHardDeadline = UINT64_MAX;//最晚的时间点</div><div class="line">    uint64_t nextSoftDeadline = UINT64_MAX;//应该触发的时间点</div><div class="line"></div><div class="line">    if (rlm-&gt;_timers) &#123;</div><div class="line">        // Look at the list of timers. We will calculate two TSR values; the next soft and next hard deadline.</div><div class="line">        // The next soft deadline is the first time we can fire any timer. This is the fire date of the first timer in our sorted list of timers.</div><div class="line">        // The next hard deadline is the last time at which we can fire the timer before we&apos;ve moved out of the allowable tolerance of the timers in our list.</div><div class="line">        for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers , idx);</div><div class="line">            // discount timers currently firing</div><div class="line">            if (__CFRunLoopTimerIsFiring(t)) continue;</div><div class="line">            </div><div class="line">            int32_t err = CHECKINT_NO_ERROR;</div><div class="line">            </div><div class="line">            //SoftDeadline是理应触发的时间</div><div class="line">            uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR;</div><div class="line">            </div><div class="line">            //HardDeadline是理应触发的时间加上tolerance（即最晚触发时间）</div><div class="line">            uint64_t oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err);</div><div class="line">            </div><div class="line">            if (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX;</div><div class="line">            </div><div class="line">            // We can stop searching if the soft deadline for this timer exceeds the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines.</div><div class="line">            </div><div class="line">            //通过这几行代码对deadline进行修正，保证前边的长tolerance的timer不会影响后面的timer的触发</div><div class="line">            </div><div class="line">            //应触发的时间点 &gt; 下次最晚触发时间点 直接退出</div><div class="line">            if (oneTimerSoftDeadline &gt; nextHardDeadline) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //应触发的时间点 &lt; 下次最晚触发时间点 </div><div class="line">            if (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123;</div><div class="line">                nextSoftDeadline = oneTimerSoftDeadline;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //最晚触发时间点 &lt; 下次最晚触发时间点</div><div class="line">            if (oneTimerHardDeadline &lt; nextHardDeadline) &#123;</div><div class="line">                nextHardDeadline = oneTimerHardDeadline;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123;</div><div class="line">            if (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) &#123;</div><div class="line">                CFRUNLOOP_NEXT_TIMER_ARMED((unsigned long)(nextSoftDeadline - mach_absolute_time()));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">            // We&apos;re going to hand off the range of allowable timer fire date to dispatch and let it fire when appropriate for the system.</div><div class="line">            uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline);</div><div class="line">            dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline);</div><div class="line">            </div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line"></div><div class="line">				//对于有leeway的情况（有tolerance的情况），只采用_dispatch_source_set_runloop_timer_4CF的方法</div><div class="line">            if (leeway &gt; 0) &#123;</div><div class="line">                // Only use the dispatch timer if we have any leeway</div><div class="line">                // &lt;rdar://problem/14447675&gt;</div><div class="line">                </div><div class="line">                // Cancel the mk timer</div><div class="line">                if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</div><div class="line">                    AbsoluteTime dummy;</div><div class="line">                    mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</div><div class="line">                    rlm-&gt;_mkTimerArmed = false;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // Arm the dispatch timer</div><div class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</div><div class="line">                rlm-&gt;_dispatchTimerArmed = true;</div><div class="line">            &#125; else &#123;</div><div class="line">            </div><div class="line">            // 对于leeway为0的情况（无tolerance的情况）,采用mk_timer的方式</div><div class="line">                // Cancel the dispatch timer</div><div class="line">                if (rlm-&gt;_dispatchTimerArmed) &#123;</div><div class="line">                    // Cancel the dispatch timer</div><div class="line">                    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888);</div><div class="line">                    rlm-&gt;_dispatchTimerArmed = false;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // Arm the mk timer</div><div class="line">                if (rlm-&gt;_timerPort) &#123;</div><div class="line">                    mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));</div><div class="line">                    rlm-&gt;_mkTimerArmed = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">#else</div><div class="line">            _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</div><div class="line">#endif</div><div class="line">#else</div><div class="line">            if (rlm-&gt;_timerPort) &#123;</div><div class="line">                mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125; else if (nextSoftDeadline == UINT64_MAX) &#123;</div><div class="line">            // Disarm the timers - there is no timer scheduled</div><div class="line">            // 移除timer</div><div class="line">            if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</div><div class="line">                AbsoluteTime dummy;</div><div class="line">                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</div><div class="line">                rlm-&gt;_mkTimerArmed = false;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">            if (rlm-&gt;_dispatchTimerArmed) &#123;</div><div class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333);</div><div class="line">                rlm-&gt;_dispatchTimerArmed = false;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    rlm-&gt;_timerHardDeadline = nextHardDeadline;</div><div class="line">    rlm-&gt;_timerSoftDeadline = nextSoftDeadline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理timer</div><div class="line">// mode and rl are locked on entry and exit</div><div class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;	/* DOES CALLOUT */</div><div class="line">    Boolean timerHandled = false;</div><div class="line">    uint64_t oldFireTSR = 0;</div><div class="line"></div><div class="line">    /* Fire a timer */</div><div class="line">    CFRetain(rlt);</div><div class="line">    __CFRunLoopTimerLock(rlt);</div><div class="line">	</div><div class="line">	//一堆判断条件</div><div class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) &#123;</div><div class="line">        void *context_info = NULL;</div><div class="line">        void (*context_release)(const void *) = NULL;</div><div class="line">        if (rlt-&gt;_context.retain) &#123;</div><div class="line">            context_info = (void *)rlt-&gt;_context.retain(rlt-&gt;_context.info);</div><div class="line">            context_release = rlt-&gt;_context.release;</div><div class="line">        &#125; else &#123;</div><div class="line">            context_info = rlt-&gt;_context.info;</div><div class="line">        &#125;</div><div class="line">        Boolean doInvalidate = (0.0 == rlt-&gt;_interval);</div><div class="line">	__CFRunLoopTimerSetFiring(rlt);</div><div class="line">        // Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer.</div><div class="line">        </div><div class="line">        //重置应触发时间和最晚触发时间</div><div class="line">        rlm-&gt;_timerSoftDeadline = UINT64_MAX;</div><div class="line">        rlm-&gt;_timerHardDeadline = UINT64_MAX;</div><div class="line">        __CFRunLoopTimerUnlock(rlt);</div><div class="line">	__CFRunLoopTimerFireTSRLock();</div><div class="line">	oldFireTSR = rlt-&gt;_fireTSR;</div><div class="line">	__CFRunLoopTimerFireTSRUnlock();</div><div class="line"></div><div class="line">        __CFArmNextTimerInMode(rlm, rl);</div><div class="line"></div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	</div><div class="line">	//处理timer的回调</div><div class="line">	__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</div><div class="line">	CHECK_FOR_FORK();</div><div class="line">        if (doInvalidate) &#123;</div><div class="line">            CFRunLoopTimerInvalidate(rlt);      /* DOES CALLOUT */</div><div class="line">        &#125;</div><div class="line">        if (context_release) &#123;</div><div class="line">            context_release(context_info);</div><div class="line">        &#125;</div><div class="line">	__CFRunLoopLock(rl);</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">        __CFRunLoopTimerLock(rlt);</div><div class="line">        </div><div class="line">    //timer处理成功的标记</div><div class="line">	timerHandled = true;</div><div class="line">	__CFRunLoopTimerUnsetFiring(rlt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //本次timer处理成功了 来更新一下下次的触发时间</div><div class="line">    if (__CFIsValid(rlt) &amp;&amp; timerHandled) &#123;</div><div class="line">        /* This is just a little bit tricky: we want to support calling</div><div class="line">         * CFRunLoopTimerSetNextFireDate() from within the callout and</div><div class="line">         * honor that new time here if it is a later date, otherwise</div><div class="line">         * it is completely ignored. */</div><div class="line"></div><div class="line">         //一下次的触发时间已经设置了 而且比上次的时间大 说明设置的没有问题，直接更新。</div><div class="line">        if (oldFireTSR &lt; rlt-&gt;_fireTSR) &#123;</div><div class="line">            /* Next fire TSR was set, and set to a date after the previous</div><div class="line">            * fire date, so we honor it. */</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            // The timer was adjusted and repositioned, during the</div><div class="line">            // callout, but if it was still the min timer, it was</div><div class="line">            // skipped because it was firing.  Need to redo the</div><div class="line">            // min timer calculation in case rlt should now be that</div><div class="line">            // timer instead of whatever was chosen.</div><div class="line">            </div><div class="line">            //这个函数就是更新下次触发时间的</div><div class="line">            __CFArmNextTimerInMode(rlm, rl);</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">        //没有设置下一次的触发时间，进行设置，然后更新列表</div><div class="line">	    uint64_t nextFireTSR = 0LL;</div><div class="line">            uint64_t intervalTSR = 0LL;</div><div class="line">            if (rlt-&gt;_interval &lt;= 0.0) &#123;</div><div class="line">            &#125; else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) &#123;</div><div class="line">        	intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</div><div class="line">            &#125; else &#123;</div><div class="line">        	intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval);</div><div class="line">            &#125;</div><div class="line">            if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) &#123;</div><div class="line">                nextFireTSR = LLONG_MAX;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (intervalTSR == 0) &#123;</div><div class="line">                    // 15304159: Make sure we don&apos;t accidentally loop forever here</div><div class="line">                    CRSetCrashLogMessage(&quot;A CFRunLoopTimer with an interval of 0 is set to repeat&quot;);</div><div class="line">                    HALT;</div><div class="line">                &#125;</div><div class="line">                uint64_t currentTSR = mach_absolute_time();</div><div class="line">                nextFireTSR = oldFireTSR;</div><div class="line">                while (nextFireTSR &lt;= currentTSR) &#123;</div><div class="line">                    nextFireTSR += intervalTSR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            CFRunLoopRef rlt_rl = rlt-&gt;_runLoop;</div><div class="line">            if (rlt_rl) &#123;</div><div class="line">                CFRetain(rlt_rl);</div><div class="line">		CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);</div><div class="line">		STACK_BUFFER_DECL(CFTypeRef, modes, cnt);</div><div class="line">		CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes);</div><div class="line">		// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up</div><div class="line">		// towards the run loop from a source, the timer has to be</div><div class="line">		// unlocked, which means we have to protect from object</div><div class="line">		// invalidation, although that&apos;s somewhat expensive.</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFRetain(modes[idx]);</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerUnlock(rlt);</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFStringRef name = (CFStringRef)modes[idx];</div><div class="line">		    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false);</div><div class="line">		    CFRelease(name);</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerFireTSRLock();</div><div class="line">		</div><div class="line">		//上面算了一堆就是计算一个正确的nextFireTSR，到这里已经拿到正确的值了，可以赋值。</div><div class="line">		rlt-&gt;_fireTSR = nextFireTSR;</div><div class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];</div><div class="line">		    if (rlm) &#123;</div><div class="line">		    </div><div class="line">		    //更新时间触发的列表</div><div class="line">                        __CFRepositionTimerInMode(rlm, rlt, true);</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerFireTSRUnlock();</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);</div><div class="line">		&#125;</div><div class="line">		CFRelease(rlt_rl);</div><div class="line">	    &#125; else &#123;</div><div class="line">	    </div><div class="line">	    //timer没有加到一个runloop里面。这个timer应该不会被触发。下面也没有调整下次触发时间的操作。。。</div><div class="line">		__CFRunLoopTimerUnlock(rlt);</div><div class="line">		__CFRunLoopTimerFireTSRLock();</div><div class="line">		rlt-&gt;_fireTSR = nextFireTSR;</div><div class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</div><div class="line">		__CFRunLoopTimerFireTSRUnlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        __CFRunLoopTimerUnlock(rlt);</div><div class="line">    &#125;</div><div class="line">    CFRelease(rlt);</div><div class="line">    return timerHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="timer总结"><a href="#timer总结" class="headerlink" title="timer总结"></a>timer总结</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop008.png" alt=""></p>
<ul>
<li>对于重复的NSTimer，其多次触发的时刻不是一开始算好的，而是timer触发后计算的。但是计算时参考的是上次应当触发的时间_fireTSR，因此计算出的下次触发的时刻不会有误差。</li>
<li>设置了tolerance的NSTimer，对于iOS和MacOS系统，实质上会采用GCD timer的形式注册到内核中，GCD timer触发后，再由RunLoop处理其回调逻辑。对于没有设置tolerance的timer，则是用mk_timer的形式注册。</li>
<li>RunLoopMode中timer的排序是按照_fireTSR，也就是应当触发的时间排序的。</li>
</ul>
<h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">//创建observer</div><div class="line"></div><div class="line">CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopObserverRef memory;</div><div class="line">    UInt32 size;</div><div class="line">    size = sizeof(struct __CFRunLoopObserver) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopObserverRef)_CFRuntimeCreateInstance(allocator, CFRunLoopObserverGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopObserverUnsetFiring(memory);</div><div class="line">    if (repeats) &#123;</div><div class="line">	__CFRunLoopObserverSetRepeats(memory);</div><div class="line">    &#125; else &#123;</div><div class="line">	__CFRunLoopObserverUnsetRepeats(memory);</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_runLoop = NULL;</div><div class="line">    memory-&gt;_rlCount = 0;</div><div class="line">    memory-&gt;_activities = activities;</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    memory-&gt;_callout = callout;</div><div class="line">    if (context) &#123;</div><div class="line">	if (context-&gt;retain) &#123;</div><div class="line">	    memory-&gt;_context.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">	&#125; else &#123;</div><div class="line">	    memory-&gt;_context.info = context-&gt;info;</div><div class="line">	&#125;</div><div class="line">	memory-&gt;_context.retain = context-&gt;retain;</div><div class="line">	memory-&gt;_context.release = context-&gt;release;</div><div class="line">	memory-&gt;_context.copyDescription = context-&gt;copyDescription;</div><div class="line">    &#125; else &#123;</div><div class="line">	memory-&gt;_context.info = 0;</div><div class="line">	memory-&gt;_context.retain = 0;</div><div class="line">	memory-&gt;_context.release = 0;</div><div class="line">	memory-&gt;_context.copyDescription = 0;</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//给mode添加observer</div><div class="line"></div><div class="line">void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</div><div class="line"></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    </div><div class="line">    //如果是common mode直接加到_commonModeItems</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rlo);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rlo&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建_observers数组</div><div class="line">	rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123;</div><div class="line">	    rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//判断是否已添加</div><div class="line">	if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123;</div><div class="line">            Boolean inserted = false;</div><div class="line">            for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123;</div><div class="line">                CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">                </div><div class="line">                //有一个排序，只有order大于已添加的observer 才会被添加到数组中</div><div class="line">                if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123;</div><div class="line">                    CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);</div><div class="line">                    inserted = true;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //添加失败直接插到第一个位置</div><div class="line">            if (!inserted) &#123;</div><div class="line">	        CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);</div><div class="line">            &#125;</div><div class="line">	    rlm-&gt;_observerMask |= rlo-&gt;_activities;</div><div class="line">	    __CFRunLoopObserverSchedule(rlo, rl, rlm);</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line"></div><div class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0;</div><div class="line">    if (cnt &lt; 1) return;</div><div class="line"></div><div class="line">    /* Fire the observers */</div><div class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1);</div><div class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * sizeof(CFRunLoopObserverRef));</div><div class="line">    CFIndex obs_cnt = 0;</div><div class="line">    </div><div class="line">    //将列表中 活动 &amp;&amp; 可用 &amp;&amp; 未处理 的observer添加到一个临时的数组中</div><div class="line">    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">        if (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123;</div><div class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    for (CFIndex idx = 0; idx &lt; obs_cnt; idx++) &#123;</div><div class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</div><div class="line">        __CFRunLoopObserverLock(rlo);</div><div class="line">        if (__CFIsValid(rlo)) &#123;</div><div class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</div><div class="line">            __CFRunLoopObserverSetFiring(rlo);</div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">            </div><div class="line">            //调用observer的回调</div><div class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info);</div><div class="line">            if (doInvalidate) &#123;</div><div class="line">                CFRunLoopObserverInvalidate(rlo);</div><div class="line">            &#125;</div><div class="line">            __CFRunLoopObserverUnsetFiring(rlo);</div><div class="line">        &#125; else &#123;</div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">        &#125;</div><div class="line">        CFRelease(rlo);</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">    if (collectedObservers != buffer) free(collectedObservers);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//给runloop添加一个block</div><div class="line"></div><div class="line">void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    </div><div class="line">    //保证mode存在</div><div class="line">    </div><div class="line">    if (CFStringGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">	mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure mode exists</div><div class="line">        CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true);</div><div class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">    &#125; else if (CFArrayGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">        CFIndex cnt = CFArrayGetCount((CFArrayRef)mode);</div><div class="line">	const void **values = (const void **)malloc(sizeof(const void *) * cnt);</div><div class="line">        CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values);</div><div class="line">	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure modes exist</div><div class="line">	for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</div><div class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	&#125;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">	free(values);</div><div class="line">    &#125; else if (CFSetGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">        CFIndex cnt = CFSetGetCount((CFSetRef)mode);</div><div class="line">	const void **values = (const void **)malloc(sizeof(const void *) * cnt);</div><div class="line">        CFSetGetValues((CFSetRef)mode, values);</div><div class="line">	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure modes exist</div><div class="line">	for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</div><div class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	&#125;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">	free(values);</div><div class="line">    &#125; else &#123;</div><div class="line">	mode = NULL;</div><div class="line">    &#125;</div><div class="line">    block = Block_copy(block);</div><div class="line">    </div><div class="line">    //如果mode或者block为空 直接返回</div><div class="line">    if (!mode || !block) &#123;</div><div class="line">	if (mode) CFRelease(mode);</div><div class="line">	if (block) Block_release(block);</div><div class="line">	return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //将block添加到列表中</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    struct _block_item *new_item = (struct _block_item *)malloc(sizeof(struct _block_item));</div><div class="line">    new_item-&gt;_next = NULL;</div><div class="line">    new_item-&gt;_mode = mode;</div><div class="line">    new_item-&gt;_block = block;</div><div class="line">    if (!rl-&gt;_blocks_tail) &#123;</div><div class="line">	rl-&gt;_blocks_head = new_item;</div><div class="line">    &#125; else &#123;</div><div class="line">	rl-&gt;_blocks_tail-&gt;_next = new_item;</div><div class="line">    &#125;</div><div class="line">    rl-&gt;_blocks_tail = new_item;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理block</div><div class="line"></div><div class="line">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</div><div class="line">    if (!rl-&gt;_blocks_head) return false;</div><div class="line">    if (!rlm || !rlm-&gt;_name) return false;</div><div class="line">    Boolean did = false;</div><div class="line">    struct _block_item *head = rl-&gt;_blocks_head;</div><div class="line">    struct _block_item *tail = rl-&gt;_blocks_tail;</div><div class="line">    rl-&gt;_blocks_head = NULL;</div><div class="line">    rl-&gt;_blocks_tail = NULL;</div><div class="line">    CFSetRef commonModes = rl-&gt;_commonModes;</div><div class="line">    CFStringRef curMode = rlm-&gt;_name;</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    struct _block_item *prev = NULL;</div><div class="line">    struct _block_item *item = head;</div><div class="line">    </div><div class="line">    //遍历block列表</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">	Boolean doit = false;</div><div class="line">	</div><div class="line">	//当前mode是block所属的mode一样 || 当前mode是common mode且commons中包含了当前mode</div><div class="line">	if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">	    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">        &#125; else &#123;</div><div class="line">	    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">	&#125;</div><div class="line">	if (!doit) prev = curr;</div><div class="line">	if (doit) &#123;</div><div class="line">	    if (prev) prev-&gt;_next = item;</div><div class="line">	    if (curr == head) head = item;</div><div class="line">	    if (curr == tail) tail = prev;</div><div class="line">	    void (^block)(void) = curr-&gt;_block;</div><div class="line">            CFRelease(curr-&gt;_mode);</div><div class="line">            free(curr);</div><div class="line">	    if (doit) &#123;</div><div class="line">	    </div><div class="line">		    //调用block</div><div class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line">	        did = true;</div><div class="line">	    &#125;</div><div class="line">            Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line">    if (head) &#123;</div><div class="line">	tail-&gt;_next = rl-&gt;_blocks_head;</div><div class="line">	rl-&gt;_blocks_head = head;</div><div class="line">        if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;</div><div class="line">    &#125;</div><div class="line">    return did;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="block总结"><a href="#block总结" class="headerlink" title="block总结"></a>block总结</h5><ul>
<li>可以直接给runloop添加block.添加成功后，block会在下一次runloop运行时被触发。</li>
<li>block不能唤醒runloop,只会被添加到链表中，等待下一次runloop被唤醒后才会被执行。</li>
</ul>
<h3 id="Runloop实践"><a href="#Runloop实践" class="headerlink" title="Runloop实践"></a>Runloop实践</h3><h4 id="查看Main-Runloop的结构"><a href="#查看Main-Runloop的结构" class="headerlink" title="查看Main Runloop的结构"></a>查看Main Runloop的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSRunLoop *runloop = [NSRunLoop mainRunLoop];</div><div class="line">NSLog(@&quot;runloop = %@&quot;,runloop);</div></pre></td></tr></table></figure>
<h5 id="具体结构如下："><a href="#具体结构如下：" class="headerlink" title="具体结构如下："></a>具体结构如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">&lt;CFRunLoop 0x60c0001e7800 [0x10805cc80]&gt;&#123;</div><div class="line"></div><div class="line">//唤醒端口 &amp;&amp; 当前状态 &amp;&amp; 是否忽略唤醒</div><div class="line">wakeup port = 0x1803, stopped = false, ignoreWakeUps = false, </div><div class="line"></div><div class="line">//current mode</div><div class="line">current mode = kCFRunLoopDefaultMode,</div><div class="line"></div><div class="line">//common mode 包含2个子mode</div><div class="line">common modes = &lt;CFBasicHash 0x60c00004db90 [0x10805cc80]&gt;&#123;type = mutable set, count = 2,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFString 0x1093cce88 [0x10805cc80]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</div><div class="line">	2 : &lt;CFString 0x108032818 [0x10805cc80]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line">//common mode 的items(包括 timer &amp;&amp; source &amp;&amp; observer)</div><div class="line">//observer activities (0x20 == kCFRunLoopBeforeWaiting)  (0x1 == kCFRunLoopEntry) (0xa0 ==  kCFRunLoopBeforeWaiting || kCFRunLoopExit)</div><div class="line"></div><div class="line">common mode items = &lt;CFBasicHash 0x60c00004df50 [0x10805cc80]&gt;&#123;type = mutable set, count = 13,</div><div class="line">entries =&gt;</div><div class="line"></div><div class="line"></div><div class="line">	//source0 系统事件</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line"></div><div class="line">	//处理手势的通知</div><div class="line">	1 : &lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;</div><div class="line"></div><div class="line">	//autoreleasepool相关通知</div><div class="line">	2 : &lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;0x7fa8a2802048&gt;</div><div class="line">)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;0x7fa8a2802048&gt;</div><div class="line">)&#125;&#125;</div><div class="line"></div><div class="line">	//mach port source</div><div class="line">	4 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line"></div><div class="line">	//处理事件队列的source</div><div class="line">	6 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line"></div><div class="line">	//处理动画事务的通知</div><div class="line">	16 : &lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;</div><div class="line"></div><div class="line">	//mach port source </div><div class="line">	17 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line"></div><div class="line">	//CA动画提交前的通知</div><div class="line">	18 : &lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;</div><div class="line"></div><div class="line">	//处理系统事件 source0</div><div class="line">	19 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">	</div><div class="line">	//处理系统事件 source1</div><div class="line">	20 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line"></div><div class="line">	//CA动画提交后的通知</div><div class="line">	21 : &lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;</div><div class="line"></div><div class="line">	//Front Board Services(前台服务)</div><div class="line">	22 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line"></div><div class="line">modes = &lt;CFBasicHash 0x60c00004dbc0 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line"></div><div class="line"></div><div class="line">	//UITrackingRunLoopMode 的 items</div><div class="line"></div><div class="line">	2 : &lt;CFRunLoopMode 0x60c0001869a0 [0x10805cc80]&gt;&#123;name = UITrackingRunLoopMode, port set = 0x1c03, queue = 0x60c000141e40, source = 0x60c000186a70 (not fired), timer port = 0x5403, </div><div class="line"></div><div class="line">	//source0</div><div class="line"></div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004dfb0 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line">	4 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">	5 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line">	//source1</div><div class="line"></div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004dfe0 [0x10805cc80]&gt;&#123;type = mutable set, count = 3,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line">	1 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	//observer</div><div class="line"></div><div class="line">	observers = (</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;</div><div class="line">),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290423333420) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//GSEventReceiveRunLoopMode 接受系统事件的内部 Mode</div><div class="line">	3 : &lt;CFRunLoopMode 0x60c000186b40 [0x10805cc80]&gt;&#123;name = GSEventReceiveRunLoopMode, port set = 0x5203, queue = 0x60c000141ef0, source = 0x60c000186c10 (not fired), timer port = 0x5103, </div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004e070 [0x10805cc80]&gt;&#123;type = mutable set, count = 1,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004e0a0 [0x10805cc80]&gt;&#123;type = mutable set, count = 1,</div><div class="line">entries =&gt;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167bc0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	observers = (null),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290424620943) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//kCFRunLoopDefaultMode</div><div class="line"></div><div class="line">	4 : &lt;CFRunLoopMode 0x60c000186660 [0x10805cc80]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x2503, queue = 0x60c000141ce0, source = 0x60c000186730 (not fired), timer port = 0x2303, </div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004e010 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line">	4 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">	5 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004e040 [0x10805cc80]&gt;&#123;type = mutable set, count = 3,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line">	1 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	observers = (</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;</div><div class="line">),</div><div class="line">	timers = &lt;CFArray 0x6080000aa5c0 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;CFRunLoopTimer 0x600000168ac0 [0x10805cc80]&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 558352446 (1.35804296 @ 30291784384812), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x106e7e849 / 0x1086fb31b) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/UIKit.framework/UIKit), context = &lt;CFRunLoopTimer context 0x600000076700&gt;&#125;</div><div class="line">)&#125;,</div><div class="line">	currently 558352445 (30290424667708) / soft deadline in: 1.35971708 sec (@ 30291784384812) / hard deadline in: 1.35971705 sec (@ 30291784384812)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//kCFRunLoopCommonModes</div><div class="line">	5 : &lt;CFRunLoopMode 0x60c000186e80 [0x10805cc80]&gt;&#123;name = kCFRunLoopCommonModes, port set = 0x420b, queue = 0x60c000142520, source = 0x60c000186db0 (not fired), timer port = 0x350b, </div><div class="line">	sources0 = (null),</div><div class="line">	sources1 = (null),</div><div class="line">	observers = (null),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290426387800) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer"><a href="#给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer" class="headerlink" title="给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)"></a>给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)</h4><p>为了方便观察添加是否成功，我们不在主线程的runloop中添加，自定义一个新的线程。</p>
<h5 id="添加Custom-Input-Source注意事项"><a href="#添加Custom-Input-Source注意事项" class="headerlink" title="添加Custom Input Source注意事项"></a>添加Custom Input Source注意事项</h5><ul>
<li>custom input source 默认状态为不处理，需要手动唤醒，手动唤醒需要先标记为待处理状态，每次runloop处理完后状态会被置回不处理。</li>
<li>在子线程添加source需要在runloop run的代码之前添加，因为run后该线程会马上休眠（当前runloop中没有能唤醒自己的source）,不再这行run后面的代码。</li>
</ul>
<h5 id="添加Mach-Port-Input-Source注意事项"><a href="#添加Mach-Port-Input-Source注意事项" class="headerlink" title="添加Mach Port Input Source注意事项"></a>添加Mach Port Input Source注意事项</h5><ul>
<li>需要同时记录主线程端口和子线程端口号，需要唤醒对应线程时直接使用该端口发送消息即可，不需要像Custom Input Source那样做标记。</li>
</ul>
<h4 id="给runloop添加自定义mode和items"><a href="#给runloop添加自定义mode和items" class="headerlink" title="给runloop添加自定义mode和items"></a>给runloop添加自定义mode和items</h4><ul>
<li>需要注意的是不能直接调用run这个方法，因为这个方法是运行在DefaultMode下的，不会触发自定义mode中的source,需要调用runMode:beforeDate方法开启runloop.</li>
</ul>
<p><a href="https://github.com/lilingyu0620/LLYRunloopDemo.git" target="_blank" rel="noopener">这里是demo</a></p>
<h4 id="Runloop在iOS中的应用"><a href="#Runloop在iOS中的应用" class="headerlink" title="Runloop在iOS中的应用"></a>Runloop在iOS中的应用</h4><p>这块直接看YY博客吧，已经没法再补充更多了。。。</p>
<p>博客链接<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></p>
<h4 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h4><p>Runloop是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。</p>
<p>Runloop使用Mach内核实现线程的睡眠，通过Source和Timer来唤醒线程，Source和Timer最终都是通过Mach Port来唤醒的线程。</p>
<p>Source有CustomSource和Mach Port Source2种，CustomSource唤醒线程前需要先被标注为待处理，MachPortSource则直接使用端口号发送唤醒消息。</p>
<p>Timer有两种实现方式分别是MK_Timer和GCD Timer,在runloop中Timer被转为了一个存了触发时间的列表，这个触发时间是一个绝对时间，会按时间大小升序排序，在最小的时间被触发后，Runloop会更新列表保证时间始终是升序排列。如果Runloop在某次运行中阻塞了很长时间，Timer的触发会受到影响。过期的时间点会被移除而不会去触发。</p>
<p>Runloop的状态都可以通过添加Observer来得到。Observer在Runloop中是按order优先级升序排序的，排在前面的通知会先被触发（order越小优先级反而越高）。</p>
<p>Mode表示当前Runloop运行在哪个模式上，Runloop必须运行在一种Mode上，Runloop在创建时会有一个DefaultMode,可以通过runmode：beforeDate 切换Runloop当前运行的Mode。</p>
<p>Mode中包含了上面的Source,Timer和Observer三种Items。Runloop运行的时候其实就是在处理这些Items中的内容，如果这三种Items都没有要处理的内容，Runloop就要开始睡了,而当Mode的items为空时，当前Runloop会退出。</p>
<p>CommonMode不是一种真正的Mode,它是一个所有Mode的集合，如果把上面三种Items添加到CommonMode,那这些Items会被添加到集合中所有的Mode中。所以添加到CommonMode中Items,不管当前Runloop运行在哪种Mode上，Items中需要处理的事件都会被触发。（前提是这个Mode已经被添加到了CommonMode集合中）。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/22/h-256与h-264的对比/" rel="next" title="h.256与h.264的对比">
                <i class="fa fa-chevron-left"></i> h.256与h.264的对比
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/08/iOS性能优化的一些套路/" rel="prev" title="iOS性能优化的一些套路">
                iOS性能优化的一些套路 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/09/10/Runloop源码解析和实践/"
           data-title="Runloop源码解析和实践" data-url="http://yoursite.com/2018/09/10/Runloop源码解析和实践/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">54</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop是干啥的"><span class="nav-number">1.</span> <span class="nav-text">RunLoop是干啥的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#疑问？？？"><span class="nav-number">2.</span> <span class="nav-text">疑问？？？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#庖丁解🐂"><span class="nav-number"></span> <span class="nav-text">庖丁解🐂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Modes"><span class="nav-number">1.</span> <span class="nav-text">Modes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input-Sources"><span class="nav-number">2.</span> <span class="nav-text">Input Sources</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Port-Based-Sources"><span class="nav-number">2.1.</span> <span class="nav-text">Port-Based Sources</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Custom-Input-Sources"><span class="nav-number">2.2.</span> <span class="nav-text">Custom Input Sources</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cocoa-Perform-Selector-Sources"><span class="nav-number">2.3.</span> <span class="nav-text">Cocoa Perform Selector Sources</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timer-Sources"><span class="nav-number">3.</span> <span class="nav-text">Timer Sources</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Run-Loop-Observers"><span class="nav-number">4.</span> <span class="nav-text">Run Loop Observers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop使用场景"><span class="nav-number">5.</span> <span class="nav-text">Runloop使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码解析"><span class="nav-number">6.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-Source-amp-amp-CFRunLoopSource-的结构"><span class="nav-number">6.1.</span> <span class="nav-text">Input Source &amp;&amp; CFRunLoopSource 的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#observer-amp-amp-CFRunLoopObserver-的结构"><span class="nav-number">6.2.</span> <span class="nav-text">observer &amp;&amp; CFRunLoopObserver 的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NSTimer-amp-amp-CFRunloopTimer-的结构"><span class="nav-number">6.3.</span> <span class="nav-text">NSTimer &amp;&amp; CFRunloopTimer 的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mode-的结构"><span class="nav-number">6.4.</span> <span class="nav-text">Mode 的结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runloop-的结构"><span class="nav-number">7.</span> <span class="nav-text">runloop 的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop"><span class="nav-number">8.</span> <span class="nav-text">Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">8.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun"><span class="nav-number">9.</span> <span class="nav-text">Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#runloop运行流程总结入下图"><span class="nav-number">9.1.</span> <span class="nav-text">runloop运行流程总结入下图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#runloop唤醒事件总结"><span class="nav-number">9.2.</span> <span class="nav-text">runloop唤醒事件总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mode和它的四大大王-Source-Timer-Observer-Block"><span class="nav-number">10.</span> <span class="nav-text">Mode和它的四大大王(Source,Timer,Observer,Block)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Mode"><span class="nav-number">10.1.</span> <span class="nav-text">Mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Source"><span class="nav-number">10.2.</span> <span class="nav-text">Source</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#source总结"><span class="nav-number">10.3.</span> <span class="nav-text">source总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timer"><span class="nav-number">10.4.</span> <span class="nav-text">Timer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#timer总结"><span class="nav-number">10.5.</span> <span class="nav-text">timer总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Observer"><span class="nav-number">10.6.</span> <span class="nav-text">Observer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Block"><span class="nav-number">10.7.</span> <span class="nav-text">Block</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#block总结"><span class="nav-number">10.8.</span> <span class="nav-text">block总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runloop实践"><span class="nav-number"></span> <span class="nav-text">Runloop实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看Main-Runloop的结构"><span class="nav-number">1.</span> <span class="nav-text">查看Main Runloop的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#具体结构如下："><span class="nav-number">1.1.</span> <span class="nav-text">具体结构如下：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer"><span class="nav-number">2.</span> <span class="nav-text">给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#添加Custom-Input-Source注意事项"><span class="nav-number">2.1.</span> <span class="nav-text">添加Custom Input Source注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#添加Mach-Port-Input-Source注意事项"><span class="nav-number">2.2.</span> <span class="nav-text">添加Mach Port Input Source注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给runloop添加自定义mode和items"><span class="nav-number">3.</span> <span class="nav-text">给runloop添加自定义mode和items</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop在iOS中的应用"><span class="nav-number">4.</span> <span class="nav-text">Runloop在iOS中的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最后的总结"><span class="nav-number">5.</span> <span class="nav-text">最后的总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
