<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="概述iOS8之后 系统提供了VideoToolBox用来处理音频和视频的编解码（硬解使用GPU），在iOS8之前，普遍使用的是ffmpeg（软解使用CPU）。 处理流程1.采集使用AVFoundation提供的AVCapture系列类自定义一个视频流采集的相机，在采集到数据的回调内处理视频编码。 相机自定义: 12345678910111213141516171819202122232425262">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS视频硬编码">
<meta property="og:url" content="http://yoursite.com/2017/03/14/iOS视频硬编码/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="概述iOS8之后 系统提供了VideoToolBox用来处理音频和视频的编解码（硬解使用GPU），在iOS8之前，普遍使用的是ffmpeg（软解使用CPU）。 处理流程1.采集使用AVFoundation提供的AVCapture系列类自定义一个视频流采集的相机，在采集到数据的回调内处理视频编码。 相机自定义: 12345678910111213141516171819202122232425262">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-03-14T03:25:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS视频硬编码">
<meta name="twitter:description" content="概述iOS8之后 系统提供了VideoToolBox用来处理音频和视频的编解码（硬解使用GPU），在iOS8之前，普遍使用的是ffmpeg（软解使用CPU）。 处理流程1.采集使用AVFoundation提供的AVCapture系列类自定义一个视频流采集的相机，在采集到数据的回调内处理视频编码。 相机自定义: 12345678910111213141516171819202122232425262">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2017/03/14/iOS视频硬编码/"/>

  <title> iOS视频硬编码 | lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                iOS视频硬编码
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-14T10:16:51+08:00" content="2017-03-14">
              2017-03-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/14/iOS视频硬编码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/iOS视频硬编码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>iOS8之后 系统提供了VideoToolBox用来处理音频和视频的编解码（硬解使用GPU），在iOS8之前，普遍使用的是ffmpeg（软解使用CPU）。</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="1-采集"><a href="#1-采集" class="headerlink" title="1.采集"></a>1.采集</h3><p>使用AVFoundation提供的AVCapture系列类自定义一个视频流采集的相机，在采集到数据的回调内处理视频编码。</p>
<p>相机自定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">self.session = [[AVCaptureSession alloc]init];</div><div class="line">    </div><div class="line">    if ([self.session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;</div><div class="line">        self.session.sessionPreset = AVCaptureSessionPreset640x480;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">    </div><div class="line">    </div><div class="line">    if ([self.videoDevice isFocusModeSupported:AVCaptureFocusModeAutoFocus]) &#123;</div><div class="line">        if ([self.videoDevice lockForConfiguration:nil]) &#123;</div><div class="line">            self.videoDevice.focusMode = AVCaptureFocusModeContinuousAutoFocus;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoInput = [[AVCaptureDeviceInput alloc]initWithDevice:self.videoDevice error:nil];</div><div class="line">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">        [self.session addInput:self.videoInput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoDataOutput = [[AVCaptureVideoDataOutput alloc]init];</div><div class="line">    </div><div class="line">    //kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange 表示原始数据的格式为YUV420</div><div class="line">//    YUV 4:4:4采样，每一个Y对应一组UV分量。</div><div class="line">//    YUV 4:2:2采样，每两个Y共用一组UV分量。</div><div class="line">//    YUV 4:2:0采样，每四个Y共用一组UV分量。</div><div class="line">    NSDictionary *settings = [[NSDictionary alloc]initWithObjectsAndKeys:[NSNumber numberWithUnsignedInteger:kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange],kCVPixelBufferPixelFormatTypeKey,nil];</div><div class="line">    self.videoDataOutput.videoSettings = settings;</div><div class="line">    self.videoDataOutput.alwaysDiscardsLateVideoFrames = YES;</div><div class="line">    </div><div class="line">    _videoOutputQueue = dispatch_queue_create(&quot;videoOutputQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    [self.videoDataOutput setSampleBufferDelegate:self queue:_videoOutputQueue];</div><div class="line">    </div><div class="line">    if ([self.session canAddOutput:self.videoDataOutput]) &#123;</div><div class="line">        [self.session addOutput:self.videoDataOutput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoConnection = [self.videoDataOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class="line">    [self.videoConnection setVideoScaleAndCropFactor:1];</div><div class="line"></div><div class="line">    self.videoConnection.videoOrientation = AVCaptureVideoOrientationPortrait;</div></pre></td></tr></table></figure>
<p>回调处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection&#123;</div><div class="line"></div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">//    CVPixelBufferRef pixelBufferRef = CMSampleBufferGetImageBuffer(sampleBuffer);</div><div class="line">    if ([self.delegate respondsToSelector:@selector(videOutputHandler:didOutputSampleBuffer:)]) &#123;</div><div class="line">        [self.delegate videOutputHandler:weakSelf didOutputSampleBuffer:sampleBuffer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sampleBuffer 这个就是视频流的原始数据。</p>
<h3 id="2-开始编码"><a href="#2-开始编码" class="headerlink" title="2.开始编码"></a>2.开始编码</h3><p>使用VideoToolBox库的相关API可能很方便的编码上面的sampleBuffer数据.</p>
<p>首先要初始化一个VTCompressionSessionRef对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> OSStatus status = VTCompressionSessionCreate(NULL, _videoConfig.videoSize.width, _videoConfig.videoSize.height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressBuffer, (__bridge void *)self, &amp;_compressionSession);</div><div class="line">    if(status != noErr)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //关键帧间隔 一般为帧率的2倍 间隔越大 压缩比越高</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_MaxKeyFrameInterval,(__bridge CFTypeRef)@(_videoConfig.keyframeInterval));</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration,(__bridge CFTypeRef)@(_videoConfig.keyframeInterval));</div><div class="line">    </div><div class="line">    </div><div class="line">    //Just remember that kVTCompressionPropertyKey_AverageBitRate takes bits and kVTCompressionPropertyKey_DataRateLimits takes bytes and seconds.</div><div class="line">//    status = VTSessionSetProperty(session, kVTCompressionPropertyKey_AverageBitRate, (__bridge CFTypeRef)@(600 * 1024));</div><div class="line">//    status = VTSessionSetProperty(session, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)@[800 * 1024 / 8, 1]);</div><div class="line">    //码率 单位是bit</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_AverageBitRate, (__bridge CFTypeRef)@(_videoConfig.bitrate * 8));</div><div class="line">    </div><div class="line">    //码率上限 单位为 byte/s</div><div class="line">    NSArray *limit = @[@(_videoConfig.bitrate),@(1)];</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)limit);</div><div class="line">    </div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_ExpectedFrameRate, (__bridge CFTypeRef)@(_videoConfig.fps));</div><div class="line"></div><div class="line">    // 设置实时编码输出（避免延迟）</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_RealTime, kCFBooleanFalse);</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_ProfileLevel,  kVTProfileLevel_H264_Baseline_AutoLevel);</div><div class="line">    </div><div class="line">    //控制是否产生B帧</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanFalse);</div><div class="line">    //16:9</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_AspectRatio16x9, kCFBooleanTrue);</div><div class="line">    </div><div class="line">    VTCompressionSessionPrepareToEncodeFrames(_compressionSession);</div></pre></td></tr></table></figure>
<p>开始编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//开始编码</div><div class="line">- (void)videoEncodeData:(CVPixelBufferRef)pixelBuffer time:(uint64_t)time&#123;</div><div class="line"></div><div class="line">    frameCount++;</div><div class="line">    </div><div class="line">    //CMTimeMake(a,b) a当前第几帧，b每秒钟多少帧。当前播放时间a/b</div><div class="line">    CMTime presentationTimeStamp = CMTimeMake(frameCount, 1000);</div><div class="line">    </div><div class="line">    //每一帧需要播放的时间</div><div class="line">    VTEncodeInfoFlags flags;</div><div class="line">    CMTime duration = CMTimeMake(1, _videoConfig.fps);</div><div class="line">    </div><div class="line">    NSDictionary *properties = nil;</div><div class="line">    if(frameCount % (int32_t)(self.videoConfig.keyframeInterval) == 0)&#123;//强制关键帧</div><div class="line">        properties = @&#123;(__bridge NSString *)kVTEncodeFrameOptionKey_ForceKeyFrame: @YES&#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSNumber *timeNumber = @(time);</div><div class="line">     OSStatus statusCode = VTCompressionSessionEncodeFrame(_compressionSession, pixelBuffer, presentationTimeStamp, duration, (__bridge CFDictionaryRef)properties, (__bridge void *)timeNumber, &amp;flags);</div><div class="line">    </div><div class="line">    if (statusCode != noErr) &#123;</div><div class="line">        NSLog(@&quot;H264: VTCompressionSessionEncodeFrame failed with %d&quot;, (int)statusCode);</div><div class="line">        </div><div class="line">        VTCompressionSessionInvalidate(_compressionSession);</div><div class="line">        CFRelease(_compressionSession);</div><div class="line">        _compressionSession = NULL;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;H264: VTCompressionSessionEncodeFrame Success&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码成功回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//编码完成的回调</div><div class="line">static void didCompressBuffer(void *VTref, void *VTFrameRef, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer)&#123;</div><div class="line"></div><div class="line">    LLYVideoEncode *videoEncode = (__bridge LLYVideoEncode *)VTref;</div><div class="line">    uint64_t timeStamp = [((__bridge_transfer NSNumber*)VTFrameRef) longLongValue];</div><div class="line">    </div><div class="line">    //编码后的原始数据</div><div class="line">    CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class="line">    CFArrayRef attachments = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, false);</div><div class="line">    </div><div class="line">    //判断关键帧</div><div class="line">    BOOL isKeyFrame = NO;</div><div class="line">    if (attachments != NULL) &#123;</div><div class="line">        CFDictionaryRef attachment;</div><div class="line">        CFBooleanRef dependsOnOthers;</div><div class="line">        attachment = (CFDictionaryRef)CFArrayGetValueAtIndex(attachments, 0);</div><div class="line">        dependsOnOthers = (CFBooleanRef)CFDictionaryGetValue(attachment, kCMSampleAttachmentKey_DependsOnOthers);</div><div class="line">        isKeyFrame = (dependsOnOthers == kCFBooleanFalse);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //关键帧需要把sps pps信息取出</div><div class="line">    if (isKeyFrame) &#123;</div><div class="line">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">        </div><div class="line">        size_t sparameterSetSize, sparameterSetCount;</div><div class="line">        const uint8_t *sparameterSet;</div><div class="line">        </div><div class="line">        //sps</div><div class="line">        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, NULL );</div><div class="line">        if (statusCode == noErr) &#123;</div><div class="line">            </div><div class="line">            //pps</div><div class="line">            size_t pparameterSetSize, pparameterSetCount;</div><div class="line">            const uint8_t *pparameterSet;</div><div class="line">            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, NULL );</div><div class="line">            if (statusCode == noErr) &#123;</div><div class="line">                </div><div class="line">                NSData *sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];</div><div class="line">                NSData *pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];</div><div class="line">                </div><div class="line">                if ([videoEncode.delegate respondsToSelector:@selector(videoEncode:sps:pps:time:)]  ) &#123;</div><div class="line">                    [videoEncode.delegate videoEncode:videoEncode sps:sps pps:pps time:timeStamp];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //视频数据 不管是不是关键帧都需要取出</div><div class="line">    //前4个字节表示长度后面的数据的长度</div><div class="line">    //除了关键帧,其它帧只有一个数据</div><div class="line">    </div><div class="line">    size_t length, totalLength;</div><div class="line">    char *dataPointer;</div><div class="line">    size_t offset = 0;</div><div class="line">    int const headLen = 4;// 返回的nalu数据前四个字节不是0001的startcode，而是大端模式的帧长度length</div><div class="line"></div><div class="line">    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(blockBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer);</div><div class="line">    if (statusCodeRet == noErr) &#123;</div><div class="line">        </div><div class="line">        // 循环获取nalu数据</div><div class="line">        while (offset &lt; totalLength - headLen) &#123;</div><div class="line">            </div><div class="line">            int NALUnitLength = 0;</div><div class="line">            memcpy(&amp;NALUnitLength, dataPointer + offset, headLen);</div><div class="line">            </div><div class="line">            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class="line">            NSData *naluData = [NSData dataWithBytes:dataPointer + headLen + offset length:NALUnitLength];</div><div class="line">            offset += headLen + NALUnitLength;</div><div class="line">            </div><div class="line">            if ([videoEncode.delegate respondsToSelector:@selector(videoEncode:frame:time:isKeyFrame:)]) &#123;</div><div class="line">                [videoEncode.delegate videoEncode:videoEncode frame:naluData time:timeStamp isKeyFrame:isKeyFrame];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是编码流程中比较关键的一环，需要将编码后的数据（H264数据）根据相应的数据格式取出来，用来做进行二次封装（封装为rtmp协议对应格式的数据）进行rtmp传输。不过这几种数据都是固定格式的，所以只要清楚相应的格式后，拆分了封装应该都是能解决的。</p>
<h3 id="3-拆分后的视频数据二次封装为rtmp格式包"><a href="#3-拆分后的视频数据二次封装为rtmp格式包" class="headerlink" title="3.拆分后的视频数据二次封装为rtmp格式包"></a>3.拆分后的视频数据二次封装为rtmp格式包</h3><p>sps和pps数据的封装(关键帧数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)packageKeyFrameSps:(NSData *)spsData pps:(NSData *)ppsData timestamp:(uint64_t)timestamp&#123;</div><div class="line">    </div><div class="line">    if (spsData.length &lt;= 0 || ppsData &lt;= 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_hasSendKeyFrame) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _hasSendKeyFrame = YES;</div><div class="line">    </div><div class="line">    const char *sps = spsData.bytes;</div><div class="line">    const char *pps = ppsData.bytes;</div><div class="line">    NSInteger sps_len = spsData.length;</div><div class="line">    NSInteger pps_len = ppsData.length;</div><div class="line">    </div><div class="line">    NSInteger total = sps_len + pps_len + 16;</div><div class="line">    uint8_t *body = (uint8_t *)malloc(total);</div><div class="line">    int index = 0;</div><div class="line">    </div><div class="line">    memset(body,0,total);</div><div class="line">    </div><div class="line">    body[index++] = 0x17;</div><div class="line">    body[index++] = 0x00;//sps_pps</div><div class="line">    </div><div class="line">    body[index++] = 0x00;</div><div class="line">    body[index++] = 0x00;</div><div class="line">    body[index++] = 0x00;</div><div class="line">    </div><div class="line">    body[index++] = 0x01;</div><div class="line">    body[index++] = sps[1];</div><div class="line">    body[index++] = sps[2];</div><div class="line">    body[index++] = sps[3];</div><div class="line">    body[index++] = 0xff;</div><div class="line">    </div><div class="line">    /*sps*/</div><div class="line">    body[index++]   = 0xe1;</div><div class="line">    body[index++] = (sps_len &gt;&gt; 8) &amp; 0xff;</div><div class="line">    body[index++] = sps_len &amp; 0xff;</div><div class="line">    memcpy(&amp;body[index],sps,sps_len);</div><div class="line">    index +=  sps_len;</div><div class="line">    </div><div class="line">    /*pps*/</div><div class="line">    body[index++]   = 0x01;</div><div class="line">    body[index++] = (pps_len &gt;&gt; 8) &amp; 0xff;</div><div class="line">    body[index++] = (pps_len) &amp; 0xff;</div><div class="line">    memcpy(&amp;body[index], pps, pps_len);</div><div class="line">    index +=  pps_len;</div><div class="line">    </div><div class="line">    if ([self.delegate respondsToSelector:@selector(videoPackage:didPacketFrame:)]) &#123;</div><div class="line">        NSData *data = [NSData dataWithBytes:body length:index];</div><div class="line">        </div><div class="line">        LLYFrame *frame = [[LLYFrame alloc] init];</div><div class="line">        frame.data = data;</div><div class="line">        frame.timestamp = 0;//一定是0</div><div class="line">        frame.msgLength = (int)data.length;</div><div class="line">        frame.msgTypeId = LLYMSGTypeID_VIDEO;</div><div class="line">        frame.msgStreamId = LLYStreamIDVideo;//video</div><div class="line">        frame.isKeyframe = YES;</div><div class="line">        [self.delegate videoPackage:self didPacketFrame:frame];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非关键帧数据的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (void)packageFrame:(NSData *)data timestamp:(uint64_t)timestamp isKeyFrame:(BOOL)isKeyFrame&#123;</div><div class="line"></div><div class="line">    if (!_hasSendKeyFrame) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSInteger i = 0;</div><div class="line">    NSInteger total = data.length + 9;</div><div class="line">    unsigned char *body = (unsigned char *)malloc(total);</div><div class="line">    </div><div class="line">    memset(body, 0, total);</div><div class="line">    </div><div class="line">    if (isKeyFrame) &#123;</div><div class="line">        body[i++] = 0x17;//1:I Frame 7:AVC</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        body[i++] = 0x27;//2:P Frame 7:AVC</div><div class="line">    &#125;</div><div class="line">    body[i++] = 0x01;//AVC NALU 不是psp_pps</div><div class="line">    </div><div class="line">    body[i++] = 0x00;</div><div class="line">    body[i++] = 0x00;</div><div class="line">    body[i++] = 0x00;//pts - dts</div><div class="line"></div><div class="line">    //长度数据</div><div class="line">    body[i++] = (data.length &gt;&gt; 24) &amp; 0xff;</div><div class="line">    body[i++] = (data.length &gt;&gt; 16) &amp; 0xff;</div><div class="line">    body[i++] = (data.length &gt;&gt;  8) &amp; 0xff;</div><div class="line">    body[i++] = (data.length ) &amp; 0xff;</div><div class="line"></div><div class="line">    memcpy(&amp;body[i], data.bytes, data.length);</div><div class="line">    </div><div class="line">    if ([self.delegate respondsToSelector:@selector(videoPackage:didPacketFrame:)]) &#123;</div><div class="line">        NSData *data = [NSData dataWithBytes:body length:total];</div><div class="line">        LLYFrame *frame = [[LLYFrame alloc]init];</div><div class="line">        frame.data = data;</div><div class="line">        frame.timestamp = (int)timestamp;</div><div class="line">        frame.msgLength = (int)data.length;</div><div class="line">        frame.msgTypeId = LLYMSGTypeID_VIDEO;</div><div class="line">        frame.msgStreamId = LLYStreamIDVideo;</div><div class="line">        frame.isKeyframe = isKeyFrame;</div><div class="line"></div><div class="line">        [self.delegate videoPackage:self didPacketFrame:frame];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-建立rtmp通道"><a href="#4-建立rtmp通道" class="headerlink" title="4.建立rtmp通道"></a>4.建立rtmp通道</h3><p>先要开始一个socket的通道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)connectToServer:(NSString *)host port:(UInt32)port&#123;</div><div class="line"></div><div class="line">    if (self.streamStatus &gt; 0) &#123;</div><div class="line">        [self close];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //输入流 用来读取数据</div><div class="line">    CFReadStreamRef readStream;</div><div class="line">    //输出流，用来发送数据</div><div class="line">    CFWriteStreamRef writeStream;</div><div class="line">    </div><div class="line">    if (port &lt;= 0) &#123;</div><div class="line">        //RTMP默认端口1935</div><div class="line">        port = 1935;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //建立socket链接</div><div class="line">    CFStreamCreatePairWithSocketToHost(NULL,(__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);</div><div class="line">    </div><div class="line">    //注意__bridge_transfer,转移对象的内存管理权</div><div class="line">    _inputStream           = (__bridge_transfer  NSInputStream  *)readStream;</div><div class="line">    _outputStream          = (__bridge_transfer  NSOutputStream *)writeStream;</div><div class="line"></div><div class="line">    _inputStream.delegate = self;</div><div class="line">    _outputStream.delegate = self;</div><div class="line">    </div><div class="line">    [_outputStream scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line">    [_inputStream  scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">    </div><div class="line">    [_inputStream open];</div><div class="line">    [_outputStream open];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和服务器建立一个rtmp通信，通过服务器返回的状态码发送相应的握手请求，在3次握手成功后，rtmp通道建立完成，就可以发送封二次封装好的数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)streamSession:(LLYStreamSession *)session didChangeStatus:(LLYStreamStatus)streamStatus&#123;</div><div class="line"></div><div class="line">    if (streamStatus &amp; NSStreamEventHasBytesAvailable) &#123;//收到数据</div><div class="line">        [self didReceivedata];</div><div class="line">        return;//return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (streamStatus &amp; NSStreamEventHasSpaceAvailable)&#123; //可以写数据</div><div class="line">        </div><div class="line">        if (_rtmpStatus == LLYRtmpSessionStatusConnected) &#123;</div><div class="line">            [self handshake0];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return;//return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if ((streamStatus &amp; NSStreamEventOpenCompleted) &amp;&amp;</div><div class="line">        _rtmpStatus &lt; LLYRtmpSessionStatusConnected) &#123;</div><div class="line">        self.rtmpStatus = LLYRtmpSessionStatusConnected;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (streamStatus &amp; NSStreamEventErrorOccurred) &#123;</div><div class="line">        self.rtmpStatus = LLYRtmpSessionStatusError;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (streamStatus &amp; NSStreamEventEndEncountered) &#123;</div><div class="line">        self.rtmpStatus = LLYRtmpSessionStatusNotConnected;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-rtmp推流"><a href="#5-rtmp推流" class="headerlink" title="5.rtmp推流"></a>5.rtmp推流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  Chunk Basic Header: HeaderType+ChannelID组成  1个字节</div><div class="line"> *     &gt;HeaderType(前两bit): 00-&gt;12字节  01-&gt;8字节</div><div class="line"> *     &gt;ChannelID(后6个bit): 02-&gt;Ping和ByteRead通道 03-&gt;Invoke通道 connect() publish()和自己写的NetConnection.Call() 04-&gt;Audio和Vidio通道</div><div class="line"> *</div><div class="line"> *  12字节举例</div><div class="line"> *  Chunk Message Header:timestamp + message_length+message_typ + msg_stream_id</div><div class="line"> *  message_typ :type为1,2,3,5,6的时候是协议控制消息</div><div class="line"> *</div><div class="line"> *               type为4的时候表示 User Control Messages [Event_type + Event_Data] Event_type有Stream Begin，Stream End...</div><div class="line"> *</div><div class="line"> *               type为8，音频数据</div><div class="line"> *</div><div class="line"> *               type为9，视频数据</div><div class="line"> *</div><div class="line"> *               type为18 元数据消息[AMF0]</div><div class="line"> *</div><div class="line"> *               type为20 命令消息 Command Message(RPC Message)</div><div class="line"> *               例如connect, createStream, publish, play, pause on the peer</div><div class="line"> *</div><div class="line"> *</div><div class="line"> *</div><div class="line"> */</div><div class="line">- (void)sendBuffer:(LLYFrame *)frame&#123;</div><div class="line">    dispatch_sync(_packageQueue, ^&#123;</div><div class="line">        </div><div class="line">        uint64_t ts = frame.timestamp;</div><div class="line">        </div><div class="line">        int streamId = frame.msgStreamId;</div><div class="line">        NSLog(@&quot;streamId------%d&quot;,streamId);</div><div class="line">        NSNumber *preTimestamp = self.preChunk[@(streamId)];</div><div class="line">        </div><div class="line">        uint8_t *chunk;</div><div class="line">        int offset = 0;</div><div class="line">        </div><div class="line">        if (preTimestamp == nil) &#123;//第一帧,音频或者视频</div><div class="line">            chunk = malloc(12);</div><div class="line">            chunk[0] = RTMP_CHUNK_TYPE_0/*0x00*/ | (streamId &amp; 0x1F); //前两个字节 00 表示12字节</div><div class="line">            offset += 1;</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, [NSMutableData be24:(uint32_t)ts], 3);</div><div class="line">            offset += 3;//时间戳3个字节</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, [NSMutableData be24:frame.msgLength], 3);</div><div class="line">            offset += 3;//消息长度3个字节</div><div class="line">            </div><div class="line">            int msgTypeId = frame.msgTypeId;//一个字节的消息类型</div><div class="line">            memcpy(chunk+offset, &amp;msgTypeId, 1);</div><div class="line">            offset += 1;</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, (uint8_t *)&amp;(_streamID), sizeof(_streamID));</div><div class="line">            offset += sizeof(_streamID);</div><div class="line">            </div><div class="line">        &#125;else&#123;//不是第一帧</div><div class="line">            chunk = malloc(8);</div><div class="line">            chunk[0] = RTMP_CHUNK_TYPE_1/*0x40*/ | (streamId &amp; 0x1F);//前两个字节01表示8字节</div><div class="line">            offset += 1;</div><div class="line">            </div><div class="line">            char *temp = [NSMutableData be24:(uint32_t)(ts - preTimestamp.integerValue)];</div><div class="line">            memcpy(chunk+offset, temp, 3);</div><div class="line">            offset += 3;</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, [NSMutableData be24:frame.msgLength], 3);</div><div class="line">            offset += 3;</div><div class="line">            </div><div class="line">            int msgTypeId = frame.msgTypeId;</div><div class="line">            memcpy(chunk+offset, &amp;msgTypeId, 1);</div><div class="line">            offset += 1;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        self.preChunk[@(streamId)] = @(ts);</div><div class="line">        </div><div class="line">        uint8_t *bufferData = (uint8_t *)frame.data.bytes;</div><div class="line">        uint8_t *outp = (uint8_t *)malloc(frame.data.length + 64);</div><div class="line">        memcpy(outp, chunk, offset);</div><div class="line">        free(chunk);</div><div class="line">        </div><div class="line">        NSUInteger total = frame.data.length;</div><div class="line">        NSInteger step = MIN(total, _outChunkSize);</div><div class="line">        </div><div class="line">        memcpy(outp+offset, bufferData, step);</div><div class="line">        offset += step;</div><div class="line">        total  -= step;</div><div class="line">        bufferData += step;</div><div class="line">        </div><div class="line">        while (total &gt; 0) &#123;</div><div class="line">            step = MIN(total, _outChunkSize);</div><div class="line">            bufferData[-1] = RTMP_CHUNK_TYPE_3/*0xC0*/ | (streamId &amp; 0x1F);//11表示一个字节,直接跳过这个字节;</div><div class="line">            memcpy(outp+offset, bufferData - 1, step + 1);</div><div class="line">            </div><div class="line">            offset += step + 1;</div><div class="line">            total  -= step;</div><div class="line">            bufferData += step;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSData *tosend = [NSData dataWithBytes:outp length:offset];</div><div class="line">        free(outp);</div><div class="line">        [self writeData:tosend];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一切OK 推流地址应该就可以用VLC播放了。</p>
<p>具体代码参考我的 <a href="https://github.com/lilingyu0620/LLYRtmpDemo.git" target="_blank" rel="noopener">demo</a>.</p>
<p><a href="http://www.jianshu.com/p/37784e363b8a" target="_blank" rel="noopener">参考文档1</a></p>
<p><a href="http://www.jianshu.com/p/6dfe49b5dab8" target="_blank" rel="noopener">参考文档2</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/18/OpenGL-ES-3-0学习笔记-简介/" rel="next" title="OpenGL ES 3.0学习笔记-简介">
                <i class="fa fa-chevron-left"></i> OpenGL ES 3.0学习笔记-简介
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/16/H-264文件结构学习笔记/" rel="prev" title="H.264文件结构学习笔记">
                H.264文件结构学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/14/iOS视频硬编码/"
           data-title="iOS视频硬编码" data-url="http://yoursite.com/2017/03/14/iOS视频硬编码/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">73</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理流程"><span class="nav-number">2.</span> <span class="nav-text">处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-采集"><span class="nav-number">2.1.</span> <span class="nav-text">1.采集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-开始编码"><span class="nav-number">2.2.</span> <span class="nav-text">2.开始编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-拆分后的视频数据二次封装为rtmp格式包"><span class="nav-number">2.3.</span> <span class="nav-text">3.拆分后的视频数据二次封装为rtmp格式包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-建立rtmp通道"><span class="nav-number">2.4.</span> <span class="nav-text">4.建立rtmp通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-rtmp推流"><span class="nav-number">2.5.</span> <span class="nav-text">5.rtmp推流</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
