<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/26/OpenGL-ES-3-0学习笔记-着色器和程序/" itemprop="url">
                  OpenGL ES 3.0学习笔记-着色器和程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-26T15:21:00+08:00" content="2017-03-26">
              2017-03-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/26/OpenGL-ES-3-0学习笔记-着色器和程序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/26/OpenGL-ES-3-0学习笔记-着色器和程序/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>如果需要使用着色器进行渲染的话，则首先必须有两个对象，分别是着色器对象及程序对象。那么如何理解这两者呢？可以将其理解为C语言的编译器和链接器。 </p>
<p>流程是这样的，源代码中提供着色器对象，然后着色器被编译成一个目标形式，再然后链接到一个程序对象。一个程序对象对应多个着色器对象，每个程序对象必须有一个顶点着色器和一个片段着色器。 </p>
<p>流程如下： </p>
<p>1.创建一个顶点着色器和一个片段着色器 </p>
<p>2.将源代码连接到每个着色器对象 </p>
<p>3.编译着色器对象 </p>
<p>4.创建一个程序对象 </p>
<p>5.将上面得到的着色器对象链接进程序对象中 </p>
<p>6.链接程序对象</p>
<h3 id="创建和编译一个着色器"><a href="#创建和编译一个着色器" class="headerlink" title="创建和编译一个着色器"></a>创建和编译一个着色器</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">GLuint shader;</div><div class="line">GLint compiled;</div><div class="line"></div><div class="line">// Create the shader object</div><div class="line">shader = glCreateShader ( type );</div><div class="line"></div><div class="line">if ( shader == 0 )</div><div class="line">&#123;</div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//type </div><div class="line">#define GL_FRAGMENT_SHADER        0x8B30 </div><div class="line">#define GL_VERTEX_SHADER          0x8B31</div></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glDeleteShader ( shader );</div></pre></td></tr></table></figure>
<p>删除着色器对象的句柄 </p>
<p>注：如果着色器已经链接到程序对象中的话，这时候直接调用glDeleteShader不会立刻去删除着色器，而是将其标注，等到着色器不在连接到任何程序对象时，其就会被删除 </p>
<h4 id="提供着色器源代码"><a href="#提供着色器源代码" class="headerlink" title="提供着色器源代码"></a>提供着色器源代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void glShaderSource(GLuint shader, //指向着色器的句柄 </div><div class="line">GLsizei count, //着色器源字符串的数量，虽然每个着色器可以有多个源字符串组成，但是每个着色器只有一个main函数 </div><div class="line">const GLchar *const*string, //指向保存数量为count的着色器源字符串的数组指针 </div><div class="line">const GLint *length //指向保存了每个着色器字符串大小且元素大小为count的整数数组指针 </div><div class="line">) </div><div class="line"> </div><div class="line">char vShaderStr[] =</div><div class="line">#version 300 es                          </div><div class="line">layout(location = 0) in vec4 vPosition;  </div><div class="line">void main()                              </div><div class="line">&#123;                                        </div><div class="line">  gl_Position = vPosition;              </div><div class="line">&#125;                                         </div><div class="line">     </div><div class="line">glShaderSource (shader, 1, &amp;shaderSrc, NULL );</div></pre></td></tr></table></figure>
<h4 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Compile the shader</div><div class="line">glCompileShader ( shader );</div></pre></td></tr></table></figure>
<p>调用glCompileShader将编译已经保存在着色器对象的着色器源代码。和常规的语言编译器一样，编译之后你想知道的第一件事情是有没有错误。你可以使用glGetShaderiv查询查询这一信息和其他有关着色器对象的信息。</p>
<h4 id="检测着色器是否成功编译"><a href="#检测着色器是否成功编译" class="headerlink" title="检测着色器是否成功编译"></a>检测着色器是否成功编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// Check the compile status</div><div class="line">glGetShaderiv ( shader, GL_COMPILE_STATUS, &amp;compiled );</div><div class="line"></div><div class="line">if ( !compiled )</div><div class="line">&#123;</div><div class="line">   GLint infoLen = 0;</div><div class="line"></div><div class="line">   glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &amp;infoLen );</div><div class="line"></div><div class="line">   if ( infoLen &gt; 1 )</div><div class="line">   &#123;</div><div class="line">      char *infoLog = malloc ( sizeof ( char ) * infoLen );</div><div class="line"></div><div class="line">      glGetShaderInfoLog ( shader, infoLen, NULL, infoLog );</div><div class="line">      esLogMessage ( &quot;Error compiling shader:\n%s\n&quot;, infoLog );</div><div class="line"></div><div class="line">      free ( infoLog );</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   glDeleteShader ( shader );</div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return shader;</div></pre></td></tr></table></figure>
<h3 id="创建和链接程序"><a href="#创建和链接程序" class="headerlink" title="创建和链接程序"></a>创建和链接程序</h3><h4 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GLuint programObject;</div><div class="line"></div><div class="line">// Create the program object</div><div class="line">programObject = glCreateProgram ( );</div></pre></td></tr></table></figure>
<h4 id="删除程序"><a href="#删除程序" class="headerlink" title="删除程序"></a>删除程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glDeleteProgram ( programObject );</div></pre></td></tr></table></figure>
<h4 id="关联着色器和程序"><a href="#关联着色器和程序" class="headerlink" title="关联着色器和程序"></a>关联着色器和程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">glAttachShader ( programObject, vertexShader );</div><div class="line">glAttachShader ( programObject, fragmentShader );</div></pre></td></tr></table></figure>
<p>注：对于程序对象和着色器对象的连接没有具体的时间要求，但是没有程序对象只能有一个顶点着色器和片段着色器与之连接</p>
<h4 id="断开着色器和程序"><a href="#断开着色器和程序" class="headerlink" title="断开着色器和程序"></a>断开着色器和程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void glDetachShader(GLuint program, GLuint shader)</div></pre></td></tr></table></figure>
<h4 id="链接着色器和程序"><a href="#链接着色器和程序" class="headerlink" title="链接着色器和程序"></a>链接着色器和程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Link the program</div><div class="line">glLinkProgram ( programObject );</div></pre></td></tr></table></figure>
<p>上述的工作都已经完成了之后需要链接程序的对象了。连接操作负责生成最终的可执行程序。在连接的时候将检查各种对象的数量，确保可以链接成功。</p>
<h4 id="检测链接是否成功"><a href="#检测链接是否成功" class="headerlink" title="检测链接是否成功"></a>检测链接是否成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// Check the link status</div><div class="line">  glGetProgramiv ( programObject, GL_LINK_STATUS, &amp;linked );</div><div class="line"></div><div class="line">  if ( !linked )</div><div class="line">  &#123;</div><div class="line">     GLint infoLen = 0;</div><div class="line"></div><div class="line">     glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &amp;infoLen );</div><div class="line"></div><div class="line">     if ( infoLen &gt; 1 )</div><div class="line">     &#123;</div><div class="line">        char *infoLog = malloc ( sizeof ( char ) * infoLen );</div><div class="line"></div><div class="line">        glGetProgramInfoLog ( programObject, infoLen, NULL, infoLog );</div><div class="line">        esLogMessage ( &quot;Error linking program:\n%s\n&quot;, infoLog );</div><div class="line"></div><div class="line">        free ( infoLog );</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     glDeleteProgram ( programObject );</div><div class="line">     return FALSE;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="设置程序对象为活动对象"><a href="#设置程序对象为活动对象" class="headerlink" title="设置程序对象为活动对象"></a>设置程序对象为活动对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void Draw ( ESContext *esContext )</div><div class="line">&#123;</div><div class="line">   UserData *userData = esContext-&gt;userData;</div><div class="line">   GLfloat vVertices[] = &#123;  0.0f,  0.5f, 0.0f,</div><div class="line">                            -0.5f, -0.5f, 0.0f,</div><div class="line">                            0.5f, -0.5f, 0.0f</div><div class="line">                         &#125;;</div><div class="line"></div><div class="line">   // Set the viewport</div><div class="line">   glViewport ( 0, 0, esContext-&gt;width, esContext-&gt;height );</div><div class="line"></div><div class="line">   // Clear the color buffer</div><div class="line">   glClear ( GL_COLOR_BUFFER_BIT );</div><div class="line"></div><div class="line">   // Use the program object</div><div class="line">   glUseProgram ( userData-&gt;programObject );</div><div class="line"></div><div class="line">   // Load the vertex data</div><div class="line">   glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, 0, vVertices );</div><div class="line">   glEnableVertexAttribArray ( 0 );</div><div class="line"></div><div class="line">   glDrawArrays ( GL_TRIANGLES, 0, 3 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/24/RTMP推流流程详解/" itemprop="url">
                  RTMP推流流程详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-24T11:14:49+08:00" content="2017-03-24">
              2017-03-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/24/RTMP推流流程详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/24/RTMP推流流程详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/rtmppush.png" alt=""></p>
<p>通过抓取主播端的rtmp数据包，我们能清晰的看到整个从握手到推流的过程，然后我们来分析一下每一个包的内容吧。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><h4 id="handshake-c0-c1"><a href="#handshake-c0-c1" class="headerlink" title="handshake c0+c1"></a>handshake c0+c1</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/handshakec0c1.png" alt=""></p>
<p>具体数据格式可以参考我的<a href="http://llyblog.com/2017/03/20/RTMP协议学习笔记/" target="_blank" rel="noopener">这一片博客</a></p>
<p>具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//c0</div><div class="line">  char c0Byte = 0x03;//rtmp版本号</div><div class="line">  NSData *c0 = [NSData dataWithBytes:&amp;c0Byte length:1];</div><div class="line">  [self writeData:c0];</div><div class="line">  </div><div class="line">  //c1</div><div class="line">  uint8_t *c1Bytes = (uint8_t *)malloc(kRtmpSignatureSize);</div><div class="line">  memset(c1Bytes, 0, 4 + 4);</div><div class="line">  NSData *c1 = [NSData dataWithBytes:c1Bytes length:kRtmpSignatureSize];</div><div class="line">  free(c1Bytes);</div><div class="line">  [self writeData:c1];</div></pre></td></tr></table></figure>
<h4 id="handshake-c2"><a href="#handshake-c2" class="headerlink" title="handshake c2"></a>handshake c2</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/handshakec2.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSData *s1 = [self.handShake subdataWithRange:NSMakeRange(0, kRtmpSignatureSize)];</div><div class="line">   //c2</div><div class="line">   uint8_t *s1Bytes = (uint8_t *)s1.bytes;</div><div class="line">   memset(s1Bytes + 4, 0, 4);</div><div class="line">   NSData *c2 = [NSData dataWithBytes:s1Bytes length:s1.length];</div><div class="line">   [self writeData:c2];</div></pre></td></tr></table></figure>
<h4 id="handshake-s0s1s2"><a href="#handshake-s0s1s2" class="headerlink" title="handshake s0s1s2"></a>handshake s0s1s2</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/handshakes0s1s2.png" alt=""></p>
<p>这个数据是服务器那边发送过来的 需要我们本地保存一份。</p>
<h3 id="协议消息"><a href="#协议消息" class="headerlink" title="协议消息"></a>协议消息</h3><p>流程如下</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/controlmessageflow.png" alt=""></p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>当客户端检测到收到s2的消息后，就可以发送‘connect’了。</p>
<p>看看connect里面的具体数据</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/controlmessageconnect.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)sendConnectPacket&#123;</div><div class="line">    NSLog(@&quot;sendConnectPacket&quot;);</div><div class="line">    //    AMF格式</div><div class="line">    RTMPChunk_0 metadata = &#123;0&#125;;</div><div class="line">    metadata.msg_stream_id = LLYStreamIDInvoke;</div><div class="line">    metadata.msg_type_id = LLYMSGTypeID_INVOKE;</div><div class="line">    </div><div class="line">    NSString *url;</div><div class="line">    NSMutableData *buff = [NSMutableData data];</div><div class="line">    if (_url.port &gt; 0) &#123;</div><div class="line">        url = [NSString stringWithFormat:@&quot;%@://%@:%zd/%@&quot;,_url.scheme,_url.host,_url.port,_url.app];</div><div class="line">    &#125;else&#123;</div><div class="line">        url = [NSString stringWithFormat:@&quot;%@://%@/%@&quot;,_url.scheme,_url.host,_url.app];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [buff appendString:@&quot;connect&quot;];</div><div class="line">    [buff appendDouble:++_numOfInvokes];</div><div class="line">    self.trackedCommands[@(_numOfInvokes)] = @&quot;connect&quot;;</div><div class="line">    [buff appendByte:kAMFObject];</div><div class="line">    [buff putKey:@&quot;app&quot; stringValue:_url.app];</div><div class="line">    [buff putKey:@&quot;type&quot; stringValue:@&quot;nonprivate&quot;];</div><div class="line">    [buff putKey:@&quot;tcUrl&quot; stringValue:url];</div><div class="line">    [buff putKey:@&quot;fpad&quot; boolValue:NO];//是否使用代理</div><div class="line">    [buff putKey:@&quot;capabilities&quot; doubleValue:15.];</div><div class="line">    [buff putKey:@&quot;audioCodecs&quot; doubleValue:10.];</div><div class="line">    [buff putKey:@&quot;videoCodecs&quot; doubleValue:7.];</div><div class="line">    [buff putKey:@&quot;videoFunction&quot; doubleValue:1.];</div><div class="line">    [buff appendByte16:0];</div><div class="line">    [buff appendByte:kAMFObjectEnd];</div><div class="line">    </div><div class="line">    metadata.msg_length.data = (int)buff.length;</div><div class="line">    [self sendPacket:buff :metadata];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Window-Acknowledgment-size"><a href="#Window-Acknowledgment-size" class="headerlink" title="Window Acknowledgment size"></a>Window Acknowledgment size</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/controlmwssageAcknowledgement.png" alt=""></p>
<p>发送端在接收到接受端返回的两个ACK间最多可以发送的字节数</p>
<h4 id="Set-Peer-Bandwidth-amp-amp-Set-Chunk-Size-amp-amp-AFM0-Command-result"><a href="#Set-Peer-Bandwidth-amp-amp-Set-Chunk-Size-amp-amp-AFM0-Command-result" class="headerlink" title="Set Peer Bandwidth &amp;&amp; Set Chunk Size &amp;&amp; AFM0 Command _result"></a>Set Peer Bandwidth &amp;&amp; Set Chunk Size &amp;&amp; AFM0 Command _result</h4><h5 id="Set-Peer-Bandwidth"><a href="#Set-Peer-Bandwidth" class="headerlink" title="Set Peer Bandwidth"></a>Set Peer Bandwidth</h5><p><img src="http://ofy1hyquv.bkt.clouddn.com/controlmessagepeerandchunksize.png" alt=""></p>
<p>限制对端的输出带宽。接受端接收到该消息后会通过设置消息中的Window ACK Size来限制已发送但未接受到反馈的消息的大小来限制发送端的发送带宽。如果消息中的Window ACK Size与上一次发送给发送端的size不同的话要回馈一个Window Acknowledgement Size的控制消息。</p>
<h5 id="Set-Chunk-Size"><a href="#Set-Chunk-Size" class="headerlink" title="Set Chunk Size"></a>Set Chunk Size</h5><p>这里为默认值128个字节。</p>
<h5 id="AFM0-Command-result-‘NetConnection-Connect-Success’"><a href="#AFM0-Command-result-‘NetConnection-Connect-Success’" class="headerlink" title="AFM0 Command _result(‘NetConnection.Connect.Success’)"></a>AFM0 Command _result(‘NetConnection.Connect.Success’)</h5><p><img src="http://ofy1hyquv.bkt.clouddn.com/controlmessageconnectresult.png" alt=""></p>
<p>这个是上面发送的connect消息的回应消息，消息类型为AFM0 0x14，从返回的code和describtion可以看出，connect已经成功。</p>
<p>接下来客户端需要发送 releaseStream , FCPublish 和 CreateStream 消息</p>
<h4 id="releaseStream-消息"><a href="#releaseStream-消息" class="headerlink" title="releaseStream 消息"></a>releaseStream 消息</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/releaseStream.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	- (void)sendReleaseStream&#123;</div><div class="line">    </div><div class="line">    RTMPChunk_0 metadata = &#123;0&#125;;</div><div class="line">    metadata.msg_stream_id = LLYStreamIDInvoke;</div><div class="line">    metadata.msg_type_id = LLYMSGTypeID_NOTIFY;</div><div class="line">    </div><div class="line">    NSMutableData *buff = [NSMutableData data];</div><div class="line">    [buff appendString:@&quot;releaseStream&quot;];</div><div class="line">    [buff appendDouble:++_numOfInvokes];</div><div class="line">    </div><div class="line">    self.trackedCommands[@(_numOfInvokes)] = @&quot;releaseStream&quot;;</div><div class="line">    [buff appendByte:kAMFNull];</div><div class="line">    [buff appendString:_url.playPath];</div><div class="line">    </div><div class="line">    metadata.msg_length.data = (int)buff.length;</div><div class="line">    [self sendPacket:buff :metadata];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CFPublish消息"><a href="#CFPublish消息" class="headerlink" title="CFPublish消息"></a>CFPublish消息</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/cfstream.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)sendFCPublish&#123;</div><div class="line">    RTMPChunk_0 metadata = &#123;0&#125;;</div><div class="line">    metadata.msg_stream_id = LLYStreamIDInvoke;</div><div class="line">    metadata.msg_type_id = LLYMSGTypeID_NOTIFY;</div><div class="line">    </div><div class="line">    NSMutableData *buff = [NSMutableData data];</div><div class="line">    [buff appendString:@&quot;FCPublish&quot;];</div><div class="line">    [buff appendDouble:(++_numOfInvokes)];</div><div class="line">    self.trackedCommands[@(_numOfInvokes)] = @&quot;FCPublish&quot;;</div><div class="line">    [buff appendByte:kAMFNull];</div><div class="line">    [buff appendString:_url.playPath];</div><div class="line">    metadata.msg_length.data = (int)buff.length;</div><div class="line">    </div><div class="line">    [self sendPacket:buff :metadata];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="createStream消息"><a href="#createStream消息" class="headerlink" title="createStream消息"></a>createStream消息</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/createStream.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)sendCreateStream&#123;</div><div class="line">    RTMPChunk_0 metadata = &#123;0&#125;;</div><div class="line">    metadata.msg_stream_id = LLYStreamIDInvoke;</div><div class="line">    metadata.msg_type_id = LLYMSGTypeID_INVOKE;</div><div class="line">    </div><div class="line">    NSMutableData *buff = [NSMutableData data];</div><div class="line">    [buff appendString:@&quot;createStream&quot;];</div><div class="line">    self.trackedCommands[@(++_numOfInvokes)] = @&quot;createStream&quot;;</div><div class="line">    [buff appendDouble:_numOfInvokes];</div><div class="line">    [buff appendByte:kAMFNull];</div><div class="line">    </div><div class="line">    metadata.msg_length.data = (int)buff.length;</div><div class="line">    [self sendPacket:buff :metadata];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后客户端会收到startStream的回应消息。</p>
<h4 id="startStream-result"><a href="#startStream-result" class="headerlink" title="startStream result"></a>startStream result</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/startStreamResult.png" alt=""></p>
<p>在收到这个消息后，就可以准备推流了。此时 客户端需要发送一个publish消息。</p>
<h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/publish.png" alt=""></p>
<p>这个消息告诉服务器，我要准备开始推流了，之后等待服务器给一个可以开始推流的回应。</p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)sendPublish&#123;</div><div class="line">    RTMPChunk_0 metadata = &#123;0&#125;;</div><div class="line">    metadata.msg_stream_id = LLYStreamIDAudio;</div><div class="line">    metadata.msg_type_id = LLYMSGTypeID_INVOKE;</div><div class="line">    </div><div class="line">    NSMutableData *buff = [NSMutableData data];</div><div class="line">    [buff appendString:@&quot;publish&quot;];</div><div class="line">    [buff appendDouble:++_numOfInvokes];</div><div class="line">    self.trackedCommands[@(_numOfInvokes)] = @&quot;publish&quot;;</div><div class="line">    [buff appendByte:kAMFNull];</div><div class="line">    [buff appendString:_url.playPath];</div><div class="line">    [buff appendString:@&quot;live&quot;];</div><div class="line">    </div><div class="line">    metadata.msg_length.data = (int)buff.length;</div><div class="line">    [self sendPacket:buff :metadata];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="onStatus-‘NetStream-Publish-Start’"><a href="#onStatus-‘NetStream-Publish-Start’" class="headerlink" title="onStatus(‘NetStream.Publish.Start’)"></a>onStatus(‘NetStream.Publish.Start’)</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/publistOnStatus.png" alt=""></p>
<p>客户端收到这个消息，表示服务器已经准备好接收流数据，客户端可以正式开始推流。</p>
<p><a href="http://llyblog.com/2017/03/14/iOS视频硬编码/" target="_blank" rel="noopener">参考文章和demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/21/使用WireShark抓取RTMP协议包/" itemprop="url">
                  使用WireShark抓取RTMP协议包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-21T11:29:05+08:00" content="2017-03-21">
              2017-03-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/21/使用WireShark抓取RTMP协议包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/21/使用WireShark抓取RTMP协议包/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在学习rtmp协议，虽然文档上对rtmp的握手过程和协议结构都讲得很清楚，但不看到实实在在的数据，心里还是没有底啊，所以今天尝试抓个包看看，因为我们正在做一个直播项目，所以想抓主播或者观众的包都是很容易的哈。</p>
<h3 id="WireShark-XQuartz"><a href="#WireShark-XQuartz" class="headerlink" title="WireShark + XQuartz"></a>WireShark + XQuartz</h3><p>升级到最新版的wireShark(Version 2.2.3)<br>升级到最新版的XQuartz（2.7.11）</p>
<h3 id="监听手机网卡"><a href="#监听手机网卡" class="headerlink" title="监听手机网卡"></a>监听手机网卡</h3><p>获取到手机的udid，然后再命令行执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvictl -s udid</div></pre></td></tr></table></figure>
<p>然后wireshark首页网卡列表会显示当前手机的网卡，如下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/wiresharkhome.png" alt=""></p>
<p>双击进入,界面上应该就有手机当前的一些网络包了</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/wiresharkphone.png" alt=""></p>
<h3 id="添加rtmp过滤器"><a href="#添加rtmp过滤器" class="headerlink" title="添加rtmp过滤器"></a>添加rtmp过滤器</h3><p>因为我们只需要看rtmp相关数据包，所以我们新建一个过滤器，wireshark提供了方便的入口</p>
<p>点击上图右上角的表达式按钮，进入新建过滤器界面</p>
<p>然后搜索rtmpt 这个要多一个t 因为rtmp字段被另外一个协议占用了。</p>
<p>然后选中当前搜索结果，点击OK，过滤器就添加好了。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/wiresharkfilter.png" alt=""></p>
<h3 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h3><p>一切准备完毕，现在可以开始抓包了。</p>
<h4 id="主播端"><a href="#主播端" class="headerlink" title="主播端"></a>主播端</h4><p>新建一个直播间，正常直播就可以了。下面是主播端的抓包数据</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/wiresharkpush.png" alt=""></p>
<p>可以清楚的看到握手的过程和每个数据包。</p>
<h4 id="观众端"><a href="#观众端" class="headerlink" title="观众端"></a>观众端</h4><p>点开一个正在直播的直播间。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/wiresharkplay.png" alt=""></p>
<p>可以看到，观众在握手成功后，向服务器发送了个play的指令。这也解惑了我之前的观众端如何开始拉流的疑问。</p>
<p>只要愿意动手，抓包原来很简单。</p>
<h3 id="–end–"><a href="#–end–" class="headerlink" title="–end–"></a>–end–</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/20/RTMP协议学习笔记/" itemprop="url">
                  RTMP协议学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-20T17:58:21+08:00" content="2017-03-20">
              2017-03-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/20/RTMP协议学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/20/RTMP协议学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写，它是由Adobe公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题。随着VR技术的发展，视频直播等领域逐渐活跃起来，RTMP作为业内广泛使用的协议也重新被相关开发者重视起来。</p>
<h3 id="rtmp协议简介"><a href="#rtmp协议简介" class="headerlink" title="rtmp协议简介"></a>rtmp协议简介</h3><p>RTMP协议是应用层协议，是要靠底层可靠的传输层协议（通常是TCP）来保证信息传输的可靠性的。在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接，在Connection链接上会传输一些控制信息，如SetChunkSize,SetACKWindowSize。其中CreateStream命令会创建一个Stream链接，用于传输具体的音视频数据和控制这些信息传输的命令信息。RTMP协议传输时会对数据做自己的格式化，这种格式的消息我们称之为RTMP Message，而实际传输的时候为了更好地实现多路复用、分包和信息的公平性，发送端会把Message划分为带有Message ID的Chunk，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据chunk中包含的data的长度，message id和message的长度把chunk还原成完整的Message，从而实现信息的收发。</p>
<h3 id="建立rtmp连接-三次握手"><a href="#建立rtmp连接-三次握手" class="headerlink" title="建立rtmp连接(三次握手)"></a>建立rtmp连接(三次握手)</h3><p>一个RTMP连接以握手开始。这里的握手和其他协议的握手不一样。这里的握手由三个固定大小的块组成，而不是可变大小的块加上头。</p>
<p>客户端（发起连接的一方）和服务端各自发送三个相同的块。这些块如果是客户端发送的话记为C0，C1和C2，如果是服务端发送的话记为S0，S1和S2。</p>
<h4 id="握手队列"><a href="#握手队列" class="headerlink" title="握手队列"></a>握手队列</h4><p>握手开始于客户端发送C0，C1块。</p>
<p>在发送C2之前客户端必须等待接收S1 。</p>
<p>在发送任何数据之前客户端必须等待接收S2。</p>
<p>服务端在发送S0和S1之前必须等待接收C0，也可以等待接收C1。</p>
<p>服务端在发送S2之前必须等待接收C1。</p>
<p>服务端在发送任何数据之前必须等待接收C2。</p>
<h4 id="C0-S0-消息格式"><a href="#C0-S0-消息格式" class="headerlink" title="C0/S0 消息格式"></a>C0/S0 消息格式</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/c0s0.png" alt=""></p>
<p>C0 和 S0是单独的一个字节，表示当前选择的RTMP版本</p>
<p>我现在看的资料当前rtmp版本是3。0-2是早期产品所用的，已被丢弃；4-31保留在未来使用 ；32-255不允许使用 （为了区分其他以某一字符开始的文本协议）。如果服务无法识别客户端请求的版本，应该返回3 。客户端可以选择减到版本3或选择取消握手。</p>
<h4 id="C1-S1-消息格式"><a href="#C1-S1-消息格式" class="headerlink" title="C1/S1 消息格式"></a>C1/S1 消息格式</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/c1s1.png" alt=""></p>
<p>C1和S1消息有1536字节长，由上面字段组成</p>
<p>时间：4字节,本字段包含时间戳。该时间戳应该是发送这个数据块的端点的后续块的时间起始点。可以是0，或其他的任何值。为了同步多个流，端点可能发送其块流的当前值。</p>
<p>零：4字节,本字段必须是全零。</p>
<p>随机数据：1528字节,本字段可以包含任何值。因为每个端点必须用自己初始化的握手和对端初始化的握手来区分身份，所以这个数据应有充分的随机性。但是并不需要加密安全的随机值，或者动态值。</p>
<h4 id="C2-S2-消息格式"><a href="#C2-S2-消息格式" class="headerlink" title="C2/S2 消息格式"></a>C2/S2 消息格式</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/c2s2.png" alt=""></p>
<p>C2和S2消息有1536字节长。是S1和C1的回复。本消息由以上字段组成。</p>
<p>时间：4字节，本字段必须包含对等段发送的时间（对C2来说是S1，对S2来说是C1）。</p>
<p>时间2：4字节，本字段必须包含先前发送的并被对端读取的包的时间戳。</p>
<p>随机回复：1528字节，本字段必须包含对端发送的随机数据字段（对C2来说是S1，对S2来说是C1）。</p>
<p>每个对等端可以用时间和时间2字段中的时间戳来快速地估计带宽和延迟。但这样做可能并不实用。</p>
<h4 id="握手示意图"><a href="#握手示意图" class="headerlink" title="握手示意图"></a>握手示意图</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/woshouliucheng.png" alt=""></p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/liuchengbiao.png" alt=""></p>
<p>流程和状态的对应表</p>
<h3 id="Message分块（Chunking）"><a href="#Message分块（Chunking）" class="headerlink" title="Message分块（Chunking）"></a>Message分块（Chunking）</h3><p>RTMP在收发数据的时候并不是以Message为单位的，而是把Message拆分成Chunk发送，而且必须在一个Chunk发送完成之后才能开始发送下一个Chunk。每个Chunk中带有MessageID代表属于哪个Message，接受端也会按照这个id来将chunk组装成Message。</p>
<p>为什么RTMP要将Message拆分成不同的Chunk呢？通过拆分，数据量较大的Message可以被拆分成较小的“Message”，这样就可以避免优先级低的消息持续发送阻塞优先级高的数据，比如在视频的传输过程中，会包括视频帧，音频帧和RTMP控制信息，如果持续发送音频数据或者控制数据的话可能就会造成视频帧的阻塞，然后就会造成看视频时最烦人的卡顿现象。同时对于数据量较小的Message，可以通过对Chunk Header的字段来压缩信息，从而减少信息的传输量。</p>
<p>Chunk的默认大小是128字节，在传输过程中，通过一个叫做Set Chunk Size的控制信息可以设置Chunk数据量的最大值，在发送端和接受端会各自维护一个Chunk Size，可以分别设置这个值来改变自己这一方发送的Chunk的最大大小。大一点的Chunk减少了计算每个chunk的时间从而减少了CPU的占用率，但是它会占用更多的时间在发送上，尤其是在低带宽的网络情况下，很可能会阻塞后面更重要信息的传输。小一点的Chunk可以减少这种阻塞问题，但小的Chunk会引入过多额外的信息（Chunk中的Header），少量多次的传输也可能会造成发送的间断导致不能充分利用高带宽的优势，因此并不适合在高比特率的流中传输。在实际发送时应对要发送的数据用不同的Chunk Size去尝试，通过抓包分析等手段得出合适的Chunk大小，并且在传输过程中可以根据当前的带宽信息和实际信息的大小动态调整Chunk的大小，从而尽量提高CPU的利用率并减少信息的阻塞机率。</p>
<p>具体Chunk格式如下：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/ChunkHeader.png" alt=""></p>
<h4 id="Basic-Header-基本的头信息"><a href="#Basic-Header-基本的头信息" class="headerlink" title="Basic Header (基本的头信息)"></a>Basic Header (基本的头信息)</h4><p>包含了chunk stream ID（流通道Id）和chunk type（chunk的类型），chunk stream id一般被简写为CSID，用来唯一标识一个特定的流通道，chunk type决定了后面Message Header的格式。Basic Header的长度可能是1，2，或3个字节，其中chunk type的长度是固定的（占2位，注意单位是位，bit），Basic Header的长度取决于CSID的大小,在足够存储这两个字段的前提下最好用尽量少的字节从而减少由于引入Header增加的数据量。</p>
<p>RTMP协议支持用户自定义［3，65599］之间的CSID，0，1，2由协议保留表示特殊信息。0代表Basic Header总共要占用2个字节，CSID在［64，319］之间，1代表占用3个字节，CSID在［64，65599］之间，2代表该chunk是控制信息和一些命令信息，后面会有详细的介绍。<br>chunk type的长度固定为2位，因此CSID的长度是（6=8-2）、（14=16-2）、（22=24-2）中的一个。</p>
<p>当Basic Header为1个字节时，CSID占6位，6位最多可以表示64个数，因此这种情况下CSID在［0，63］之间，其中用户可自定义的范围为［3，63］。格式如下图所示：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/chunk-basicheader1.png" alt=""></p>
<p>当Basic Header为2个字节时，CSID占14位，此时协议将chunk type所在字节的其他位都置为0，剩下的一个字节来表示CSID - 64，这样共有14位存储CSID，8位可以表示［0，255］共256个数，因此这种情况下CSID在［64，319］，其中319=255+64。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/chunkbasicheader2.png" alt=""></p>
<p>当Basic Header为3个字节时，CSID占22位，此时协议将［2，8］位置为1，余下的16个位表示CSID－64，这样共有16个位来存储CSID，16位可以表示［0，65535］共65536个数，因此这种情况下CSID在［64，65599］，其中65599=65535+64，需要注意的是，Basic Header是采用小端存储的方式，越往后的字节数量级越高，因此通过这3个字节每一位的值来计算CSID时，应该是:[第三个字节的值] * 256 + [第二个字节的值] + 64</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/chunk-basicheader2.png" alt=""></p>
<p>可以看到2个字节和3个字节的Basic Header所能表示的CSID是有交集的［64，319］，但实际实现时还是应该秉着最少字节的原则使用2个字节的表示方式来表示［64，319］的CSID。</p>
<h4 id="Message-Header（消息的头信息）"><a href="#Message-Header（消息的头信息）" class="headerlink" title="Message Header（消息的头信息）"></a>Message Header（消息的头信息）</h4><p>包含了要发送的实际信息（可能是完整的，也可能是一部分）的描述信息。Message Header的格式和长度取决于Basic Header的chunk type，共有4种不同的格式，由上面所提到的Basic Header中的fmt字段控制。其中第一种格式可以表示其他三种表示的所有数据，但由于其他三种格式是基于对之前chunk的差量化的表示，因此可以更简洁地表示相同的数据，实际使用的时候还是应该采用尽量少的字节表示相同意义的数据。以下按照字节数从多到少的顺序分别介绍这4种格式的Message Header。</p>
<h5 id="Type＝0"><a href="#Type＝0" class="headerlink" title="Type＝0:"></a>Type＝0:</h5><p><img src="http://ofy1hyquv.bkt.clouddn.com/chunk-messageheader0.png" alt=""></p>
<p>type=0时Message Header占用11个字节，其他三种能表示的数据它都能表示，但在chunk stream的开始的第一个chunk和头信息中的时间戳后退（即值与上一个chunk相比减小，通常在回退播放的时候会出现这种情况）的时候必须采用这种格式。</p>
<p>timestamp（时间戳）：占用3个字节，因此它最多能表示到16777215=0xFFFFFF=2^24-1, 当它的值超过这个最大值时，这三个字节都置为1，这样实际的timestamp会转存到Extended Timestamp字段中，接受端在判断timestamp字段24个位都为1时就会去Extended timestamp中解析实际的时间戳。</p>
<p>message length（消息数据的长度）：占用3个字节，表示实际发送的消息的数据如音频帧、视频帧等数据的长度，单位是字节。注意这里是Message的长度，也就是chunk属于的Message的总数据长度，而不是chunk本身Data的数据的长度。</p>
<p>message type id(消息的类型id)：占用1个字节，表示实际发送的数据的类型，如8代表音频数据、9代表视频数据。<br>msg stream id（消息的流id）：占用4个字节，表示该chunk所在的流的ID，和Basic Header的CSID一样，它采用小端存储的方式，</p>
<h5 id="Type-1"><a href="#Type-1" class="headerlink" title="Type = 1:"></a>Type = 1:</h5><p><img src="http://ofy1hyquv.bkt.clouddn.com/chunk-messageheader1.png" alt=""></p>
<p>type=1时Message Header占用7个字节，省去了表示msg stream id的4个字节，表示此chunk和上一次发的chunk所在的流相同，如果在发送端只和对端有一个流链接的时候可以尽量去采取这种格式。</p>
<p>timestamp delta：占用3个字节，注意这里和type＝0时不同，存储的是和上一个chunk的时间差。类似上面提到的timestamp，当它的值超过3个字节所能表示的最大值时，三个字节都置为1，实际的时间戳差值就会转存到Extended Timestamp字段中，接受端在判断timestamp delta字段24个位都为1时就会去Extended timestamp中解析时机的与上次时间戳的差值。</p>
<h5 id="Type-2"><a href="#Type-2" class="headerlink" title="Type = 2:"></a>Type = 2:</h5><p><img src="http://ofy1hyquv.bkt.clouddn.com/chunk-messageheader2.png" alt=""></p>
<p>type=2时Message Header占用3个字节，相对于type＝1格式又省去了表示消息长度的3个字节和表示消息类型的1个字节，表示此chunk和上一次发送的chunk所在的流、消息的长度和消息的类型都相同。余下的这三个字节表示timestamp delta，使用同type＝1</p>
<h5 id="Type-3"><a href="#Type-3" class="headerlink" title="Type = 3"></a>Type = 3</h5><p>0字节！！！好吧，它表示这个chunk的Message Header和上一个是完全相同的，自然就不用再传输一遍了。</p>
<p>当它跟在Type＝0的chunk后面时，表示和前一个chunk的时间戳都是相同的。什么时候连时间戳都相同呢？就是一个Message拆分成了多个chunk，这个chunk和上一个chunk同属于一个Message。</p>
<p>而当它跟在Type＝1或者Type＝2的chunk后面时，表示和前一个chunk的时间戳的差是相同的。比如第一个chunk的Type＝0，timestamp＝100，第二个chunk的Type＝2，timestamp delta＝20，表示时间戳为100+20=120，第三个chunk的Type＝3，表示timestamp delta＝20，时间戳为120+20=140</p>
<h4 id="Extended-Timestamp（扩展时间戳）："><a href="#Extended-Timestamp（扩展时间戳）：" class="headerlink" title="Extended Timestamp（扩展时间戳）："></a>Extended Timestamp（扩展时间戳）：</h4><p>上面我们提到在chunk中会有时间戳timestamp和时间戳差timestamp delta，并且它们不会同时存在，只有这两者之一大于3个字节能表示的最大数值0xFFFFFF＝16777215时，才会用这个字段来表示真正的时间戳，否则这个字段为0。扩展时间戳占4个字节，能表示的最大数值就是0xFFFFFFFF＝4294967295。当扩展时间戳启用时，timestamp字段或者timestamp delta要全置为1，表示应该去扩展时间戳字段来提取真正的时间戳或者时间戳差。注意扩展时间戳存储的是完整值，而不是减去时间戳或者时间戳差的值。</p>
<h4 id="Chunk-Data（块数据）"><a href="#Chunk-Data（块数据）" class="headerlink" title="Chunk Data（块数据）"></a>Chunk Data（块数据）</h4><p>用户层面上真正想要发送的与协议无关的数据，长度在(0,chunkSize]之间</p>
<h4 id="chunk示例"><a href="#chunk示例" class="headerlink" title="chunk示例"></a>chunk示例</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/sample-chunk1.png" alt=""></p>
<p>首先包含第一个Message的chunk的Chunk Type为0，因为它没有前面可参考的chunk，timestamp为1000，表示时间戳。type为0的header占用11个字节，假定chunkstreamId为3&lt;64，因此Basic Header占用1个字节，再加上Data的32个字节，因此第一个chunk共44＝11+1+32个字节。</p>
<p>第二个chunk和第一个chunk的CSID，TypeId，Data的长度都相同，因此采用Chunk Type＝2，timestamp delta＝1020-1000＝20，因此第二个chunk占用36=3+1+32个字节。</p>
<p>第三个chunk和第二个chunk的CSID，TypeId，Data的长度和时间戳差都相同，因此采用Chunk Type＝3省去全部Message Header的信息，占用33=1+32个字节。</p>
<p>第四个chunk和第三个chunk情况相同，也占用33=1+32个字节。</p>
<p>最后实际发送的chunk如下：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/sample-chunk1-result.png" alt=""></p>
<h4 id="chunk示例2"><a href="#chunk示例2" class="headerlink" title="chunk示例2"></a>chunk示例2</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/sample-chunk2.png" alt=""></p>
<p>注意到Data的Length＝307&gt;128,因此这个Message要切分成几个chunk发送.</p>
<p>第一个chunk的Type＝0，Timestamp＝1000，承担128个字节的Data，因此共占用140=11+1+128个字节。</p>
<p>第二个chunk也要发送128个字节，其他字段也同第一个chunk，因此采用Chunk Type＝3，此时时间戳也为1000，共占用129=1+128个字节。</p>
<p>第三个chunk要发送的Data的长度为307-128-128=51个字节，还是采用Type＝3，共占用1+51＝52个字节。</p>
<p>最后实际发送的chunk如下：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/sample-chunk2-result.png" alt=""></p>
<h3 id="协议控制消息（Protocol-Control-Message）"><a href="#协议控制消息（Protocol-Control-Message）" class="headerlink" title="协议控制消息（Protocol Control Message）"></a>协议控制消息（Protocol Control Message）</h3><p>在RTMP的chunk流会用一些特殊的值来代表协议的控制消息，它们的Message Stream ID必须为0（代表控制流信息），CSID必须为2，Message Type ID可以为1，2，3，5，6，具体代表的消息会在下面依次说明。控制消息的接受端会忽略掉chunk中的时间戳，收到后立即生效。</p>
<h4 id="Set-Chunk-Size-Message-Type-ID-1"><a href="#Set-Chunk-Size-Message-Type-ID-1" class="headerlink" title="Set Chunk Size(Message Type ID=1)"></a>Set Chunk Size(Message Type ID=1)</h4><p>设置chunk中Data字段所能承载的最大字节数，默认为128B，通信过程中可以通过发送该消息来设置chunk Size的大小（不得小于128B），而且通信双方会各自维护一个chunkSize，两端的chunkSize是独立的。比如当A想向B发送一个200B的Message，但默认的chunkSize是128B，因此就要将该消息拆分为Data分别为128B和72B的两个chunk发送，如果此时先发送一个设置chunkSize为256B的消息，再发送Data为200B的chunk，本地不再划分Message，B接受到Set Chunk Size的协议控制消息时会调整的接受的chunk的Data的大小，也不用再将两个chunk组成为一个Message。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/set-chunksize.png" alt=""></p>
<h4 id="Abort-Message-Message-Type-ID-2"><a href="#Abort-Message-Message-Type-ID-2" class="headerlink" title="Abort Message(Message Type ID=2)"></a>Abort Message(Message Type ID=2)</h4><p>当一个Message被切分为多个chunk，接受端只接收到了部分chunk时，发送该控制消息表示发送端不再传输同Message的chunk，接受端接收到这个消息后要丢弃这些不完整的chunk。Data数据中只需要一个CSID，表示丢弃该CSID的所有已接收到的chunk。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/abort%EF%BC%8Dmessage.png" alt=""></p>
<h4 id="Acknowledgement-Message-Type-ID-3"><a href="#Acknowledgement-Message-Type-ID-3" class="headerlink" title="Acknowledgement(Message Type ID=3)"></a>Acknowledgement(Message Type ID=3)</h4><p>当收到对端的消息大小等于窗口大小（Window Size）时接受端要回馈一个ACK给发送端告知对方可以继续发送数据。窗口大小就是指收到接受端返回的ACK前最多可以发送的字节数量，返回的ACK中会带有从发送上一个ACK后接收到的字节数。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/ACK-message.png" alt=""></p>
<h4 id="Window-Acknowledgement-Size-Message-Type-ID-5"><a href="#Window-Acknowledgement-Size-Message-Type-ID-5" class="headerlink" title="Window Acknowledgement Size(Message Type ID=5)"></a>Window Acknowledgement Size(Message Type ID=5)</h4><p>发送端在接收到接受端返回的两个ACK间最多可以发送的字节数。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/ACK-windowsize.png" alt=""></p>
<h4 id="Set-Peer-Bandwidth-Message-Type-ID-6"><a href="#Set-Peer-Bandwidth-Message-Type-ID-6" class="headerlink" title="Set Peer Bandwidth(Message Type ID=6)"></a>Set Peer Bandwidth(Message Type ID=6)</h4><p>限制对端的输出带宽。接受端接收到该消息后会通过设置消息中的Window ACK Size来限制已发送但未接受到反馈的消息的大小来限制发送端的发送带宽。如果消息中的Window ACK Size与上一次发送给发送端的size不同的话要回馈一个Window Acknowledgement Size的控制消息。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/Peer-Bandwidth.png" alt=""></p>
<p>Hard(Limit Type＝0)接受端应该将Window Ack Size设置为消息中的值</p>
<p>Soft(Limit Type=1)接受端可以将Window Ack Size设为消息中的值，也可以保存原来的值（前提是原来的Size小与该控制消息中的Window Ack Size）</p>
<p>Dynamic(Limit Type=2)如果上次的Set Peer Bandwidth消息中的Limit Type为0，本次也按Hard处理，否则忽略本消息，不去设置Window Ack Size。</p>
<h3 id="不同类型的RTMP-Message"><a href="#不同类型的RTMP-Message" class="headerlink" title="不同类型的RTMP Message"></a>不同类型的RTMP Message</h3><h4 id="Command-Message-命令消息，Message-Type-ID＝17或20"><a href="#Command-Message-命令消息，Message-Type-ID＝17或20" class="headerlink" title="Command Message(命令消息，Message Type ID＝17或20)"></a>Command Message(命令消息，Message Type ID＝17或20)</h4><p>表示在客户端和服务器间传递的在对端执行某些操作的命令消息。如<br>connect表示连接对端，对端如果同意连接的话会记录发送端信息并返回连接成功消息。publish表示开始向对方推流，接受端接到命令后准备好接受对端发送的流信息，下面会对比较常见的Command Message具体介绍。当信息使用AMF0编码时，Message Type ID＝20，AMF3编码时Message Type ID＝17.</p>
<p>发送端发送时会带有命令的名字，如connect，TransactionID表示此次命令的标识，Command Object表示相关参数。接受端收到命令后，会返回以下三种消息中的一种：_result 消息表示接受该命令，对端可以继续往下执行流程，_error消息代表拒绝该命令要执行的操作，method name消息代表要在之前命令的发送端执行的函数名称。这三种回应的消息都要带有收到的命令消息中的Transaction Id来表示本次的回应作用于哪个命令。</p>
<p>可以认为发送命令消息的对象有两种，一种是NetConnection，表示双端的上层连接，一种是NetStream，表示流信息的传输通道，控制流信息的状态，如Play播放流，Pause暂停。</p>
<h5 id="NetConnection-Commands-连接层的命令"><a href="#NetConnection-Commands-连接层的命令" class="headerlink" title="NetConnection Commands(连接层的命令)"></a>NetConnection Commands(连接层的命令)</h5><p>用来管理双端之间的连接状态，同时也提供了异步远程方法调用（RPC）在对端执行某方法，以下是常见的连接层的命令：</p>
<ul>
<li><p>connect:用于客户端向服务器发送连接请求 </p>
</li>
<li><p>Call:用于在对端执行某函数，即常说的RPC：远程进程调用</p>
</li>
<li><p>Create Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk</p>
</li>
</ul>
<h5 id="NetStream-Commands-流连接上的命令"><a href="#NetStream-Commands-流连接上的命令" class="headerlink" title="NetStream Commands(流连接上的命令)"></a>NetStream Commands(流连接上的命令)</h5><p>Netstream建立在NetConnection之上，通过NetConnection的createStream命令创建，用于传输具体的音频、视频等信息。在传输层协议之上只能连接一个NetConnection，但一个NetConnection可以建立多个NetStream来建立不同的流通道传输数据。</p>
<p>以下会列出一些常用的NetStream Commands，服务端收到命令后会通过onStatus的命令来响应客户端，表示当前NetStream的状态。</p>
<ul>
<li><p>play(播放):由客户端向服务器发起请求从服务器端接受数据（如果传输的信息是视频的话就是请求开始播流），可以多次调用，这样本地就会形成一组数据流的接收者。注意其中有一个reset字段，表示是覆盖之前的播流（设为true）还是重新开始一路播放（设为false）。</p>
</li>
<li><p>play2（播放）：和上面的play命令不同的是，play2命令可以将当前正在播放的流切换到同样数据但不同比特率的流上，服务器端会维护多种比特率的文件来供客户端使用play2命令来切换。</p>
</li>
<li><p>deleteStream(删除流)：用于客户端告知服务器端本地的某个流对象已被删除，不需要再传输此路流。</p>
</li>
<li><p>receiveAudio(接收音频)：通知服务器端该客户端是否要发送音频</p>
</li>
<li><p>receiveVideo(接收视频)：通知服务器端该客户端是否要发送视频</p>
</li>
<li><p>publish(推送数据)：由客户端向服务器发起请求推流到服务器。</p>
</li>
<li><p>seek(定位流的位置)：定位到视频或音频的某个位置，以毫秒为单位。</p>
</li>
<li><p>pause（暂停）：客户端告知服务端停止或恢复播放。<br>如果Pause为true即表示客户端请求暂停的话，服务端暂停对应的流会返回NetStream.Pause.Notify的onStatus命令来告知客户端当前流处于暂停的状态，当Pause为false时，服务端会返回NetStream.Unpause.Notify的命令来告知客户端当前流恢复。如果服务端对该命令响应失败，返回_error信息。</p>
</li>
</ul>
<h4 id="Data-Message（数据消息，Message-Type-ID＝15或18）"><a href="#Data-Message（数据消息，Message-Type-ID＝15或18）" class="headerlink" title="Data Message（数据消息，Message Type ID＝15或18）"></a>Data Message（数据消息，Message Type ID＝15或18）</h4><p>传递一些元数据（MetaData，比如视频名，分辨率等等）或者用户自定义的一些消息。当信息使用AMF0编码时，Message Type ID＝18，AMF3编码时Message Type ID＝15.</p>
<h4 id="Shared-Object-Message-共享消息，Message-Type-ID＝16或19"><a href="#Shared-Object-Message-共享消息，Message-Type-ID＝16或19" class="headerlink" title="Shared Object Message(共享消息，Message Type ID＝16或19)"></a>Shared Object Message(共享消息，Message Type ID＝16或19)</h4><p>表示一个Flash类型的对象，由键值对的集合组成，用于多客户端，多实例时使用。当信息使用AMF0编码时，Message Type ID＝19，AMF3编码时Message Type ID＝16.</p>
<h4 id="Audio-Message（音频信息，Message-Type-ID＝8）：音频数据。"><a href="#Audio-Message（音频信息，Message-Type-ID＝8）：音频数据。" class="headerlink" title="Audio Message（音频信息，Message Type ID＝8）：音频数据。"></a>Audio Message（音频信息，Message Type ID＝8）：音频数据。</h4><h4 id="Video-Message（视频信息，Message-Type-ID＝9）：视频数据。"><a href="#Video-Message（视频信息，Message-Type-ID＝9）：视频数据。" class="headerlink" title="Video Message（视频信息，Message Type ID＝9）：视频数据。"></a>Video Message（视频信息，Message Type ID＝9）：视频数据。</h4><h4 id="Aggregate-Message-聚集信息，Message-Type-ID＝22-：多个RTMP子消息的集合"><a href="#Aggregate-Message-聚集信息，Message-Type-ID＝22-：多个RTMP子消息的集合" class="headerlink" title="Aggregate Message (聚集信息，Message Type ID＝22)：多个RTMP子消息的集合"></a>Aggregate Message (聚集信息，Message Type ID＝22)：多个RTMP子消息的集合</h4><h4 id="User-Control-Message-Events-用户控制消息，Message-Type-ID-4"><a href="#User-Control-Message-Events-用户控制消息，Message-Type-ID-4" class="headerlink" title="User Control Message Events(用户控制消息，Message Type ID=4)"></a>User Control Message Events(用户控制消息，Message Type ID=4)</h4><p>告知对方执行该信息中包含的用户控制事件，比如Stream Begin事件告知对方流信息开始传输。和前面提到的协议控制信息（Protocol Control Message）不同，这是在RTMP协议层的，而不是在RTMP chunk流协议层的，这个很容易弄混。该信息在chunk流中发送时，Message Stream ID=0,Chunk Stream Id=2,Message Type Id=4。</p>
<h3 id="RTMP-推流和播放流程图"><a href="#RTMP-推流和播放流程图" class="headerlink" title="RTMP 推流和播放流程图"></a>RTMP 推流和播放流程图</h3><h4 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/publish-flow.png" alt=""></p>
<p>命令执行过程中的消息流是：</p>
<ul>
<li><p>1.客户端发送连接命令到服务端，请求与一个服务应用实例建立连接。</p>
</li>
<li><p>2.接收到连接命令后，服务端发送”窗口确认（致谢）消息”到客户端。服务端同时连接到连接命令中提到的应用。</p>
</li>
<li><p>3.服务端发送”设置带宽”协议消息到客户端。</p>
</li>
<li><p>4.在处理完”设置带宽”消息后，客户端发送”窗口确认（致谢）大小”消息到服务端。</p>
</li>
<li><p>5.服务端发送用户控制消息中的流开始消息到客户端。</p>
</li>
<li><p>6.服务端发送结果命令消息通知客户端连接状态。该命令指定传输ID（对于连接命令总是1）。同时还指定一些属性，例如，Flash media server 版本（字符串），能力（数字），以及其他的连接信息，例如，层（字符串），代码（字符串），描述（字符串），对象编码（数字）等。</p>
</li>
</ul>
<h4 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/play-flow.png" alt=""></p>
<p>命令执行过程中的消息流是：</p>
<ul>
<li><p>1.客户端发送连接命令到服务端，请求与一个服务应用实例建立连接。</p>
</li>
<li><p>2.接收到连接命令后，服务端发送”窗口确认（致谢）消息”到客户端。服务端同时连接到连接命令中提到的应用。</p>
</li>
<li><p>3.服务端发送”设置带宽”协议消息到客户端。</p>
</li>
<li><p>4.在处理完”设置带宽”消息后，客户端发送”窗口确认（致谢）大小”消息到服务端。</p>
</li>
<li><p>5.服务端发送用户控制消息中的流开始消息到客户端。</p>
</li>
<li><p>6.服务端发送结果命令消息通知客户端连接状态。该命令指定传输ID（对于连接命令总是1）。同时还指定一些属性，例如，Flash media server 版本（字符串），能力（数字），以及其他的连接信息，例如，层（字符串），代码（字符串），描述（字符串），对象编码（数字）等。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/H-264文件结构学习笔记/" itemprop="url">
                  H.264文件结构学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-16T20:31:08+08:00" content="2017-03-16">
              2017-03-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/16/H-264文件结构学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/16/H-264文件结构学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>相关研究显示 H.264/AVC 与 MPEG-2 及 MPEG-4 相较之下，无论是压缩率或视讯质量皆有大幅的提升，而且H.264/AVC也首次将 视讯编码层(Video Coding Layer，VCL)与网络提取层(Network Abstraction Layer，NAL)的概念涵盖进来，以往视讯标准着重的是压缩效能部分，而H.264/AVC包含一个内建的NAL网络协议适应层，即由NAL来提供网络的状态，可以让VCL有更好的编译码弹性与纠错能力，使得H.264/AVC非常适用于多媒体串流(multimedia streaming)及行动电视(mobile TV)的相关应用</p>
<h3 id="编码核心思想"><a href="#编码核心思想" class="headerlink" title="编码核心思想"></a>编码核心思想</h3><p>在编码方面，我理解的他的理论依据是：参照一段时间内图像的统计结果表明，在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小！B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。这段图像我们称为一个序列（序列就是有相同特点的一段数据），当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。</p>
<p>在H264协议里定义了三种帧，完整编码的帧叫I帧，参考之前的I帧生成的只包含差异部分编码的帧叫P帧，还有一种参考前后的帧编码的帧叫B帧。</p>
<p>H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。</p>
<h3 id="关于序列的说明"><a href="#关于序列的说明" class="headerlink" title="关于序列的说明"></a>关于序列的说明</h3><p>在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流，以I帧开始，到下一个I帧结束。</p>
<p>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像,但不是所有I帧图像都是IDR图像。H.264 引入 IDR 图像是为了解码的同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p>
<p>一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。</p>
<h3 id="IPB帧"><a href="#IPB帧" class="headerlink" title="IPB帧"></a>IPB帧</h3><h4 id="I帧"><a href="#I帧" class="headerlink" title="I帧"></a>I帧</h4><p>1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输; </p>
<p>2.解码时仅用I帧的数据就可重构完整图像; </p>
<p>3.I帧描述了图像背景和运动主体的详情; </p>
<p>4.I帧不需要参考其他画面而生成; </p>
<p>5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量); </p>
<p>6.I帧是帧组GOP（既一个帧序列）的基础帧(第一帧),在一组中只有一个I帧; </p>
<p>7.I帧不需要考虑运动矢量; </p>
<p>8.I帧所占数据的信息量比较大</p>
<h4 id="P帧"><a href="#P帧" class="headerlink" title="P帧"></a>P帧</h4><p>前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>
<p>P帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p>
<p>1.P帧是I帧后面相隔1~2帧的编码帧; </p>
<p>2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差); </p>
<p>3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像; </p>
<p>4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧; </p>
<p>5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧; </p>
<p>6.由于P帧是参考帧,它可能造成解码错误的扩散; </p>
<p>7.由于是差值传送,P帧的压缩比较高。</p>
<h4 id="B帧"><a href="#B帧" class="headerlink" title="B帧"></a>B帧</h4><p>双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况，但我这样说简单些），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。</p>
<p>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p>
<p>1.B帧是由前面的I或P帧和后面的P帧来进行预测的; </p>
<p>2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量; </p>
<p>3.B帧是双向预测编码帧; </p>
<p>4.B帧压缩比最高,因为它只反映了参考帧间运动主体的变化情况,预测比较准确; </p>
<p>5.B帧不是参考帧,不会造成解码错误的扩散。 </p>
<p>注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p>
<h3 id="压缩方法"><a href="#压缩方法" class="headerlink" title="压缩方法"></a>压缩方法</h3><p>h264的压缩方法:</p>
<p>1.分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多。 </p>
<p>2.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧; </p>
<p>3.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧; </p>
<p>4.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</p>
<p>帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。帧内压缩一般达不到很高的压缩，跟编码jpeg差不多。</p>
<p>帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。</p>
<h3 id="网络提取层（NAL）"><a href="#网络提取层（NAL）" class="headerlink" title="网络提取层（NAL）"></a>网络提取层（NAL）</h3><p>以NAL封包为单位的方式来做为VCL编译码的运算单位，这样传输层拿到NAL封包之后不需要再进行切割，只需附加该传输协议的文件头信息(adding header only)就可以交由底层传送出去。</p>
<p>如图所示，可以将NAL当成是一个专作封装(packaging)的模块，用来将VCL压缩过的bitstream封装成适当大小的封包单位(NAL-unit)，并在NAL-unit Header中的NAL-unit Type字段记载此封包的型式，每种型式分别对应到VCL中不同的编解碼工具。NAL另外一个重要的功能为当网络发生壅塞而导致封包错误或接收次序错乱(out-of-order)的状况时，传输层协议会在Reference Flag作设定的动作，接收端的VCL在收到这种NAL封包时，就知道要进行所谓的纠错运算(error concealment)，在解压缩的同时也会尝试将错误修正回来</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-03.gif" alt=""></p>
<p>一个完整的H.264/AVC bitstream是由多个NAL-units所组成的，所以此bitstream也称之为NAL unit stream，一个NAL unit stream内可以包含多个压缩视讯序列(coded video sequence)，一个单独的压缩视讯序列代表一部视讯影片，而压缩视讯序列又是由多个access units所组成，当接收端收到一个access unit后，可以完整地译码成单张的画面，而每个压缩视讯序列的第一个access unit必须为Instantaneous Decoding Refresh (IDR) access unit，IDRaccess unit的内容全是采用intra-prediction编码，所以自己本身即可完全译码，不用参考其他access unit的数据。access unit亦是由多个NAL-units所组成，标准中总共规范12种的NAL-unit型式，这些可以进一步分类成VCL NAL-unit及non-VCL NAL-unit，所谓的VCL NAL-unit纯粹是压缩影像的内容，而所谓的non-VCL NAL-unit则有两种：Parameter Sets与Supplemental Enhancement Information (SEI)，SEI可以存放影片简介、版权宣告、用户自行定义的数据…等；Parameter Sets主要是描述整个压缩视讯序列的参数，例如：长宽比例、影像显现的时间点(timestamp)、相关译码所需的参数…等，这些信息非常重要，万一在传送的过程中发生错误，会导致整段影片无法译码，以往像MPEG-2/-4都把这些信息放在一般的packet header，所以很容易随着packet loss而消失，现在H.264/AVC将这些信息独立出来成为特殊的parameter set，可以采用所谓的out-of-band的方式来传送，以便将out-of-band channel用最高层级的信道编码(channel coding)保护机制，来保证传输的正确性。</p>
<p>总结：</p>
<p>第一层是多个序列帧（多个GOP）。</p>
<p>第二层是每个序列帧中具体的IPB帧。</p>
<p>第三层是每一帧具体的数据（NALU）。</p>
<h3 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h3><h4 id="NAL单元格式："><a href="#NAL单元格式：" class="headerlink" title="NAL单元格式："></a>NAL单元格式：</h4><p>NAL头 + RBSP</p>
<p>RBSP：封装于网络抽象单元的数据称之为原始字节序列载荷RBSP，它是NAL的基本传输单元。其中，RBSP又分为视频编码数据和控制数据。其基本结构是：在原始编码数据的后面填加了结尾比特。一个bit“1”若干比特“0”，以便字节对齐。</p>
<p>RBSP的类型： </p>
<p>RBSP 类型之一 PS: 包括序列参数集 SPS  和 图像参数集 PPS </p>
<p>SPS：包含的是针对一连续编码视频序列的参数，如标识符 seq_parameter_set_id、帧数及 POC 的约束、参考帧数目、解码图像尺寸和帧场编码模式选择标识等等。 </p>
<p>PPS：对应的是一个序列中某一幅图像或者某几幅图像，其参数如标识符 pic_parameter_set_id、可选的 seq_parameter_set_id、熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等等。 </p>
<h4 id="NALU类型"><a href="#NALU类型" class="headerlink" title="NALU类型"></a>NALU类型</h4><p>标识NAL单元中的RBSP数据类型，其中，nal_unit_type为1， 2， 3， 4， 5及12的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。 </p>
<p>0：未规定 </p>
<p>1：非IDR图像中不采用数据划分的片段 </p>
<p>2：非IDR图像中A类数据划分片段 </p>
<p>3：非IDR图像中B类数据划分片段 </p>
<p>4：非IDR图像中C类数据划分片段 </p>
<p>5：IDR图像的片段 </p>
<p>6：补充增强信息 (SEI) </p>
<p>7：序列参数集 </p>
<p>8：图像参数集 </p>
<p>9：分割符 </p>
<p>10：序列结束符 </p>
<p>11：流结束符 </p>
<p>12：填充数据 </p>
<p>13 – 23：保留 </p>
<p>24 – 31：未规定 </p>
<h3 id="视讯编码层-VCL"><a href="#视讯编码层-VCL" class="headerlink" title="视讯编码层(VCL)"></a>视讯编码层(VCL)</h3><p>视频压缩的原理是利用影像在时间与空间上存有相似性，这些相似的数据经过压缩算法处理之后，可以将人眼无法感知的部分抽离出来，这些称为视觉冗余(visual redundancy)的部分在去除之后，就可以达到视频压缩的目的。如图1所示，H.264/AVC的视讯编码机制是以图块(block-based)为基础单元，也就是说先将整张影像分割成许多矩形的小区域，称之为巨图块(macroblock，MB)，再将这些巨图块进行编码，先使用画面内预测(intra-prediction)与画面间预测(inter-prediction)技术，以去除影像之间的相似性来得到所谓的差余影像(residual)，再将差余影像施以空间转换(transform)与量化(quantize)来去除视觉冗余，最后视讯编码层会输出编码过的比特流(bitstream)，之后再包装成网络提取层的单元封包(NAL-unit)，经由网络传送到远程或储存在储存媒体中。</p>
<h4 id="H-264-AVC影像格式阶层架构"><a href="#H-264-AVC影像格式阶层架构" class="headerlink" title="H.264/AVC影像格式阶层架构"></a>H.264/AVC影像格式阶层架构</h4><p>H.264/AVC的阶层架构由小到大依序是sub-block、block、macroblock、slice、slicegroup、frame/field-picture、sequence。对一个采用4:2:0取样的MB而言，它是由16x16点的Luma与相对应的2个8x8点Chroma来组成，而在H.264/AVC的规范中，MB可再分割成多个16x8、8x16、8x8、8x4、4x8、4x4格式的sub-blocks。所谓的slice是许多MB的集合，而一张影像是由许多slice所组成(图3)，slice为H.264/AVC格式中的最小可译码单位(self-decodable unit)，也就是说一个slice单靠本身的压缩数据就能译码，而不必依靠其他slice，这样的好处是当传送到远程时，每接收完一笔slice的压缩数据就能马上译码，不用等待整张的数据接收完后才能开始，而且万一传送的过程中发生数据遗失或错误，也只是影响该笔slice，不会对其他slice有所影响，但跟MPEG-2的slice不同处在于它允许slice的范围可以超过一行MB，也就是说H.264/AVC允许整张影像只由单一个slice组成。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-04.gif" alt=""></p>
<h4 id="Slice的编码模式-IPB帧"><a href="#Slice的编码模式-IPB帧" class="headerlink" title="Slice的编码模式(IPB帧)"></a>Slice的编码模式(IPB帧)</h4><p>H.264/AVC的slice依照编码的类型可以分成下列种类：(1)I-slice: slice的全部MB都采用intra-prediction的方式来编码；(2) P-slice: slice中的MB使用intra-prediction和inter-prediction的方式来编码，但每一个inter-prediction block最多只能使用一个移动向量；(3) B-slice:与P-slice类似，但每一个inter-prediction block可以使用二个移动向量。比较特别的是B-slice的‘B’是指Bi-predictive，与MPEG-2/-4 B-frame的Bi-directional概念有很大的不同，MPEG-2/-4 B-frame被限定只能由前一张和后一张的I(或P)-frame来做inter- prediction，但是H.264/AVC B-slice除了可由前一张和后一张影像的I(或P、B)-slice外，也能从前二张不同影像的I(或P、B)-slice来做inter- prediction，</p>
<p>而H.264/AVC另外增加两种特殊slice类型：</p>
<p>(1) SP-slice:即所谓的Switching P slice，为P-slice的一种特殊类型，用来串接两个不同bitrate的bitstream；</p>
<p>(2) SI-slice: 即所谓的Switching I slice，为I-slice的一种特殊类型，除了用来串接两个不同content的bitstream外，也可用来执行随机存取(random access)来达到网络VCR的功能。</p>
<p>这两种特殊的slice主要是考虑当进行Video-On-Demand streaming的应用时，对同一个视讯内容的影片来说，server会预先存放不同bitrate的压缩影片，而当带宽改变时，server就会送出适合当时带宽比特率的影片，传统的做法是需要等到适当的时间点来传送新的I-slice (容量较P-slice大上许多)，但因为带宽变小导致需要较多的时间来传送I-slice，如此会让client端的影像有所延迟，为了让相同content但不同bitrate的bitstream可以较平顺地串接，使用SP-slice会很容易来达成(图4)，不仅可以直接送出新的bitstream，也因为传送的P-slice的容量较小，所以不会有时间延迟的情形出现</p>
<p>SP-slice</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-05.gif" alt=""></p>
<p>SI-slice</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-06.gif" alt=""></p>
<h4 id="画面内预测技术-Intra-frame-Prediction-帧内压缩"><a href="#画面内预测技术-Intra-frame-Prediction-帧内压缩" class="headerlink" title="画面内预测技术(Intra-frame Prediction)-帧内压缩"></a>画面内预测技术(Intra-frame Prediction)-帧内压缩</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-07.gif" alt=""></p>
<p>以往的压缩标准在进行intra-prediction时，多半只是将转换系数做差值编码，而H.264/AVC在空间领域(spatial domain)来进行像点之间的预测，而不是用转换过的系数，它提供两种intra-prediction的型式：intra_4x4及intra_16x16，所谓的intra_4x4是以Luma 4x4 sub-block为单位，找出它的参考对象(predictor)后，再将其与参考对象相减后所产生的差余影像(residual)送入转换算法，而寻找参考对象的模式共有9种预测的方向(上图)，以mode 0 (vertical)为例，{a,e,i,m}、{b,f,j,n}、{c,g,k,o}、{d,h,l,p}的参考对象分别为A、B、C、D；Luma intra_16x16与Chroma的模式跟Luma intra_4x4类似</p>
<h4 id="画面间预测技术-Inter-frame-Prediction-帧间压缩"><a href="#画面间预测技术-Inter-frame-Prediction-帧间压缩" class="headerlink" title="画面间预测技术(Inter-frame Prediction)-帧间压缩"></a>画面间预测技术(Inter-frame Prediction)-帧间压缩</h4><p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-08.gif" alt=""></p>
<p>至于横跨每张画面之间的预测技术，H.264/AVC提供了更丰富的编码模式，计有下述几种区块分割(partition)的方法：16x16、16x8、8x16、8x8、8x4、4x8、4x4，多样的分割方式可以让移动向量的预测更准确，如上图所示，画面中有些移动的区域并不是正方形，使用长方形或较小的4x4分割来做预测的区域，可以大幅降低差余影像的数值来增加了压缩比，但也因此P-slice中的MB最多可有16个移动向量(motion vector)，而B-slice中的MB最多可拥有32个移动向量，虽然这些会增加移动向量档头(header)的容量，但整体来说对压缩比仍有正面的益处。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/200504-03-09.gif" alt=""></p>
<p>以往的压缩标准所使用的动态估测(motion estimation)，只有使用前一张图像来作为预测的对象，H.264/AVC提供了多重参考图像(multiple reference frames)的概念，使得移动向量不再只限于前后相邻的影像，而是可以跨过多张影像，如上图所示，在时间点t的图块，可以使用t-1到t-2图像中的图块来作为预测的对象，当影片有周期重复性的内容时，例如：背景影像周期性的出现或被遮盖、对象有来回跳动的行为、形状忽大忽小，或是摄影机在拍摄时，因为有多处的取景点，并且摄影画面在取景点之间来回移动，这种情形在球类比赛转播时常出现，这些状况都能得到较好的动态预测结果，因而提高了压缩的效能。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/iOS视频硬编码/" itemprop="url">
                  iOS视频硬编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-14T10:16:51+08:00" content="2017-03-14">
              2017-03-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/14/iOS视频硬编码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/iOS视频硬编码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>iOS8之后 系统提供了VideoToolBox用来处理音频和视频的编解码（硬解使用GPU），在iOS8之前，普遍使用的是ffmpeg（软解使用CPU）。</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="1-采集"><a href="#1-采集" class="headerlink" title="1.采集"></a>1.采集</h3><p>使用AVFoundation提供的AVCapture系列类自定义一个视频流采集的相机，在采集到数据的回调内处理视频编码。</p>
<p>相机自定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">self.session = [[AVCaptureSession alloc]init];</div><div class="line">    </div><div class="line">    if ([self.session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;</div><div class="line">        self.session.sessionPreset = AVCaptureSessionPreset640x480;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">    </div><div class="line">    </div><div class="line">    if ([self.videoDevice isFocusModeSupported:AVCaptureFocusModeAutoFocus]) &#123;</div><div class="line">        if ([self.videoDevice lockForConfiguration:nil]) &#123;</div><div class="line">            self.videoDevice.focusMode = AVCaptureFocusModeContinuousAutoFocus;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoInput = [[AVCaptureDeviceInput alloc]initWithDevice:self.videoDevice error:nil];</div><div class="line">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">        [self.session addInput:self.videoInput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoDataOutput = [[AVCaptureVideoDataOutput alloc]init];</div><div class="line">    </div><div class="line">    //kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange 表示原始数据的格式为YUV420</div><div class="line">//    YUV 4:4:4采样，每一个Y对应一组UV分量。</div><div class="line">//    YUV 4:2:2采样，每两个Y共用一组UV分量。</div><div class="line">//    YUV 4:2:0采样，每四个Y共用一组UV分量。</div><div class="line">    NSDictionary *settings = [[NSDictionary alloc]initWithObjectsAndKeys:[NSNumber numberWithUnsignedInteger:kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange],kCVPixelBufferPixelFormatTypeKey,nil];</div><div class="line">    self.videoDataOutput.videoSettings = settings;</div><div class="line">    self.videoDataOutput.alwaysDiscardsLateVideoFrames = YES;</div><div class="line">    </div><div class="line">    _videoOutputQueue = dispatch_queue_create(&quot;videoOutputQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    [self.videoDataOutput setSampleBufferDelegate:self queue:_videoOutputQueue];</div><div class="line">    </div><div class="line">    if ([self.session canAddOutput:self.videoDataOutput]) &#123;</div><div class="line">        [self.session addOutput:self.videoDataOutput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoConnection = [self.videoDataOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class="line">    [self.videoConnection setVideoScaleAndCropFactor:1];</div><div class="line"></div><div class="line">    self.videoConnection.videoOrientation = AVCaptureVideoOrientationPortrait;</div></pre></td></tr></table></figure>
<p>回调处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection&#123;</div><div class="line"></div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">//    CVPixelBufferRef pixelBufferRef = CMSampleBufferGetImageBuffer(sampleBuffer);</div><div class="line">    if ([self.delegate respondsToSelector:@selector(videOutputHandler:didOutputSampleBuffer:)]) &#123;</div><div class="line">        [self.delegate videOutputHandler:weakSelf didOutputSampleBuffer:sampleBuffer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sampleBuffer 这个就是视频流的原始数据。</p>
<h3 id="2-开始编码"><a href="#2-开始编码" class="headerlink" title="2.开始编码"></a>2.开始编码</h3><p>使用VideoToolBox库的相关API可能很方便的编码上面的sampleBuffer数据.</p>
<p>首先要初始化一个VTCompressionSessionRef对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> OSStatus status = VTCompressionSessionCreate(NULL, _videoConfig.videoSize.width, _videoConfig.videoSize.height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressBuffer, (__bridge void *)self, &amp;_compressionSession);</div><div class="line">    if(status != noErr)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //关键帧间隔 一般为帧率的2倍 间隔越大 压缩比越高</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_MaxKeyFrameInterval,(__bridge CFTypeRef)@(_videoConfig.keyframeInterval));</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration,(__bridge CFTypeRef)@(_videoConfig.keyframeInterval));</div><div class="line">    </div><div class="line">    </div><div class="line">    //Just remember that kVTCompressionPropertyKey_AverageBitRate takes bits and kVTCompressionPropertyKey_DataRateLimits takes bytes and seconds.</div><div class="line">//    status = VTSessionSetProperty(session, kVTCompressionPropertyKey_AverageBitRate, (__bridge CFTypeRef)@(600 * 1024));</div><div class="line">//    status = VTSessionSetProperty(session, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)@[800 * 1024 / 8, 1]);</div><div class="line">    //码率 单位是bit</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_AverageBitRate, (__bridge CFTypeRef)@(_videoConfig.bitrate * 8));</div><div class="line">    </div><div class="line">    //码率上限 单位为 byte/s</div><div class="line">    NSArray *limit = @[@(_videoConfig.bitrate),@(1)];</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)limit);</div><div class="line">    </div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_ExpectedFrameRate, (__bridge CFTypeRef)@(_videoConfig.fps));</div><div class="line"></div><div class="line">    // 设置实时编码输出（避免延迟）</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_RealTime, kCFBooleanFalse);</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_ProfileLevel,  kVTProfileLevel_H264_Baseline_AutoLevel);</div><div class="line">    </div><div class="line">    //控制是否产生B帧</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanFalse);</div><div class="line">    //16:9</div><div class="line">    VTSessionSetProperty(_compressionSession, kVTCompressionPropertyKey_AspectRatio16x9, kCFBooleanTrue);</div><div class="line">    </div><div class="line">    VTCompressionSessionPrepareToEncodeFrames(_compressionSession);</div></pre></td></tr></table></figure>
<p>开始编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//开始编码</div><div class="line">- (void)videoEncodeData:(CVPixelBufferRef)pixelBuffer time:(uint64_t)time&#123;</div><div class="line"></div><div class="line">    frameCount++;</div><div class="line">    </div><div class="line">    //CMTimeMake(a,b) a当前第几帧，b每秒钟多少帧。当前播放时间a/b</div><div class="line">    CMTime presentationTimeStamp = CMTimeMake(frameCount, 1000);</div><div class="line">    </div><div class="line">    //每一帧需要播放的时间</div><div class="line">    VTEncodeInfoFlags flags;</div><div class="line">    CMTime duration = CMTimeMake(1, _videoConfig.fps);</div><div class="line">    </div><div class="line">    NSDictionary *properties = nil;</div><div class="line">    if(frameCount % (int32_t)(self.videoConfig.keyframeInterval) == 0)&#123;//强制关键帧</div><div class="line">        properties = @&#123;(__bridge NSString *)kVTEncodeFrameOptionKey_ForceKeyFrame: @YES&#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSNumber *timeNumber = @(time);</div><div class="line">     OSStatus statusCode = VTCompressionSessionEncodeFrame(_compressionSession, pixelBuffer, presentationTimeStamp, duration, (__bridge CFDictionaryRef)properties, (__bridge void *)timeNumber, &amp;flags);</div><div class="line">    </div><div class="line">    if (statusCode != noErr) &#123;</div><div class="line">        NSLog(@&quot;H264: VTCompressionSessionEncodeFrame failed with %d&quot;, (int)statusCode);</div><div class="line">        </div><div class="line">        VTCompressionSessionInvalidate(_compressionSession);</div><div class="line">        CFRelease(_compressionSession);</div><div class="line">        _compressionSession = NULL;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;H264: VTCompressionSessionEncodeFrame Success&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码成功回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//编码完成的回调</div><div class="line">static void didCompressBuffer(void *VTref, void *VTFrameRef, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer)&#123;</div><div class="line"></div><div class="line">    LLYVideoEncode *videoEncode = (__bridge LLYVideoEncode *)VTref;</div><div class="line">    uint64_t timeStamp = [((__bridge_transfer NSNumber*)VTFrameRef) longLongValue];</div><div class="line">    </div><div class="line">    //编码后的原始数据</div><div class="line">    CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class="line">    CFArrayRef attachments = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, false);</div><div class="line">    </div><div class="line">    //判断关键帧</div><div class="line">    BOOL isKeyFrame = NO;</div><div class="line">    if (attachments != NULL) &#123;</div><div class="line">        CFDictionaryRef attachment;</div><div class="line">        CFBooleanRef dependsOnOthers;</div><div class="line">        attachment = (CFDictionaryRef)CFArrayGetValueAtIndex(attachments, 0);</div><div class="line">        dependsOnOthers = (CFBooleanRef)CFDictionaryGetValue(attachment, kCMSampleAttachmentKey_DependsOnOthers);</div><div class="line">        isKeyFrame = (dependsOnOthers == kCFBooleanFalse);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //关键帧需要把sps pps信息取出</div><div class="line">    if (isKeyFrame) &#123;</div><div class="line">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">        </div><div class="line">        size_t sparameterSetSize, sparameterSetCount;</div><div class="line">        const uint8_t *sparameterSet;</div><div class="line">        </div><div class="line">        //sps</div><div class="line">        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, NULL );</div><div class="line">        if (statusCode == noErr) &#123;</div><div class="line">            </div><div class="line">            //pps</div><div class="line">            size_t pparameterSetSize, pparameterSetCount;</div><div class="line">            const uint8_t *pparameterSet;</div><div class="line">            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, NULL );</div><div class="line">            if (statusCode == noErr) &#123;</div><div class="line">                </div><div class="line">                NSData *sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];</div><div class="line">                NSData *pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];</div><div class="line">                </div><div class="line">                if ([videoEncode.delegate respondsToSelector:@selector(videoEncode:sps:pps:time:)]  ) &#123;</div><div class="line">                    [videoEncode.delegate videoEncode:videoEncode sps:sps pps:pps time:timeStamp];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //视频数据 不管是不是关键帧都需要取出</div><div class="line">    //前4个字节表示长度后面的数据的长度</div><div class="line">    //除了关键帧,其它帧只有一个数据</div><div class="line">    </div><div class="line">    size_t length, totalLength;</div><div class="line">    char *dataPointer;</div><div class="line">    size_t offset = 0;</div><div class="line">    int const headLen = 4;// 返回的nalu数据前四个字节不是0001的startcode，而是大端模式的帧长度length</div><div class="line"></div><div class="line">    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(blockBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer);</div><div class="line">    if (statusCodeRet == noErr) &#123;</div><div class="line">        </div><div class="line">        // 循环获取nalu数据</div><div class="line">        while (offset &lt; totalLength - headLen) &#123;</div><div class="line">            </div><div class="line">            int NALUnitLength = 0;</div><div class="line">            memcpy(&amp;NALUnitLength, dataPointer + offset, headLen);</div><div class="line">            </div><div class="line">            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class="line">            NSData *naluData = [NSData dataWithBytes:dataPointer + headLen + offset length:NALUnitLength];</div><div class="line">            offset += headLen + NALUnitLength;</div><div class="line">            </div><div class="line">            if ([videoEncode.delegate respondsToSelector:@selector(videoEncode:frame:time:isKeyFrame:)]) &#123;</div><div class="line">                [videoEncode.delegate videoEncode:videoEncode frame:naluData time:timeStamp isKeyFrame:isKeyFrame];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是编码流程中比较关键的一环，需要将编码后的数据（H264数据）根据相应的数据格式取出来，用来做进行二次封装（封装为rtmp协议对应格式的数据）进行rtmp传输。不过这几种数据都是固定格式的，所以只要清楚相应的格式后，拆分了封装应该都是能解决的。</p>
<h3 id="3-拆分后的视频数据二次封装为rtmp格式包"><a href="#3-拆分后的视频数据二次封装为rtmp格式包" class="headerlink" title="3.拆分后的视频数据二次封装为rtmp格式包"></a>3.拆分后的视频数据二次封装为rtmp格式包</h3><p>sps和pps数据的封装(关键帧数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)packageKeyFrameSps:(NSData *)spsData pps:(NSData *)ppsData timestamp:(uint64_t)timestamp&#123;</div><div class="line">    </div><div class="line">    if (spsData.length &lt;= 0 || ppsData &lt;= 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_hasSendKeyFrame) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _hasSendKeyFrame = YES;</div><div class="line">    </div><div class="line">    const char *sps = spsData.bytes;</div><div class="line">    const char *pps = ppsData.bytes;</div><div class="line">    NSInteger sps_len = spsData.length;</div><div class="line">    NSInteger pps_len = ppsData.length;</div><div class="line">    </div><div class="line">    NSInteger total = sps_len + pps_len + 16;</div><div class="line">    uint8_t *body = (uint8_t *)malloc(total);</div><div class="line">    int index = 0;</div><div class="line">    </div><div class="line">    memset(body,0,total);</div><div class="line">    </div><div class="line">    body[index++] = 0x17;</div><div class="line">    body[index++] = 0x00;//sps_pps</div><div class="line">    </div><div class="line">    body[index++] = 0x00;</div><div class="line">    body[index++] = 0x00;</div><div class="line">    body[index++] = 0x00;</div><div class="line">    </div><div class="line">    body[index++] = 0x01;</div><div class="line">    body[index++] = sps[1];</div><div class="line">    body[index++] = sps[2];</div><div class="line">    body[index++] = sps[3];</div><div class="line">    body[index++] = 0xff;</div><div class="line">    </div><div class="line">    /*sps*/</div><div class="line">    body[index++]   = 0xe1;</div><div class="line">    body[index++] = (sps_len &gt;&gt; 8) &amp; 0xff;</div><div class="line">    body[index++] = sps_len &amp; 0xff;</div><div class="line">    memcpy(&amp;body[index],sps,sps_len);</div><div class="line">    index +=  sps_len;</div><div class="line">    </div><div class="line">    /*pps*/</div><div class="line">    body[index++]   = 0x01;</div><div class="line">    body[index++] = (pps_len &gt;&gt; 8) &amp; 0xff;</div><div class="line">    body[index++] = (pps_len) &amp; 0xff;</div><div class="line">    memcpy(&amp;body[index], pps, pps_len);</div><div class="line">    index +=  pps_len;</div><div class="line">    </div><div class="line">    if ([self.delegate respondsToSelector:@selector(videoPackage:didPacketFrame:)]) &#123;</div><div class="line">        NSData *data = [NSData dataWithBytes:body length:index];</div><div class="line">        </div><div class="line">        LLYFrame *frame = [[LLYFrame alloc] init];</div><div class="line">        frame.data = data;</div><div class="line">        frame.timestamp = 0;//一定是0</div><div class="line">        frame.msgLength = (int)data.length;</div><div class="line">        frame.msgTypeId = LLYMSGTypeID_VIDEO;</div><div class="line">        frame.msgStreamId = LLYStreamIDVideo;//video</div><div class="line">        frame.isKeyframe = YES;</div><div class="line">        [self.delegate videoPackage:self didPacketFrame:frame];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非关键帧数据的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (void)packageFrame:(NSData *)data timestamp:(uint64_t)timestamp isKeyFrame:(BOOL)isKeyFrame&#123;</div><div class="line"></div><div class="line">    if (!_hasSendKeyFrame) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSInteger i = 0;</div><div class="line">    NSInteger total = data.length + 9;</div><div class="line">    unsigned char *body = (unsigned char *)malloc(total);</div><div class="line">    </div><div class="line">    memset(body, 0, total);</div><div class="line">    </div><div class="line">    if (isKeyFrame) &#123;</div><div class="line">        body[i++] = 0x17;//1:I Frame 7:AVC</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        body[i++] = 0x27;//2:P Frame 7:AVC</div><div class="line">    &#125;</div><div class="line">    body[i++] = 0x01;//AVC NALU 不是psp_pps</div><div class="line">    </div><div class="line">    body[i++] = 0x00;</div><div class="line">    body[i++] = 0x00;</div><div class="line">    body[i++] = 0x00;//pts - dts</div><div class="line"></div><div class="line">    //长度数据</div><div class="line">    body[i++] = (data.length &gt;&gt; 24) &amp; 0xff;</div><div class="line">    body[i++] = (data.length &gt;&gt; 16) &amp; 0xff;</div><div class="line">    body[i++] = (data.length &gt;&gt;  8) &amp; 0xff;</div><div class="line">    body[i++] = (data.length ) &amp; 0xff;</div><div class="line"></div><div class="line">    memcpy(&amp;body[i], data.bytes, data.length);</div><div class="line">    </div><div class="line">    if ([self.delegate respondsToSelector:@selector(videoPackage:didPacketFrame:)]) &#123;</div><div class="line">        NSData *data = [NSData dataWithBytes:body length:total];</div><div class="line">        LLYFrame *frame = [[LLYFrame alloc]init];</div><div class="line">        frame.data = data;</div><div class="line">        frame.timestamp = (int)timestamp;</div><div class="line">        frame.msgLength = (int)data.length;</div><div class="line">        frame.msgTypeId = LLYMSGTypeID_VIDEO;</div><div class="line">        frame.msgStreamId = LLYStreamIDVideo;</div><div class="line">        frame.isKeyframe = isKeyFrame;</div><div class="line"></div><div class="line">        [self.delegate videoPackage:self didPacketFrame:frame];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-建立rtmp通道"><a href="#4-建立rtmp通道" class="headerlink" title="4.建立rtmp通道"></a>4.建立rtmp通道</h3><p>先要开始一个socket的通道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)connectToServer:(NSString *)host port:(UInt32)port&#123;</div><div class="line"></div><div class="line">    if (self.streamStatus &gt; 0) &#123;</div><div class="line">        [self close];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //输入流 用来读取数据</div><div class="line">    CFReadStreamRef readStream;</div><div class="line">    //输出流，用来发送数据</div><div class="line">    CFWriteStreamRef writeStream;</div><div class="line">    </div><div class="line">    if (port &lt;= 0) &#123;</div><div class="line">        //RTMP默认端口1935</div><div class="line">        port = 1935;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //建立socket链接</div><div class="line">    CFStreamCreatePairWithSocketToHost(NULL,(__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);</div><div class="line">    </div><div class="line">    //注意__bridge_transfer,转移对象的内存管理权</div><div class="line">    _inputStream           = (__bridge_transfer  NSInputStream  *)readStream;</div><div class="line">    _outputStream          = (__bridge_transfer  NSOutputStream *)writeStream;</div><div class="line"></div><div class="line">    _inputStream.delegate = self;</div><div class="line">    _outputStream.delegate = self;</div><div class="line">    </div><div class="line">    [_outputStream scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line">    [_inputStream  scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">    </div><div class="line">    [_inputStream open];</div><div class="line">    [_outputStream open];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和服务器建立一个rtmp通信，通过服务器返回的状态码发送相应的握手请求，在3次握手成功后，rtmp通道建立完成，就可以发送封二次封装好的数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)streamSession:(LLYStreamSession *)session didChangeStatus:(LLYStreamStatus)streamStatus&#123;</div><div class="line"></div><div class="line">    if (streamStatus &amp; NSStreamEventHasBytesAvailable) &#123;//收到数据</div><div class="line">        [self didReceivedata];</div><div class="line">        return;//return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (streamStatus &amp; NSStreamEventHasSpaceAvailable)&#123; //可以写数据</div><div class="line">        </div><div class="line">        if (_rtmpStatus == LLYRtmpSessionStatusConnected) &#123;</div><div class="line">            [self handshake0];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return;//return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if ((streamStatus &amp; NSStreamEventOpenCompleted) &amp;&amp;</div><div class="line">        _rtmpStatus &lt; LLYRtmpSessionStatusConnected) &#123;</div><div class="line">        self.rtmpStatus = LLYRtmpSessionStatusConnected;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (streamStatus &amp; NSStreamEventErrorOccurred) &#123;</div><div class="line">        self.rtmpStatus = LLYRtmpSessionStatusError;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (streamStatus &amp; NSStreamEventEndEncountered) &#123;</div><div class="line">        self.rtmpStatus = LLYRtmpSessionStatusNotConnected;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-rtmp推流"><a href="#5-rtmp推流" class="headerlink" title="5.rtmp推流"></a>5.rtmp推流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  Chunk Basic Header: HeaderType+ChannelID组成  1个字节</div><div class="line"> *     &gt;HeaderType(前两bit): 00-&gt;12字节  01-&gt;8字节</div><div class="line"> *     &gt;ChannelID(后6个bit): 02-&gt;Ping和ByteRead通道 03-&gt;Invoke通道 connect() publish()和自己写的NetConnection.Call() 04-&gt;Audio和Vidio通道</div><div class="line"> *</div><div class="line"> *  12字节举例</div><div class="line"> *  Chunk Message Header:timestamp + message_length+message_typ + msg_stream_id</div><div class="line"> *  message_typ :type为1,2,3,5,6的时候是协议控制消息</div><div class="line"> *</div><div class="line"> *               type为4的时候表示 User Control Messages [Event_type + Event_Data] Event_type有Stream Begin，Stream End...</div><div class="line"> *</div><div class="line"> *               type为8，音频数据</div><div class="line"> *</div><div class="line"> *               type为9，视频数据</div><div class="line"> *</div><div class="line"> *               type为18 元数据消息[AMF0]</div><div class="line"> *</div><div class="line"> *               type为20 命令消息 Command Message(RPC Message)</div><div class="line"> *               例如connect, createStream, publish, play, pause on the peer</div><div class="line"> *</div><div class="line"> *</div><div class="line"> *</div><div class="line"> */</div><div class="line">- (void)sendBuffer:(LLYFrame *)frame&#123;</div><div class="line">    dispatch_sync(_packageQueue, ^&#123;</div><div class="line">        </div><div class="line">        uint64_t ts = frame.timestamp;</div><div class="line">        </div><div class="line">        int streamId = frame.msgStreamId;</div><div class="line">        NSLog(@&quot;streamId------%d&quot;,streamId);</div><div class="line">        NSNumber *preTimestamp = self.preChunk[@(streamId)];</div><div class="line">        </div><div class="line">        uint8_t *chunk;</div><div class="line">        int offset = 0;</div><div class="line">        </div><div class="line">        if (preTimestamp == nil) &#123;//第一帧,音频或者视频</div><div class="line">            chunk = malloc(12);</div><div class="line">            chunk[0] = RTMP_CHUNK_TYPE_0/*0x00*/ | (streamId &amp; 0x1F); //前两个字节 00 表示12字节</div><div class="line">            offset += 1;</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, [NSMutableData be24:(uint32_t)ts], 3);</div><div class="line">            offset += 3;//时间戳3个字节</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, [NSMutableData be24:frame.msgLength], 3);</div><div class="line">            offset += 3;//消息长度3个字节</div><div class="line">            </div><div class="line">            int msgTypeId = frame.msgTypeId;//一个字节的消息类型</div><div class="line">            memcpy(chunk+offset, &amp;msgTypeId, 1);</div><div class="line">            offset += 1;</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, (uint8_t *)&amp;(_streamID), sizeof(_streamID));</div><div class="line">            offset += sizeof(_streamID);</div><div class="line">            </div><div class="line">        &#125;else&#123;//不是第一帧</div><div class="line">            chunk = malloc(8);</div><div class="line">            chunk[0] = RTMP_CHUNK_TYPE_1/*0x40*/ | (streamId &amp; 0x1F);//前两个字节01表示8字节</div><div class="line">            offset += 1;</div><div class="line">            </div><div class="line">            char *temp = [NSMutableData be24:(uint32_t)(ts - preTimestamp.integerValue)];</div><div class="line">            memcpy(chunk+offset, temp, 3);</div><div class="line">            offset += 3;</div><div class="line">            </div><div class="line">            memcpy(chunk+offset, [NSMutableData be24:frame.msgLength], 3);</div><div class="line">            offset += 3;</div><div class="line">            </div><div class="line">            int msgTypeId = frame.msgTypeId;</div><div class="line">            memcpy(chunk+offset, &amp;msgTypeId, 1);</div><div class="line">            offset += 1;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        self.preChunk[@(streamId)] = @(ts);</div><div class="line">        </div><div class="line">        uint8_t *bufferData = (uint8_t *)frame.data.bytes;</div><div class="line">        uint8_t *outp = (uint8_t *)malloc(frame.data.length + 64);</div><div class="line">        memcpy(outp, chunk, offset);</div><div class="line">        free(chunk);</div><div class="line">        </div><div class="line">        NSUInteger total = frame.data.length;</div><div class="line">        NSInteger step = MIN(total, _outChunkSize);</div><div class="line">        </div><div class="line">        memcpy(outp+offset, bufferData, step);</div><div class="line">        offset += step;</div><div class="line">        total  -= step;</div><div class="line">        bufferData += step;</div><div class="line">        </div><div class="line">        while (total &gt; 0) &#123;</div><div class="line">            step = MIN(total, _outChunkSize);</div><div class="line">            bufferData[-1] = RTMP_CHUNK_TYPE_3/*0xC0*/ | (streamId &amp; 0x1F);//11表示一个字节,直接跳过这个字节;</div><div class="line">            memcpy(outp+offset, bufferData - 1, step + 1);</div><div class="line">            </div><div class="line">            offset += step + 1;</div><div class="line">            total  -= step;</div><div class="line">            bufferData += step;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSData *tosend = [NSData dataWithBytes:outp length:offset];</div><div class="line">        free(outp);</div><div class="line">        [self writeData:tosend];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一切OK 推流地址应该就可以用VLC播放了。</p>
<p>具体代码参考我的 <a href="https://github.com/lilingyu0620/LLYRtmpDemo.git" target="_blank" rel="noopener">demo</a>.</p>
<p><a href="http://www.jianshu.com/p/37784e363b8a" target="_blank" rel="noopener">参考文档1</a></p>
<p><a href="http://www.jianshu.com/p/6dfe49b5dab8" target="_blank" rel="noopener">参考文档2</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/18/OpenGL-ES-3-0学习笔记-简介/" itemprop="url">
                  OpenGL ES 3.0学习笔记-简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-18T17:10:53+08:00" content="2017-02-18">
              2017-02-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/18/OpenGL-ES-3-0学习笔记-简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/18/OpenGL-ES-3-0学习笔记-简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="可编程管线的各个阶段"><a href="#可编程管线的各个阶段" class="headerlink" title="可编程管线的各个阶段"></a>可编程管线的各个阶段</h2><h3 id="1-顶点着色器"><a href="#1-顶点着色器" class="headerlink" title="1.顶点着色器"></a>1.顶点着色器</h3><p>顶点着色器实现了顶点操作的通用可编程方法。</p>
<p>顶点着色器的输入包括：</p>
<ul>
<li><p>着色器程序–描述顶点上执行操作的顶点着色器程序源代码或者可执行文件。</p>
</li>
<li><p>顶点着色器输入（或者属性）– 用顶点数组提供的每个顶点的数据。</p>
</li>
<li><p>统一变量– 顶点（或者片段）着色器使用的不变数据</p>
</li>
<li><p>采样器–代表顶点着色器使用纹理的特殊统一变量类型</p>
</li>
</ul>
<p>顶点着色器可以用于通过矩阵变换位置，计算照明公式来生成逐顶点颜色以及生成或者变换纹理坐标等基于顶点的传统操作。此外，因为顶点着色器由应用程序规定，所以它可以用于执行自定义计算，实施新的变换，照明或者传统的固定功能管线所不允许的基于顶点的效果。</p>
<p>简单实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#version 300 es//版本号                        </div><div class="line">uniform mat4 u_mvpMatrix;//变换矩阵</div><div class="line">//输入数据</div><div class="line">in vec4 a_position;//顶点坐标</div><div class="line">in vec4 a_color;//顶点颜色</div><div class="line">//输出数据</div><div class="line">out vec4 v_color;//顶点颜色</div><div class="line"> void main()                              </div><div class="line"> &#123;             </div><div class="line"> 	  v_color = a_color;                           </div><div class="line">     gl_Position = a_position * u_mvpMatrix;              </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="2-图元装配"><a href="#2-图元装配" class="headerlink" title="2.图元装配"></a>2.图元装配</h3><p>顶点着色器之后，管线的下一个阶段是图元装配。<br>图元是三角形，直线或者点精灵等几何对象。</p>
<p>对于每个图元，必须确定图元是否位于视锥体（屏幕上可见的3D空间区域）内，如果图元没有完全在视锥体内，则可能需要进行裁剪，如果图元完全处于该区域之外，它就会被抛弃。裁剪之后，顶点位置被转换为屏幕坐标。也可以执行一次淘汰操作，根据图元面向前方或者后方抛弃它们，裁剪和淘汰之后，图元便准备传递给管线的下一个阶段–光栅化阶段。</p>
<h3 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3.光栅化"></a>3.光栅化</h3><p>光栅化是将图元转化为一组二维片段的过程，然后，这些片段由片段着色器处理。这些二维片段代表着可在屏幕上绘制的像素。</p>
<h3 id="4-片段着色器"><a href="#4-片段着色器" class="headerlink" title="4.片段着色器"></a>4.片段着色器</h3><p>片段着色器为片段上的操作实现了通用的可编程方法。<br>片段着色器的输入：</p>
<ul>
<li><p>着色器程序–描述片段上所执行操作的片段着色器程序源代码或者可执行文件。</p>
</li>
<li><p>输入变量–光栅化单元用插值为每个片段生成的顶点着色器输出。</p>
</li>
<li><p>统一变量–片段（或者顶点）着色器使用的不变数据。</p>
</li>
<li><p>采样器–代表片段着色器所用纹理的特殊统一变量类型。</p>
</li>
</ul>
<p>简单实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#version 300 es                              </div><div class="line"> precision mediump float;//默认的精度限定符</div><div class="line"> in vec4 v_color;</div><div class="line">                      </div><div class="line"> out vec4 fragColor;                          </div><div class="line"> void main()                                  </div><div class="line"> &#123;                                            </div><div class="line">    fragColor = v_color;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="5-逐片段操作"><a href="#5-逐片段操作" class="headerlink" title="5.逐片段操作"></a>5.逐片段操作</h3><p>在逐片段操作阶段，在每个片段上执行如下功能：</p>
<ul>
<li><p>像素归属测试–这个测试确定帧缓冲区中位置（Xw,Yw）的像素目前是不是归OpenGL ES 所有。</p>
</li>
<li><p>裁剪测试–裁剪测试确定（Xw,Yw）是否位于作为OpenGL ES状态的一部分的裁剪矩形范围内。如果该片段位于裁剪区域之外，则被抛弃。</p>
</li>
<li><p>模板和深度测试–这些测试在输入片段的模板和深度值上进行，以确保片段是否应该被拒绝。</p>
</li>
<li><p>混合–混合将新生成的片段颜色值与保存在帧缓冲区（Xw,Yw）位置的颜色值组合起来。</p>
</li>
<li><p>抖动–抖动可用于最小化因为使用有限精度在帧缓冲区中保存颜色值而产生的伪像。</p>
</li>
</ul>
<p>在逐片段操作的最后，片段或者被拒绝，或者在帧缓冲区的（Xw,Yw）位置写入片段的代码，深度或者模板值。写入片段颜色 深度和模板值取决于启用的相应写入掩码。写入掩码可以更精细的控制写入相关缓冲区的颜色，深度和模板值。</p>
<h2 id="OpenGL-ES-3-0新功能"><a href="#OpenGL-ES-3-0新功能" class="headerlink" title="OpenGL ES 3.0新功能"></a>OpenGL ES 3.0新功能</h2><ul>
<li><p>纹理</p>
</li>
<li><p>着色器</p>
</li>
<li><p>几何形状</p>
</li>
<li><p>缓冲区对象</p>
</li>
<li><p>帧缓冲区</p>
</li>
</ul>
<h2 id="OpenGL-ES-3-0-和向后兼容性"><a href="#OpenGL-ES-3-0-和向后兼容性" class="headerlink" title="OpenGL ES 3.0 和向后兼容性"></a>OpenGL ES 3.0 和向后兼容性</h2><h2 id="EGL（iOS不支持）"><a href="#EGL（iOS不支持）" class="headerlink" title="EGL（iOS不支持）"></a>EGL（iOS不支持）</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/UML类图中类的关系/" itemprop="url">
                  UML类图中类的关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-08T16:22:32+08:00" content="2017-02-08">
              2017-02-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/08/UML类图中类的关系/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/08/UML类图中类的关系/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、关联关系"><a href="#一、关联关系" class="headerlink" title="一、关联关系"></a>一、关联关系</h2><p>关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等等。在UML类图中，用实线连接有关联关系的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必须的，可以根据需要增加，其目的是使类之间的关系更加明确。</p>
<h3 id="1-双向关联"><a href="#1-双向关联" class="headerlink" title="1.双向关联"></a>1.双向关联</h3><p>默认情况下，关联是双向的。例如：顾客(Customer)购买商品(Product)并拥有商品，反之，卖出的商品总有某个顾客与之相关联。因此，Customer类和Product类之间具有双向关联关系 如下图: </p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94.jpg" alt=""></p>
<h3 id="2-单向关联"><a href="#2-单向关联" class="headerlink" title="2.单向关联"></a>2.单向关联</h3><p>类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客(Customer)拥有地址(Address)，则Customer类与Address类具有单向关联关系 如下图:</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94.jpg" alt=""></p>
<h3 id="3-自关联"><a href="#3-自关联" class="headerlink" title="3.自关联"></a>3.自关联</h3><p>在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象<br>如下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/%E8%87%AA%E5%85%B3%E8%81%94.jpg" alt=""></p>
<h3 id="4-多重性关联"><a href="#4-多重性关联" class="headerlink" title="4.多重性关联"></a>4.多重性关联</h3><p>多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。</p>
<p>对象之间可以存在多种多重性关联关系，常见的多重性表示方式如下所示：</p>
<p>表示方式<br>多重性说明</p>
<p>1..1<br>表示另一个类的一个对象只与该类的一个对象有关系</p>
<p>0..*<br>表示另一个类的一个对象与该类的零个或多个对象有关系</p>
<p>1..*<br>表示另一个类的一个对象与该类的一个或多个对象有关系</p>
<p>0..1<br>表示另一个类的一个对象没有或只与该类的一个对象有关系</p>
<p>m..n<br>表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</p>
<p>如下图</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/%E5%A4%9A%E9%87%8D%E6%80%A7%E5%85%B3%E8%81%94.jpg" alt=""></p>
<h3 id="5-聚合关系"><a href="#5-聚合关系" class="headerlink" title="5.聚合关系"></a>5.聚合关系</h3><p>聚合(Aggregation)关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如：汽车发动机(Engine)是汽车(Car)的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系</p>
<p>如下图</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.jpg" alt=""></p>
<h3 id="6-组合关系"><a href="#6-组合关系" class="headerlink" title="6.组合关系"></a>6.组合关系</h3><p>组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如：人的头(Head)与嘴巴(Mouth)，嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系</p>
<p>如下图</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.jpg" alt=""></p>
<h2 id="二、依赖关系"><a href="#二、依赖关系" class="headerlink" title="二、依赖关系"></a>二、依赖关系</h2><p>依赖(Dependency)关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如：驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此类Driver依赖类Car</p>
<p>如下图<br><img src="http://ofy1hyquv.bkt.clouddn.com/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.jpg" alt=""></p>
<h2 id="三、泛化关系"><a href="#三、泛化关系" class="headerlink" title="三、泛化关系"></a>三、泛化关系</h2><p>泛化(Generalization)关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。在代码实现时，我们使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字、在C++/C#中使用冒号“：”来实现。例如：Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名(name)和年龄(age)，每一个Student和Teacher也都具有这两个属性，另外Student类增加了属性学号(studentNo)，Teacher类增加了属性教师编号(teacherNo)，Person类的方法包括行走move()和说话say()，Student类和Teacher类继承了这两个方法，而且Student类还新增方法study()，Teacher类还新增方法teach()</p>
<p>如下图<br><img src="http://ofy1hyquv.bkt.clouddn.com/%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.jpg" alt=""></p>
<h2 id="四、接口与实现关系"><a href="#四、接口与实现关系" class="headerlink" title="四、接口与实现关系"></a>四、接口与实现关系</h2><p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如：定义了一个交通工具接口Vehicle，包含一个抽象操作move()，在类Ship和类Car中都实现了该move()操作，不过具体的实现细节将会不一样</p>
<p>如下图<br><img src="http://ofy1hyquv.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/08/iOS并发编程指南/" itemprop="url">
                  iOS并发编程指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-08T10:04:02+08:00" content="2016-12-08">
              2016-12-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/08/iOS并发编程指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/08/iOS并发编程指南/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近又看了下官方关于并发编程的文档，简单做一下总结。</p>
<h2 id="并发和程序设计"><a href="#并发和程序设计" class="headerlink" title="并发和程序设计"></a>并发和程序设计</h2><h3 id="并发编程的几个概念："><a href="#并发编程的几个概念：" class="headerlink" title="并发编程的几个概念："></a>并发编程的几个概念：</h3><p>-</p>
<p>并发：并发表示同时发生多件事情的概念</p>
<p>并行：并行是多个任务同时发生并且同时运行直到结束</p>
<p>-</p>
<p>同步：同步指函数运行时会阻塞当前线程一直运行结束</p>
<p>异步：异步指函数运行时不会阻塞当前线程</p>
<p>-</p>
<p>串行：当前队列中的任务是顺序执行的</p>
<p>并行: 当前队列中的任务是并发执行的，没有特定的顺序</p>
<p>-</p>
<h3 id="并发的优点和缺点"><a href="#并发的优点和缺点" class="headerlink" title="并发的优点和缺点"></a>并发的优点和缺点</h3><p>优点：</p>
<pre><code>•    充分发挥多核处理器优势，将不同线程任务分配给不同的处理器，真正进入“并行运算”状态
•    将耗时的任务分配到其他线程执行，由主线程负责统一更新界面会使应用程序更加流畅，用户体验更好
•    当硬件处理器的数量增加，程序会运行更快，而程序无需做任何调整
</code></pre><p>缺点：</p>
<pre><code>增加了开销，并增加了整体的代码的复杂性，使得代码更难编写和调试
</code></pre><p>使用并发编程之前，你应该分解出可执行的工作单元，并确定你需要的队列。</p>
<h2 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>NSOperation是一个面向对象的方式来封装要异步执行的工作，被设计成结合操作队列(NSOperationQueue)使用，也可以自己单独使用</p>
<p>子类：</p>
<p>Target/Action 方式初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomethingWithObj:) object:nil];</div></pre></td></tr></table></figure>
<p>Block方式初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        //Do something here.</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>所有的NSOperation对象支持以下特性:</p>
<p>1.设置依赖关系</p>
<p>2.设置完成块</p>
<p>3.使用KVO通知监听你的Operations执行状态改变</p>
<p>4.设置优先级</p>
<p>5.取消操作</p>
<h3 id="自定义Operation（默认start为非并发）"><a href="#自定义Operation（默认start为非并发）" class="headerlink" title="自定义Operation（默认start为非并发）"></a>自定义Operation（默认start为非并发）</h3><p>1.继承NSOperation基类</p>
<p>2.至少实现下面两个方法：</p>
<p>initialization</p>
<p>main</p>
<p>3.其他可添加的方法</p>
<p>自定义的在主函数调用的方法</p>
<p>数据的存取方法</p>
<p>NSCoding协议的方法</p>
<h3 id="并发执行的配置操作"><a href="#并发执行的配置操作" class="headerlink" title="并发执行的配置操作"></a>并发执行的配置操作</h3><p>1.重写isConcurrent函数并返回YES</p>
<p>2.重写start函数</p>
<p>3.重写isExecuting和isFinished函数</p>
<h3 id="NSOperation属性列表"><a href="#NSOperation属性列表" class="headerlink" title="NSOperation属性列表"></a>NSOperation属性列表</h3><p>isCancelled 是否取消</p>
<p>isConcurrent 是否并发</p>
<p>isExecuting 是否正在执行</p>
<p>isFinished 是否已经完成</p>
<p>isReady 是否准备好要执行</p>
<p>dependencies(array) 依赖关系数组</p>
<p>queuePriority 优先级</p>
<p>completionBlock 完成块</p>
<p>优先级:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</div><div class="line">	NSOperationQueuePriorityVeryLow = -8L,</div><div class="line">	NSOperationQueuePriorityLow = -4L,</div><div class="line">	NSOperationQueuePriorityNormal = 0,</div><div class="line">	NSOperationQueuePriorityHigh = 4,</div><div class="line">	NSOperationQueuePriorityVeryHigh = 8</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><h3 id="串行队列-创建一个线程"><a href="#串行队列-创建一个线程" class="headerlink" title="串行队列(创建一个线程)"></a>串行队列(创建一个线程)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t sQueue = dispatch_queue_create(&quot;这是串行队列&quot;, NULL);</div></pre></td></tr></table></figure>
<h3 id="并发队列-创建多个线程"><a href="#并发队列-创建多个线程" class="headerlink" title="并发队列(创建多个线程)"></a>并发队列(创建多个线程)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t cQueue = dispatch_queue_create(&quot;这是并发队列&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<h3 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mQueue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<h3 id="后台队列"><a href="#后台队列" class="headerlink" title="后台队列"></a>后台队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t gQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</div></pre></td></tr></table></figure>
<h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<h3 id="同步执行-不会开辟新的线程"><a href="#同步执行-不会开辟新的线程" class="headerlink" title="同步执行(不会开辟新的线程)"></a>同步执行(不会开辟新的线程)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>以上可能有四种组合方式：</p>
<p>dispatch_sync + 串行队列 （串行执行）</p>
<p>dispatch_sync + 并发队列 （串行执行）</p>
<p>dispatch_async + 串行队列 （串行执行）</p>
<p>dispatch_async + 并发队列 （并行执行）</p>
<h3 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h3><p>将多个任务放到这个组里面，可以在所有的任务都结束后得到一个回调。</p>
<h3 id="dispatch-barrier-async-dispatch-queue-create"><a href="#dispatch-barrier-async-dispatch-queue-create" class="headerlink" title="dispatch_barrier_async + dispatch_queue_create()"></a>dispatch_barrier_async + dispatch_queue_create()</h3><p>使用时需要自己创建并发队列，不能使用后台队列。</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p>和dispatch_sync一样，是同步运行的，会阻塞当前线程。</p>
<h3 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h3><p>可以根据自己需要创建需要的signal数量，如果只创建一个则为串行执行。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>循环引用</p>
<p>死锁</p>
<p>相关<a href="https://github.com/lilingyu0620/Concurrency-Programming-Guide.git" target="_blank" rel="noopener">demo</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="- END -"></a>- END -</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/28/App-Programming-Guide-for-iOS/" itemprop="url">
                  App Programming Guide for iOS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-28T11:44:25+08:00" content="2016-11-28">
              2016-11-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/28/App-Programming-Guide-for-iOS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/28/App-Programming-Guide-for-iOS/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近看了下苹果官方文档这块，做一下总结。</p>
<h2 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h2><h3 id="一、短时间的后台执行"><a href="#一、短时间的后台执行" class="headerlink" title="一、短时间的后台执行"></a>一、短时间的后台执行</h3><p>1.使用 beginBackgroundTaskWithName 方法创建一个后台任务，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^&#123;</div><div class="line">       // Clean up any unfinished task business by marking where you</div><div class="line">       // stopped or ending the task outright.</div><div class="line">       [application endBackgroundTask:bgTask];</div><div class="line">       bgTask = UIBackgroundTaskInvalid;</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>该任务可以在后台运行180秒的时间，UIApllication提供了字段<br>backgroundTimeRemaining获取当前剩余时间。</p>
<p>2.使用NSURLSession的后台下载任务，可以在后台继续下载一段时间。创建一个后台任务的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSURLSession *)backgroundURLSession &#123;</div><div class="line">    static NSURLSession *session = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSString *identifier = @&quot;com.yourcompany.appId.BackgroundSession&quot;;</div><div class="line">        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:identifier];</div><div class="line">        sessionConfig.sessionSendsLaunchEvents = YES;//默认是YES</div><div class="line">        sessionConfig.discretionary = YES;//性能相关</div><div class="line">defaultSessionConfiguration];</div><div class="line">        session = [NSURLSession sessionWithConfiguration:sessionConfig</div><div class="line">                                                delegate:self</div><div class="line">                                           delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return session;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、长时间的后台运行"><a href="#二、长时间的后台运行" class="headerlink" title="二、长时间的后台运行"></a>二、长时间的后台运行</h3><p>有些App需要长时间在后台运行的，比如音乐播放器 录音App 导航App (Voice over IP)VoipApp 外设App 大量后台下载任务类。。。需要在Xcode上做相应的设置才行，参考下面这个图，在Capabilities的Background Modes标签中勾选你想实现的功能。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/iosguide01.png" alt=""></p>
<h2 id="实现特定功能的策略"><a href="#实现特定功能的策略" class="headerlink" title="实现特定功能的策略"></a>实现特定功能的策略</h2><h3 id="一、隐私策略-使用磁盘加密保护数据"><a href="#一、隐私策略-使用磁盘加密保护数据" class="headerlink" title="一、隐私策略,使用磁盘加密保护数据"></a>一、隐私策略,使用磁盘加密保护数据</h3><p>使用NSData类设置保护等级。<br>当写入新文件时，你可以使用NSData的writeToFile:options:error:方法,具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">[[NSData data] writeToFile:@&quot;文件需要写入的路径&quot; options:NSDataWritingAtomic error:&amp;error];</div></pre></td></tr></table></figure>
<p>options参数传入的即为文件的保护等级，具体枚举类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSDataWritingOptions) &#123;</div><div class="line">    NSDataWritingAtomic = 1UL &lt;&lt; 0,	//保存时提示使用辅助文件，相当于自动</div><div class="line">    NSDataWritingWithoutOverwriting,//提示,以防止覆盖现有的文件.不能和NSDataWritingAtomic合并使用。</div><div class="line">    NSDataWritingFileProtectionNone,//文件被加密但是当设备被锁屏时不能被密码保护</div><div class="line">    NSDataWritingFileProtectionComplete,//当设备被锁屏文件被加密且不能被访问   </div><div class="line">NSDataWritingFileProtectionCompleteUnlessOpen,//当设备被锁屏文件被加密且不能被访问，如果当文件被访问时设备锁屏，应用仍然可以在锁屏状态下访问文件.</div><div class="line">NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication,//文件被加密且不能访问直到设备启动，用户解锁一次后。</div><div class="line">    NSDataWritingFileProtectionMask,</div><div class="line">    // Options with old names for NSData writing methods. Please stop using these old names.</div><div class="line">    NSAtomicWrite = NSDataWritingAtomic	    // Deprecated name for NSDataWritingAtomic</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于已存在的文件，你可以使用NSFileManager的setAttributes:ofItemAtPath:error:方法。具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSFileManager defaultManager] setAttributes:@&#123;NSFileProtectionComplete:NSFileProtectionKey&#125; ofItemAtPath:@&quot;文件路径&quot; error:nil]</div></pre></td></tr></table></figure>
<p>NSFileManager的保护等级枚举值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSFileProtectionNone //文件未受保护，随时可以问 （Default）</div><div class="line"></div><div class="line">NSFileProtectionComplete //文件受到保护，而且只有在设备未被锁定时才可访问</div><div class="line"></div><div class="line">NSFileProtectionCompleteUntilFirstUserAuthenticatio//文件受到保护，直到设备启动且用户第一次输入密码</div><div class="line"></div><div class="line">NSFileProtectionCompleteUnlessOpen//文件受到保护，而且只有在设备未被锁定时才可打开，不过即便在设备被锁定时，已经打开的文件还是可以继续使用和写入</div></pre></td></tr></table></figure>
<h3 id="二、区别每一个用户"><a href="#二、区别每一个用户" class="headerlink" title="二、区别每一个用户"></a>二、区别每一个用户</h3><p>区别每一个用户或者设备主要有下面几种方式实现：</p>
<p>1.账号密码方式</p>
<p>2.设备唯一标识符   [[UIDevice currentDevice]identifierForVendor]；App卸载后再安装，值不一样。</p>
<p>3.广告标识符NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];<br>重置系统，值会重新生成。</p>
<p>4.三方框架(OpenUDID)等</p>
<h3 id="三、尊重的限制（评级）"><a href="#三、尊重的限制（评级）" class="headerlink" title="三、尊重的限制（评级）"></a>三、尊重的限制（评级）</h3><p>每个App都会有一个评级，而且App所展示的内容也有对应的评级，如果评级不在允许的范围，则不能使用该内容。这个评级系统是USA的。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/iosguide02.png" alt=""></p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/iosguide03.png" alt=""></p>
<p>具体获取方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL isBooksAllow = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;com.apple.content-rating.ExplicitBooksAllowed&quot;];</div></pre></td></tr></table></figure>
<p>如果objectForKey返回为空，这意味着这个限制信息是不可用的。在这种情况下,您的应用程序可以使用自己的策略来确定适当的评级。</p>
<h3 id="四、保存当前App的状态"><a href="#四、保存当前App的状态" class="headerlink" title="四、保存当前App的状态"></a>四、保存当前App的状态</h3><p>实现appdelegate的下面两个代理，告诉系统你需要保存和恢复当前App的状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder &#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL) application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder &#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化每个VC的时候，需要为restorationIdentifier和restorationClass这两个字段赋值，否则，不能保存VC的状态。</p>
<p>具体保存和恢复过程如下：</p>
<p>保存过程：<br>1.告诉UIKit支持保存<br>2.告诉UIKit什么控制器和视图需要保存<br>3.给保存的对象编码</p>
<p>恢复过程:<br>1.告诉UIKit支持恢复<br>2.提供需要的UIKit对象<br>3.让保存的对象恢复原样</p>
<p>对应的每个VC需要遵守UIViewControllerRestoration,UIStateRestoring这两个协议，然后自己实现下面这3个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+ (nullable UIViewController *) viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder&#123;</div><div class="line">    UIViewController *vc = (UIViewController *)[UIApplication sharedApplication].delegate.window.rootViewController;</div><div class="line">    return vc;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)encodeRestorableStateWithCoder:(NSCoder *)coder</div><div class="line">&#123;</div><div class="line">    [coder encodeObject:self.progressLabel.text forKey:@&quot;LabelTextKey&quot;];</div><div class="line">    CGFloat progress = self.downloadProgress.progress;</div><div class="line">    [coder encodeObject:[NSString stringWithFormat:@&quot;%.2f&quot;,self.downloadProgress.progress] forKey:@&quot;ProgressKey&quot;];</div><div class="line">    [super encodeRestorableStateWithCoder:coder];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)decodeRestorableStateWithCoder:(NSCoder *)coder</div><div class="line">&#123;</div><div class="line">    NSString *string = [coder decodeObjectForKey:@&quot;LabelTextKey&quot;];</div><div class="line">    self.progressLabel.text = string;</div><div class="line">    CGFloat progress = [[coder decodeObjectForKey:@&quot;ProgressKey&quot;] floatValue];</div><div class="line">    self.downloadProgress.progress = progress;</div><div class="line">    [super decodeRestorableStateWithCoder:coder];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是保存和恢复的流程图：</p>
<p>保存<br><img src="http://ofy1hyquv.bkt.clouddn.com/iosguide04.png" alt=""></p>
<p>恢复<br><img src="http://ofy1hyquv.bkt.clouddn.com/iosguide05.png" alt=""></p>
<h2 id="App之间的通信"><a href="#App之间的通信" class="headerlink" title="App之间的通信"></a>App之间的通信</h2><h3 id="一、AirDrop"><a href="#一、AirDrop" class="headerlink" title="一、AirDrop"></a>一、AirDrop</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/iosguide06.png" alt=""></p>
<p>创建一个UIActivityViewController实例即可实现airdrop功能，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[[[NSBundle mainBundle] URLForResource:@&quot;Steve&quot; withExtension:@&quot;pdf&quot;]] applicationActivities:@[[[UIActivity alloc] init]]];</div><div class="line">    </div><div class="line">    // hide AirDrop</div><div class="line">//     activity.excludedActivityTypes = @[UIActivityTypeAirDrop];</div><div class="line">    </div><div class="line">    UIPopoverPresentationController *popover = activity.popoverPresentationController;</div><div class="line">    if (popover) &#123;</div><div class="line">        popover.sourceView = self.activityButton;</div><div class="line">        popover.permittedArrowDirections = UIPopoverArrowDirectionAny;</div><div class="line">    &#125;</div><div class="line">    //只能模态的显示</div><div class="line">    [self presentViewController:activity animated:YES completion:NULL];</div></pre></td></tr></table></figure>
<p>其中，excludedActivityTypes字段可以控制界面显示内容。</p>
<p>tips:因为 UIActivityViewController 只支持模态显示，在iPad上使用时，需要使用UIPopoverPresentationController设置显示样式。</p>
<h3 id="二、URL-Schemes"><a href="#二、URL-Schemes" class="headerlink" title="二、URL Schemes"></a>二、URL Schemes</h3><p>Schemes表示一个URL中最初始的位置即://之前的那段字符<br>比如<a href="http://www.apple.com这个网址的Schemes是http,支持浏览器打开。" target="_blank" rel="noopener">http://www.apple.com这个网址的Schemes是http,支持浏览器打开。</a></p>
<p>如果一个app设置了Url Schemes,则可以通过这个url从第三方打开该APP，并可以传递一些参数。<br>每个URL必须能唯一标识一个APP，如果Url Schemes发生冲突，则最后被安装的APP会被调用。</p>
<p>系统的APP的URL Schemes优先级最高。</p>
<p>PS: iOS9新增了一个白名单，苹果规定开发者只能设置50个 URL Schemes 来打开别的应用，在openurl之前要先用canOpenUrl判断URL是否能被打开，但是返回上一个App不需要判断，也不用设置白名单</p>
<h3 id="三、KeyChain"><a href="#三、KeyChain" class="headerlink" title="三、KeyChain"></a>三、KeyChain</h3><p>KeyChain是苹果提供的一种安全的保存用户名、密码、证书的方式，将敏感信息保存在keychain中后，这些信息不会随着app的卸载而丢失，除非开发人员在app中手动删除敏感信息，否则，这些信息将会一直保存在keychain中.</p>
<p>手机刷机或者恢复出厂后数据会丢失。</p>
<p>iOS10以后，使用KeyChain需要在Xcode的Capabilities中打开KeyChain权限，否则无法获取保存和读取数据的权限。</p>
<h3 id="四、UIPasteboard"><a href="#四、UIPasteboard" class="headerlink" title="四、UIPasteboard"></a>四、UIPasteboard</h3><p>粘贴板分为系统粘贴板和自定义粘贴板，自定义粘贴板只能同组的APP可以互相访问，系统的粘贴板所有的App都可以访问。</p>
<p>详见<a href="https://github.com/lilingyu0620/iOS-APP-Communication.git" target="_blank" rel="noopener">App之间的通信demo</a></p>
<h2 id="性能tips"><a href="#性能tips" class="headerlink" title="性能tips"></a>性能tips</h2><h3 id="一、像素混合"><a href="#一、像素混合" class="headerlink" title="一、像素混合"></a>一、像素混合</h3><p>当UILabel的背景色和父视图的背景色不一致，或者几个重叠的控件之间的背景色不一致时，会出现像素混合的问题，修改方法是将所有的控件背景色调为一致。</p>
<h3 id="二、离屏渲染"><a href="#二、离屏渲染" class="headerlink" title="二、离屏渲染"></a>二、离屏渲染</h3><p>给控件设置圆角的时候会出现离屏渲染的问题，如果是UIImageView，可以通过重画UIImage为圆形图片，再赋值给UIImageView的方式解决，具体代码参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)lly_drawRadiusWithRoundCorner:(CGFloat)radius andSize:(CGSize) size&#123;</div><div class="line"></div><div class="line">    CGRect rect = CGRectMake(0,0,size.width,size.height);</div><div class="line">    </div><div class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, NO, [UIScreen mainScreen].scale);</div><div class="line">    CGContextAddPath(UIGraphicsGetCurrentContext(), [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)].CGPath);</div><div class="line">    CGContextClip(UIGraphicsGetCurrentContext());</div><div class="line">    </div><div class="line">    [self drawInRect:rect];</div><div class="line">    </div><div class="line">    CGContextDrawPath(UIGraphicsGetCurrentContext(), kCGPathFillStroke);</div><div class="line">    </div><div class="line">    UIImage *output = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    </div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    </div><div class="line">    return  output;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="–-END-–"><a href="#–-END-–" class="headerlink" title="– END –"></a>– END –</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">34</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
