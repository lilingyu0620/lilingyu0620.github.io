<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" itemprop="url">
                  使用AudioQueue实现一个音频播放(二)--边播边缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T16:01:06+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://llyblog.com/2018/05/07/使用AudioQueue实现一个音频播放器/" target="_blank" rel="noopener">前一篇文章</a>中介绍了使用AuidoQueue实现一个音频播放器的功能,最近我又把这个项目完善了一下，做了一个边播边缓存的功能。</p>
<p>因为播放部分的逻辑我们已经完成，这里主要是怎么缓存数据的问题，实现之前我想到了2种方案。</p>
<h3 id="方案一-在didReceiveDataBlock中缓存文件"><a href="#方案一-在didReceiveDataBlock中缓存文件" class="headerlink" title="方案一 在didReceiveDataBlock中缓存文件"></a>方案一 在didReceiveDataBlock中缓存文件</h3><p>直接在拿到音频数据进行播放的同时就将数据写入文件，这种方案的优点是实时性，播放过的音频数据都会被缓存起来，缺点就是缓存的文件可能并不是一个完整的音频，比如播了1分钟后seek到2分钟的地方继续播，中间1分钟的数据可能就没有收到，这就导致缓存的文件是有问题的，如果下次直接播这个本地文件可能就凉凉了。。。</p>
<h3 id="方案二-在success的回调中缓存数据"><a href="#方案二-在success的回调中缓存数据" class="headerlink" title="方案二 在success的回调中缓存数据"></a>方案二 在success的回调中缓存数据</h3><p>在success中回调回来的数据就是完整的音频数据，缓存这个数据不会出现数据不完整的情况，但是这个回调并不是实时返回的，会在整个音频的数据都获取到以后才会返回，有一个延迟，如果网络不太好，可能直到音频播放完了才会返回。</p>
<p>考虑到方案的可行性和数据的可用性，这里我选择了方案二，毕竟完整的数据比缓存的实时性更重要一些。当然，这个方案一我觉得还是有优化的空间，如果能够优化到保证了数据的完整性，会比方案二更优。</p>
<h3 id="增加的模块"><a href="#增加的模块" class="headerlink" title="增加的模块"></a>增加的模块</h3><p>这里我增加了2个模块，一个是文件的操作模块，还有一个是网络模块。</p>
<h4 id="LLYFileManager"><a href="#LLYFileManager" class="headerlink" title="LLYFileManager"></a>LLYFileManager</h4><p>文件操作模块是对音频数据的存储相关操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@interface LLYFileManager : NSObject</div><div class="line"></div><div class="line">//网络地址转本地地址</div><div class="line">+ (NSString *)pathWithUrl:(NSString *)fileUrl;</div><div class="line">//将数据保存到本地目录下</div><div class="line">+ (BOOL)saveFileWithPath:(NSString *)path fileObject:(id)fileObject;</div><div class="line">//判断当前url对应的文件是否已经缓存</div><div class="line">+ (BOOL)isFileExit:(NSString *)url;</div><div class="line">//获取文件大小</div><div class="line">+ (unsigned long long)fileSizeWithFilePath:(NSString *)filePath;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="LLYHttpSessionManager"><a href="#LLYHttpSessionManager" class="headerlink" title="LLYHttpSessionManager"></a>LLYHttpSessionManager</h4><p>网络模块是基于AFNetworking做的一个二次封装<a href="http://llyblog.com/2018/06/14/AFNetworking学习笔记与实践/" target="_blank" rel="noopener">(参考这篇文章)</a>，主要就是请求音频数据。</p>
<h3 id="播放优化"><a href="#播放优化" class="headerlink" title="播放优化"></a>播放优化</h3><p>在播放前，我们需判断一下当前url对应的文件是否已经下载到本地了，如果已经下载就直接播本地的文件，否则还是走网络播放的逻辑。</p>
<p>这个判断逻辑我是这样处理的，先发送一个http head请求，拿到对应url文件的countOfBytesExpectedToReceive，然后将countOfBytesExpectedToReceive和本地文件大小（fileSize）进行比较，如果fileSize &gt;= contentExceptLength，则说明本地文件是完整的音频文件，可以直接播放，否则的话还是走网络播放的逻辑，并在success回调中覆盖之前的不完整文件。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioPlayer.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/AFNetworking学习笔记与实践/" itemprop="url">
                  AFNetworking学习笔记与实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T09:58:47+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/AFNetworking学习笔记与实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/AFNetworking学习笔记与实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从AF使用NSURLSession重写之后，还没有看过源码，NSURLSession是基于NSURLConnection的封装，应该是汲取了AF之前的设计，内部封装了一个NSOperation来实现异步请求。最近要做一个音频播放的边播边缓存的功能，网路请求这块需要封装一下，随便研究一下AF的源码，这里我按模块逐个分析一下。</p>
<h4 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h4><p>这个模块是AF中最大也是最重要的一个模块，它封装了一个session,提供了一系列的初始化方法和创建task的方法。如果大家对session和task的概念还不太理解，可以先看一下NSURLSession这个类的相关内容（这个大概说一下，session是管理所有网络请求的，每一个网络请求是一个task，task是使用session创建的，所有task共享session的相关设置）。</p>
<p>先来看一下创建task的方法，这里总共有datatask,uploadtask和downloadtask三种task，不过他们的创建逻辑都是一样的，以datatask为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看看上面这个宏的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</div><div class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</div><div class="line">        // Fix of bug</div><div class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</div><div class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</div><div class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</div><div class="line">    &#125; else &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static dispatch_queue_t url_session_manager_creation_queue() &#123;</div><div class="line">    static dispatch_queue_t af_url_session_manager_creation_queue;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return af_url_session_manager_creation_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里这样做主要是为了解决ios8之前的一个bug，如果异步同时创建task的话，task的id有可能是一样的，这会导致回调时出现问题（completionHandler被替换），为了解决这个问题，创建task的操作都放在一个串行队列中执行。</p>
<p>然后看一下添加代理这个又是要干嘛</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，af为每一个task都创建了一个delegate，然后将代理存在了self.mutableTaskDelegatesKeyedByTaskIdentifier这个字典中，键值是task的id,这里也解释了上面的为啥要同步创建task,那么它为啥要为每个task添加一个代理呢，我们继续往下看。</p>
<p>看完task的创建，然后我们再来看一下数据的回调。<strong>af为每个NSURLSession的回调函数创建了对应block和setBlock的方法，如果你需要哪个代理里面的数据，直接创建对应的block即可。</strong></p>
<p>我们先来看最常用的回调方法，即请求完成的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line">        </div><div class="line">        //将该task的代理从字典中移除</div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看有点奇怪，这2方法名一毛一样啊。没有错，这两个方法是同一个代理方法，只是他们的实现对象是不一样的，第一个的实现对象是AFURLSessionManager类,第二个的实现对象则是AFURLSessionManagerTaskDelegate这个类，这里就解释上面的为啥要为每一个task设置一个代理，af这里其实是吧NSURLSession的代理又包了一层，将NSURLSession的数据都传到AFURLSessionManagerTaskDelegate这个类里面去处理了。</p>
<p>然后我们看一下这个回调中对数据的处理，可以看到回调的返回都是放在一个gcd的group中处理的，如果我们设置了返回处理线程的话就使用设置的线程，否则会在主线程中处理数据的返回，如果有错误是直接返回了，没有错误的话，会先使用responeseSerializer去验证一下返回的数据格式是否合法，这个类我们下面在细看。</p>
<p>继续看其他几个我觉得比较常用的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">          dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">didReceiveResponse:(NSURLResponse *)response</div><div class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</div><div class="line">&#123;</div><div class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</div><div class="line"></div><div class="line">    if (self.dataTaskDidReceiveResponse) &#123;</div><div class="line">        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">          dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</div><div class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</div><div class="line"></div><div class="line">    if (self.dataTaskDidReceiveData) &#123;</div><div class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</div><div class="line">    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</div><div class="line"></div><div class="line">	//这里保存的数据会在complete的回调中使用</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这2个回调一个是收到responese被触发，这个回调可以拿到相应头部信息，比如接收文件的大小，格式等，一个是收到数据时被触发，进度相关的信息就在通过这个回调拿到的。<strong>还有一点就是，download的task不会走datatask的代理，意味着download的数据只能在下载完成后通过文件的方式拿到。</strong></p>
<h4 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h4><p>这个类就是继承了AFURLSessionManager，然后提供了一些封装好的创建task的方法。平时二次封装也是使用这个类就行。</p>
<p>然后这个类有三个比较重要的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;</div></pre></td></tr></table></figure>
<p>这里简单介绍每个属性的用途，下面还有详解。<br>requestSerializer主要用来设置httpheader，responseSerializer主要用来解析返回数据是否合法，<br>securityPolicy主要用来验证服务器证书。</p>
<h4 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h4><p>先来看一下AFHTTPRequestSerializer在AFHTTPSessionManager中是如何使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在调用AFURLSessionManager的创建task方法前，会先调用一下下面这个方法生成一个request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div></pre></td></tr></table></figure>
<p>那我们来具体看一下这个方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</div><div class="line">                                 URLString:(NSString *)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(method);</div><div class="line">    NSParameterAssert(URLString);</div><div class="line"></div><div class="line">    NSURL *url = [NSURL URLWithString:URLString];</div><div class="line"></div><div class="line">    NSParameterAssert(url);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</div><div class="line">    mutableRequest.HTTPMethod = method;</div><div class="line"></div><div class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</div><div class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</div><div class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</div><div class="line"></div><div class="line">	return mutableRequest;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSString *query = nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                case AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</div><div class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体流程：</p>
<ul>
<li>使用url和method创建一个mutableRequest，</li>
<li>kvo相关属性，如果不为空则kvc到mutableRequest</li>
<li>设置HTTPRequestHeaders数组中相关属性到mutableRequest</li>
<li>将传入的参数做一下url编码</li>
<li>如果是get，head,delete方式，将参数加到url后面，否则，将参数设置为mutableRequest的body，同时设置mutableRequest的Content-Type.</li>
</ul>
<p>可以看出，这个类的主要作用就是创建request，给request设置相应的header和body,对url和参数进行编码(url使用URLEncode,body使用UNICode编码).</p>
<h4 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h4><p>这个类在上面的complete回调中有提到，这里具体分析。</p>
<p>af一共提供了7种ResponseSerializer，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">AFHTTPResponseSerializer</div><div class="line"></div><div class="line">AFJSONResponseSerializer</div><div class="line"></div><div class="line">AFXMLParserResponseSerializer</div><div class="line"></div><div class="line">AFXMLDocumentResponseSerializer</div><div class="line"></div><div class="line">AFPropertyListResponseSerializer</div><div class="line"></div><div class="line">AFImageResponseSerializer</div><div class="line"></div><div class="line">AFCompoundResponseSerializer</div></pre></td></tr></table></figure>
<p>不同的response针对不同的数据类型。</p>
<p>他们的主要区别其实就在acceptableContentTypes这个属性上，它是一个集合，用来存储我们需要接受的数据类型。</p>
<p>比如JSON的acceptableContentTypes为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</div></pre></td></tr></table></figure>
<p>IMAGE的acceptableContentTypes为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;image/tiff&quot;, @&quot;image/jpeg&quot;, @&quot;image/gif&quot;, @&quot;image/png&quot;, @&quot;image/ico&quot;, @&quot;image/x-icon&quot;, @&quot;image/bmp&quot;, @&quot;image/x-bmp&quot;, @&quot;image/x-xbitmap&quot;, @&quot;image/x-win-bitmap&quot;, nil];</div></pre></td></tr></table></figure>
<p>我们可以通过NSHTTPSessionManager的responseSerializer修改你需要的数据类型。</p>
<p>回到之前的complete回调，看看具体怎么使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</div><div class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</div><div class="line"></div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[response MIMEType] 这个type就是当前服务器返回的数据的格式，需要self.acceptableContentTypes这个集合中包含上面的type，解析数据的时候才会返回成功，所以，如果遇到解析失败的话，可以断点到这里看一下这个type然后手动添加到acceptableContentTypes这个集合中。</p>
<h4 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h4><p>af提供了三种验证证书的方式，第一种不需要本地证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123;</div><div class="line">    AFSSLPinningModeNone,//默认方式，只需要验证服务器返回的证书是否合法</div><div class="line">    AFSSLPinningModePublicKey,//需要验证本地证书中的公钥是否包含服务器返回的证书中的公钥</div><div class="line">    AFSSLPinningModeCertificate,//需要验证本地证书是否在服务器证书的证书链中</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对应的有几种不同的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123;</div><div class="line">    NSArray *paths = [bundle pathsForResourcesOfType:@&quot;cer&quot; inDirectory:@&quot;.&quot;];</div><div class="line"></div><div class="line">    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];</div><div class="line">    for (NSString *path in paths) &#123;</div><div class="line">        NSData *certificateData = [NSData dataWithContentsOfFile:path];</div><div class="line">        [certificates addObject:certificateData];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [NSSet setWithSet:certificates];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)defaultPinnedCertificates &#123;</div><div class="line">    static NSSet *_defaultPinnedCertificates = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSBundle *bundle = [NSBundle bundleForClass:[self class]];</div><div class="line">        _defaultPinnedCertificates = [self certificatesInBundle:bundle];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _defaultPinnedCertificates;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)defaultPolicy &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</div><div class="line">    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = pinningMode;</div><div class="line"></div><div class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们看一下到底是如何进行证书验证的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(NSString *)domain</div><div class="line">&#123;</div><div class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</div><div class="line">        // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</div><div class="line">        //  According to the docs, you should only trust your provided certs for evaluation.</div><div class="line">        //  Pinned certificates are added to the trust. Without pinned certificates,</div><div class="line">        //  there is nothing to evaluate against.</div><div class="line">        //</div><div class="line">        //  From Apple Docs:</div><div class="line">        //          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</div><div class="line">        //           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</div><div class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableArray *policies = [NSMutableArray array];</div><div class="line">    if (self.validatesDomainName) &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</div><div class="line">    &#125; else &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</div><div class="line"></div><div class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    switch (self.SSLPinningMode) &#123;</div><div class="line">        case AFSSLPinningModeNone:</div><div class="line">        default:</div><div class="line">            return NO;</div><div class="line">        case AFSSLPinningModeCertificate: &#123;</div><div class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</div><div class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</div><div class="line"></div><div class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                return NO;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</div><div class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">            </div><div class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    return YES;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        case AFSSLPinningModePublicKey: &#123;</div><div class="line">            NSUInteger trustedPublicKeyCount = 0;</div><div class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            for (id trustChainPublicKey in publicKeys) &#123;</div><div class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</div><div class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += 1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return trustedPublicKeyCount &gt; 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</div><div class="line">    BOOL isValid = NO;</div><div class="line">    SecTrustResultType result;</div><div class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out);</div><div class="line"></div><div class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</div><div class="line"></div><div class="line">_out:</div><div class="line">    return isValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重点看一下self.allowInvalidCertificates这个参数，可以看到，如果使用默认的验证策略，同时self.allowInvalidCertificates = YES的话，会直接返回YES，相当于没有验证，所有这里我们一般将self.allowInvalidCertificates = NO。self.validatesDomainName这个参数默认为YES就可以了。</p>
<p>验证服务器证书是否合法的方法为AFServerTrustIsValid，这个方法里面就是调用的系统的方法。</p>
<p>那这个验证方法到底在哪里调用的呢，我们看一下下面这个代理，在NSURLSessionManager中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</div><div class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</div><div class="line">&#123;</div><div class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">    __block NSURLCredential *credential = nil;</div><div class="line"></div><div class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</div><div class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</div><div class="line">    &#125; else &#123;</div><div class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">                if (credential) &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">                &#125; else &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的https请求都会先进这个代理，这个challenge.protectionSpace对象中就是服务器发过来的需要客户端验证的证书，域名等相关重要信息，然后af调用evaluateServerTrust这个方法对相关信息进行验证。</p>
<h3 id="实战，简单的二次封装"><a href="#实战，简单的二次封装" class="headerlink" title="实战，简单的二次封装"></a>实战，简单的二次封装</h3><p>我这边使用一个单例来管理AFHTTPSessionManager,在init方法中，设置相关delegate对应的block.这里设置block主要是满足我需要在开始获取到音频数据的时候就对数据进行处理，不需要等到整个请求完成再处理数据的需求。如果需要其他delegate的信息，添加相应的block即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)shareInstance&#123;</div><div class="line">    static LLYHttpSessionManager *_llyHttpSessionManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _llyHttpSessionManager = [[LLYHttpSessionManager alloc]init];</div><div class="line">    &#125;);</div><div class="line">    return _llyHttpSessionManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init&#123;</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        _httpSessionManager = [[AFHTTPSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">        _httpSessionManager.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line">//        [_httpSessionManager.requestSerializer setValue:[self generateXUserAgent] forHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">//        [_httpSessionManager.requestSerializer setValue:[self generateClientCookie] forHTTPHeaderField:@&quot;Cookie&quot;];</div><div class="line">        </div><div class="line">        __weak __typeof(self)weakSelf = self;</div><div class="line">        </div><div class="line">        [_httpSessionManager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) &#123;</div><div class="line">            if (weakSelf.didReceiveResponseBlock) &#123;</div><div class="line">                weakSelf.didReceiveResponseBlock(session, dataTask, response);</div><div class="line">            &#125;</div><div class="line">            return NSURLSessionResponseAllow;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        [_httpSessionManager setDataTaskDidReceiveDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSData * _Nonnull data) &#123;</div><div class="line">            if (weakSelf.didReceiveDataBlock) &#123;</div><div class="line">                weakSelf.didReceiveDataBlock(session, dataTask, data);</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        //默认json</div><div class="line">        self.fileType = LLYHttpFileType_JSON;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为我这边需要请求音视频的数据，af提供的几种responese默认是不支持音视频格式的，所有我封装了几种文件type，每种type对应不同的responese</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, LLYHttpFileType) &#123;</div><div class="line">    LLYHttpFileType_JSON = 0,</div><div class="line">    LLYHttpFileType_IMAGE,</div><div class="line">    LLYHttpFileType_AUDIO,</div><div class="line">    LLYHttpFileType_VIDEO</div><div class="line">&#125;;</div><div class="line"></div><div class="line">- (void)setResponseSerializer:(LLYHttpFileType)fileType&#123;</div><div class="line">    </div><div class="line">    switch (fileType) &#123;</div><div class="line">        case LLYHttpFileType_JSON:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_IMAGE:</div><div class="line">        &#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFImageResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_AUDIO:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">            _httpSessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;audio/mpeg&quot;,nil];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_VIDEO:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">            _httpSessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;video/mp4&quot;,@&quot;video/mpeg&quot;,nil];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">        &#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后提供了2个block，分别是didReceiveResponseBlock和didReceiveDataBlock，如果需要拿到请求过程中的相关数据和信息，直接实现这2个block就ok了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) DidReceiveResponseBlock didReceiveResponseBlock;</div><div class="line">@property (nonatomic, copy) DidReceiveDataBlock didReceiveDataBlock;</div></pre></td></tr></table></figure>
<p>针对不同的数据类型，我这边提供了相应的task的创建方法，然后还提供了一个总的创建task的方法和一个下载方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestJSONWithMethod:(LLYHttpMethod)method</div><div class="line">                                       urlString:(nullable NSString *)URLString</div><div class="line">                                      parameters:(nullable id)parameters</div><div class="line">                                        progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                         success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                             failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestIMAGEWithMethod:(LLYHttpMethod)method</div><div class="line">                                           urlString:(nullable NSString *)URLString</div><div class="line">                                          parameters:(nullable id)parameters</div><div class="line">                                            progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                             success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                             failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestAUDIOWithMethod:(LLYHttpMethod)method</div><div class="line">                                            urlString:(nullable NSString *)URLString</div><div class="line">                                           parameters:(nullable id)parameters</div><div class="line">                                             progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                              success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                              failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestVIDEOWithMethod:(LLYHttpMethod)method</div><div class="line">                                            urlString:(nullable NSString *)URLString</div><div class="line">                                           parameters:(nullable id)parameters</div><div class="line">                                             progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                              success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                              failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestWithMethod:(LLYHttpMethod)method</div><div class="line">                                        fileType:(LLYHttpFileType)fileType</div><div class="line">                              urlString:(nullable NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure</div><div class="line">;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDownloadTask *)downloadWithUrl:(nullable NSString *)urlString</div><div class="line">                                     progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgressBlock</div><div class="line">                                  destination:(nullable NSURL * _Nullable(^)(NSURL * _Nullable targetPath, NSURLResponse * _Nullable response))destination</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse * _Nullable response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>实现部分就比较简单了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionTask *)requestWithMethod:(LLYHttpMethod)method</div><div class="line">                                        fileType:(LLYHttpFileType)fileType</div><div class="line">                                       urlString:(NSString *)URLString</div><div class="line">                                      parameters:(nullable id)parameters</div><div class="line">                                        progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    self.fileType = fileType;</div><div class="line">    </div><div class="line">    NSURLSessionTask *task = nil;</div><div class="line">    </div><div class="line">    switch (method) &#123;</div><div class="line">        case LLYHttpMethod_GET:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager GET:URLString parameters:parameters progress:downloadProgress success:success failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case LLYHttpMethod_POST:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager POST:URLString parameters:parameters progress:downloadProgress success:success failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case LLYHttpMethod_HEAD:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager HEAD:URLString parameters:parameters success:^(NSURLSessionDataTask * _Nonnull task) &#123;</div><div class="line">                if (success) &#123;</div><div class="line">                    success(task,nil);</div><div class="line">                &#125;</div><div class="line">            &#125; failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return task;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadWithUrl:(NSString *)urlString</div><div class="line">                                     progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                  destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler&#123;</div><div class="line">    NSURLSessionDownloadTask *task = nil;</div><div class="line">    </div><div class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];</div><div class="line">    </div><div class="line">    task = [_httpSessionManager downloadTaskWithRequest:request progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</div><div class="line">    </div><div class="line">    [task resume];</div><div class="line">    </div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lilingyu0620/LLYAFNetworking.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/15/使用FFMPEG解码之-音频解码/" itemprop="url">
                  使用FFMPEG解码之--音频解码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-15T11:15:41+08:00" content="2018-05-15">
              2018-05-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/15/使用FFMPEG解码之-音频解码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/15/使用FFMPEG解码之-音频解码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天一直在写使用ffmpeg完成一个视频播放器的demo,因为对音频这一块比较熟悉，所以先从音频解码开始下手，也熟悉一下ffmpeg的使用流程。音频解码这块已经完成了，所以这里先简单总结一下整个音频解码的流程。这里只说大概流程，具体实现细节参考下面的demo就可以。</p>
<h4 id="1-注册ffmpeg"><a href="#1-注册ffmpeg" class="headerlink" title="1.注册ffmpeg"></a>1.注册ffmpeg</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">av_register_all()</div></pre></td></tr></table></figure>
<h4 id="2-初始化AVFormatContext"><a href="#2-初始化AVFormatContext" class="headerlink" title="2.初始化AVFormatContext"></a>2.初始化AVFormatContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AVFormatContext *formatCtx = avformat_alloc_context();</div></pre></td></tr></table></figure>
<h4 id="3-可以注册一个打断回调"><a href="#3-可以注册一个打断回调" class="headerlink" title="3.可以注册一个打断回调"></a>3.可以注册一个打断回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AVIOInterruptCB int_cb = &#123;interrupt_callback,(__bridge void *)self&#125;;</div><div class="line">    formatCtx-&gt;interrupt_callback = int_cb;</div></pre></td></tr></table></figure>
<p>其中 interrupt_callback 是一个函数指针 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static int interrupt_callback(void *ctx)&#123;</div><div class="line">    if (!ctx) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    __unsafe_unretained LLYDecoder *decoder = (__bridge LLYDecoder *)ctx;</div><div class="line">    const BOOL bRet = [decoder detectInterrupted];</div><div class="line">    if (bRet) &#123;</div><div class="line">        NSLog(@&quot;DEBUG: INTERRUPT_CALLBACK!&quot;);</div><div class="line">    &#125;</div><div class="line">    return bRet;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打断状态</div><div class="line">- (BOOL)detectInterrupted&#123;</div><div class="line">    //打断超时</div><div class="line">    if ([[NSDate date] timeIntervalSince1970] - _readLastestFrameTime &gt; _subscribeTimeOutTimeInSecs) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return _interrupted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使返回一个是否被打断的状态。</p>
<h4 id="4-打开流地址"><a href="#4-打开流地址" class="headerlink" title="4.打开流地址"></a>4.打开流地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (int)openInputWithFormatCtx:(AVFormatContext **)formatCtx path:(NSString *)path parameter:(NSDictionary *)parameters&#123;</div><div class="line">    const char *inputURL = [path cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    AVDictionary *options = NULL;</div><div class="line">    //TCURL应该与流的CDN相关 如果原始的req中有tcUrl，就使用原始的</div><div class="line">    NSString *rtmpTCURLStr = parameters[RTMP_TCURL_KEY];</div><div class="line">    if (rtmpTCURLStr.length &gt; 0) &#123;</div><div class="line">        const char *rtmpTcURL = [rtmpTCURLStr cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">        av_dict_set(&amp;options, &quot;rtmp_tcurl&quot;, rtmpTcURL, 0);</div><div class="line">    &#125;</div><div class="line">    return avformat_open_input(formatCtx, inputURL, NULL, &amp;options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个是否打开成功的状态。0表示成功</p>
<h4 id="5-设置解析参数probesize-amp-max-analyze-duration"><a href="#5-设置解析参数probesize-amp-max-analyze-duration" class="headerlink" title="5.设置解析参数probesize &amp; max_analyze_duration"></a>5.设置解析参数probesize &amp; max_analyze_duration</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//个人理解是开始读取数据的延时和缓存空间（默认5M）</div><div class="line">- (void)initAnalyzeDurationAndProbeSize:(AVFormatContext *)formatCtx parameter:(NSDictionary *)parameters&#123;</div><div class="line">    float probeSize = [parameters[PROBE_SIZE] floatValue];</div><div class="line">    formatCtx-&gt;probesize = probeSize ?: 50 * 1024;</div><div class="line">    NSArray *durations = parameters[MAX_ANALYZE_DURATION_ARRAY];</div><div class="line">    if (durations &amp;&amp; durations.count &gt; _connectionRetry) &#123;</div><div class="line">        formatCtx-&gt;max_analyze_duration = [durations[_connectionRetry] floatValue];</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        //pow(x,y) x的y次方</div><div class="line">        float multiplier = 0.5 + (double)pow(2.0, (double)_connectionRetry) * 0.25;</div><div class="line">        formatCtx-&gt;max_analyze_duration = multiplier;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //帧率</div><div class="line">    BOOL fpsProbeSizeConfiged = [parameters[FPS_PROBE_SIZE_CONFIGURED] floatValue];</div><div class="line">    if (fpsProbeSizeConfiged) &#123;</div><div class="line">        formatCtx-&gt;fps_probe_size = 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-获取音视频信息"><a href="#6-获取音视频信息" class="headerlink" title="6.获取音视频信息"></a>6.获取音视频信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int findStreamErrorCode = 0;</div><div class="line">double startFindStreamTimeMills = CFAbsoluteTimeGetCurrent() * 1000;</div><div class="line">if ((findStreamErrorCode = avformat_find_stream_info(formatCtx, NULL)) &lt; 0) &#123;</div><div class="line">    avformat_close_input(&amp;formatCtx);</div><div class="line">    avformat_free_context(formatCtx);</div><div class="line">    NSLog(@&quot;Video decoder find stream info failed... find stream ErrCode is %s&quot;, av_err2str(findStreamErrorCode));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取的信息都在formatCtx这个参数里存着，后面很多地方要用。</p>
<h4 id="7-获取流数据的索引数组"><a href="#7-获取流数据的索引数组" class="headerlink" title="7.获取流数据的索引数组"></a>7.获取流数据的索引数组</h4><p>通过流的类型获取流的索引，有时候可能音频或者视频都有好几路流数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//获取流数据的索引</div><div class="line">static NSArray *collectionStreams(AVFormatContext *formatCtx,enum AVMediaType codecType)&#123;</div><div class="line">    NSMutableArray *ma = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; formatCtx-&gt;nb_streams; i++) &#123;</div><div class="line">        if (codecType == formatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type) &#123;</div><div class="line">            [ma addObject:@(i)];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-通过流的索引，获取每一路流的AVCodecContext-amp-AVCodec"><a href="#8-通过流的索引，获取每一路流的AVCodecContext-amp-AVCodec" class="headerlink" title="8.通过流的索引，获取每一路流的AVCodecContext &amp; AVCodec"></a>8.通过流的索引，获取每一路流的AVCodecContext &amp; AVCodec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AVCodecContext *codecCtx = _formatCtx-&gt;streams[streamIndex]-&gt;codec;</div><div class="line">//获取该stream对应的解码器</div><div class="line">AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</div><div class="line">if(!codec)&#123;</div><div class="line">    NSLog(@&quot;Find Audio Decoder Failed codec_id %d CODEC_ID_AAC is %d&quot;, codecCtx-&gt;codec_id, AV_CODEC_ID_AAC);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="9-打开解码器"><a href="#9-打开解码器" class="headerlink" title="9.打开解码器"></a>9.打开解码器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int openCodecErrorCode = 0;</div><div class="line">if ((openCodecErrorCode = avcodec_open2(codecCtx, codec, NULL)) &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;open Audio Codec Failed openCodecErr is %s&quot;, av_err2str(openCodecErrorCode));</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-如果不支持当前流的采样格式，需要做一下重新采样"><a href="#10-如果不支持当前流的采样格式，需要做一下重新采样" class="headerlink" title="10.如果不支持当前流的采样格式，需要做一下重新采样"></a>10.如果不支持当前流的采样格式，需要做一下重新采样</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//是否需要重采样</div><div class="line">SwrContext *swrContext = NULL;</div><div class="line">if (![self audioCodecIsSupported:codecCtx]) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;because of audio Codec Is Not Supported so we will init swresampler...&quot;);</div><div class="line">    /**</div><div class="line">     * 初始化resampler</div><div class="line">     * @param s               Swr context, can be NULL</div><div class="line">     * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)</div><div class="line">     * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).</div><div class="line">     * @param out_sample_rate output sample rate (frequency in Hz)</div><div class="line">     * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)</div><div class="line">     * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).</div><div class="line">     * @param in_sample_rate  input sample rate (frequency in Hz)</div><div class="line">     * @param log_offset      logging level offset</div><div class="line">     * @param log_ctx         parent logging context, can be NULL</div><div class="line">     */</div><div class="line">    swrContext = swr_alloc_set_opts(NULL, av_get_default_channel_layout(codecCtx-&gt;channels), AV_SAMPLE_FMT_S16, codecCtx-&gt;sample_rate, av_get_default_channel_layout(codecCtx-&gt;channels), codecCtx-&gt;sample_fmt, codecCtx-&gt;sample_rate, 0, NULL);</div><div class="line">    if (!swrContext || swr_init(swrContext)) &#123;</div><div class="line">        if (swrContext)</div><div class="line">            swr_free(&amp;swrContext);</div><div class="line">        avcodec_close(codecCtx);</div><div class="line">        NSLog(@&quot;init resampler failed...&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (BOOL)audioCodecIsSupported:(AVCodecContext *) audioCodecCtx;&#123;</div><div class="line">    if (audioCodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S16) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11-初始化一个AVFrame"><a href="#11-初始化一个AVFrame" class="headerlink" title="11.初始化一个AVFrame"></a>11.初始化一个AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_audioFrame = av_frame_alloc();</div><div class="line">if (!_audioFrame) &#123;</div><div class="line">    NSLog(@&quot;Alloc Audio Frame Failed...&quot;);</div><div class="line">    if (swrContext)</div><div class="line">        swr_free(&amp;swrContext);</div><div class="line">    avcodec_close(codecCtx);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="12-获取AVPacket"><a href="#12-获取AVPacket" class="headerlink" title="12.获取AVPacket"></a>12.获取AVPacket</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AVPacket packet;</div><div class="line">if (av_read_frame(_formatCtx, &amp;packet) &lt; 0) &#123;</div><div class="line">        _isEOF = YES;</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="13-获取AVFrame"><a href="#13-获取AVFrame" class="headerlink" title="13.获取AVFrame"></a>13.获取AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int gotFrame = 0;</div><div class="line">//len =  number of bytes consumed from the input *AVPacket</div><div class="line">int len = avcodec_decode_audio4(_audioCodecCtx, _audioFrame, &amp;gotFrame, &amp;packet);</div><div class="line">if (len &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;decode audio error, skip packet&quot;);</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="14-将AVFrame转为自定义的LLYAudioFrame"><a href="#14-将AVFrame转为自定义的LLYAudioFrame" class="headerlink" title="14.将AVFrame转为自定义的LLYAudioFrame"></a>14.将AVFrame转为自定义的LLYAudioFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (LLYAudioFrame *)handleAudioFrame&#123;</div><div class="line">    </div><div class="line">    if (!_audioFrame-&gt;data[0]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    const NSUInteger numChannels = _audioCodecCtx-&gt;channels;</div><div class="line">    NSInteger numFrames;</div><div class="line">    </div><div class="line">    void *audioData;</div><div class="line">    </div><div class="line">    if (_swrContext) &#123;</div><div class="line">        const NSUInteger ratio = 2;</div><div class="line">        const int bufSize = av_samples_get_buffer_size(NULL, (int)numChannels ,(int)(_audioFrame-&gt;nb_samples * ratio), AV_SAMPLE_FMT_S16, 1);</div><div class="line">        if (!_swrBuffer || _swrBufferSize &lt; bufSize) &#123;</div><div class="line">            _swrBufferSize = bufSize;</div><div class="line">            _swrBuffer = realloc(_swrBuffer, _swrBufferSize);</div><div class="line">        &#125;</div><div class="line">        Byte *outbuf[2] = &#123;_swrBuffer,0&#125;;</div><div class="line">        numFrames = swr_convert(_swrContext, outbuf, (int)(_audioFrame-&gt;nb_samples * ratio), (const uint8_t **)_audioFrame-&gt;data, _audioFrame-&gt;nb_samples);</div><div class="line">        if (numFrames &lt; 0) &#123;</div><div class="line">            NSLog(@&quot;fail resample audio&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        audioData = _swrBuffer;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (_audioCodecCtx-&gt;sample_fmt != AV_SAMPLE_FMT_S16) &#123;</div><div class="line">            NSLog(@&quot;Audio format is invalid&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        audioData = _audioFrame-&gt;data[0];</div><div class="line">        numFrames = _audioFrame-&gt;nb_samples;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //总帧数 = 一条信道的帧数*信道数</div><div class="line">    const NSUInteger numElements = numFrames * numChannels;</div><div class="line">    NSMutableData *pcmData = [NSMutableData dataWithLength:numElements * sizeof(SInt16)];</div><div class="line">    memcpy(pcmData.mutableBytes, audioData, numElements * sizeof(SInt16));</div><div class="line">    LLYAudioFrame *frame = [[LLYAudioFrame alloc]init];</div><div class="line">    frame.position = av_frame_get_best_effort_timestamp(_audioFrame) * _audioTimeBase;</div><div class="line">    frame.duration = av_frame_get_pkt_duration(_audioFrame) * _audioTimeBase;</div><div class="line">    frame.sampleData = pcmData;</div><div class="line">    frame.frameType = LLYFrameType_Audio;</div><div class="line">    </div><div class="line">    return frame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里判断一下如果是重采样的，需要做一个转换。</p>
<h3 id="视频解码（补充）"><a href="#视频解码（补充）" class="headerlink" title="视频解码（补充）"></a>视频解码（补充）</h3><p>视频解码的工作也做完了，流程和音频大同小异，只是在最后几步的时候会有差异</p>
<h4 id="获取AVFrame"><a href="#获取AVFrame" class="headerlink" title="获取AVFrame"></a>获取AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int gotFrmae = 0;</div><div class="line">int len = avcodec_decode_video2(_videoCodecCtx, _videoFrame, &amp;gotFrmae, &amp;packet);</div><div class="line">if (len &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;decode video error, skip packet %s&quot;, av_err2str(len));</div><div class="line">    *errorState = 1;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用video的解码api.</p>
<h4 id="将AVFrame转为自定义的LLYVideoFrame"><a href="#将AVFrame转为自定义的LLYVideoFrame" class="headerlink" title="将AVFrame转为自定义的LLYVideoFrame"></a>将AVFrame转为自定义的LLYVideoFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (LLYVideoFrame *)handleVideoFrame&#123;</div><div class="line">    </div><div class="line">    if (!_videoFrame-&gt;data[0]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LLYVideoFrame *videoFrame = [[LLYVideoFrame alloc]init];</div><div class="line">    //将yuv数据取出来</div><div class="line">    if (_videoCodecCtx-&gt;pix_fmt == AV_PIX_FMT_YUV420P || _videoCodecCtx-&gt;pix_fmt == AV_PIX_FMT_YUVJ420P) &#123;</div><div class="line">        videoFrame.luma = copyFrameData(_videoFrame-&gt;data[0], _videoFrame-&gt;linesize[0], _videoCodecCtx-&gt;width, _videoCodecCtx-&gt;height);</div><div class="line">        videoFrame.chromaB = copyFrameData(_videoFrame-&gt;data[1], _videoFrame-&gt;linesize[1], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">        videoFrame.chromaR = copyFrameData(_videoFrame-&gt;data[2], _videoFrame-&gt;linesize[2], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">    &#125;else&#123;</div><div class="line">        //不是yuv格式先要将格式转为yuv的</div><div class="line">        if (!_swsContext &amp;&amp;</div><div class="line">            ![self setupScaler]) &#123;</div><div class="line">            NSLog(@&quot;fail setup video scaler&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sws_scale(_swsContext,</div><div class="line">                  (const uint8_t **)_videoFrame-&gt;data,</div><div class="line">                  _videoFrame-&gt;linesize,</div><div class="line">                  0,</div><div class="line">                  _videoCodecCtx-&gt;height,</div><div class="line">                  _picture.data,</div><div class="line">                  _picture.linesize);</div><div class="line">        videoFrame.luma = copyFrameData(_picture.data[0], _videoFrame-&gt;linesize[0], _videoCodecCtx-&gt;width, _videoCodecCtx-&gt;height);</div><div class="line">        videoFrame.chromaB = copyFrameData(_picture.data[1], _videoFrame-&gt;linesize[1], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">        videoFrame.chromaR = copyFrameData(_picture.data[2], _videoFrame-&gt;linesize[2], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">    &#125;</div><div class="line">    videoFrame.width = _videoCodecCtx-&gt;width;</div><div class="line">    videoFrame.height = _videoCodecCtx-&gt;height;</div><div class="line">    videoFrame.lineSize = _videoFrame-&gt;linesize[0];</div><div class="line">    videoFrame.frameType = LLYFrameType_Video;</div><div class="line">    videoFrame.position = av_frame_get_best_effort_timestamp(_videoFrame) * _videoTimeBase;</div><div class="line">    const int64_t frameDuration = av_frame_get_pkt_duration(_videoFrame);</div><div class="line">    if (frameDuration) &#123;</div><div class="line">        videoFrame.duration = frameDuration * _videoTimeBase;</div><div class="line">        videoFrame.duration += _videoFrame-&gt;repeat_pict * _videoTimeBase * 0.5;</div><div class="line">    &#125; else &#123;</div><div class="line">        // sometimes, ffmpeg unable to determine a frame duration</div><div class="line">        // as example yuvj420p stream from web camera</div><div class="line">        videoFrame.duration = 1.0 / _fps;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return videoFrame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里转为自定义的LLYVideoFrame时需要将YUV的数据都取出来。</p>
<p>主要流程大概就是上面这些了。当然还有一些细节的东西，这里没有一一列出来，可以从demo中寻找答案。</p>
<p><a href="https://github.com/lilingyu0620/LLYFFMPEGPlayer.git" target="_blank" rel="noopener">LLYFFMPEGPlayer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/FFMPEG学习笔记/" itemprop="url">
                  FFMPEG学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-07T17:52:01+08:00" content="2018-05-07">
              2018-05-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/07/FFMPEG学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/FFMPEG学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想要从事音视频相关的工作，FFMPEG是绕不开的一道坎，就像吉他里面的大横按，既然我能给征服大横按，相信我也能征服你，FFMPEG！！！</p>
<p>自学音视频相关的内容也有一段时间啦，比如之前的H264,RTMP,FLV,还有最近的AudioUint和AudioQueue，通过这段时间的学习，我总结出来的方法就是，先将他们的数据结构分析清楚，了解主要的api，然后从简单的api开始实践。</p>
<p>所以我们先来看一下FFMPEG的主要数据结构和api…</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="文件读取相关"><a href="#文件读取相关" class="headerlink" title="文件读取相关"></a>文件读取相关</h4><h5 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h5><p>AVIOContext是FFMPEG管理输入输出数据的结构体</p>
<p>比较重要的属性：</p>
<ul>
<li><p>unsigned char *buffer：缓存读取的数据</p>
</li>
<li><p>int buffer_size：缓存大小（默认32768）</p>
</li>
<li><p>unsigned char *buf_ptr：当前指针读取到的位置</p>
</li>
<li><p>unsigned char *buf_end：缓存结束的位置</p>
</li>
<li><p>void *opaque：URLContext结构体</p>
</li>
</ul>
<h4 id="协议相关"><a href="#协议相关" class="headerlink" title="协议相关"></a>协议相关</h4><h5 id="URLContext、URLProtocol"><a href="#URLContext、URLProtocol" class="headerlink" title="URLContext、URLProtocol"></a>URLContext、URLProtocol</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">typedef struct URLContext &#123;  </div><div class="line">    const AVClass *av_class; ///&lt; information for av_log(). Set by url_open().  </div><div class="line">    struct URLProtocol *prot;  </div><div class="line">    int flags;  </div><div class="line">    int is_streamed;  /**&lt; true if streamed (no seek possible), default = false */  </div><div class="line">    int max_packet_size;  /**&lt; if non zero, the stream is packetized with this max packet size */  </div><div class="line">    void *priv_data;  </div><div class="line">    char *filename; /**&lt; specified URL */  </div><div class="line">    int is_connected;  </div><div class="line">    AVIOInterruptCB interrupt_callback;  </div><div class="line">&#125; URLContext;  </div><div class="line"></div><div class="line">typedef struct URLProtocol &#123;  </div><div class="line">    const char *name;  </div><div class="line">    int (*url_open)(URLContext *h, const char *url, int flags);  </div><div class="line">    int (*url_read)(URLContext *h, unsigned char *buf, int size);  </div><div class="line">    int (*url_write)(URLContext *h, const unsigned char *buf, int size);  </div><div class="line">    int64_t (*url_seek)(URLContext *h, int64_t pos, int whence);  </div><div class="line">    int (*url_close)(URLContext *h);  </div><div class="line">    struct URLProtocol *next;  </div><div class="line">    int (*url_read_pause)(URLContext *h, int pause);  </div><div class="line">    int64_t (*url_read_seek)(URLContext *h, int stream_index,  </div><div class="line">        int64_t timestamp, int flags);  </div><div class="line">    int (*url_get_file_handle)(URLContext *h);  </div><div class="line">    int priv_data_size;  </div><div class="line">    const AVClass *priv_data_class;  </div><div class="line">    int flags;  </div><div class="line">    int (*url_check)(URLContext *h, int mask);  </div><div class="line">&#125; URLProtocol;</div></pre></td></tr></table></figure>
<p>URLContext结构体中还有一个结构体URLProtocol,每种协议（rtp，rtmp，file等）对应一个URLProtocol。</p>
<h4 id="封装格式相关"><a href="#封装格式相关" class="headerlink" title="封装格式相关"></a>封装格式相关</h4><h5 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h5><p>这个结构体描述了一个媒体文件或媒体流的构成和基本信息</p>
<p>在使用FFMPEG进行开发的时候，AVFormatContext是一个贯穿始终的数据结构，很多函数都要用到它作为参数。</p>
<p>看几个主要变量的作用:</p>
<ul>
<li><p>struct AVInputFormat *iformat：输入数据的封装格式</p>
</li>
<li><p>AVIOContext *pb：输入数据的缓存</p>
</li>
<li><p>unsigned int nb_streams：视音频流的个数</p>
</li>
<li><p>AVStream **streams：音视频流</p>
</li>
<li><p>char filename[1024]：文件名</p>
</li>
<li><p>int64_t duration：时长（单位：微秒us，转换为秒需要除以1000000）</p>
</li>
<li><p>int bit_rate：比特率（单位bps，转换为kbps需要除以1000）</p>
</li>
<li><p>AVDictionary *metadata：元数据</p>
</li>
</ul>
<h5 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h5><p>作为输入容器，包含了输入文件的音视频流信息,程序从输入容器从读出音视频包进行解码处理</p>
<h5 id="AVOutputFormat"><a href="#AVOutputFormat" class="headerlink" title="AVOutputFormat"></a>AVOutputFormat</h5><p>作为输出容器，程序把编码好的音视频包写入到输出容器中</p>
<h4 id="编解码相关"><a href="#编解码相关" class="headerlink" title="编解码相关"></a>编解码相关</h4><h5 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h5><p>这是一个描述编解码器上下文的数据结构，包含了众多编解码器需要的参数信息</p>
<p>看一下关键属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">enum AVMediaType codec_type：编解码器的类型（视频，音频...）</div><div class="line"></div><div class="line">struct AVCodec  *codec：采用的解码器AVCodec（H.264,MPEG2...）</div><div class="line"></div><div class="line">int bit_rate：平均比特率</div><div class="line"></div><div class="line">uint8_t *extradata; int extradata_size：针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</div><div class="line"></div><div class="line">AVRational time_base：根据该参数，可以把PTS转化为实际的时间（单位为秒s）</div><div class="line"></div><div class="line">int width, height：如果是视频的话，代表宽和高</div><div class="line"></div><div class="line">int refs：运动估计参考帧的个数（H.264的话会有多帧，MPEG2这类的一般就没有了）</div><div class="line"></div><div class="line">int sample_rate：采样率（音频）</div><div class="line"></div><div class="line">int channels：声道数（音频）</div><div class="line"></div><div class="line">enum AVSampleFormat sample_fmt：采样格式</div><div class="line"></div><div class="line">int profile：型（H.264里面就有，其他编码标准应该也有）</div><div class="line"></div><div class="line">int level：级（和profile差不太多）</div></pre></td></tr></table></figure>
<h5 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h5><p>AVCodec是存储编解码器信息的结构体，每一个编解码器对应一个该结构体。</p>
<p>下面说一下最主要的几个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const char *name：编解码器的名字，比较短</div><div class="line"></div><div class="line">const char *long_name：编解码器的名字，全称，比较长</div><div class="line"></div><div class="line">enum AVMediaType type：指明了类型，是视频，音频，还是字幕</div><div class="line"></div><div class="line">enum AVCodecID id：ID，不重复</div><div class="line"></div><div class="line">const AVRational *supported_framerates：支持的帧率（仅视频）</div><div class="line"></div><div class="line">const enum AVPixelFormat *pix_fmts：支持的像素格式（仅视频）</div><div class="line"></div><div class="line">const int *supported_samplerates：支持的采样率（仅音频）</div><div class="line"></div><div class="line">const enum AVSampleFormat *sample_fmts：支持的采样格式（仅音频）</div><div class="line"></div><div class="line">const uint64_t *channel_layouts：支持的声道数（仅音频）</div><div class="line"></div><div class="line">int priv_data_size：私有数据的大小</div></pre></td></tr></table></figure>
<h5 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h5><p>AVStream是存储每一个视频/音频流信息的结构体</p>
<p>AVStream重要的变量如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int index：标识该视频/音频流</div><div class="line"></div><div class="line">AVCodecContext *codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）</div><div class="line"></div><div class="line">AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。FFMPEG其他结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。PTS*time_base=真正的时间</div><div class="line"></div><div class="line">int64_t duration：该视频/音频流长度</div><div class="line"></div><div class="line">AVDictionary *metadata：元数据信息</div><div class="line"></div><div class="line">AVRational avg_frame_rate：帧率（注：对视频来说，这个挺重要的）</div><div class="line"></div><div class="line">AVPacket attached_pic：附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面。</div></pre></td></tr></table></figure>
<h5 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h5><p>AVPacket是存储压缩编码数据相关信息的结构体</p>
<p>重要的变量有以下几个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!--例如对于H.264来说。1个AVPacket的data通常对应一个NAL。</div><div class="line"></div><div class="line">注意：在这里只是对应，而不是一模一样。他们之间有微小的差别：使用FFMPEG类库分离出多媒体文件中的H.264码流</div><div class="line"></div><div class="line">因此在使用FFMPEG进行视音频处理的时候，常常可以将得到的AVPacket的data数据直接写成文件，从而得到视音频的码流文件。</div><div class="line">--&gt;</div><div class="line"></div><div class="line">uint8_t *data：压缩编码的数据。</div><div class="line"></div><div class="line">int   size：data的大小</div><div class="line"></div><div class="line">int64_t pts：显示时间戳</div><div class="line"></div><div class="line">int64_t dts：解码时间戳</div><div class="line"></div><div class="line">int   stream_index：标识该AVPacket所属的视频/音频流。</div></pre></td></tr></table></figure>
<h5 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h5><p>AVFrame结构体一般用于存储原始数据（即非压缩数据，例如对视频来说是YUV，RGB，对音频来说是PCM），此外还包含了一些相关的信息。比如说，解码的时候存储了宏块类型表，QP表，运动矢量表等数据。编码的时候也存储了相关的数据。因此在使用FFMPEG进行码流分析的时候，AVFrame是一个很重要的结构体。</p>
<p>下面看几个主要变量的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uint8_t *data[AV_NUM_DATA_POINTERS]：解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）</div><div class="line"></div><div class="line">int linesize[AV_NUM_DATA_POINTERS]：data中“一行”数据的大小。注意：未必等于图像的宽，一般大于图像的宽。</div><div class="line"></div><div class="line">int width, height：视频帧宽和高（1920x1080,1280x720...）</div><div class="line"></div><div class="line">int nb_samples：音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个</div><div class="line"></div><div class="line">int format：解码后原始数据类型（YUV420，YUV422，RGB24...）</div><div class="line"></div><div class="line">int key_frame：是否是关键帧</div><div class="line"></div><div class="line">enum AVPictureType pict_type：帧类型（I,B,P...）</div><div class="line"></div><div class="line">AVRational sample_aspect_ratio：宽高比（16:9，4:3...）</div><div class="line"></div><div class="line">int64_t pts：显示时间戳</div><div class="line"></div><div class="line">int coded_picture_number：编码帧序号</div><div class="line"></div><div class="line">int display_picture_number：显示帧序号</div><div class="line"></div><div class="line">int8_t *qscale_table：QP表</div><div class="line"></div><div class="line">uint8_t *mbskip_table：跳过宏块表</div><div class="line"></div><div class="line">int16_t (*motion_val[2])[2]：运动矢量表</div><div class="line"></div><div class="line">uint32_t *mb_type：宏块类型表</div><div class="line"></div><div class="line">short *dct_coeff：DCT系数，这个没有提取过</div><div class="line"></div><div class="line">int8_t *ref_index[2]：运动估计参考帧列表（貌似H.264这种比较新的标准才会涉及到多参考帧）</div><div class="line"></div><div class="line">int interlaced_frame：是否是隔行扫描</div><div class="line"></div><div class="line">uint8_t motion_subsample_log2：一个宏块中的运动矢量采样个数，取log的</div></pre></td></tr></table></figure>
<p>结构体之间的关系可以参考下图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/FFMPEG/20130914204051125.jpg" alt=""></p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="avcodec-init"><a href="#avcodec-init" class="headerlink" title="avcodec_init()"></a>avcodec_init()</h4><p>初始化libavcodec,一般最先调用该函数</p>
<p>该函数必须在调用libavcodec里的其它函数前调用,一般在程序启动或模块初始化时调用,如果你调用了多次也无所谓,因为后面的调用不会做任何事情.从函数的实现里你可以发现,代码中对多次调用进行了控制.</p>
<h4 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all()"></a>av_register_all()</h4><p>初始化 libavformat和注册所有的muxers、demuxers和protocols，</p>
<p>一般在调用avcodec_init后调用该方法</p>
<p>其中会调用avcodec_register_all()注册多种音视频格式的编解码器,并注册各种文件的编解复用器</p>
<h4 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context()"></a>avformat_alloc_context()</h4><p>分配一个AVFormatContext结构，负责申请一个AVFormatContext结构的内存,并进行简单初始化</p>
<h4 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input()"></a>avformat_open_input()</h4><p>打开一个流媒体文件</p>
<h4 id="avformat-close-input"><a href="#avformat-close-input" class="headerlink" title="avformat_close_input()"></a>avformat_close_input()</h4><p>关闭一个流媒体文件</p>
<h4 id="avformat-free-context"><a href="#avformat-free-context" class="headerlink" title="avformat_free_context()"></a>avformat_free_context()</h4><p>释放一个AVFormatContext结构</p>
<p>使用 avformat_alloc_context()分配的结构,采用该函数进行释放,除释放AVFormatContext结构本身内存之外,AVFormatContext中指针所指向的内存也会一并释放</p>
<h4 id="avio-alloc-context"><a href="#avio-alloc-context" class="headerlink" title="avio_alloc_context()"></a>avio_alloc_context()</h4><p>为I/0缓存申请并初始化一个AVIOContext结构,结束使用时必须使用av_free()进行释放</p>
<h4 id="av-open-input-file"><a href="#av-open-input-file" class="headerlink" title="av_open_input_file()"></a>av_open_input_file()</h4><p>以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息.</p>
<h4 id="av-close-input-file"><a href="#av-close-input-file" class="headerlink" title="av_close_input_file()"></a>av_close_input_file()</h4><p>关闭使用avformat_close_input()打开的输入文件容器,但并不关系它的codecs</p>
<p>使用 av_close_input_file 关闭后,就不再需要使用avformat_free_context 进行释放了</p>
<h4 id="av-find-stream-info-AVFormatContext-ic"><a href="#av-find-stream-info-AVFormatContext-ic" class="headerlink" title="av_find_stream_info(AVFormatContext *ic)"></a>av_find_stream_info(AVFormatContext *ic)</h4><p>通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的</p>
<h4 id="AVCodec-avcodec-find-decoder-enum-CodecID-id"><a href="#AVCodec-avcodec-find-decoder-enum-CodecID-id" class="headerlink" title="AVCodec *avcodec_find_decoder(enum CodecID id)"></a>AVCodec *avcodec_find_decoder(enum CodecID id)</h4><p>通过code ID查找一个已经注册的音视频解码器</p>
<p>查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p>音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的ID来查找</p>
<h4 id="AVCodec-avcodec-find-decoder-by-name-constchar-name"><a href="#AVCodec-avcodec-find-decoder-by-name-constchar-name" class="headerlink" title="AVCodec  avcodec_find_decoder_by_name (constchar  name)"></a>AVCodec <em> avcodec_find_decoder_by_name (constchar </em> name)</h4><p>通过一个指定的名称查找一个已经注册的音视频解码器</p>
<p>查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p>音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的name来查找</p>
<h4 id="avcodec-find-encoder"><a href="#avcodec-find-encoder" class="headerlink" title="avcodec_find_encoder()"></a>avcodec_find_encoder()</h4><h4 id="avcodec-find-encoder-by-name"><a href="#avcodec-find-encoder-by-name" class="headerlink" title="avcodec_find_encoder_by_name()"></a>avcodec_find_encoder_by_name()</h4><p>同上。。。</p>
<h4 id="int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2"><a href="#int-avcodec-open-AVCodecContext-avctx-AVCodec-codec-avcodec-open2" class="headerlink" title="int avcodec_open(AVCodecContext  avctx, AVCodec  codec) / avcodec_open2()"></a>int avcodec_open(AVCodecContext <em> avctx, AVCodec </em> codec) / avcodec_open2()</h4><p>使用给定的AVCodec初始化AVCodecContext</p>
<h4 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format()"></a>av_guess_format()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AVOutputFormat *av_guess_format(constchar *short_name,</div><div class="line"></div><div class="line">                                constchar *filename,</div><div class="line"></div><div class="line">                                constchar *mime_type);</div></pre></td></tr></table></figure>
<p>返回一个已经注册的最合适的输出格式</p>
<h4 id="void-av-init-packet-AVPacket-pkt"><a href="#void-av-init-packet-AVPacket-pkt" class="headerlink" title="void av_init_packet(AVPacket *pkt);"></a>void av_init_packet(AVPacket *pkt);</h4><p>使用默认值初始化AVPacket</p>
<p>定义AVPacket对象后,请使用av_init_packet进行初始化</p>
<h4 id="int-av-read-frame-AVFormatContext-s-AVPacket-pkt"><a href="#int-av-read-frame-AVFormatContext-s-AVPacket-pkt" class="headerlink" title="int av_read_frame(AVFormatContext  s, AVPacket  pkt)"></a>int av_read_frame(AVFormatContext <em> s, AVPacket </em> pkt)</h4><p>从输入源文件容器中读取一个AVPacket数据包</p>
<p>该函数读出的包并不每次都是有效的,对于读出的包我们都应该进行相应的解码(视频解码/音频解码),</p>
<p>在返回值&gt;=0时,循环调用该函数进行读取,循环调用之前请调用av_free_packet函数清理AVPacket</p>
<h4 id="avcodec-decode-video2"><a href="#avcodec-decode-video2" class="headerlink" title="avcodec_decode_video2()"></a>avcodec_decode_video2()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int avcodec_decode_video2(AVCodecContext *avctx, 										AVFrame *picture,</div><div class="line">                         int *got_picture_ptr,</div><div class="line">                         AVPacket *avpkt);</div><div class="line">                         </div><div class="line">                         </div><div class="line">// 解码视频流AVPacket</div><div class="line">// 使用av_read_frame读取媒体流后需要进行判断,如果为视频流则调用该函数解码</div><div class="line">// 返回结果&lt;0时失败,此时程序应该退出检查原因</div><div class="line">// 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做</div><div class="line">// 如下处理:</div><div class="line">//   vPacket.size -= vLen;</div><div class="line">//   vPacket.data += vLen;</div><div class="line">// 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</div><div class="line">// 返回 got_picture_ptr &gt; 0 时,表示解码到了AVFrame *picture,其后可以对picture进程处理</div></pre></td></tr></table></figure>
<h4 id="avcodec-decode-audio3-avcodec-decode-audio4"><a href="#avcodec-decode-audio3-avcodec-decode-audio4" class="headerlink" title="avcodec_decode_audio3()/avcodec_decode_audio4()"></a>avcodec_decode_audio3()/avcodec_decode_audio4()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples,</div><div class="line"></div><div class="line">                         int *frame_size_ptr,</div><div class="line"></div><div class="line">                         AVPacket *avpkt);</div><div class="line">                         </div><div class="line">int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,</div><div class="line">int *got_frame_ptr, </div><div class="line">const AVPacket *avpkt);</div><div class="line"></div><div class="line"></div><div class="line">// 解码音频流AVPacket</div><div class="line">// 使用av_read_frame读取媒体流后需要进行判断,如果为音频流则调用该函数解码</div><div class="line">// 返回结果&lt;0时失败,此时程序应该退出检查原因</div><div class="line">// 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做</div><div class="line">// 如下处理:</div><div class="line">//   vPacket.size -= vLen;</div><div class="line">//   vPacket.data += vLen;</div><div class="line">// 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/使用AudioQueue实现一个音频播放器/" itemprop="url">
                  使用AudioQueue实现一个音频播放器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-07T15:46:32+08:00" content="2018-05-07">
              2018-05-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/07/使用AudioQueue实现一个音频播放器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/使用AudioQueue实现一个音频播放器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在系统的学习了AudioQueue相关姿势之后，我尝试使用AudioQueue做一个简单的音频播放器，包括播放，暂停，停止，快进快退，同时支持本地音频和网络音频等功能。</p>
<p>这里将整个流程分为下面几个模块：</p>
<ul>
<li><p>AudioProperty – 用来保存音频的相关属性</p>
</li>
<li><p>AudioSource – 主要负责提供音频数据</p>
<ul>
<li>LocalAudioSource 本地数据来源</li>
<li>NetAudioSource 网络数据来源</li>
</ul>
</li>
</ul>
<ul>
<li>AudioStream – 主要负责对音频流的解析</li>
</ul>
<ul>
<li>AudioQueue – 主要负责音频播放</li>
</ul>
<ul>
<li>AudioPlayer – 播放器实体，负责管理上面的几个模块。</li>
</ul>
<p>下面分模块来介绍下：</p>
<h4 id="AudioProperty"><a href="#AudioProperty" class="headerlink" title="AudioProperty"></a>AudioProperty</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@protocol LLYAudioPropertyDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)audioProrperty_error:(NSError *)error;</div><div class="line">- (void)audioProperty_statusChanged:(LLYAudioStatus)audioStatus;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface LLYAudioProperty : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign) UInt64 fileSize;</div><div class="line">@property (nonatomic, assign) UInt32 packetMaxSize;</div><div class="line">@property (nonatomic, assign) void * magicData;</div><div class="line">@property (nonatomic, assign) UInt32 cookieSize;</div><div class="line">@property (nonatomic, assign) LLYAudioStatus status;</div><div class="line">@property (nonatomic, strong) NSError *error;</div><div class="line">@property (nonatomic, weak) id &lt;LLYAudioPropertyDelegate&gt; delegate;</div><div class="line">@property (nonatomic, assign) AudioStreamBasicDescription audioDesc;</div><div class="line"></div><div class="line">- (void)error:(LLYAudioError)errorType;</div><div class="line">- (NSString *)errorDomain:(LLYAudioError)errorType;</div><div class="line">- (void)clean;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当每次音频的状态发生改变时，我们通过上面的代理将状态传给UI。</p>
<p>这里我们保存了fileSize和audioDesc，主要是用来计算音频的总时长，计算方法在之前已经介绍过了。</p>
<h4 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h4><p>因为这个模块有两种类型，所以我们先定义一个父类，然后让子类去继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@class LLYBaseAudioSource;</div><div class="line"></div><div class="line">@protocol LLYAudioSourceDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)audioSource_fileType:(LLYBaseAudioSource *)curAudioSource fileType:(AudioFileTypeID)fileType;</div><div class="line">- (void)audioSource_dataArrived:(LLYBaseAudioSource *)curAudioSource data:(NSData *)data contine:(BOOL)isContine;</div><div class="line">- (void)audioSource_finished:(LLYBaseAudioSource *)curAudioSource error:(NSError *)error;</div><div class="line">- (void)audioSource_shouldExit:(LLYBaseAudioSource*)currAudioData;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface LLYBaseAudioSource : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *urlStr;</div><div class="line">@property (nonatomic, weak) id&lt;LLYAudioSourceDelegate&gt; delegate;</div><div class="line">@property (nonatomic, assign) int audioVersion;</div><div class="line">@property (nonatomic, strong) LLYAudioProperty *audioProperty;</div><div class="line"></div><div class="line">- (void)start;</div><div class="line">- (void)cancel;</div><div class="line">- (void)seekToOffset:(UInt64)offset;</div><div class="line">- (AudioFileTypeID)fileTypeWithFileExtension:(NSString *)fileExtension;</div><div class="line">- (void)audioSourceError:(NSString *)errorDomain userInfo:(NSDictionary *)userInfo;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在我们获取到原始的音频数据后，也是通过代理的方式将数据交给其它模块去处理。</p>
<p>具体看一下本地和网络数据获取的方式有何不同：</p>
<h5 id="LLYLocalAudioSource"><a href="#LLYLocalAudioSource" class="headerlink" title="LLYLocalAudioSource"></a>LLYLocalAudioSource</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)loadData&#123;</div><div class="line">    if([[NSFileManager defaultManager] fileExistsAtPath:self.urlStr])&#123;</div><div class="line">        NSError *error;</div><div class="line">        NSDictionary *fileAttDic = [[NSFileManager defaultManager] attributesOfItemAtPath:self.urlStr error:&amp;error];</div><div class="line">        fileSize = [[fileAttDic objectForKey:NSFileSize] longValue];</div><div class="line">        if (fileSize &gt; 0) &#123;</div><div class="line">            self.audioProperty.fileSize = fileSize;</div><div class="line">            filehandle = [NSFileHandle fileHandleForReadingAtPath:self.urlStr];</div><div class="line">            currOffset = 0;</div><div class="line">            if (!fileTimer) &#123;</div><div class="line">                fileTimer = [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(fileTimer_intval) userInfo:nil repeats:YES];</div><div class="line">                [[NSRunLoop currentRunLoop] run];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            [self audioSourceError:@&quot;file read error&quot; userInfo:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        [self audioSourceError:@&quot;file not exists&quot; userInfo:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我是使用了一个计时器去读取的本地数据，用while循环应该也是ok的。然后是整个数据读取操作都需要放在子线程去操作，因为如果放在主线程的话会阻塞当前线程，造成UI卡顿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)fileTimer_intval&#123;</div><div class="line">    </div><div class="line">    if (exit) &#123;</div><div class="line">        [filehandle closeFile];</div><div class="line">        filehandle=nil;</div><div class="line">        </div><div class="line">        if (self.delegate) &#123;</div><div class="line">            [self.delegate audioSource_shouldExit:self];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CFRunLoopStop([[NSRunLoop currentRunLoop] getCFRunLoop]);//必须停止，要不线程一直不会被释放</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!filehandle) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (newOffset &gt; 0) &#123;</div><div class="line">        currOffset = newOffset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UInt64 currReadLength = readLength;</div><div class="line">    if (currOffset + currReadLength &gt; fileSize) &#123;</div><div class="line">        currReadLength = fileSize - currOffset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (currOffset == 0) &#123;</div><div class="line">        isContine = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (newOffset &gt; 0)&#123;</div><div class="line">        [filehandle seekToFileOffset:newOffset];</div><div class="line">        </div><div class="line">        newOffset = 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    audioFileData = [filehandle readDataOfLength:currReadLength];</div><div class="line">    if (audioFileData &amp;&amp; self.delegate) &#123;</div><div class="line">        [self.delegate audioSource_dataArrived:self data:audioFileData contine:isContine];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    currOffset += currReadLength;</div><div class="line"></div><div class="line">    if (currOffset &gt;= fileSize) &#123;</div><div class="line">        if (fileTimer) &#123;</div><div class="line">            [fileTimer invalidate];</div><div class="line">            fileTimer=nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!isContine) &#123;</div><div class="line">        isContine = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!fileTimer) &#123;</div><div class="line">        if (self.delegate) &#123;</div><div class="line">            [self.delegate audioSource_finished:self error:nil];</div><div class="line">            [filehandle closeFile];</div><div class="line">            filehandle=nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在数据读取过程中，我们需要记录一下当前读取了多少数据，防止最后一次读取的数据不够，这里还有2个参数是seek相关的，isContine 和 newOffset ，当newOffset不为0时，我们需要将当前文件的读取偏移量seek到newOffset处，然后在继续读文件，同时，我们标记isContine为NO，通知其他模块，清空之前的音频读取相关记录，重新开始读取新的数据。</p>
<h5 id="LLYNetAudioSource"><a href="#LLYNetAudioSource" class="headerlink" title="LLYNetAudioSource"></a>LLYNetAudioSource</h5><p>网络音频和本地音频处理起来不太一样，因为它们使用的是不同的协议，本地文件可以看做file协议，网络音频则是http协议。不过原理上其实是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)requestStart&#123;</div><div class="line">    </div><div class="line">    if (!self.audioTask) &#123;</div><div class="line">        </div><div class="line">        self.audioRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:self.urlStr]];</div><div class="line">        if (seekOffset) &#123;</div><div class="line">            [self.audioRequest setValue:[NSString stringWithFormat:@&quot;bytes=%llu-&quot;,seekOffset] forHTTPHeaderField:@&quot;Range&quot;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        self.audioSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue new]];</div><div class="line">        self.audioTask = [self.audioSession dataTaskWithRequest:self.audioRequest];</div><div class="line">        [self.audioTask resume];</div><div class="line">        </div><div class="line">        NSLog(@&quot;requestStart current thread %@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDataDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">didReceiveResponse:(NSURLResponse *)response</div><div class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;didReceiveResponse current thread %@&quot;,[NSThread currentThread]);</div><div class="line"></div><div class="line">    fileSize = seekOffset + response.expectedContentLength;</div><div class="line">    seekOffset = 0;</div><div class="line">    self.audioProperty.fileSize = fileSize;</div><div class="line">    </div><div class="line">    completionHandler(NSURLSessionResponseAllow);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;didReceiveData current thread %@&quot;,[NSThread currentThread]);</div><div class="line"></div><div class="line">    if (self.delegate) &#123;</div><div class="line">        if (currDataSize == 0) &#123;</div><div class="line">            isContine = NO;</div><div class="line">        &#125;</div><div class="line">        [self.delegate audioSource_dataArrived:self data:data contine:isContine];</div><div class="line">        currDataSize = currDataSize + data.length;</div><div class="line">        if (!isContine) &#123;</div><div class="line">            isContine = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的 ，这个数据请求过程也是放在子线程中进行。</p>
<p>这里，使用代理的方式而不是完成快的方式去请求数据，是因为音频数据相对来说还是有点大的，如果使用完成块的方式需要等待数据全部请求完成才会返回，等待时候会比较长，而且我们在开始播放音频时也并不需要全部的数据，边播放请求数据也比较符合正常的逻辑。</p>
<p>在发送请求前，也有一个seek相关的操作，如果当前是seek后第一次请求数据，通过设置http header中的Range的字段，请求seek后的数据。</p>
<h4 id="LLYAudioStream"><a href="#LLYAudioStream" class="headerlink" title="LLYAudioStream"></a>LLYAudioStream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@protocol LLYAudioStreamDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)audioStream_readyToProducePackets;</div><div class="line">- (void)audioStream_packets:(NSData *)data packetNum:(UInt32)packetCount packetDesc:(AudioStreamPacketDescription *)inPacketDesc;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface LLYAudioStream : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign) AudioStreamBasicDescription audioDesc;</div><div class="line">@property (nonatomic, assign) double duration;</div><div class="line">@property (nonatomic, weak) id&lt;LLYAudioStreamDelegate&gt; delegate;</div><div class="line">@property (nonatomic, strong) LLYAudioProperty *audioProperty;</div><div class="line">@property (nonatomic, assign) UInt64 seekByteOffset;</div><div class="line">@property (nonatomic, assign) double seekTime;</div><div class="line">@property (nonatomic, assign) NSInteger audioVersion;</div><div class="line"></div><div class="line">//- (instancetype)initWithFileType:(AudioFileTypeID)fileTypeID;</div><div class="line"></div><div class="line">- (void)audioStreamParseBytes:(NSData *)data flags:(UInt32)flags;</div><div class="line"></div><div class="line">- (void)getSeekToOffset:(double)seekToTime;</div><div class="line"></div><div class="line">- (void)close;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>收到AudioSource的数据后，使用AudioStream来解析，然后把解析到的数据通过代理给AudioQueue，这就是AudoStream需要做的事情。</p>
<p>这里主要看一下下面几个方法：</p>
<h5 id="计算seek的偏移量"><a href="#计算seek的偏移量" class="headerlink" title="计算seek的偏移量"></a>计算seek的偏移量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)getSeekToOffset:(double)seekToTime&#123;</div><div class="line">    </div><div class="line">    self.seekByteOffset = dataOffset +</div><div class="line">    (seekToTime / self.duration) * (_audioProperty.fileSize - dataOffset);</div><div class="line">    </div><div class="line">    if (self.seekByteOffset &gt; _audioProperty.fileSize - 2 * _audioProperty.packetMaxSize)&#123;</div><div class="line">        self.seekByteOffset = _audioProperty.fileSize - 2 * _audioProperty.packetMaxSize;</div><div class="line">    &#125;</div><div class="line">    self.seekTime = seekToTime;</div><div class="line">    isSeeking=YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总时长"><a href="#总时长" class="headerlink" title="总时长"></a>总时长</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(double)duration&#123;</div><div class="line">    double calculatedBitRate = [self calculatedBitRate];</div><div class="line">    </div><div class="line">    if (calculatedBitRate == 0 || _audioProperty.fileSize == 0)</div><div class="line">    &#123;</div><div class="line">        return 0.0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return (_audioProperty.fileSize-dataOffset) / (calculatedBitRate * 0.125);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (double)calculatedBitRate</div><div class="line">&#123;</div><div class="line">    if (packetDuration &amp;&amp; packetCount &gt; BitRateEstimationMinPackets)</div><div class="line">    &#123;</div><div class="line">        double averagePacketByteSize = packetDataSize / packetCount;</div><div class="line">        return 8.0 * averagePacketByteSize / packetDuration;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (bitRate)</div><div class="line">    &#123;</div><div class="line">        return (double)bitRate;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AudioQueue模块和AudioPlayer模块相对来讲就比较简单了，之前的demo里面也使用过，就不一一介绍。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioPlayer.git" target="_blank" rel="noopener">demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/28/AudioQueue学习笔记和实战/" itemprop="url">
                  AudioQueue学习笔记和实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-28T12:09:55+08:00" content="2018-04-28">
              2018-04-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/28/AudioQueue学习笔记和实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/28/AudioQueue学习笔记和实战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioQueue理论学习"><a href="#AudioQueue理论学习" class="headerlink" title="AudioQueue理论学习"></a>AudioQueue理论学习</h3><p>AudioQueue是iOS提供的又一套实现音频播放和录制的框架，怎么说呢，使用起来其实也不比AduioUnit方便很多，特别是在buffer的管理上，新手理解起来还是有点费劲的，在被她折磨了一周后，现在终于把她征服了，这里做一下总结。</p>
<p>首先看一下官方给的AudioQueue工作流程图</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioQueue/audioqueue.png" alt=""></p>
<p>这里给出的是播放本地路径下的音频文件，流程总结如下：</p>
<ol>
<li>读取音频文件，在音频文件的回调中给buffers填充数据</li>
<li>将填充满的buffers给AudioQueue播放</li>
<li>AudioQueue播放完一个Buffer后,把这个buffer还给AudioQueue的回调继续填充</li>
<li>循环2和3直到音频播放完</li>
</ol>
<h4 id="主要的api"><a href="#主要的api" class="headerlink" title="主要的api:"></a>主要的api:</h4><h5 id="AudioQueueNewOutput"><a href="#AudioQueueNewOutput" class="headerlink" title="AudioQueueNewOutput"></a>AudioQueueNewOutput</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueNewOutput(const AudioStreamBasicDescription *inFormat, AudioQueueOutputCallback inCallbackProc, void *inUserData, CFRunLoopRef inCallbackRunLoop, CFStringRef inCallbackRunLoopMode, UInt32 inFlags, AudioQueueRef  _Nullable *outAQ);</div></pre></td></tr></table></figure>
<p>该方法用于创建一个用于输出音频的AudioQueue</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inFormat：该參数指明了即将播放的音频的数据格式 </li>
<li>inCallbackProc：该回调用于当AudioQueue已使用完一个缓冲区时通知用户，用户能够继续填充音频数据 </li>
<li>inUserData：由用户传入的数据指针，用于传递给回调函数 </li>
<li>inCallbackRunLoop：指明回调事件发生在哪个RunLoop之中，假设传递NULL，表示在AudioQueue所在的线程上运行该回调事件，普通情况下，传递NULL就可以。 </li>
<li>inCallbackRunLoopMode：指明回调事件发生的RunLoop的模式，传递NULL相当于kCFRunLoopCommonModes，通常情况下传递NULL就可以 </li>
<li>outAQ：该AudioQueue的引用实例，</li>
</ol>
<h5 id="AudioQueueOutput-Callback"><a href="#AudioQueueOutput-Callback" class="headerlink" title="AudioQueueOutput_Callback"></a>AudioQueueOutput_Callback</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void AudioQueueOutput_Callback(void *inClientData,AudioQueueRef inAQ,AudioQueueBufferRef inBuffer)</div></pre></td></tr></table></figure>
<p>这个是AudioQueue的回调函数，会将已经播放完的buffer还回来。</p>
<h5 id="AudioQueueAllocateBuffer"><a href="#AudioQueueAllocateBuffer" class="headerlink" title="AudioQueueAllocateBuffer"></a>AudioQueueAllocateBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueAllocateBuffer(AudioQueueRef inAQ, UInt32 inBufferByteSize, AudioQueueBufferRef  _Nullable *outBuffer);</div></pre></td></tr></table></figure>
<p>该方法的作用是为存放音频数据的缓冲区开辟空间</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inAQ：AudioQueue的引用实例 </li>
<li>inBufferByteSize：须要开辟的缓冲区的大小 </li>
<li>outBuffer：开辟的缓冲区的引用实例</li>
</ol>
<h5 id="AudioQueueEnqueueBuffer"><a href="#AudioQueueEnqueueBuffer" class="headerlink" title="AudioQueueEnqueueBuffer"></a>AudioQueueEnqueueBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueEnqueueBuffer(AudioQueueRef inAQ, AudioQueueBufferRef inBuffer, UInt32 inNumPacketDescs, const AudioStreamPacketDescription *inPacketDescs);</div></pre></td></tr></table></figure>
<p>该方法用于将已经填充数据的AudioQueueBuffer入队到AudioQueue</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inAQ：AudioQueue的引用实例 </li>
<li>inBuffer：须要入队的缓冲区实例 </li>
<li>inNumPacketDescs：缓冲区中共存在有多少帧音频数据 </li>
<li>inPacketDescs：缓冲区中每一帧的相关信息。用户须要指明当中每一帧在缓冲区中数据的偏移值，通过字段mStartOffset来指定</li>
</ol>
<h5 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueStart(AudioQueueRef inAQ, const AudioTimeStamp *inStartTime);</div><div class="line">OSStatus AudioQueuePause(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueStop(AudioQueueRef inAQ, Boolean inImmediate);</div><div class="line">OSStatus AudioQueueFlush(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueReset(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueDispose(AudioQueueRef inAQ, Boolean inImmediate);</div></pre></td></tr></table></figure>
<h4 id="AudioFileStream"><a href="#AudioFileStream" class="headerlink" title="AudioFileStream"></a>AudioFileStream</h4><p>数据的相关内容都和它相关，所以还是很重要的，其实AudioQueue使用起来比较简单，复杂的部分都在这个数据的处理上了。。。</p>
<h5 id="AudioFileStreamOpen"><a href="#AudioFileStreamOpen" class="headerlink" title="AudioFileStreamOpen"></a>AudioFileStreamOpen</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//        AudioFileStreamOpen的参数说明如下：</div><div class="line">//        1. inClientData：用户指定的数据，用于传递给回调函数，这里我们指定(__bridge LocalAudioPlayer*)self</div><div class="line">//        2. inPropertyListenerProc：当解析到一个音频信息时，将回调该方法</div><div class="line">//        3. inPacketsProc：当解析到一个音频帧时，将回调该方法</div><div class="line">//        4. inFileTypeHint：指明音频数据的格式，如果你不知道音频数据的格式，可以传0</div><div class="line">//        5. outAudioFileStream：AudioFileStreamID实例，需保存供后续使用</div><div class="line"></div><div class="line">AudioFileStreamOpen (		void * __nullable						inClientData,</div><div class="line">							AudioFileStream_PropertyListenerProc	inPropertyListenerProc,</div><div class="line">							AudioFileStream_PacketsProc				inPacketsProc,</div><div class="line">                			AudioFileTypeID							inFileTypeHint,</div><div class="line">                			AudioFileStreamID __nullable * __nonnull outAudioFileStream)</div></pre></td></tr></table></figure>
<p>这个函数会创建一个AudioFileStreamID,之后所有的操作都是基于这个ID来的，然后还是创建2个回调 inPropertyListenerProc 和 inPacketsProc，这2个回调函数比较重要，下面详说。</p>
<h5 id="AudioFileStreamParseBytes"><a href="#AudioFileStreamParseBytes" class="headerlink" title="AudioFileStreamParseBytes"></a>AudioFileStreamParseBytes</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//        参数的说明如下：</div><div class="line">//        1. inAudioFileStream：AudioFileStreamID实例，由AudioFileStreamOpen打开</div><div class="line">//        2. inDataByteSize：此次解析的数据字节大小</div><div class="line">//        3. inData：此次解析的数据大小</div><div class="line">//        4. inFlags：数据解析标志，其中只有一个值kAudioFileStreamParseFlag_Discontinuity = 1，表示解析的数据是否是不连续的，目前我们可以传0。</div><div class="line"></div><div class="line"></div><div class="line">AudioFileStreamParseBytes(	</div><div class="line">								AudioFileStreamID				inAudioFileStream,</div><div class="line">								UInt32							inDataByteSize,</div><div class="line">								const void * __nullable			inData,</div><div class="line">								AudioFileStreamParseFlags		inFlags)</div></pre></td></tr></table></figure>
<p>只有对数据进行了解析，才会进到上面的2个回调函数里面。</p>
<h5 id="AudioFileStreamPropertyListenerProc"><a href="#AudioFileStreamPropertyListenerProc" class="headerlink" title="AudioFileStreamPropertyListenerProc"></a>AudioFileStreamPropertyListenerProc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void AudioFileStreamPropertyListenerProc(void *inClientData,</div><div class="line">                                         AudioFileStreamID inAudioFileStream,</div><div class="line">                                         AudioFileStreamPropertyID inPropertyID,</div><div class="line">                                         UInt32 *ioFlags)</div></pre></td></tr></table></figure>
<p>在这个回调中，你可以拿到你想要的音频相关信息，比如音频结构（AudioStreamBasicDescription），码率（BitRate），MagicCookie等等，通过这些信息，你还可以计算其他数据，比如音频总时长。</p>
<p>这里分享下音频时长的2种计算方式：</p>
<ul>
<li><p>总时长 = 总帧数*单帧的时长</p>
<p>  单帧的时长 = 单帧的采样个数*每帧的时长</p>
<p>  每帧的时长 = 1/采样率</p>
</li>
</ul>
<p><strong>采样率：单位时间内的采样个数</strong></p>
<ul>
<li>总时长 = 文件总的字节数/码率</li>
</ul>
<p><strong>码率：单位时间内的文件字节数</strong></p>
<h5 id="AudioFileStreamPacketsProc"><a href="#AudioFileStreamPacketsProc" class="headerlink" title="AudioFileStreamPacketsProc"></a>AudioFileStreamPacketsProc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void AudioFileStreamPacketsProc(void *inClientData,</div><div class="line">                                UInt32 inNumberBytes,</div><div class="line">                                UInt32 inNumberPackets,</div><div class="line">                                const void *inInputData,</div><div class="line">                                AudioStreamPacketDescription *inPacketDescriptions)</div></pre></td></tr></table></figure>
<p>在这个回调中，你能够拿到每一个packet的数据，然后数据的填充都在这里完成。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>这里只讲几个比较重要的细节，其他的可以参考demo中的代码。</p>
<ol>
<li>AudioQueueNewOutput在创建的时候有2个runloop相关的参数，这里直接传NULL就行，不要取当前的runloop和model</li>
<li>AudioQueueOutput_Callback里面在标记可使用的buffer时要加锁，不然音频无法正常播放</li>
<li>记得设置AVAudioSession的category</li>
<li>读取音频数据时使用while循环，比使用计时器优雅</li>
<li>kAudioFileStreamProperty_DataFormat这个属性是必须要获取到的，在创建AudioQueue的时候需要传入</li>
<li>填装数据的时候要判断对当前buffer的可用填装空间，如果装不下了就别再装啦。。。</li>
<li>AudioQueueEnqueueBuffer给AudioQueue塞完数据后，需要判断下一个buffer是否可用，不可用的话得一直等着，知道可用为止。</li>
</ol>
<p><a href="https://github.com/lilingyu0620/LLYAudioUnitPlayer.git" target="_blank" rel="noopener">demo</a></p>
<p><a href="http://www.cnblogs.com/llguanli/p/8453133.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/16/AudioUnit实战/" itemprop="url">
                  AudioUnit实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-16T14:33:25+08:00" content="2018-04-16">
              2018-04-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/16/AudioUnit实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/16/AudioUnit实战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面学习了AudioUnit相关理论姿势，现在结合实际demo继续深入学习一下。。。</p>
<h3 id="AudioUnit–播放本地音频"><a href="#AudioUnit–播放本地音频" class="headerlink" title="AudioUnit–播放本地音频"></a>AudioUnit–播放本地音频</h3><p>因为AudioUnit只支持PCM文件，所以这里我们先使用一个本地的PCM文件进行播放，后续会有播放其他格式文件的demo,需要用到转码的相关API。</p>
<p>这里我们使用<strong>NSInputStream</strong>直接读取音频文件，因为不需要转码，所以读取到的数据就是可以直接拿来播放的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSInputStream *inputStream;</div><div class="line"> 	NSURL *url = [NSURL fileURLWithPath:self.pcmPath];</div><div class="line">   inputStream = [NSInputStream inputStreamWithURL:url];</div><div class="line">   if (!inputStream) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败!!!!%@&quot;,url);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">       [inputStream open];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>初始化AudioUnit相关内容前，我们需要全局设置一下<strong>AVAudioSession</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//设置audiosession</div><div class="line"></div><div class="line">   NSError *error = nil;   </div><div class="line">   AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;error];</div></pre></td></tr></table></figure>
<p>然后可以开始初始化AudioUnit，这里我们需要的是Output type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   AudioUnit playerAudioUnit;</div><div class="line"></div><div class="line">//AU描述</div><div class="line">   AudioComponentDescription audioUnitDesc;</div><div class="line">   audioUnitDesc.componentType = kAudioUnitType_Output;</div><div class="line">   audioUnitDesc.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">   audioUnitDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">   audioUnitDesc.componentFlags = 0;</div><div class="line">   audioUnitDesc.componentFlagsMask = 0;</div><div class="line">   </div><div class="line">   //AudioUnit裸创建</div><div class="line">   AudioComponent audioComponent = AudioComponentFindNext(NULL, &amp;audioUnitDesc);</div><div class="line">   AudioComponentInstanceNew(audioComponent, &amp;playerAudioUnit);</div></pre></td></tr></table></figure>
<p>接下来有一个<strong>kAudioOutputUnitProperty_EnableIO</strong>属性的设置，这里如果只是播放功能的话，实际上是不需要设置的，因为AudioUnit默认就是支持播放的，如果需要输入功能（比如录音）时，就必须设置这个属性，之后的demo会有使用，这里我们先不设置这个属性，设置的相关格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//通用参数设置,这里是设置扬声器</div><div class="line">  OSStatus status = noErr;</div><div class="line">  UInt32 flag = 1;</div><div class="line">  UInt32 outputBus = 0;//Element 0</div><div class="line">  status = AudioUnitSetProperty(playerAudioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, outputBus, &amp;flag, sizeof(flag));</div><div class="line">  if (status) &#123;</div><div class="line">      NSLog(@&quot;AudioUnitSetProperty error with status:%d&quot;, status);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后我们需要设置AudioUnit的播放音频的格式，这里一般都是PCM格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//设置音频具体结构</div><div class="line">   AudioStreamBasicDescription audioStreamDesc;</div><div class="line">//    bzero(&amp;audioStreamDesc, sizeof(audioStreamDesc));</div><div class="line">   memset(&amp;audioStreamDesc, 0, sizeof(audioStreamDesc));</div><div class="line">   audioStreamDesc.mFormatID = kAudioFormatLinearPCM;</div><div class="line">   audioStreamDesc.mSampleRate = 44100;//采样率</div><div class="line">   audioStreamDesc.mChannelsPerFrame = 1;//声道数</div><div class="line">   audioStreamDesc.mFramesPerPacket = 1;//每帧只有一个packet</div><div class="line">   audioStreamDesc.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger;//kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;</div><div class="line">   audioStreamDesc.mBitsPerChannel = 16;//位深</div><div class="line">   audioStreamDesc.mBytesPerFrame = 2;</div><div class="line">   audioStreamDesc.mBytesPerPacket = 2;</div><div class="line"></div><div class="line">//这里是设置的输出音频的格式</div><div class="line">   status = AudioUnitSetProperty(playerAudioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, outputBus, &amp;audioStreamDesc,sizeof(audioStreamDesc));</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;AudioUnitSetProperty error with status:%d&quot;, status);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>最后设置一下输出的回调，这个回调是每次扬声器需要播放数据时都会调一次这个回调，然后我们在这个回调里面把要播放的数据塞给扬声器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">	//callback</div><div class="line">    AURenderCallbackStruct callbackStruct;</div><div class="line">    callbackStruct.inputProc = PlayCallback;</div><div class="line">    callbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">    AudioUnitSetProperty(playerAudioUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, outputBus, &amp;callbackStruct, sizeof(callbackStruct));</div><div class="line"></div><div class="line">	//最后初始化AudioUnit</div><div class="line">    OSStatus result = AudioUnitInitialize(playerAudioUnit);</div><div class="line">    NSLog(@&quot;result = %d&quot;,result);</div><div class="line">    </div><div class="line">    //回调实现</div><div class="line">    static OSStatus PlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line"></div><div class="line">    __unsafe_unretained LLYAudioUnitPlayer *play = (__bridge LLYAudioUnitPlayer *)inRefCon;</div><div class="line"></div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;out size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line"></div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就可以开始播放音频了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)play&#123;</div><div class="line">    </div><div class="line">    [self initAudioUnit];</div><div class="line">    </div><div class="line">    AudioOutputUnitStart(playerAudioUnit);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stop&#123;</div><div class="line">    </div><div class="line">    AudioOutputUnitStop(playerAudioUnit);</div><div class="line">    [inputStream close];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AudioUnit–录音-播放-保存本地"><a href="#AudioUnit–录音-播放-保存本地" class="headerlink" title="AudioUnit–录音+播放+保存本地"></a>AudioUnit–录音+播放+保存本地</h3><p>这个demo做的事情是把本地播放的音频和录制的音频一起输出并写入文件。播放音频部分和上面的流程一样，这里主要说一下录制音频部分的流程。</p>
<p>AVAudioSession的设置，这里我们需要用到录音功能，同时我们还需要设置一下采样频率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//设置AVAudioSession</div><div class="line">   [[AVAudioSession sharedInstance]setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;error];</div><div class="line">   if (error) &#123;</div><div class="line">       NSLog(@&quot;setCategory error %@&quot;,error);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   [[AVAudioSession sharedInstance] setPreferredIOBufferDuration:0.05 error:&amp;error];</div><div class="line">   if (error) &#123;</div><div class="line">       NSLog(@&quot;setPreferredIOBufferDuration error:%@&quot;, error);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们使用AudioBufferList 这个数据结构来保存获取到的录音音频数据，先对该数据结构做一个初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">AudioBufferList *bufferList;</div><div class="line"></div><div class="line">// buffer list</div><div class="line">uint32_t numberBuffers = 2;</div><div class="line">bufferList = (AudioBufferList *)malloc(sizeof(AudioBufferList) + (numberBuffers - 1) * sizeof(AudioBuffer));</div><div class="line">bufferList-&gt;mNumberBuffers = numberBuffers;</div><div class="line">bufferList-&gt;mBuffers[0].mNumberChannels = 1;</div><div class="line">bufferList-&gt;mBuffers[0].mDataByteSize = BUFFERSIZE;</div><div class="line">bufferList-&gt;mBuffers[0].mData = malloc(BUFFERSIZE);</div><div class="line"></div><div class="line">for (int i =1; i &lt; numberBuffers; ++i) &#123;</div><div class="line">    bufferList-&gt;mBuffers[i].mNumberChannels = 1;</div><div class="line">    bufferList-&gt;mBuffers[i].mDataByteSize = BUFFERSIZE;</div><div class="line">    bufferList-&gt;mBuffers[i].mData = malloc(BUFFERSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着上个demo的代码，这里我们再设置一下输入的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AudioStreamBasicDescription outputFormat = inputFormat;</div><div class="line">   outputFormat.mChannelsPerFrame = 2;</div><div class="line">   status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                 kAudioUnitProperty_StreamFormat,</div><div class="line">                                 kAudioUnitScope_Input,</div><div class="line">                                 OUTPUT_BUS,</div><div class="line">                                 &amp;outputFormat,</div><div class="line">                                 sizeof(outputFormat));</div><div class="line">   </div><div class="line">   if (status != noErr) &#123;</div><div class="line">       NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后我们需要设置AudioUnit的输入能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// enable record</div><div class="line">  UInt32 flag = 1;</div><div class="line">  status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                kAudioOutputUnitProperty_EnableIO,</div><div class="line">                                kAudioUnitScope_Input,</div><div class="line">                                INPUT_BUS,</div><div class="line">                                &amp;flag,</div><div class="line">                                sizeof(flag));</div><div class="line">  if (status != noErr) &#123;</div><div class="line">      NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>之后设置一下录音的回调，在回调中获取录音的音频数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    // set callback</div><div class="line">    AURenderCallbackStruct recordCallback;</div><div class="line">    recordCallback.inputProc = RecordCallback;</div><div class="line">    recordCallback.inputProcRefCon = (__bridge void *)self;</div><div class="line">    status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                  kAudioOutputUnitProperty_SetInputCallback,</div><div class="line">                                  kAudioUnitScope_Output,</div><div class="line">                                  INPUT_BUS,</div><div class="line">                                  &amp;recordCallback,</div><div class="line">                                  sizeof(recordCallback));</div><div class="line">    if (status != noErr) &#123;</div><div class="line">        NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    #pragma mark - callback</div><div class="line">    </div><div class="line">static OSStatus RecordCallback(void *inRefCon,</div><div class="line">                               AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                               const AudioTimeStamp *inTimeStamp,</div><div class="line">                               UInt32 inBusNumber,</div><div class="line">                               UInt32 inNumberFrames,</div><div class="line">                               AudioBufferList *ioData)</div><div class="line">&#123;</div><div class="line">    LLYAudioUnitRecord *record = (__bridge LLYAudioUnitRecord *)inRefCon;</div><div class="line">    record-&gt;bufferList-&gt;mNumberBuffers = 1;</div><div class="line">    OSStatus status = AudioUnitRender(record-&gt;recordAudioUnit, ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, record-&gt;bufferList);</div><div class="line">    if (status != noErr) &#123;</div><div class="line">        NSLog(@&quot;AudioUnitRender error:%d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;size1 = %d&quot;, record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    [record writePCMData:record-&gt;bufferList-&gt;mBuffers[0].mData size:record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们把录音的音频数据保存在了bufferList中。这个bufferList中的数据将被手动塞给播放的回调进行播放，播放（输出）的回调代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static OSStatus OutPlayCallback(void *inRefCon,</div><div class="line">                             AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                             const AudioTimeStamp *inTimeStamp,</div><div class="line">                             UInt32 inBusNumber,</div><div class="line">                             UInt32 inNumberFrames,</div><div class="line">                             AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitRecord *record = (__bridge LLYAudioUnitRecord *)inRefCon;</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, record-&gt;bufferList-&gt;mBuffers[0].mData, record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    NSInteger bytes = BUFFERSIZE &lt; ioData-&gt;mBuffers[1].mDataByteSize * 2 ? BUFFERSIZE : ioData-&gt;mBuffers[1].mDataByteSize * 2; //</div><div class="line">    bytes = [record-&gt;inputStream read:record-&gt;buffer maxLength:bytes];</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt; bytes; ++i) &#123;</div><div class="line">        ((Byte*)ioData-&gt;mBuffers[1].mData)[i/2] = record-&gt;buffer[i];</div><div class="line">    &#125;</div><div class="line">    ioData-&gt;mBuffers[1].mDataByteSize = (UInt32)bytes / 2;</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[1].mDataByteSize &lt; ioData-&gt;mBuffers[0].mDataByteSize) &#123;</div><div class="line">        ioData-&gt;mBuffers[0].mDataByteSize = ioData-&gt;mBuffers[1].mDataByteSize;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    NSLog(@&quot;size2 = %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们给ioData-&gt;mBuffers塞了2组数据，一组是从bufferList中获取的录音音频数据，另外一组是从inputStream中读取的本地音频数据，所以播放时既能听到本地音频也能听到我们录音的音频。</p>
<p>将音频写入文件的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)writePCMData:(Byte *)buffer size:(int)size &#123;</div><div class="line">    static FILE *file = NULL;</div><div class="line">    NSString *pathStr = [LLYAudioUnitRecord recordPath];</div><div class="line">    if (!file) &#123;</div><div class="line">        file = fopen(pathStr.UTF8String, &quot;w&quot;);</div><div class="line">    &#125;</div><div class="line">    fwrite(buffer, size, 1, file);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSString *)recordPath&#123;</div><div class="line">    return [CommonUtil documentsPath:@&quot;/record.pcm&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AudioUnit–播放MP3"><a href="#AudioUnit–播放MP3" class="headerlink" title="AudioUnit–播放MP3"></a>AudioUnit–播放MP3</h3><p>上面说过，AudioUnit是不支持直接播放MP3文件格式的，所以这里我们先把MP3转码为pcm格式然后再塞给播放回调去播放。</p>
<p>播放的逻辑我们已经很清楚了，这里我主要说一下怎么转码。这里我们用到了<strong>AudioFile</strong>和<strong>AudioConverter</strong>两个类，AudioFile主要做音频相关信息的读取，AudioConverter主要做转码的工作。</p>
<p>先来看一下AudioFile的相关代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">   AudioFileID audioFileID;</div><div class="line">   AudioStreamBasicDescription audioFileFormat;</div><div class="line">   AudioStreamPacketDescription *audioPacketFormat;</div><div class="line">   </div><div class="line">SInt64 readedPacket;</div><div class="line">   UInt64 packetNums;</div><div class="line">   UInt64 packetNumsInBuffer;</div><div class="line">   </div><div class="line">   //获取源音频的ID</div><div class="line">   NSString *mp3Path = [CommonUtil bundlePath:@&quot;abc.mp3&quot;];</div><div class="line">   NSURL *mp3Url = [NSURL fileURLWithPath:mp3Path];</div><div class="line">   OSStatus status = AudioFileOpenURL((__bridge CFURLRef)mp3Url, kAudioFileReadPermission, 0, &amp;audioFileID);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败 %@&quot;, mp3Url);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频的FileFormat</div><div class="line">   uint32_t size = sizeof(AudioStreamBasicDescription);</div><div class="line">   status = AudioFileGetProperty(audioFileID, kAudioFilePropertyDataFormat, &amp;size, &amp;audioFileFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取fileformat失败 error status %d&quot;, status);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   //获取源音频的packetnum</div><div class="line">   size = sizeof(packetNums);</div><div class="line">   status = AudioFileGetProperty(audioFileID, kAudioFilePropertyAudioDataPacketCount, &amp;size, &amp;packetNums);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取packetnum失败 error status %d&quot;, status);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频单个packet的最大buffer数</div><div class="line">   uint32_t sizePerPacket = audioFileFormat.mFramesPerPacket;</div><div class="line">   if (sizePerPacket == 0) &#123;</div><div class="line">       size = sizeof(sizePerPacket);</div><div class="line">       status = AudioFileGetProperty(audioFileID, kAudioFilePropertyMaximumPacketSize, &amp;size, &amp;sizePerPacket);</div><div class="line">       if (status) &#123;</div><div class="line">           NSLog(@&quot;获取packetmaxnum失败 error status %d&quot;, status);</div><div class="line">           return ;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频的packetformat</div><div class="line">   audioPacketFormat = malloc(sizeof(AudioStreamPacketDescription) * (CONST_BUFFER_SIZE/sizePerPacket + 1));</div></pre></td></tr></table></figure>
<p>这里说一下packetnum这个属性，因为音频数据流都是以一个个packet的格式封装起来的，所以这个获取的packetnum实际上就是音频的总长度，而每个packet里面又以帧（frame）为单位做了一层封装，每个packet里面的帧数不固定。每一帧就是实际的音频数据了。</p>
<p>因为数据的处理都在播放回调中，我们来看看AudioConverter都做了哪些工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">	//上面拿到了音频的数据格式，这里用来做AudioConverter的初始化</div><div class="line">	//初始化audioconverter</div><div class="line">    status = AudioConverterNew(&amp;audioFileFormat, &amp;outputFormat, &amp;audioConverter);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;AudioConverterNew eror with status:%d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">	OSStatus ConPlayCallback(void *inRefCon,</div><div class="line">                      AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                      const AudioTimeStamp *inTimeStamp,</div><div class="line">                      UInt32 inBusNumber,</div><div class="line">                      UInt32 inNumberFrames,</div><div class="line">                      AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitConverter *converter = (__bridge LLYAudioUnitConverter *)inRefCon;</div><div class="line">    </div><div class="line">    converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize = CONST_BUFFER_SIZE;</div><div class="line">    OSStatus status = AudioConverterFillComplexBuffer(converter-&gt;audioConverter, InputDataProc, inRefCon, &amp;inNumberFrames, converter-&gt;bufferList, NULL);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;转换格式失败 %d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;out size: %d&quot;, converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, converter-&gt;bufferList-&gt;mBuffers[0].mData, converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    //    fwrite(player-&gt;buffList-&gt;mBuffers[0].mData, player-&gt;buffList-&gt;mBuffers[0].mDataByteSize, 1, [player pcmFile]);</div><div class="line">    </div><div class="line">    if (converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [converter onPlayEnd];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，是调用了<strong>AudioConverterFillComplexBuffer</strong>这个方法做的转码，其中第二个参数又是一个回调函数，转码后的数据同样是保存在converter-&gt;bufferList这个结构里面，然后在后面塞给ioData-&gt;mBuffers去播放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">OSStatus InputDataProc(AudioConverterRef inAudioConverter, UInt32 *ioNumberDataPackets, AudioBufferList *ioData, AudioStreamPacketDescription **outDataPacketDescription, void *inUserData)</div><div class="line">&#123;</div><div class="line">    LLYAudioUnitConverter *player = (__bridge LLYAudioUnitConverter *)(inUserData);</div><div class="line">    </div><div class="line">    UInt32 byteSize = CONST_BUFFER_SIZE;</div><div class="line">    OSStatus status = AudioFileReadPacketData(player-&gt;audioFileID, NO, &amp;byteSize, player-&gt;audioPacketFormat, player-&gt;readedPacket, ioNumberDataPackets, player-&gt;convertBuffer);</div><div class="line">    </div><div class="line">    if (outDataPacketDescription) &#123; // 这里要设置好packetFormat，否则会转码失败</div><div class="line">        *outDataPacketDescription = player-&gt;audioPacketFormat;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if(status) &#123;</div><div class="line">        NSLog(@&quot;读取文件失败&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!status &amp;&amp; ioNumberDataPackets &gt; 0) &#123;</div><div class="line">        ioData-&gt;mBuffers[0].mDataByteSize = byteSize;</div><div class="line">        ioData-&gt;mBuffers[0].mData = player-&gt;convertBuffer;</div><div class="line">        player-&gt;readedPacket += *ioNumberDataPackets;</div><div class="line">        return noErr;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return NO_MORE_DATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个回调函数主要负责读取mp3文件给上面的AudioConverterFillComplexBuffer函数用来做转码处理。</p>
<h3 id="AudioUnit–更简单的播放MP3"><a href="#AudioUnit–更简单的播放MP3" class="headerlink" title="AudioUnit–更简单的播放MP3"></a>AudioUnit–更简单的播放MP3</h3><p>上一个demo中我们使用AudioUnit播放了一个MP3文件，用到了AudioFile和AudioConverter类的相关方法，可以看到，使用这种方式播放MP3文件是比较繁琐的，我们要获取音频的很多信息，要设置回调，要使用一系列的相关api。。。下面介绍一种更简单的播放MP3的方式，使用<strong>ExtAudioFile</strong>，看名字就知道，它是上面介绍的AudioFile的扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//ExtAudioFileRef对象</div><div class="line"></div><div class="line"> ExtAudioFileRef extAudioFile;</div><div class="line">   AudioStreamBasicDescription audioFileFormat;</div><div class="line">   AudioStreamBasicDescription outputFormat;</div><div class="line">   </div><div class="line">    OSStatus status = noErr;</div><div class="line">   NSURL *mp3Url = [NSURL fileURLWithPath:[CommonUtil bundlePath:@&quot;/abc.mp3&quot;]];</div><div class="line">   status = ExtAudioFileOpenURL((__bridge CFURLRef)mp3Url, &amp;extAudioFile);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取MP3音频的格式（非必需）</div><div class="line">   uint32_t size = sizeof(AudioStreamBasicDescription);</div><div class="line">   status = ExtAudioFileGetProperty(extAudioFile, kExtAudioFileProperty_FileDataFormat, &amp;size, &amp;audioFileFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;读取音频格式失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    //initFormat 设置输出格式</div><div class="line">   memset(&amp;outputFormat, 0, sizeof(outputFormat));</div><div class="line">   outputFormat.mSampleRate       = 44100;</div><div class="line">   outputFormat.mFormatID         = kAudioFormatLinearPCM;</div><div class="line">   outputFormat.mFormatFlags      = kLinearPCMFormatFlagIsSignedInteger;</div><div class="line">   outputFormat.mBytesPerPacket   = 2;</div><div class="line">   outputFormat.mFramesPerPacket  = 1;</div><div class="line">   outputFormat.mBytesPerFrame    = 2;</div><div class="line">   outputFormat.mChannelsPerFrame = 1;</div><div class="line">   outputFormat.mBitsPerChannel   = 16;</div><div class="line">    status = ExtAudioFileSetProperty(extAudioFile, kExtAudioFileProperty_ClientDataFormat, size, &amp;outputFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;设置转码音频格式失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取总长度（非必需）</div><div class="line">    size = sizeof(totalFrame);</div><div class="line">   status = ExtAudioFileGetProperty(extAudioFile, kExtAudioFileProperty_FileLengthFrames, &amp;size, &amp;totalFrame);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取音频总长度失败&quot;);</div><div class="line">   &#125;</div><div class="line">   NSLog(@&quot;音频总长度：%llu&quot;,totalFrame);</div></pre></td></tr></table></figure>
<p>AudioUnit相关的代码参考上面的几个demo. 这个必需的操作就是open file，获取到extAudioFile。然后我们看看回调里面做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">OSStatus ExtPlayCallback(void *inRefCon,</div><div class="line">                      AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                      const AudioTimeStamp *inTimeStamp,</div><div class="line">                      UInt32 inBusNumber,</div><div class="line">                      UInt32 inNumberFrames,</div><div class="line">                      AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitExtPlayer *player = (__bridge LLYAudioUnitExtPlayer *)inRefCon;</div><div class="line">    player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize = BUFFER_SIZE_CONST;</div><div class="line">    OSStatus status = ExtAudioFileRead(player-&gt;extAudioFile, &amp;inNumberFrames, player-&gt;bufferList);</div><div class="line">    NSLog(@&quot;inNumberFrames = %d&quot;,inNumberFrames);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;转码失败&quot;);</div><div class="line">    &#125;</div><div class="line">    if (!inNumberFrames) &#123;</div><div class="line">        NSLog(@&quot;播放结束&quot;);</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;out size : %d&quot;,player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, player-&gt;bufferList-&gt;mBuffers[0].mData, player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    player-&gt;readedFrame += player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize / player-&gt;outputFormat.mBytesPerFrame;</div><div class="line">    </div><div class="line">    NSLog(@&quot;readedFrame = %d&quot;,player-&gt;readedFrame);</div><div class="line">    </div><div class="line">    if (player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [player onPlayEnd];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只调用了一个<strong>ExtAudioFileRead</strong>方法，就把MP3文件转成了pcm文件存到了player-&gt;bufferList中，最终塞给ioData-&gt;mBuffers去播放即可。是不是比上面demo要简单很多呢。</p>
<h3 id="AudioUnit–使用AUGraph播放伴奏-录音"><a href="#AudioUnit–使用AUGraph播放伴奏-录音" class="headerlink" title="AudioUnit–使用AUGraph播放伴奏+录音"></a>AudioUnit–使用AUGraph播放伴奏+录音</h3><p>前面都是直接使用AudioUnit实现播放，录音相关工作，这一小节我们来学习一下使用AUGraph管理AudioUnit，当你需要多个AudioUnit来实现不同的模块，且各模块的输入输出直接又有相关联时，使用AUGraph是比较好的选择，因为它可以为AudioUnit之间建立连接，直接进行数据传递，省去了我们手动传递数据的麻烦。</p>
<p>这里我是分了三步来实现整个功能的：</p>
<ul>
<li>1.先播放本地音频</li>
<li>2.加入录音功能</li>
<li>3.将录音音频和本地音频送给mix,mix的输出绑定到io的输出</li>
</ul>
<p>首先来看第一步，使用AUGraph播放本地音频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">//相关变量</div><div class="line"></div><div class="line">   AUGraph playerGraph;</div><div class="line">   </div><div class="line">   //io相关</div><div class="line">   AUNode ioNode;</div><div class="line">   AudioUnit ioUnit;</div><div class="line">   </div><div class="line">   AudioStreamBasicDescription audioFormat;</div><div class="line">   </div><div class="line">   NSInputStream *inputStream;</div><div class="line"></div><div class="line"></div><div class="line">//init</div><div class="line"></div><div class="line">    </div><div class="line">   NSURL *url = [NSURL fileURLWithPath:[CommonUtil bundlePath:@&quot;/abc.pcm&quot;]];</div><div class="line">   inputStream = [NSInputStream inputStreamWithURL:url];</div><div class="line">   if (!inputStream) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败!!!!%@&quot;,url);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">       [inputStream open];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayback error:nil]; // 只有播放</div><div class="line"></div><div class="line">OSStatus status = noErr;</div><div class="line">   status = NewAUGraph(&amp;playerGraph);</div><div class="line">   CheckStatus(status, @&quot;创建AUGraph失败&quot;, YES);</div><div class="line">   </div><div class="line">   AudioComponentDescription outputAudioDesc;</div><div class="line">   outputAudioDesc.componentType = kAudioUnitType_Output;</div><div class="line">   outputAudioDesc.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">   outputAudioDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">   outputAudioDesc.componentFlags = 0;</div><div class="line">   outputAudioDesc.componentFlagsMask = 0;</div><div class="line">   </div><div class="line">   status = AUGraphAddNode(playerGraph, &amp;outputAudioDesc, &amp;ioNode);</div><div class="line">   CheckStatus(status, @&quot;绑定node失败&quot;, YES);</div><div class="line">   </div><div class="line">   status = AUGraphOpen(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;打开AUGraph失败&quot;, YES);</div><div class="line">   </div><div class="line">   status = AUGraphNodeInfo(playerGraph, ioNode, NULL, &amp;ioUnit);</div><div class="line">   CheckStatus(status, @&quot;创建AudioUnit失败&quot;, YES);</div><div class="line"></div><div class="line">   // audio format</div><div class="line">   audioFormat.mSampleRate = 44100;</div><div class="line">   audioFormat.mFormatID = kAudioFormatLinearPCM;</div><div class="line">   audioFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsNonInterleaved;</div><div class="line">   audioFormat.mFramesPerPacket = 1;</div><div class="line">   audioFormat.mChannelsPerFrame = 1;</div><div class="line">   audioFormat.mBytesPerPacket = 2;</div><div class="line">   audioFormat.mBytesPerFrame = 2;</div><div class="line">   audioFormat.mBitsPerChannel = 16;</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">   CheckStatus(status, @&quot;设置输入音频数据格式失败&quot;, YES);</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">   CheckStatus(status, @&quot;设置输出音频格式失败&quot;, YES);</div><div class="line"></div><div class="line">   </div><div class="line">   //callback</div><div class="line">   AURenderCallbackStruct callbackStruct;</div><div class="line">   callbackStruct.inputProc = LLYPlayCallback;</div><div class="line">   callbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">   AudioUnitSetProperty(playerUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &amp;callbackStruct, sizeof(callbackStruct));</div><div class="line">   </div><div class="line">   status  = AUGraphInitialize(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;Graph初始化失败&quot;, YES);</div><div class="line">   status = AUGraphStart(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;Graph start失败&quot;, YES);</div></pre></td></tr></table></figure>
<p>io的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	static OSStatus LLYPlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;out size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步：加入录音功能，这里其实只需要对第一步做一下修改,将io回调数据处理的bus改为输入，设置输入相关属性即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   AudioBufferList *buffList;</div><div class="line">   Byte *buffer;</div><div class="line">   </div><div class="line">   </div><div class="line">   //init</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];</div><div class="line">   [audioSession setPreferredIOBufferDuration:0.02 error:&amp;error];</div><div class="line"></div><div class="line">   </div><div class="line">   // buffer</div><div class="line">   uint32_t numberBuffers = 1;</div><div class="line">   buffList = (AudioBufferList *)malloc(sizeof(AudioBufferList));</div><div class="line">   buffList-&gt;mNumberBuffers = numberBuffers;</div><div class="line">   buffList-&gt;mBuffers[0].mNumberChannels = 1;</div><div class="line">   buffList-&gt;mBuffers[0].mDataByteSize = GRAPH_CONST_BUFFER_SIZE;</div><div class="line">   buffList-&gt;mBuffers[0].mData = malloc(GRAPH_CONST_BUFFER_SIZE);</div><div class="line">   buffer = malloc(GRAPH_CONST_BUFFER_SIZE);</div><div class="line"></div><div class="line">//设置输入格式</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(AudioStreamBasicDescription));</div><div class="line">   CheckStatus(status, @&quot;设置输出音频格式失败&quot;, YES);</div><div class="line">   </div><div class="line">   </div><div class="line">//设置输入部分的回调，实际的录音数据是在这里获取的，</div><div class="line">   AURenderCallbackStruct outputCallbackStruct;</div><div class="line">   outputCallbackStruct.inputProc = OutputPlayCallback;</div><div class="line">   outputCallbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioOutputUnitProperty_SetInputCallback, kAudioUnitScope_Output, 1, &amp;outputCallbackStruct, sizeof(outputCallbackStruct));</div><div class="line">   CheckStatus(status, @&quot;ioUnit绑定回调失败&quot;, YES);</div></pre></td></tr></table></figure>
<p>io的回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	static OSStatus OutputPlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    play-&gt;buffList-&gt;mNumberBuffers = 1;</div><div class="line">    OSStatus status = AudioUnitRender(play-&gt;ioUnit, ioActionFlag, inTimeStamp, inBusNumber, inNumberFrames, play-&gt;buffList);</div><div class="line">    CheckStatus(status, @&quot;获取录音音频失败&quot;, YES);</div><div class="line">    </div><div class="line">//    NSLog(@&quot;record size %d:&quot;,play-&gt;buffList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    //将录音写入文件</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步：获取2路音频并同时播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    //负责获取2路音频和混合</div><div class="line">    AUNode mixNode;</div><div class="line">    AudioUnit mixUnit;</div><div class="line"></div><div class="line">	 //混合相关</div><div class="line">    AudioComponentDescription mixAudioDesc;</div><div class="line">    mixAudioDesc.componentType = kAudioUnitType_Mixer;</div><div class="line">    mixAudioDesc.componentSubType = kAudioUnitSubType_MultiChannelMixer;</div><div class="line">    mixAudioDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    mixAudioDesc.componentFlags = 0;</div><div class="line">    mixAudioDesc.componentFlagsMask = 0;</div><div class="line">    </div><div class="line">    status = AUGraphAddNode(playerGraph, &amp;mixAudioDesc, &amp;mixNode);</div><div class="line">    CheckStatus(status, @&quot;绑定混合node失败&quot;, YES);</div><div class="line">    </div><div class="line">    status = AUGraphNodeInfo(playerGraph, mixNode, NULL, &amp;mixUnit);</div><div class="line">    CheckStatus(status, @&quot;创建混合AudioUnit失败&quot;, YES);</div><div class="line"></div><div class="line">    //绑定nodes，这里就是将mix的输出和io的输出绑定起来，不再需要手动设置io的输出回调了</div><div class="line">    status = AUGraphConnectNodeInput(playerGraph, mixNode, 0, ioNode, 0);</div><div class="line">    CheckStatus(status, @&quot;绑定node失败&quot;, YES);</div><div class="line"></div><div class="line">    //设置bus数</div><div class="line">    UInt32 busCount = 2;</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &amp;busCount, sizeof(busCount));</div><div class="line">    CheckStatus(status, @&quot;设置声道数失败&quot;, YES);</div><div class="line">    </div><div class="line">    //设置混合的输入格式,有多条输入</div><div class="line">    //bus0</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">    CheckStatus(status, @&quot;设置混合音频输入数据格式失败&quot;, YES);</div><div class="line">    //bus1</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 1, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">    CheckStatus(status, @&quot;设置混合音频输入数据格式失败&quot;, YES);</div><div class="line"></div><div class="line">	 //获取背景音频数据</div><div class="line">    AURenderCallbackStruct callback0;</div><div class="line">    callback0.inputProc = mixCallback0;</div><div class="line">    callback0.inputProcRefCon = (__bridge void *)self;</div><div class="line">//    status = AUGraphSetNodeInputCallback(playerGraph, mixNode, 0, &amp;callback0);</div><div class="line">    CheckStatus(AudioUnitSetProperty(mixUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &amp;callback0, sizeof(callback0)), @&quot;add mix callback fail&quot;,YES);</div><div class="line"></div><div class="line">    //获取录音数据</div><div class="line">    AURenderCallbackStruct callback1;</div><div class="line">    callback1.inputProc = mixCallback1;</div><div class="line">    callback1.inputProcRefCon = (__bridge void *)self;</div><div class="line">//    status = AUGraphSetNodeInputCallback(playerGraph, mixNode, 1, &amp;callback1);</div><div class="line">    CheckStatus(AudioUnitSetProperty(mixUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 1, &amp;callback1, sizeof(callback1)), @&quot;add mix callback fail&quot;,YES);</div></pre></td></tr></table></figure>
<p>mix的2路数据的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	//获取本地播放的音频</div><div class="line">	static OSStatus mixCallback0(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData) &#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;audio size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	//获取录音音频</div><div class="line">	static OSStatus mixCallback1(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData) &#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line"></div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, play-&gt;buffList-&gt;mBuffers[0].mData, play-&gt;buffList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = play-&gt;buffList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    NSLog(@&quot;record size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line"></div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mix的2路回调中，我们分别获取到了数据并塞给mix的输入，然后mix直接输出到io的输出bus进行播放，中间不在需要我们做额外的工作。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioUnitPlayer.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/AudioUnit学习笔记/" itemprop="url">
                  AudioUnit学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T16:15:43+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/AudioUnit学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/AudioUnit学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioUnit简介"><a href="#AudioUnit简介" class="headerlink" title="AudioUnit简介"></a>AudioUnit简介</h3><p>在iOS中，所有的上层音频技术都是基于AudioUnit和CoreMedia来实现的。<br>下图可以直观的反应出AudioUnit的层级关系。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/auidounit1-1.png" alt=""></p>
<p>对于普通的音频播放功能可能不需要直接使用AudioUnit来实现，但是如果你需要实现比较高级的功能（比如录音，混音等），就需要使用AudioUnit了。</p>
<p>根据不同的音频目的，iOS将AudioUnit共分为7类。如下图所示</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-2.png" alt=""></p>
<ul>
<li><p>effect units 这个是用在ipod类app上的，比较少使用到。</p>
</li>
<li><p>mixer units 做混音的，有2个audio unit，3D mixer比较适合用来做游戏的3d音效。multichannel mixer提供混合任意数量的单声道或立体声流,立体声输出。</p>
</li>
<li><p>i/o units  远程I/O单元是最常用的。它连接到输入和输出音频硬件和给你对传入和传出的低延迟访问音频样本值。它提供了硬件音频格式和应用程序之间的格式转换音频格式。声音处理I/O单元扩展了远程I/O单元，通过添加声学回声取消使用网络电话或者语音聊天应用程序。通用输出装置不连接到音频硬件,而是提供了一个机制来处理链的输出发送到您的应用程序。</p>
</li>
<li><p>Format Converter Unit 用来处理音频格式的转换。</p>
</li>
</ul>
<h3 id="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit"><a href="#iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit" class="headerlink" title="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit."></a>iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit.</h3><h4 id="通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit"><a href="#通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit" class="headerlink" title="通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit"></a>通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit</h4><p>在创建一个AudioUnit实例之前，需要先创建一个audiocomponent 创建方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//组件描述</div><div class="line">AudioComponentDescription ioUnitDescription;</div><div class="line">//组件类型</div><div class="line">ioUnitDescription.componentType          = kAudioUnitType_Output;</div><div class="line">//组件子类型</div><div class="line">ioUnitDescription.componentSubType       = kAudioUnitSubType_RemoteIO;</div><div class="line">//默认值</div><div class="line">ioUnitDescription.componentManufacturer  = kAudioUnitManufacturer_Apple;</div><div class="line">ioUnitDescription.componentFlags         = 0;</div><div class="line">ioUnitDescription.componentFlagsMask     = 0;</div><div class="line"></div><div class="line">AudioComponent foundIoUnitReference = AudioComponentFindNext (NULL,&amp;ioUnitDescription);</div><div class="line">AudioUnit ioUnitInstance;</div><div class="line">AudioComponentInstanceNew (</div><div class="line">    foundIoUnitReference,</div><div class="line">    &amp;ioUnitInstance</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="使用AUGraph创建AudioUnit"><a href="#使用AUGraph创建AudioUnit" class="headerlink" title="使用AUGraph创建AudioUnit"></a>使用AUGraph创建AudioUnit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">AUGraph processingGraph;</div><div class="line">NewAUGraph (&amp;processingGraph);</div><div class="line"> </div><div class="line">// Add an audio unit node to the graph, then instantiate the audio unit</div><div class="line">AUNode ioNode;</div><div class="line">AUGraphAddNode (</div><div class="line">    processingGraph,</div><div class="line">    &amp;ioUnitDescription,</div><div class="line">    &amp;ioNode</div><div class="line">);</div><div class="line">AUGraphOpen (processingGraph); // indirectly performs audio unit instantiation</div><div class="line"> </div><div class="line">// Obtain a reference to the newly-instantiated I/O unit</div><div class="line">AudioUnit ioUnit;</div><div class="line">AUGraphNodeInfo (</div><div class="line">    processingGraph,</div><div class="line">    ioNode,</div><div class="line">    NULL,</div><div class="line">    &amp;ioUnit</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="使用Scopes和Elements来指定AudioUnit"><a href="#使用Scopes和Elements来指定AudioUnit" class="headerlink" title="使用Scopes和Elements来指定AudioUnit"></a>使用Scopes和Elements来指定AudioUnit</h3><p>Scope和Elements的关系如下图所示：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-3.png" alt=""></p>
<p>对于通用的audioUnit,可以有1-2条输入输出流，输入和输出不一定相等，比如mixer,可以两个音频输入，混音合成一个音频流输出。每个element表示一个音频处理上下文(context), 也称为bus。每个element有输出和输出部分，称为scope，分别是input scope和Output scope。Global scope确定只有一个element，就是element0，有些属性只能在Global scope上设置。</p>
<p>inputbus = Element1 = 1,outputbus = Element0 = 0</p>
<h3 id="使用Property来config-AudioUnit"><a href="#使用Property来config-AudioUnit" class="headerlink" title="使用Property来config AudioUnit"></a>使用Property来config AudioUnit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UInt32 busCount = 2;</div><div class="line"> </div><div class="line">OSStatus result = AudioUnitSetProperty (</div><div class="line">    mixerUnit,</div><div class="line">    kAudioUnitProperty_ElementCount,   // the property key</div><div class="line">    kAudioUnitScope_Input,             // the scope to set the property on</div><div class="line">    0,                                 // the element to set the property on</div><div class="line">    &amp;busCount,                         // the property value</div><div class="line">    sizeof (busCount)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一个普通的播放行为可能需要设置的属性有 <em>kAudioOutputUnitProperty_EnableIO</em>，<em>kAudioUnitProperty_StreamFormat</em>，<em>kAudioUnitProperty_SetRenderCallback</em> 三个，不同行为需要设置不同的属性。</p>
<h3 id="I-O-Unit的基本特征"><a href="#I-O-Unit的基本特征" class="headerlink" title="I/O Unit的基本特征"></a>I/O Unit的基本特征</h3><p>i/o unit是最常见的一种AudioUnit</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-4.png" alt=""></p>
<p>对于remote_IO类型audioUnit，即从硬件采集和输出到硬件的audioUnit,它的逻辑是固定的：固定2个element,麦克风经过element1到APP，APP经element0到扬声器。</p>
<p>我们能把控的是中间的“APP内处理”部分，结合上图，淡黄色的部分就是APP可控的，Element1这个组件负责链接麦克风和APP，它的输入部分是系统控制，输出部分是APP控制；Element0负责连接APP和扬声器，输入部分APP控制，输出部分系统控制。</p>
<h3 id="使用AUGraph来管理AudioUnit"><a href="#使用AUGraph来管理AudioUnit" class="headerlink" title="使用AUGraph来管理AudioUnit"></a>使用AUGraph来管理AudioUnit</h3><h3 id="Render-Callback-Functions-Feed-Audio-to-Audio-Units"><a href="#Render-Callback-Functions-Feed-Audio-to-Audio-Units" class="headerlink" title="Render Callback Functions Feed Audio to Audio Units"></a>Render Callback Functions Feed Audio to Audio Units</h3><p>当音频数据是由内存或者磁盘提供的话，数据都需要从渲染回调函数这里提供给inputbus，当你想要对音频数据进行自定义的处理的话，就在这里进行吧。</p>
<p>渲染回调函数格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static OSStatus MyAURenderCallback (</div><div class="line">    void                        *inRefCon,</div><div class="line">    AudioUnitRenderActionFlags  *ioActionFlags,</div><div class="line">    const AudioTimeStamp        *inTimeStamp,</div><div class="line">    UInt32                      inBusNumber,</div><div class="line">    UInt32                      inNumberFrames,</div><div class="line">    AudioBufferList             *ioData</div><div class="line">) &#123; /* callback body */ &#125;</div></pre></td></tr></table></figure>
<p>各参数的关系如下图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-5.png" alt=""></p>
<h3 id="Working-with-the-AudioStreamBasicDescription-structure"><a href="#Working-with-the-AudioStreamBasicDescription-structure" class="headerlink" title="Working with the AudioStreamBasicDescription structure"></a>Working with the AudioStreamBasicDescription structure</h3><p>AudioStreamBasicDescription 这个结构体表示当前音频的格式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct AudioStreamBasicDescription &#123;</div><div class="line">    Float64 mSampleRate;//采样率</div><div class="line">    UInt32  mFormatID;//格式ID</div><div class="line">    UInt32  mFormatFlags;//存储标识</div><div class="line">    UInt32  mBytesPerPacket;//每个packet的字节数</div><div class="line">    UInt32  mFramesPerPacket;//每个packet包含几个frame</div><div class="line">    UInt32  mBytesPerFrame;//每个frame的字节数</div><div class="line">    UInt32  mChannelsPerFrame;//每个frame的声道数</div><div class="line">    UInt32  mBitsPerChannel;//每个声道的位数</div><div class="line">    UInt32  mReserved;</div><div class="line">&#125;;</div><div class="line">typedef struct AudioStreamBasicDescription  AudioStreamBasicDescription;</div></pre></td></tr></table></figure>
<h3 id="Understanding-Where-and-How-to-Set-Stream-Formats"><a href="#Understanding-Where-and-How-to-Set-Stream-Formats" class="headerlink" title="Understanding Where and How to Set Stream Formats"></a>Understanding Where and How to Set Stream Formats</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-6.png" alt=""></p>
<p>这个图展示了一个完整的录音+混音+播放的流程，在组件两边设置stream的格式，在代码里的概念是scope。</p>
<h3 id="在使用AUGraph时选择不同的设计模式"><a href="#在使用AUGraph时选择不同的设计模式" class="headerlink" title="在使用AUGraph时选择不同的设计模式"></a>在使用AUGraph时选择不同的设计模式</h3><h4 id="I-O-Pass-Through"><a href="#I-O-Pass-Through" class="headerlink" title="I/O Pass Through"></a>I/O Pass Through</h4><p>简单的音频输入输出场景，直接使用AudioUnit链接两端，不需要设置渲染回调.</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-1.png" alt=""></p>
<h4 id="I-O-Without-a-Render-Callback-Function"><a href="#I-O-Without-a-Render-Callback-Function" class="headerlink" title="I/O Without a Render Callback Function"></a>I/O Without a Render Callback Function</h4><p>需要多个AudioUnit来处理的场景，使用AudioUnit链接各部分，不需要设置回调。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-2.png" alt=""></p>
<h4 id="I-O-with-a-Render-Callback-Function"><a href="#I-O-with-a-Render-Callback-Function" class="headerlink" title="I/O with a Render Callback Function"></a>I/O with a Render Callback Function</h4><p>设置渲染回调的方式来处理输入输出的链接。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-3.png" alt=""></p>
<h4 id="Output-Only-with-a-Render-Callback-Function"><a href="#Output-Only-with-a-Render-Callback-Function" class="headerlink" title="Output-Only with a Render Callback Function"></a>Output-Only with a Render Callback Function</h4><p>只有输出没有输入的场景，设置渲染回调来链接输出端。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-4.png" alt=""></p>
<p>复杂的场景，需要设置多个渲染回调。同时需要多个AudioUnit来处理链接。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-5.png" alt=""></p>
<h3 id="构建AudioUnit-app的流程"><a href="#构建AudioUnit-app的流程" class="headerlink" title="构建AudioUnit app的流程"></a>构建AudioUnit app的流程</h3><p>无论选择上面的哪种设计，构建app的基本流程如下：</p>
<ul>
<li><p>Configure your audio session.</p>
</li>
<li><p>Specify audio units.</p>
</li>
<li><p>Create an audio processing graph, then obtain the<br>audio units.</p>
</li>
<li><p>Configure the audio units.</p>
</li>
<li><p>Connect the audio unit nodes.</p>
</li>
<li><p>Provide a user interface.</p>
</li>
<li><p>Initialize and then start the audio processing graph.</p>
</li>
</ul>
<h3 id="使用指定的AudioUnit"><a href="#使用指定的AudioUnit" class="headerlink" title="使用指定的AudioUnit"></a>使用指定的AudioUnit</h3><h4 id="Using-I-O-Units"><a href="#Using-I-O-Units" class="headerlink" title="Using I/O Units"></a>Using I/O Units</h4><ul>
<li>Remote I/O Unit</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-1.png" alt=""></p>
<ul>
<li><p>Voice-Processing I/O Unit</p>
</li>
<li><p>Generic Output Unit</p>
</li>
</ul>
<h4 id="Using-Mixer-Units"><a href="#Using-Mixer-Units" class="headerlink" title="Using Mixer Units"></a>Using Mixer Units</h4><ul>
<li>Multichannel Mixer Unit</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-2.png" alt=""></p>
<ul>
<li>3D Mixer Unit</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-3.png" alt=""></p>
<h4 id="Using-Effect-Units"><a href="#Using-Effect-Units" class="headerlink" title="Using Effect Units"></a>Using Effect Units</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-4.png" alt=""></p>
<h3 id="Identifier-Keys-for-Audio-Units"><a href="#Identifier-Keys-for-Audio-Units" class="headerlink" title="Identifier Keys for Audio Units"></a>Identifier Keys for Audio Units</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-5.png" alt=""></p>
<p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/flv格式和seek原理/" itemprop="url">
                  flv格式和seek原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T09:42:55+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/flv格式和seek原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/flv格式和seek原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FLV（Flash Video）是Adobe公司设计开发的一种流行的流媒体格式，由于其视频文件体积轻巧、封装简单等特点，使其很适合在互联网上进行应用。此外，FLV可以使用Flash Player进行播放，而Flash Player插件已经安装在全世界绝大部分浏览器上，这使得通过网页播放FLV视频十分容易。目前主流的视频网站如优酷网，土豆网，乐视网等网站无一例外地使用了FLV格式。FLV封装格式的文件后缀通常为“.flv”。</p>
<h3 id="flv数据格式"><a href="#flv数据格式" class="headerlink" title="flv数据格式"></a>flv数据格式</h3><p>从整个文件上来看,FLV是由The FLV header 和 The FLV File Body 组成.</p>
<h4 id="FLV-header"><a href="#FLV-header" class="headerlink" title="FLV header"></a>FLV header</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/header.png" alt=""></p>
<p>Signature: FLV 文件的前3个字节为固定的‘F’‘L’‘V’,用来标识这个文件是flv格式的.在做格式探测的时候，</p>
<p>如果发现前3个字节为“FLV”，就认为它是flv文件.</p>
<p>Version: 第4个字节表示flv版本号.</p>
<p>Flags: 第5个字节中的第0位和第2位,分别表示 video 与 audio 存在的情况.(1表示存在,0表示不存在)</p>
<p>DataOffset : 最后4个字节表示FLV header 长度.</p>
<h4 id="FLV-File-Body"><a href="#FLV-File-Body" class="headerlink" title="FLV File Body"></a>FLV File Body</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/body.png" alt=""></p>
<p>FLV File Body是由一连串的<strong>Previous Tag Size</strong> + tags构成.<strong>Previous Tag Size</strong>就是4个字节数据,表示前一个tag的size.</p>
<h4 id="FLV-Tag"><a href="#FLV-Tag" class="headerlink" title="FLV Tag"></a>FLV Tag</h4><p>FLV文件中的数据都是由一个个TAG组成,TAG里面的数据可能是video、audio、scripts.</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/tag2.png" alt=""></p>
<p>TagType: TAG中第1个字节中的前5位表示这个TAG中包含数据的类型,8 = audio,9 = video,18 = script data.</p>
<p>DataSize:StreamID之后的数据长度.</p>
<p>Timestamp和TimestampExtended组成了这个TAG 包数据的PTS信息,PTS= Timestamp | TimestampExtended &lt;&lt; 24.</p>
<p>StreamID之后的数据就是每种格式的情况不一样了，接下格式进行详细的介绍.</p>
<h4 id="Audio-Tags"><a href="#Audio-Tags" class="headerlink" title="Audio Tags"></a>Audio Tags</h4><p>如果TAG包中的TagType==8时，就表示这个TAG是audio。</p>
<p>StreamID之后的数据就表示是AudioTagHeader，AudioTagHeader结构如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/audiotagheader.png" alt=""></p>
<h4 id="Video-Tags"><a href="#Video-Tags" class="headerlink" title="Video Tags"></a>Video Tags</h4><p>如果TAG包中的TagType==9时，就表示这个TAG是video.</p>
<p>StreamID之后的数据就表示是VideoTagHeader，VideoTagHeader结构如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/videotagheader.png" alt=""></p>
<h4 id="SCRIPTDATA-控制帧）"><a href="#SCRIPTDATA-控制帧）" class="headerlink" title="SCRIPTDATA(控制帧）"></a>SCRIPTDATA(控制帧）</h4><p>如果TAG包中的TagType==18时，就表示这个TAG是SCRIPT.</p>
<p>该类型Tag又通常被称为Metadata Tag，会放一些关于FLV视频和音频的元数据信息如：duration、width、height等。<strong>通常该类型Tag会跟在File Header后面作为第一个Tag出现，而且只有一个。</strong></p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/STD.png" alt=""></p>
<p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，用来装入一个“onMetaData”标志，这个标志与Adobe的一些API调用有，在此不细述。第二个AMF包封装一个数组类型，这个数组中包含了音视频信息项的名称和值。具体说明如下，大家可以参照图片上的数据进行理解。</p>
<p>第一个AMF包：<br>       第1个字节表示AMF包类型，一般总是0x02，表示字符串，其他值表示意义请查阅文档。<br>       第2-3个字节为UI16类型值，表示字符串的长度，一般总是0x000A（“onMetaData”长度）。<br>       后面字节为字符串数据，一般总为“onMetaData”。</p>
<p>第二个AMF包：<br>       第1个字节表示AMF包类型，一般总是0x08，表示数组。<br>       第2-5个字节为UI32类型值，表示数组元素的个数。<br>       后面即为各数组元素的封装，数组元素为元素名称和值组成的对。表示方法如下：<br>       第1-2个字节表示元素名称的长度，假设为L。<br>       后面跟着为长度为L的字符串。<br>       第L+3个字节表示元素值的类型。<br>       后面跟着为对应值，占用字节数取决于值的类型</p>
<h4 id="onMetaData"><a href="#onMetaData" class="headerlink" title="onMetaData"></a>onMetaData</h4><p>onMetaData 是SCRIPTDATA中对我们来说十分重要的信息，结构如下表：<br><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/onMetaData.png" alt=""></p>
<p>这里面的duration、filesize、视频的width、height等这些信息对我们来说很有用.</p>
<h3 id="metadata和yamdi-flvtool2-ruby-FLVMDI-非开源"><a href="#metadata和yamdi-flvtool2-ruby-FLVMDI-非开源" class="headerlink" title="metadata和yamdi,flvtool2(ruby),FLVMDI(非开源)"></a>metadata和yamdi,flvtool2(ruby),FLVMDI(非开源)</h3><p>yamdi为flv文件增加了很多metadata信息，比如创建者、是否有关键帧、是否有视频、是否有音频，视频高度和宽度等等。而yamdi加入的meta数据中，最有效的要数关键帧。被注入了关键帧的flv可以实现像土豆网、优酷网等大型视频网站一样的“拖进度”，提前拖到缓冲还未加载到的位置开始播放。</p>
<h4 id="keyframes"><a href="#keyframes" class="headerlink" title="keyframes"></a>keyframes</h4><p>keyframes中包含着2个内容 ‘filepositions’ and ‘times’分别指的是关键帧的文件位置和关键帧的PTS.通过keyframes可以建立起自己的Index，然后再seek和快进快退的操作中，快速有效的跳转到你想要找的关键帧的位置进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/20/IP地址与协议详解/" itemprop="url">
                  IP地址与协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-20T18:29:57+08:00" content="2018-03-20">
              2018-03-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/20/IP地址与协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/20/IP地址与协议详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本的ip地址结构"><a href="#基本的ip地址结构" class="headerlink" title="基本的ip地址结构"></a>基本的ip地址结构</h3><p>ipv4:点分十进制，共32位</p>
<p>ipv6:冒号隔开8个16位数，共128位</p>
<h4 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h4><p>ip地址中一些连续的位称为网络号，其余位称为主机号。</p>
<p>ip地址空间的划分涉及五大类：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ip地址与协议详解/ipcategory.png" alt=""></p>
<p>A,B,C为单播，D为组播。</p>
<h4 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h4><p>在一个站点接入Internet后为其分配一个网络号，然后由站点管理员进一步划分本地的子网数。</p>
<p>通过子网寻址，一个站点被分配一个A，B或C类的<strong>网络号</strong>，保留一些剩余主机号进一步用于站点内分配。该站点可能将基础地址中的主机部分进一步划分为一个<strong>子网号</strong>和一个<strong>主机号</strong>.</p>
<p>如下图，该站点将每一个地址的前16位固定为网络号，后16位8位为子网号，8位为主机号。这个特殊配置允许站点支持256个子网，每个子网最多可包含254台主机。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ip地址与协议详解/subnet.png" alt=""></p>
<p><strong>同一个子网中每台主机的IPv4地址拥有相同的子网号</strong></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应的IP地址中获取网络和子网信息。</p>
<p>掩码由路由器和主机使用，以确认一个IP地址的网络/子网部分的结束和主机部分的开始。子网掩码中的一位设为1表示一个IP地址的对应位与一个地址的网络/子网部分的对应位相结合（位与）.并将结果作为转发数据报的基础。</p>
<p>IP地址与子网掩码做（位与）运算，以形成用于路由的地址的网络/子网标识符。</p>
<p>子网掩码纯粹是站点内部的局部问题。。。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议是无连接的，这意味着IP不维护网络单元（路由器）中数据报相关的任何链接状态信息，每个数据报独立于其他数据报来处理。这也意味着IP数据报可不按顺序交付。</p>
<p>当某些错误发生时，例如一台路由器临时用尽缓冲区，IP提供一个简单的错误处理方式：丢弃一些数据（通常是最后到达的数据报）。</p>
<h4 id="协议头部结构"><a href="#协议头部结构" class="headerlink" title="协议头部结构"></a>协议头部结构</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ip地址与协议详解/ipv4head.png" alt=""></p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>它包含IP数据报的版本号：IPV4是4，IPV6是6.</p>
<p>IPV4和IPV6两个协议之间不能直接互操作。</p>
<h4 id="IHL（头部长度）"><a href="#IHL（头部长度）" class="headerlink" title="IHL（头部长度）"></a>IHL（头部长度）</h4><p>保存IPV4头部中32位字的数量，包括任何选项。由于他是一个4位的字段，所以IPV4的头部被限制最多15个32位字（60个字节）.</p>
<h4 id="DS-区分服务"><a href="#DS-区分服务" class="headerlink" title="DS(区分服务)"></a>DS(区分服务)</h4><p>前6位被称为区分服务字段，后两位是显示拥塞通知字段或指示位。</p>
<h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>IPV4数据报的总长度。通过这个字段和IHL字段，我们知道数据报的数据部分从哪里开始，以及他的长度。由于它是一个16位的字段，所以IPV4数据报的最大长度是65535字节。</p>
<p>由于一些携带IPV4数据报的低层协议不能精确表达自己封装数据的大小，所以需要在头部中给出总长度字段。例如，以太网会将短帧补充到最小长度（64字节）。虽然以太网最小有效载荷为46字节，单一个IPV4数据报也可能会更小（20字节）。如果没有提供总长度字段，IPV4实现将无法知道一个46字节的以太网帧是一个IP数据报，还是经过填充的IP数据报，这样可能会导致混淆。</p>
<p>尽管可发送一个65535字节的IP数据报，但是大多数链路层不能携带这么大的数据，所以会对发数据进行<strong>分片</strong>。主机不接受大于576字节的IPV4数据报。</p>
<h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>标识字段帮助标识由IPV4主机发送的数据报，为了避免将一个数据报分片和其他分片混淆，发送主机通常在每次发送数据报时都将一个内部计数器加1，并将该计算器值复制到IPV4标识字段。</p>
<h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>TTL字段用于设置一个数据报可经过的路由器数量的上限。发送方将他初始化为某一个值（文档建议为64，但128或255也不少见），每台路由器在转发数据报时将该值减1.当这个字段值达到0时，改数据报被丢弃，并使用一个ICMP消息通知发送方。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>IPV4头部中的协议字段包含一个数字，表示数据报有效载荷部分的数据类型。最常见的值为17（UDP）和6（TCP）。</p>
<h4 id="头部校验和"><a href="#头部校验和" class="headerlink" title="头部校验和"></a>头部校验和</h4><p>头部校验和字段仅计算IPV4头部。理解这一点很重要，因为这意味着IP协议不检测IPV4数据报有效载荷的正确性。需要其他上层协议自己去实现（<strong>比如TCP的校验和字段</strong>）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">57</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
