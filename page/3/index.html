<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/22/iOS性能检测工具总结/" itemprop="url">
                  iOS性能检测工具总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-08-22T17:51:37+08:00" content="2019-08-22">
              2019-08-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/08/22/iOS性能检测工具总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/22/iOS性能检测工具总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个资深的iOS开发，除了专业能力要过硬，还应该具有一些产品scene,关注一些技术之外的内容，学会发现问题然后利用技术去解决这些问题。比如用户体验问题，用户在使用app的过程中，可能会遇到哪些体验不佳的问题，我们要做的就是利用技术手段找出这些问题，然后一一解决，尽我们所能为用户提供最后的用户体验。排除交互设计本身外，最可能出现用户体验问题的原因就是手机在性能上出现了一些瓶颈，因此，找出这些性能瓶颈的时间节点和当前实时数据能很大程度上帮助我们定位到最终原因。</p>
<p>基于以上的出发点，我们就需要开发一套自己的性能检测工具和上报机制，在app出现性能问题时拿到一手的数据，帮助我们定位问题和解决问题。</p>
<h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p>app的性能主要受两部分内容的影响，一个是手机本身的硬件设备，还有一个就是当前网络状况。这里分两部分分别介绍检测工具的功能点。</p>
<h4 id="设备性能"><a href="#设备性能" class="headerlink" title="设备性能"></a>设备性能</h4><h5 id="fps"><a href="#fps" class="headerlink" title="fps"></a>fps</h5><p>fps主要用来检测当前页面的卡顿情况，如果fps降到50帧以下，页面卡顿就会比较明显，这个时候就需要具体再去分析卡顿原因。</p>
<h5 id="cpu-usage"><a href="#cpu-usage" class="headerlink" title="cpu usage"></a>cpu usage</h5><p>cpu利用率主要有三个可以参考的指标，分别是用户使用率，系统使用率和空闲率。</p>
<h5 id="disk"><a href="#disk" class="headerlink" title="disk"></a>disk</h5><p>磁盘空间有已用空间和可用空间。</p>
<h5 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h5><p>内存使用情况有总内存，总可用内存和当前app已用内存。这里都是指的物理内存。因为虚拟内存的检测并没有什么意义。</p>
<h5 id="battery"><a href="#battery" class="headerlink" title="battery"></a>battery</h5><p>当前电量。</p>
<p>以上这些指标，大部分需要调用mach内核的相关api才能成功获取，而且需要轮询获取才能保证数据的时效性。</p>
<h4 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h4><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>包括当前域名对应的ip,解析总耗时和失败情况。</p>
<h5 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h5><p>当前网络延时，一个RTT时长。</p>
<h5 id="Reachability"><a href="#Reachability" class="headerlink" title="Reachability"></a>Reachability</h5><p>当前网络状态，包括wifi，4G或者无网。</p>
<h5 id="Metrics-iOS10"><a href="#Metrics-iOS10" class="headerlink" title="Metrics(iOS10)"></a>Metrics(iOS10)</h5><p>Metrics包括了下面这张图中的相关时长：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/iOS性能监控工具/zfgdZ.png" alt=""></p>
<p>iOS10以后，可以直接从URLSession的回调中拿到这些耗时指标。</p>
<h5 id="TraceRoute"><a href="#TraceRoute" class="headerlink" title="TraceRoute"></a>TraceRoute</h5><p>一个完整的请求的路径，包括数据经过的每一个节点和耗时。该数据可以完整反映出一个数据报的传输过程。</p>
<h5 id="Traffic-I-O"><a href="#Traffic-I-O" class="headerlink" title="Traffic(I/O)"></a>Traffic(I/O)</h5><p>网络I/O</p>
<h3 id="上报格式"><a href="#上报格式" class="headerlink" title="上报格式"></a>上报格式</h3><p>为了方便上报和数据分析，需要统一各项数据的上报格式，以上面的Metrics为例，将各项数据按统一的格式一同上报，定义格式如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/iOS性能监控工具/Metrics.png" alt=""></p>
<p>上报格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NetworkMetrics: 450,50,80,60,100,120,Network Load</div><div class="line">NetworkMetrics: 220,0,0,0,100,120,Loacl Cache</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/29/操作系统原理-内存管理/" itemprop="url">
                  操作系统原理--内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-29T10:56:23+08:00" content="2019-05-29">
              2019-05-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/29/操作系统原理-内存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/29/操作系统原理-内存管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h3 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h3><h3 id="内存的分配与回收"><a href="#内存的分配与回收" class="headerlink" title="内存的分配与回收"></a>内存的分配与回收</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/29/操作系统原理-线程/" itemprop="url">
                  操作系统原理--线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-29T10:56:14+08:00" content="2019-05-29">
              2019-05-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/29/操作系统原理-线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/29/操作系统原理-线程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><h3 id="线程的结构"><a href="#线程的结构" class="headerlink" title="线程的结构"></a>线程的结构</h3><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/29/操作系统原理-进程/" itemprop="url">
                  操作系统原理--进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-29T10:56:08+08:00" content="2019-05-29">
              2019-05-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/29/操作系统原理-进程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/29/操作系统原理-进程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><h3 id="进程的结构"><a href="#进程的结构" class="headerlink" title="进程的结构"></a>进程的结构</h3><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/04/一个网络请求的流程/" itemprop="url">
                  一个网络请求的流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-04-04T17:36:44+08:00" content="2019-04-04">
              2019-04-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/04/04/一个网络请求的流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/04/一个网络请求的流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最新在看《计算机网络–自顶向下方法》，把从应用层到链路层的所有网络协议都重新学习了一遍。这里借用这个标题，来梳理一下相关协议的工作原理和流程，以及各层的协议之间是如何协同工作的。</p>
<h3 id="首先-你得连上Internet吧"><a href="#首先-你得连上Internet吧" class="headerlink" title="首先 你得连上Internet吧"></a>首先 你得连上Internet吧</h3><p>当我们连接上一个路由器后，会得到一个ip地址，如果此时你的路由器已经连接到了ISP,那么恭喜你可以开始在网上🏄了。那么这个ip地址到底是咋分配到我们的机器的呢？！！！</p>
<h4 id="DHCP-dynamic-host-configuration-protocol"><a href="#DHCP-dynamic-host-configuration-protocol" class="headerlink" title="DHCP(dynamic host configuration protocol)"></a>DHCP(dynamic host configuration protocol)</h4><p>动态主机配置协议，运行在网卡，路由器和交换机等网络设备上，主要用来分配ip地址。和其他协议类似，也是以报文的形式进行通信。</p>
<p>当我们的主机发起一个网络连接请求时，DHCP协议会生成一个DHCP报文，并使用UDP传输协议进行传输，该UDP报文会包含一个组播ip(255.255.255.255)的目标地址,组播ip意味着该网段内所有设备都会收到这条UDP报文。此时因为本机还没有分配ip,所以源ip会是0.0.0.0。</p>
<p>上面的UDP报文会被包在以太网帧中进行传输，该以太网帧的目的地址也是一个组播mac地址（FF.FF.FF.FF.FF.FF）,所以该帧会被网段内所有设备接收。而该帧的原地址即为本机的mac地址（比如 28:cf:e9:14:d1:0f 这是我的设备的mac地址）。</p>
<p>路由器收到该以太网帧，一层层解析出DHCP报文，然后路由器决定分配一个ip地址给主机（10.236.142.22）,于是通过路由器上的DHCP服务器包装一个DHCP的响应报文，把包括了DNS服务器ip,路由器ip,子网掩码和分配给主机的ip一起发送给该主机。因为路由器已经知道了主机的mac地址，所以该报文会顺利的到达。</p>
<p>主机网卡在收到DHCP ACK报文后，解析出相关的ip并配置好网络组件。至此，主机连接Internet成功。</p>
<h3 id="只有域名是不可以的"><a href="#只有域名是不可以的" class="headerlink" title="只有域名是不可以的"></a>只有域名是不可以的</h3><p>连上Internet后，我们就可以上google了。于是我们在浏览器上输入www.google.com，也就是google的域名，不包括前面的www(www是一个网络应用，中文名叫万维网)。而google的主页应该是放在服务器上的，通过域名是如何访问到服务器上的google主页的呢?!!!</p>
<h4 id="DNS-domain-name-system"><a href="#DNS-domain-name-system" class="headerlink" title="DNS(domain name system)"></a>DNS(domain name system)</h4><p>DNS主要用来查询域名对应的ip地址。和DHCP一样，DNS报文使用UDP进行传输。DNS报文将www.google.com放入报文段，然后组装成UDP报文，在上面的DHCP ACK中，已经拿到了DNS的ip,所以在组装ip报文的时候目的ip直接使用dns的ip,源ip则为主机的ip。</p>
<p>之后，ip报文会被放到以太网帧中进行传输，想要将dns报文发送到dns服务器，首先第一个难题就是如何传送到所在网络的网关路由器，在上面的DHCP ACK报文中，已经拿到了网关路由器的ip了，但是ip只是作用在网络层，如果没有mac地址，链路层上是无法传输的。</p>
<h4 id="ARP-address-resolution-protocol"><a href="#ARP-address-resolution-protocol" class="headerlink" title="ARP(address resolution protocol)"></a>ARP(address resolution protocol)</h4><p>地址解析协议，通过一个ip地址获取mac地址。ARP使用网关路由器的ip地址生成一个ARP查询报文，然后将该报文放到目标地址为(FF.FF.FF.FF.FF.FF)的以太网帧上，因为是广播地址，所以网关路由器顺利收到该帧，并生成一个ARP的回答报文，报文中带上了网关路由器的mac地址。然后将回答报文放到目的地址为主机mac地址的以太网帧中，这样，我们就顺利的拿到了网关路由器的mac地址。</p>
<p>通过ARP,dns查询报文顺利的发送到了网关路由器。之后，又该何去何从？！！！</p>
<h4 id="BGP-broder-gateway-protocol"><a href="#BGP-broder-gateway-protocol" class="headerlink" title="BGP(broder gateway protocol)"></a>BGP(broder gateway protocol)</h4><p>边界网关协议，AS(自治系统)之间的路由选择协议，BGP极其复杂，许多专著致力于研究该主题，它的基本工作流程是：</p>
<ul>
<li>从相邻AS处获取子网可达性信息</li>
<li>向本AS内部的所有路由器传播这些可达性信息</li>
<li>基于可达性信息和AS策略，决定到达子网的最优路由</li>
</ul>
<p>我们还得回到最上面的DHCP ACK中去，因为DNS的ip地址是这个报文给返回的，那么它又是如何生成该ip的呢。其实这个ip并不是它生成的，是ISP提供的。当路由器连接上ISP以后，对应的路由转发表会进行更新，所以dns的ip对应的转发接口已经存在于路由转发表中（根据BGP边界网关协议），至此，dns查询报文被发送到对应的dns服务器上。</p>
<p>dns服务器接收到查询报文后，开始根据域名在缓存中查找对应的ip,如果缓存中没有找到，会去到ISP的权威dns服务器上查找，如何还找不到，会去到.com对应顶级dns服务器上查找，如果还是没有找到，会到跟域名服务器上查找，如果根域名上也没有找到，则返回查询失败。如果在其他dns服务器上成功找到对应的ip,该服务器会先缓存到本地，然后生成一个UDP的DNS回答报名，发送到对应的主机上，至此，我们终于拿到了google.com对应的ip地址。接下来我们要开始发送http的get请求了。</p>
<h3 id="顺理成章的http请求"><a href="#顺理成章的http请求" class="headerlink" title="顺理成章的http请求"></a>顺理成章的http请求</h3><p>拿到ip后，http客户端会生成一个get请求，然后封装到tcp的报文中。tcp在进行数据传输前，会有一个三次握手的过程，握手成功后，get请求的报文成功被google的服务器接收，然后服务器通过url找到对应的资源，生成一个http的响应报文并封装在tcp的报文中，然后发送给客户端。</p>
<p>因为已经建立了连接，所以响应报文不在需要握手的流程，客户端顺利收到响应报文，并解析出资源数据，将数据丢给浏览器进行显示（浏览器如何解析数据并渲染的流程不在这篇文章的讨论范围之内）。。。</p>
<p>因为http并不是长链接（1.1以后才支持），所以在一个http请求结束后，客户端还是发起一个断开链接的操作，也称四次挥手的过程。至于断开连接为啥会比建立连接多一次握手过程，就留给读者自己去比较和分析吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此 一个完整的网络请求就总结完毕了，当然，这只是一个大概的流程总结，重点介绍和DHCP和链路层相关的几个协议，tcp和ip协议因为之前已经总结过所以这里只是一笔带过。如果想要了解得更为深入的话，当然推荐大家看一下《TCP/IP详解》系列书籍和我正在看的这本《计算机网络–自顶向下方法》书了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/《架构整洁之道》学习笔记/" itemprop="url">
                  《架构整洁之道》学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-03-11T16:23:51+08:00" content="2019-03-11">
              2019-03-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/03/11/《架构整洁之道》学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/11/《架构整洁之道》学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一章-设计与架构究竟是什么"><a href="#第一章-设计与架构究竟是什么" class="headerlink" title="第一章 设计与架构究竟是什么"></a>第一章 设计与架构究竟是什么</h3><ul>
<li><p>软件架构的终极目标是,用最小的人力成本满足构建和维护该系统的需求.</p>
</li>
<li><p>慢但是稳,是成功的秘诀</p>
</li>
<li><p>程序员们总是用这句话来欺骗自己:<strong>我们可以未来再重构代码,产品上线最重要</strong>.但是结果大家都知道,产品上线后重构工作就再也没有人提起.所以重构的时机永远不会再有了…</p>
</li>
</ul>
<h3 id="第二章-两个价值维度"><a href="#第二章-两个价值维度" class="headerlink" title="第二章 两个价值维度"></a>第二章 两个价值维度</h3><p>架构价值比行为价值更重要</p>
<h4 id="行为价值-业务"><a href="#行为价值-业务" class="headerlink" title="行为价值(业务)"></a>行为价值(业务)</h4><p>行为价值并不是程序员工作的全部</p>
<h4 id="架构价值"><a href="#架构价值" class="headerlink" title="架构价值"></a>架构价值</h4><ul>
<li>software = 灵活的产品</li>
<li>软件变更的难度应该和变更的范畴成等比关系,而与变更的具体形状无关</li>
</ul>
<h4 id="艾森豪威尔矩阵"><a href="#艾森豪威尔矩阵" class="headerlink" title="艾森豪威尔矩阵"></a>艾森豪威尔矩阵</h4><ul>
<li>我有两种难题:紧急的和重要的,而紧急的难题永远是不重要的,重要的难题永远是不紧急的.</li>
<li>重要比紧急更应该被重视</li>
</ul>
<h4 id="为好的软件架构而持续斗争"><a href="#为好的软件架构而持续斗争" class="headerlink" title="为好的软件架构而持续斗争"></a>为好的软件架构而持续斗争</h4><ul>
<li>公司内部的抗争本来就是无止境的</li>
<li>如果你是架构师,这项工作就加倍重要</li>
</ul>
<h3 id="第四章-结构化编程"><a href="#第四章-结构化编程" class="headerlink" title="第四章 结构化编程"></a>第四章 结构化编程</h3><ul>
<li>编码的整个过程应该是可推导的</li>
<li>功能性降解拆分,将复杂的逻辑分解为一个个小的单元,以函数,分支,循环等的方式最终呈现.</li>
<li>结构化编程是对程序控制权的直接转移的限制</li>
</ul>
<h3 id="第五章-面向对象编程-OOD"><a href="#第五章-面向对象编程-OOD" class="headerlink" title="第五章 面向对象编程(OOD)"></a>第五章 面向对象编程(OOD)</h3><ul>
<li>面向对象编程是对程序控制权的间接转移的限制</li>
</ul>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li>类的private和public属性和方法</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承的作用是让我们可以在某个作用域内对外部定义的某一组变量与函数进行覆盖.</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li>多态是函数指针的应用</li>
<li>插件化是多态的一种实践</li>
<li>多态是实现依赖反转的一种好的选择</li>
</ul>
<h3 id="第六章-函数式编程"><a href="#第六章-函数式编程" class="headerlink" title="第六章 函数式编程"></a>第六章 函数式编程</h3><ul>
<li>函数式编程中变量是不可变的</li>
<li>原子操作只能保证当前线程下的线程安全问题</li>
<li>函数式编程是对程序中赋值操作的限制</li>
</ul>
<h3 id="设计原则-SOLID"><a href="#设计原则-SOLID" class="headerlink" title="设计原则(SOLID)"></a>设计原则(SOLID)</h3><p>设计目标:</p>
<ul>
<li>使软件可容忍被改动</li>
<li>使软件更容易被理解</li>
<li>构建可在多个软件系统中复用的组件</li>
</ul>
<h3 id="第七章-SRP单一职责原则"><a href="#第七章-SRP单一职责原则" class="headerlink" title="第七章 SRP单一职责原则"></a>第七章 SRP单一职责原则</h3><ul>
<li>函数设计也需要遵循SRP原则</li>
<li>任何一个软件模块都应该有且仅有一个被修改的原因</li>
<li>任何一个软件模块都应该只对某一类行为者负责</li>
<li>Employee类中各行为应该被分解</li>
</ul>
<h3 id="第八章-OCP开闭原则"><a href="#第八章-OCP开闭原则" class="headerlink" title="第八章 OCP开闭原则"></a>第八章 OCP开闭原则</h3><ul>
<li>良好的设计软件应该易于扩展,同时抗拒修改</li>
<li>如果A组件不想被B组件上发生的修改所影响,那么就应该让B组件依赖于A组件</li>
<li>利用SRP分解功能,利用DIP反转依赖</li>
<li>软件系统不应该依赖不直接使用的组件</li>
</ul>
<h3 id="第九章-LSP里氏替换原则"><a href="#第九章-LSP里氏替换原则" class="headerlink" title="第九章 LSP里氏替换原则"></a>第九章 LSP里氏替换原则</h3><ul>
<li>以接口的形式实现函数调用的可替换性</li>
</ul>
<h3 id="第十章-ISP接口隔离原则"><a href="#第十章-ISP接口隔离原则" class="headerlink" title="第十章 ISP接口隔离原则"></a>第十章 ISP接口隔离原则</h3><ul>
<li>利用接口隔离原则隔离掉不需要的依赖关系,因为不需要的依赖会导致不必要的重新编译和重新部署</li>
</ul>
<h3 id="第十一章-DIP依赖反转原则"><a href="#第十一章-DIP依赖反转原则" class="headerlink" title="第十一章 DIP依赖反转原则"></a>第十一章 DIP依赖反转原则</h3><ul>
<li>如果想要设计一个灵活的系统,在源代码层面的依赖关系中就应该多引用抽象类型而非具体实现</li>
<li>接口比具体实现更稳定,因为如果修改接口必须修改实现,但是反之则不一定.</li>
<li>不要在具体实现类上创建子类,具体实现应该放到子类去做,除非是比较稳定且通用的逻辑.</li>
<li>不要覆盖包含具体实现的函数,如果必须这样,请在覆盖方法中先调用父类方法.</li>
<li>源代码依赖方向永远是控制流方向的反转</li>
</ul>
<h3 id="第十二章-组件"><a href="#第十二章-组件" class="headerlink" title="第十二章 组件"></a>第十二章 组件</h3><ul>
<li>组件是软件部署的单元,是整个软件系统在部署过程中可以独立完成部署的最小实体.</li>
<li>重定位技术和链接器是组件的单独部署成为可能</li>
<li>墨菲定律:程序的规模会一直不断地增长下去,直到将有限的编译和链接时间填满为止</li>
<li>摩尔定律:硬件的更新周期为18个月</li>
</ul>
<h3 id="第十三章-组件聚合"><a href="#第十三章-组件聚合" class="headerlink" title="第十三章 组件聚合"></a>第十三章 组件聚合</h3><h4 id="复用-发布等同原则-REP"><a href="#复用-发布等同原则-REP" class="headerlink" title="复用/发布等同原则(REP)"></a>复用/发布等同原则(REP)</h4><ul>
<li>软件复用的最小粒度应等同于其发布的最小粒度</li>
<li>ERP原则就是指组件中的类与模块必须是彼此紧密相关的,一个组件不能由一组毫无关联的类和模块组成</li>
<li>一个组件中包含的类与模块还应该是可以同时发布的</li>
</ul>
<h4 id="共同闭包原则-CCP"><a href="#共同闭包原则-CCP" class="headerlink" title="共同闭包原则(CCP)"></a>共同闭包原则(CCP)</h4><ul>
<li>我们应该将那些会同时修改,并且为相同目的而修改的类放到同一个组件中,而将不会同时修改,并且不会为了相同目的而修改的那些类放到不同的组件中</li>
<li>CCP原则是SRP原则和OCP原则的组件版</li>
</ul>
<h4 id="共同复用原则-CRP"><a href="#共同复用原则-CRP" class="headerlink" title="共同复用原则(CRP)"></a>共同复用原则(CRP)</h4><ul>
<li>不要强迫一个组件的用户依赖他们不需要的东西</li>
<li>我们希望组件中的所有类是不可拆分的,不应该出现别人只需要依赖它的某几个类而不需要其他类的情况</li>
<li>CRP的作用不仅是告诉我们应该将哪些类放在一起,更重要的是要告诉我们应该将哪些类分开</li>
<li>CRP原则实际上是ISP原则的一个普适版,ISP建议我们不要依赖不需要的类,CRP建议我们不要依赖不需要的组件</li>
<li>优秀的架构师应该在REP,CCP和CRP原则间找到一个好的平衡点,一个项目的组件结构设计的重心是根据该项目的开发时间和成熟度不断变化的</li>
</ul>
<h3 id="第十四章-组件耦合"><a href="#第十四章-组件耦合" class="headerlink" title="第十四章 组件耦合"></a>第十四章 组件耦合</h3><h4 id="无依赖环原则"><a href="#无依赖环原则" class="headerlink" title="无依赖环原则"></a>无依赖环原则</h4><ul>
<li>组件依赖关系图中不应该出现环</li>
<li>依赖环会导致组件之间的发布和运行很难稳定下来</li>
<li>每周构建是指team每一周专门抽出一天来进行组件的构建调试工作,而其他时间则忽略组件的构建问题</li>
<li>消除循环依赖的一个解决办法是将研发项目划分成一些可单独发布的组件,这些组件独立完成构建和发布</li>
<li>DIP原则打破循环依赖好的选择</li>
</ul>
<h4 id="自上而下的设计"><a href="#自上而下的设计" class="headerlink" title="自上而下的设计"></a>自上而下的设计</h4><ul>
<li>组件结构图是不可能自上而下被设计出来的,它必须随着软件系统的变化而变化和扩张.</li>
<li>组件结构图并不是用来描述应用程序功能的,它更像是应用程序在构建性与维护性方面的一张地图</li>
<li>组件结构图的一个重要目的是如何隔离频繁的变更</li>
</ul>
<h4 id="稳定依赖原则"><a href="#稳定依赖原则" class="headerlink" title="稳定依赖原则"></a>稳定依赖原则</h4><ul>
<li>依赖关系必须要指向更稳定的方向</li>
<li>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖</li>
<li>稳定性指标的计算方法:出口依赖/(出口依赖+入口依赖). 0最稳定,1最不稳定.</li>
<li>组件并不是都需要稳定</li>
</ul>
<h4 id="稳定抽象原则"><a href="#稳定抽象原则" class="headerlink" title="稳定抽象原则"></a>稳定抽象原则</h4><ul>
<li>一个组件的抽象化程度应该与其稳定性保持一致</li>
<li>组件抽象化的计算方法:组件中的抽象类和接口/组件中类的个数 0表现没有抽象类 1表示全是抽象类</li>
<li>好的组件结构应该在抽象和稳定之间找到一个好的平衡点</li>
</ul>
<h3 id="第十五章-什么是软件架构"><a href="#第十五章-什么是软件架构" class="headerlink" title="第十五章 什么是软件架构"></a>第十五章 什么是软件架构</h3><ul>
<li>软件架构师自身需要是程序员,并且必须坚持一直做一线程序员,绝对不要听从那些说应该让软件架构师从代码中解放出来以专心解决高阶问题的伪建议</li>
<li>软件架构的实质就是规划如何将系统切分成组件,并安排好组件之间的排序关系,以及组件之间的通信方式</li>
<li>如果想设计一个便于推进各项工作的系统,其策略就是要在设计中尽可能长时间的保留尽可能多的可选项</li>
<li>开发,部署,运行和维护是软件架构的主要目标</li>
<li>哪些可选项应该保留:它们就是那些无关紧要的细节设计</li>
<li>策略是软件中所有的业务规则与操作过程,是系统真正的价值所在,而细节则是程序员们与策略交互的方式.</li>
<li>软件架构师的目标是创建一种系统形态,该形态会以策略为最基本的元素,并让细节与策略脱离关系,并允许在具体决策过程中推迟或延迟与细节相关的内容</li>
</ul>
<h3 id="第十六章-独立性"><a href="#第十六章-独立性" class="headerlink" title="第十六章 独立性"></a>第十六章 独立性</h3><p>所谓独立性是指一个良好的软件架构必须支持一下几点：</p>
<ul>
<li>支持系统所有用例的能力</li>
<li>独立的开发能力</li>
<li>独立的部署能力</li>
</ul>
<h4 id="再谈解耦模式"><a href="#再谈解耦模式" class="headerlink" title="再谈解耦模式"></a>再谈解耦模式</h4><ul>
<li>源码层次解耦，也叫单体结构</li>
<li>部署层次解耦</li>
<li>服务层次解耦（微服务）</li>
</ul>
<h3 id="第十七章-划分边界"><a href="#第十七章-划分边界" class="headerlink" title="第十七章 划分边界"></a>第十七章 划分边界</h3><p>软件设计本身就是一门划分边界的艺术。<strong>架构师追求的目标就是最大限度降低构建和维护一个系统所需要的人力，而一个系统最消耗人力资源的地方，就是系统中存在的耦合，尤其是那些过早做出的，不成熟的决策所导致的耦合（深以为然）！！！</strong></p>
<h4 id="边界线应该画在何处？"><a href="#边界线应该画在何处？" class="headerlink" title="边界线应该画在何处？"></a>边界线应该画在何处？</h4><p>边界线应该画在那些不相关的事情之间。比如UI与业务逻辑，UI与数据库，业务逻辑与数据库…</p>
<h4 id="插件式架构"><a href="#插件式架构" class="headerlink" title="插件式架构"></a>插件式架构</h4><ul>
<li>组件应该可以用插件的方式集成到其他系统中。</li>
<li>插件式的架构保证了组件的变更不会影响系统整体的业务逻辑。</li>
<li>插件式架构是SRP原则的具体实现。</li>
</ul>
<h3 id="第十九章-策略与层次"><a href="#第十九章-策略与层次" class="headerlink" title="第十九章 策略与层次"></a>第十九章 策略与层次</h3><p>软件就是策略语句的集合，软件设计的工作重点之一就是将这些策略彼此分离，然后将它们按照变更的方式进行重新分组。其中变更原因、时间和层次相同的策略应该被分到同一个组件中（OCP）。反之，变更原因、时间和层次不同策略则应该分属不用的组件。</p>
<p>架构设计的工作需要将组件重排组合成为一个有向无环图。图中的每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之间的依赖关系，他们将不同级别的组件链接起来。</p>
<p>在一个设计良好的架构中，依赖关系的方向通常取决于他们所关联的组件层次。依赖关系应该与数据流向脱钩，而与组件所在的层次挂钩。</p>
<h3 id="第二十章-业务逻辑"><a href="#第二十章-业务逻辑" class="headerlink" title="第二十章 业务逻辑"></a>第二十章 业务逻辑</h3><ul>
<li>关键业务逻辑，是指系统中真正用来赚钱或者省钱的部分。</li>
<li>关键业务数据，是指关键业务逻辑需要处理的数据。</li>
<li>物业实体（Entity）：关键业务逻辑+关键业务数据。</li>
</ul>
<h3 id="第二十二章-整洁架构"><a href="#第二十二章-整洁架构" class="headerlink" title="第二十二章 整洁架构"></a>第二十二章 整洁架构</h3><ul>
<li>六边形架构（端口与适配器架构）</li>
<li>DCI架构</li>
<li>BCE架构</li>
</ul>
<p>共同的设计目标：按照不同关注点对软件进行切割。即这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口，系统接口则属于其他层。</p>
<h4 id="整洁架构图："><a href="#整洁架构图：" class="headerlink" title="整洁架构图："></a>整洁架构图：</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/架构整洁之道/201507-CleanArchitecture.jpg" alt="整洁架构"></p>
<p>由内向外分别代表：</p>
<ul>
<li>业务实体</li>
<li>用例</li>
<li>接口适配器</li>
<li>框架和驱动程序</li>
</ul>
<h4 id="依赖关系规则"><a href="#依赖关系规则" class="headerlink" title="依赖关系规则"></a>依赖关系规则</h4><ul>
<li>越靠近中心，其所在的软件层级就越高。外层代表机制，内层代表策略。</li>
<li>依赖关系应该是外层依赖内层，低层依赖高层。</li>
<li>使用DIP原则控制依赖。</li>
<li>夸边界的数据处理，不直接使用业务实体数据对象，也不要违反依赖规则。</li>
</ul>
<h3 id="第二十三章-展示器和谦卑对象"><a href="#第二十三章-展示器和谦卑对象" class="headerlink" title="第二十三章 展示器和谦卑对象"></a>第二十三章 展示器和谦卑对象</h3><ul>
<li>谦卑对象是指系统中难以测试的部分,比如UI。</li>
<li>展示器则是可测试的对象，展示器的工作是将需要展示的数据按照规则进行处理，然后给UI层去展示。</li>
</ul>
<h3 id="第二十四章-不完全边界"><a href="#第二十四章-不完全边界" class="headerlink" title="第二十四章 不完全边界"></a>第二十四章 不完全边界</h3><p>构建不完全边界的一种方法就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把这些组件构建成一个新的组件。</p>
<ul>
<li>策略模式：不直接依赖实例，而是依赖一个由实例提供的抽象策略。</li>
<li>门户模式：类似抽象工厂的方式提供可替换的抽象方法。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/18/《程序员修炼之道-从小工到专家》读书笔记/" itemprop="url">
                  《程序员修炼之道-从小工到专家》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-18T11:25:21+08:00" content="2019-02-18">
              2019-02-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/18/《程序员修炼之道-从小工到专家》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/18/《程序员修炼之道-从小工到专家》读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="第一章-注重实效的哲学"><a href="#第一章-注重实效的哲学" class="headerlink" title="第一章 注重实效的哲学"></a>第一章 注重实效的哲学</h4><p>注重实效的程序员的特点:</p>
<ul>
<li>处理问题,寻求解决方案时的态度,风格,哲学. </li>
<li>越出直接的问题去思考,设法把问题放在更大的语境中.</li>
<li>对所做的事情负责</li>
<li>接受变化,注重交流</li>
</ul>
<h5 id="我的源码让猫吃了"><a href="#我的源码让猫吃了" class="headerlink" title="我的源码让猫吃了"></a>我的源码让猫吃了</h5><p>对所做的事情负责,如果项目未能按时交付或者出现严重bug,要提供各种选择,不要找蹩脚的借口(比如说我的源码被猫吃了…).</p>
<h5 id="软件的熵"><a href="#软件的熵" class="headerlink" title="软件的熵"></a>软件的熵</h5><p><strong>熵</strong>是一个物理概率,指的是一个系统中无序的总量,在软件中,称为<strong>软件腐烂</strong></p>
<p><strong>破窗户</strong>是导致软件腐烂的原因之一,破窗户指的是那些<strong>低劣设计,错误决策或是糟糕的代码</strong>.</p>
<p>破窗户应该发现一个修一个,如果没有足够的时间进行适当的修复,就用木板把它钉起来(注释,#warning,或者假数据替换)</p>
<p>破窗户会间接影响其他开发人员的代码质量,导致整体的项目质量下降…</p>
<h5 id="石头汤和煮青蛙"><a href="#石头汤和煮青蛙" class="headerlink" title="石头汤和煮青蛙"></a>石头汤和煮青蛙</h5><p>做变化的催化剂,写出高质量的代码,提供好的idea,侧面影响其他人…</p>
<p>大多数软件灾难都是从微不足道的小事情开始的,大多数项目的拖延都是一天一天发生的,系统一个特性一个特性的偏离起规范,一个又一个补丁被打到某段代码上,知道最初的代码一点没有留下.这就像<strong>温水煮青蛙</strong>.程序员不应该做一只温水里的青蛙.</p>
<h5 id="你的知识产权"><a href="#你的知识产权" class="headerlink" title="你的知识产权"></a>你的知识产权</h5><p>知识产权:程序员所知道的关于计算技术和他们所工作的应用领域的全部事实,以及他们的所有经验.</p>
<p>管理知识产权:</p>
<ul>
<li>严肃的投资者定期投资-作为习惯</li>
<li>多元化是长期成功的关键</li>
<li>聪明的投资者在保守的投资和高风险,高回报的投资之间平衡他们的资产</li>
<li>投资者设法低买高卖,以获取最大回报</li>
<li>应周期性的重新评估和平衡资产</li>
</ul>
<p>具体目标:</p>
<ul>
<li>每年至少学习一种新语言</li>
<li>每季度阅读一本技术书籍</li>
<li>也要阅读非技术</li>
<li>上课</li>
<li>参加线下活动</li>
<li>试验不同的环境</li>
<li>跟上潮流</li>
<li>上网</li>
</ul>
<p>学会抓住学习的机会</p>
<p>批判的思考:批判的分析你读到的听到的,要有自己的理解,不要人云亦云.</p>
<h5 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h5><p>知道你想要说什么,提前理好提纲或者打腹稿</p>
<p>了解你的听众,要知道对方期待听到什么内容</p>
<p>选择时机</p>
<p>选择风格(有点难,一般人都只有一种风格)</p>
<p>让文档美观(ppt大神)</p>
<p>让听众参与</p>
<p>学会做倾听者(但不要做垃圾桶)</p>
<p>回复他人</p>
<p><strong>除非你生活在真空中,你才不需要能交流.交流越有效,你就越有影响力</strong></p>
<h4 id="第二章-注重实效的途径"><a href="#第二章-注重实效的途径" class="headerlink" title="第二章 注重实效的途径"></a>第二章 注重实效的途径</h4><p>有些提示和诀窍可应用于软件开发的所有层面,有些想法几乎是公理,有些过程实际上普遍适用.但是,人们几乎没有为这些途径建立这样的文档,你可能会发现,它们作为零散的段落写在关于设计,项目管理或编码的讨论中…</p>
<h5 id="重复的危害"><a href="#重复的危害" class="headerlink" title="重复的危害"></a>重复的危害</h5><p><strong>DRY</strong>:系统中的每一项知识都必须具有单一,无歧义,权威的表示.</p>
<p>重复是怎样产生的:</p>
<ul>
<li>强加的重复,开发着觉得无可选择,环境要求.</li>
<li>无意的重复,开发者没有意识到他们在重复.</li>
<li>无耐性的重复,开发者偷懒,copy比较容易.</li>
<li>开发者之间的重复,几个人重复了同样的信息.</li>
</ul>
<h5 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h5><p>正交性是从几何学中借来的术语,如果两条直线相交成直角,它们就是正交的.沿着某一条直线移动,你投影到另一条直线上的位置不变.</p>
<p>正交性的好处:消除无关事物之间的影响(解耦不必要的依赖)</p>
<p><strong>分层设计</strong>是正交系统的强大方式..因为每层都只适用在其下面的层次提供的抽象,在改动底层实现,而又不影响其他代码方面,你拥有极大的灵活性.分层也降低了模块间依赖关系失控的风险.</p>
<p>正交性的简单测试方法:如果我显著的改变某个特定功能背后的需求,有多少模块会受影响?在正交系统中,答案是<strong>一个</strong></p>
<p>正交性在编码中的应用:</p>
<ul>
<li>让你的代码保持解耦</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数</li>
<li>养成不断批判对待自己代码的习惯.寻找任何重新进行组织,以改善其结构和正交性的机会,这个过程叫做重构,它非常重要.</li>
</ul>
<h5 id="曳光弹"><a href="#曳光弹" class="headerlink" title="曳光弹"></a>曳光弹</h5><p>顾名思义,再开始一个项目之前,眼前是一片黑暗的,看不到未来的样子,这时我们可以发射一枚曳光弹,用在软件开发上就是先写一个大概的demo,有一个前行的方向…</p>
<p>曳光代码的好处:</p>
<ul>
<li>用户能够及早看到能工作的东西</li>
<li>开发者构建了一个他们能在其中工作的结构</li>
<li>你有了一个集成平台</li>
<li>你有了可用于演示的东西</li>
<li>你将更能够感受到工作进展</li>
</ul>
<h4 id="第三章-基本工具"><a href="#第三章-基本工具" class="headerlink" title="第三章 基本工具"></a>第三章 基本工具</h4><h5 id="纯文本的威力"><a href="#纯文本的威力" class="headerlink" title="纯文本的威力"></a>纯文本的威力</h5><p>xml,html,sgml…</p>
<p>用纯文本保存知识的好处:</p>
<ul>
<li>保证不过时</li>
<li>杠杆作用</li>
<li>更易于测试</li>
</ul>
<h5 id="shell游戏"><a href="#shell游戏" class="headerlink" title="shell游戏"></a>shell游戏</h5><h5 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h5><p>vim,Emacs…</p>
<h5 id="源码控制"><a href="#源码控制" class="headerlink" title="源码控制"></a>源码控制</h5><p>svn,git…</p>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>调试的心理学:</p>
<ul>
<li>调试是解决问题,要据此发起进攻</li>
<li>要修正问题,而不是发出指责(bug是你的还是别人的,这不是真的很有关系.)</li>
<li>不要恐慌,如果你看到bug报告的第一反应是<strong>那不可能</strong>,你就完全错了.一个脑细胞都不要浪费在以<strong>“但那时不可能”</strong>起头的思路上,因为很明显,那不仅可能,而且已经发生.</li>
<li>小心近视,要抵制只修正你看到的症状的急迫愿望,更有可能的情况是,实际的故障离你正在观察的地方可能还有几步远,并且可能涉及许多其他的相关事物.</li>
</ul>
<p>调试策略:</p>
<ul>
<li>你需要与qa面谈,搜集比最初给你的数据更多的数据.</li>
<li>qa不可能全覆盖所有的case,你需要系统的进行这样的测试,比如分支语句,你可能需要自己造数据去覆盖所有的分支.</li>
<li>复现bug</li>
<li>是数据可视化(log)</li>
<li>堆栈和断点</li>
<li>橡皮鸭,把你的逻辑对着桌上的橡皮鸭描述一遍,看看有没有漏洞.</li>
<li>消除过程,二分调试</li>
<li>遇到自认为不可能的bug时,不要假定,要证明.</li>
</ul>
<h5 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h5><p>脚手架,代码块,模版工具…</p>
<h4 id="第四章-注重实效的偏执"><a href="#第四章-注重实效的偏执" class="headerlink" title="第四章 注重实效的偏执"></a>第四章 注重实效的偏执</h4><p>你不可能写出完美的软件</p>
<h5 id="按合约设计"><a href="#按合约设计" class="headerlink" title="按合约设计"></a>按合约设计</h5><p>DBC:通过合约进行设计</p>
<h5 id="死程序不说谎"><a href="#死程序不说谎" class="headerlink" title="死程序不说谎"></a>死程序不说谎</h5><p>尽早崩溃…</p>
<h5 id="断言式编程"><a href="#断言式编程" class="headerlink" title="断言式编程"></a>断言式编程</h5><p>如果它不可能发生,用断言确保它不会发生…</p>
<h5 id="何时使用异常"><a href="#何时使用异常" class="headerlink" title="何时使用异常"></a>何时使用异常</h5><p>将异常用于异常的问题…</p>
<h5 id="怎样配平资源"><a href="#怎样配平资源" class="headerlink" title="怎样配平资源"></a>怎样配平资源</h5><p>只要在编程,我们都要管理资源:内存,事务,线程,文件,定时器所有数量有限的事物.大多数时候,资源使用遵循一种可预测的模式,你分配资源,使用它,然后释放它.</p>
<p>要有始有终</p>
<h4 id="第五章-弯曲或折断"><a href="#第五章-弯曲或折断" class="headerlink" title="第五章 弯曲或折断"></a>第五章 弯曲或折断</h4><p>模块和组件的解耦方案</p>
<h5 id="解耦与得墨忒耳法则"><a href="#解耦与得墨忒耳法则" class="headerlink" title="解耦与得墨忒耳法则"></a>解耦与得墨忒耳法则</h5><p>多模块耦合的危害</p>
<ul>
<li>调用链冗长</li>
<li>对一个模块的简单改动会传遍系统中的一些无关模块</li>
<li>开发者害怕改动代码,因为他们不清楚哪些代码可能受影响</li>
</ul>
<p>函数的得墨忒耳法则规定,某个对象的任何方法都应该只调用以下情形的方法:</p>
<ul>
<li>它自身的方法</li>
<li>传入该方法的任何对象的方法</li>
<li>它创建的任何对象的方法</li>
<li>任何直接持有的组件的对象的方法(比如全局对象)</li>
</ul>
<h5 id="元程序设计"><a href="#元程序设计" class="headerlink" title="元程序设计"></a>元程序设计</h5><p>细节会弄乱我们整洁的代码,特别是如果它经常变化.所以我们必须把细节<strong>赶出去</strong>,让我们的代码容易适应变化.</p>
<p>动态配置:要配置,不要集成.要用元数据描述应用的配置选项:调谐参数,用户偏好,安装目录等…</p>
<p>元数据就是数据的数据.</p>
<h5 id="时间解耦"><a href="#时间解耦" class="headerlink" title="时间解耦"></a>时间解耦</h5><p>模块间的时间依赖…我们需要容许并发,并考虑解除任何时间或者次序上的依赖,这样我们才可以获取灵活性,并减少许多开发领域中的任何基于时间的依赖:工作流分析,架构,设计,还有部署.</p>
<p>工作流的改善:使用UML流程图优化工作流.</p>
<p>编写多线程代码,为并发设计.</p>
<h5 id="黑板"><a href="#黑板" class="headerlink" title="黑板"></a>黑板</h5><p>将模块细节画到黑板上,用黑板协调工作流.</p>
<h4 id="第六章-当你编码时"><a href="#第六章-当你编码时" class="headerlink" title="第六章 当你编码时"></a>第六章 当你编码时</h4><p>编码不是机械地把设计转换为可执行语句,这种态度是许多程序丑恶,低效,结构糟糕,不可维护和完全错误的最大一个原因.</p>
<h5 id="靠巧合编程"><a href="#靠巧合编程" class="headerlink" title="靠巧合编程"></a>靠巧合编程</h5><p>深思熟虑的编程,而不是靠运气和偶然的成功.</p>
<p>怎样深思熟虑的编程:</p>
<ul>
<li>总是意识到你在做什么</li>
<li>不要盲目的编程</li>
<li>按照计划行事</li>
<li>依靠可靠的事物,不要依靠巧合或假定</li>
<li>为你的假定建立文档</li>
<li>不要只是测试你的代码,还要测试你的假定</li>
<li>为你的工作划分优先级</li>
<li>不要做历史的奴隶,不要让已有的代码支配将来的代码,如果不再适用,所有的代码都可以被替换.</li>
</ul>
<h5 id="算法速率"><a href="#算法速率" class="headerlink" title="算法速率"></a>算法速率</h5><p>大O表示法</p>
<p>常识估算:</p>
<ul>
<li>简单循环 O(n)</li>
<li>嵌套循环 O(n<em>n || n</em>m)</li>
<li>二分法 O(log(n))</li>
<li>分而治之 O(nlog(n))</li>
<li>组合 O(n!)</li>
</ul>
<p>最快的并非是最好的…</p>
<h5 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h5><p>何时重构:</p>
<ul>
<li>重复,你发现了对DRY原则的违反</li>
<li>非正交的设计</li>
<li>过时的知识</li>
<li>性能问题</li>
</ul>
<p>早重构,常重构</p>
<p>如何重构:</p>
<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前,确保你拥有良好的测试.</li>
<li>采取短小,深思熟虑的步骤.</li>
</ul>
<h5 id="易于测试的代码"><a href="#易于测试的代码" class="headerlink" title="易于测试的代码"></a>易于测试的代码</h5><p>针对合约进行测试</p>
<p>编写单元测试</p>
<p>使用测试设备</p>
<h4 id="第七章-在项目开始之前"><a href="#第七章-在项目开始之前" class="headerlink" title="第七章 在项目开始之前"></a>第七章 在项目开始之前</h4><h5 id="需求之坑"><a href="#需求之坑" class="headerlink" title="需求之坑"></a>需求之坑</h5><p>完美,不是再没有什么需要增加,而是在没有什么需要去掉时到达.</p>
<p>与用户一同工作,以像用户一样思考.</p>
<p>抽象比细节活得更长久</p>
<h5 id="解开不可能解开的谜题"><a href="#解开不可能解开的谜题" class="headerlink" title="解开不可能解开的谜题"></a>解开不可能解开的谜题</h5><p>不要在盒子外面思考,要找到盒子.</p>
<p>不能可解决的问题:</p>
<ul>
<li>有更容易的方法吗</li>
<li>你是在设法解决真正的问题,还是被外围的技术问题转移了注意力</li>
<li>这件事情为什么是一个问题</li>
<li>是什么使它如此难以解决</li>
<li>它必须以这种方式完成吗</li>
<li>它真的必须完成吗</li>
</ul>
<h5 id="规范陷阱"><a href="#规范陷阱" class="headerlink" title="规范陷阱"></a>规范陷阱</h5><p>编写规范是一项重要职责,但每一个细节都被写在规范里的想法是错误的:</p>
<ul>
<li>规范将捕捉系统或其需求的每一处细节和细微差别这一想法是幼稚的</li>
<li>语言自身的表达能力存在问题</li>
<li>对有些事情,做胜于描述</li>
</ul>
<h4 id="第八章-注重实效的项目"><a href="#第八章-注重实效的项目" class="headerlink" title="第八章 注重实效的项目"></a>第八章 注重实效的项目</h4><h5 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h5><ul>
<li>不要留破窗户</li>
<li>不要做温水里的青蛙</li>
<li>交流的重要性</li>
<li>DRY</li>
<li>正交性</li>
</ul>
<h5 id="无处不在的自动化"><a href="#无处不在的自动化" class="headerlink" title="无处不在的自动化"></a>无处不在的自动化</h5><ul>
<li>项目编译</li>
<li>生成代码</li>
<li>回归测试</li>
<li>构建自动化</li>
</ul>
<h5 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h5><p>早测试,常测试,自动测试</p>
<p>要到通过全部测试,编码才算完成</p>
<p>测试什么:</p>
<ul>
<li><p>单元测试</p>
<p>  模块测试</p>
</li>
<li><p>集成测试</p>
<p>  子系统能很好的系统工作</p>
</li>
<li><p>验证和校验</p>
<p>  用户回归</p>
</li>
<li><p>资源耗尽,错误及恢复</p>
<p>  1.内存空间<br>  2.磁盘空间<br>  3.cpu带宽<br>  4.挂钟时间<br>  5.磁盘带宽<br>  6.网络带宽<br>  7.调色板<br>  8.视频分辨率<br>  9.fps</p>
</li>
<li><p>性能测试</p>
<p>  预期的用户数,连接数或每秒事务数</p>
</li>
<li><p>可用性测试</p>
<p>  qa,灰度…</p>
</li>
</ul>
<h5 id="全都是写"><a href="#全都是写" class="headerlink" title="全都是写"></a>全都是写</h5><p>把英语当作又一种编程语言</p>
<p>把文档建在里面,不要栓在外面</p>
<h5 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h5><p>在你的作品上签名,你的签名应该被视为质量的保证.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/08/iOS性能优化的一些套路/" itemprop="url">
                  iOS性能优化的一些套路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-08T17:56:56+08:00" content="2018-10-08">
              2018-10-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/08/iOS性能优化的一些套路/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/08/iOS性能优化的一些套路/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">程序优化第一法则：不要优化</div><div class="line">							————编程珠玑（续）</div><div class="line">							</div><div class="line">过早的优化是万恶之源</div><div class="line">							————Donald Knuth</div></pre></td></tr></table></figure>
<p>不要过早优化，也不要为了优化而优化，只有在项目真正需要优化的时候再优化。我们实际工作中，在开始一个项目时，应该也不会太多去考虑性能优化的问题。不过随着项目版本的不断迭代，模块和代码量不断增加，研发团队人员变动，以及其他各种原因，难免会出现一些实现不太友好的代码和方案，影响到app的用户体验，这个时候就需要相应的优化来提升app的性能。</p>
<p>iOS的性能优化是一个比较有挑战的工作，有一定的难度，需要着手优化的人有一定的姿势积累，能够分析出各方面可能出现的性能问题。所以一般也是进阶必须掌握的技能。当然，优化的过程和可优化的一些点也是有套路的，综合网上的方案和自身的一些经验，这里做一下简单的总结：</p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>这里说的启动优化指的是冷启动，根据启动的流程，可以分为2部分来分别优化，具体如下：</p>
<h4 id="main函数之前"><a href="#main函数之前" class="headerlink" title="main函数之前"></a>main函数之前</h4><p>ipa实际上就是一堆二进制文件（.o文件）的集合，而这堆二进制文件就是xcode编译我们的代码后生产的最终产物，文件头部会给操作系统留下入口（这个入口不是main，而是@start标识）。当应用被启动，系统首先找到程序入口，将二进制文件分页映射到虚拟内存（mmap），然后加载动态库（load image），然后对需要rel的符号的地址进行rebase和bind，之后就是对使用的oc类和分类的注册和初始化。至此，mian函数前的工作做完了。</p>
<h5 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h5><p>知道了具体流程，我们就可以对流程中各个环节进行有针对性的优化了：</p>
<ul>
<li>利用Xcode的DYLD_PRINT_STATISTICS环境变量监测mian函数前的耗时.</li>
<li>尽可能精简代码量，减少mmap次数。</li>
<li>动态库的使用，移除不必要的动态库依赖。</li>
<li>合并或者删除无用的oc类和分类。</li>
<li>删除没有被调用的方法,减少非唯一selector的个数。</li>
<li>将不必须的初始化方法从+load移到+initialize。</li>
</ul>
<h4 id="main函数之后"><a href="#main函数之后" class="headerlink" title="main函数之后"></a>main函数之后</h4><p>这部分内容就是业务相关的东西了，根据各自app的需求会有不同的优化方案，不像上面的部分具有通用性。启动优化的最终目的肯定都是最快的展示首页内容，这里列举一些常用的优化套路。</p>
<ul>
<li>能延迟执行的就延迟执行。比如SDK的注册，非首页UI的创建等。</li>
<li>不能延迟执行的，尽量放到后台执行。比如网络请求，数据读取，原始JSON数据转对象，日志发送等。</li>
<li>既不能延时又不能后台执行的尽量已懒加载的方式创建实例。</li>
<li>利用检测工具监测启动阶段函数调用的耗时情况，进行针对性优化。</li>
</ul>
<p>具体细节可参考<a href="https://techblog.toutiao.com/2018/05/29/untitled-24/" target="_blank" rel="noopener">今日头条这篇优化文章</a></p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>蒸米大大的<a href="https://mp.weixin.qq.com/s/WQ7rrTJm-cn3Cb6e_zZ4cA" target="_blank" rel="noopener">这一篇文章</a>比较详细的描述了iOS中的虚拟内存和物理内存相关的内容。我们一般说的在程序中分配和回收内存指的都是虚拟内存，程序员一般不直接和物理内存（cpu内存，不包括磁盘）打交道。更多虚拟内存和物理内存的内容可阅读操作系统相关的文章和书籍去学习。</p>
<p>在计算机发展的初期，程序员都是直接访问物理内存，随着计算机技术的飞速发展，这种内存访问方式不再满足程序员的需求，新的内存访问方式出现，这就是被沿用至今的<strong>虚拟内存</strong>。虚拟内存在程序员和物理内存之间提供了一个良好的中间环境，它隔离了程序员直接使用物理内存带来的各种危险操作，提高了物理内存的利用率，简化了内存管理方式，保证了进程的安全。所以有这样一句古话：<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>，看来不是没有道理的。</p>
<p>言归正传，下面我们从创建、复用、回收三个方面总结一下iOS在内存使用过程中的一些需要注意的点：</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>减少大图的使用。</li>
<li>weak strong dance保证self的生命周期。</li>
<li>weak替换unsafe_unretain，保证指针安全。</li>
<li>合理利用自动释放池，避免内存暴涨导致OOM。</li>
<li>尽量使用懒加载的方式创建对象，避免无用和重复创建，减少不必要的内存开销。</li>
<li>在子线程手动申请（malloc）大内存的的时候 ping 一下主线程，因为子线程无法收到内存警告的传递。</li>
</ul>
<h4 id="缓存和复用"><a href="#缓存和复用" class="headerlink" title="缓存和复用"></a>缓存和复用</h4><ul>
<li>合理使用缓存减轻CPU的计算压力。</li>
<li>复用UI对象内存，通过绑定model更新UI。</li>
<li>合理使用缓存数据结构（NSCache VS NSMapTable VS NSHashTable VS NSDictionary）。</li>
</ul>
<h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ul>
<li>保证使用的内存能够被正确的回收掉，避免内存泄露（timer,delegate,block）。</li>
<li>使用适当的工具对内存的回收进行检测，发生内存泄露及时抛出提示。</li>
<li>处理系统的内存警告。</li>
</ul>
<h3 id="UI优化"><a href="#UI优化" class="headerlink" title="UI优化"></a>UI优化</h3><p>先说一下iOS中UI展示的过程。iOS中的视图容器是CALayer,所有的显示在屏幕上的内容最终都是被渲染到CALayer上。CPU计算好需要渲染的内容放入渲染缓冲区，GPU从渲染缓冲区拿到数据，OpenGLES经过顶点着色，光栅化，片元着色，逐片段操作等一系列流程，将处理好的数据（bitmap）丢到后帧缓冲区，前帧缓冲区再从后帧缓冲区更新数据，最终渲染到CALayer。</p>
<p>从上面展示的流程可以看到，UI的展示分为两个部分，CPU处理部分和GPU处理部分。如果某一部分的处理被阻塞的话，UI显示就会出现卡顿。所以，可以从这两部分着手优化。</p>
<h4 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h4><ul>
<li>利用UI卡顿检测工具检测屏幕的fps。</li>
<li>懒加载方式创建UI对象，使用CALayer替换UIView。</li>
<li>减少视图相关属性的修改，避免视图层级的调整，尽量不要动态添加和移除视图。</li>
<li>文本的异步计算和渲染。</li>
<li>尽量提前计算好视图布局并缓存，避免动态计算和更新布局。</li>
<li>异步解码图片和绘制视图。</li>
</ul>
<h4 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h4><ul>
<li>将多个小图合并为一张大图显示，控制图片尺寸不要大于GPU处理上限。</li>
<li>避免带透明度的视图重叠显示，会产生像素的混合。</li>
<li>避免出现离屏渲染。</li>
</ul>
<p>具体细节参考<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">YY的这篇文章</a></p>
<h3 id="ipa包大小优化"><a href="#ipa包大小优化" class="headerlink" title="ipa包大小优化"></a>ipa包大小优化</h3><p>上面提到过，iOS的ipa包实际上就是一堆二进制文件的集合。而这堆二进制文件，就是我们的代码经过Xcode编译之后的产物。这里简单介绍一下Xcode点击run后的整个流程：</p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><ul>
<li>将所有的 <em>#deifne</em> 删除 并展开所有的宏定义。</li>
<li>处理所有的条件编译指令 比如#if #else #ifdef #endif 等等。</li>
<li>处理#include预编译指令 将所包含的文件插入到预编译指令的位置。</li>
<li>删除所有的注释 // /<em> </em>/ 等等。</li>
<li>添加行号和文件名标识。</li>
<li>保留所有#pragma编译器指令。</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译过程就是把预处理完成的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件（词法分析-&gt;语法分析-&gt;语义分析-&gt;源代码优化-&gt;代码生成&gt;目标代码优化）。</p>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul>
<li>利用有限状态机扫描源代码 生成一系列记号（Token）。</li>
<li>记号分类：关键字、标识符、字面量（包括数字，字符串）、特殊符号（+、=）。</li>
<li>每种记号存入对应的表内。</li>
<li>词法规则可以自定义。</li>
</ul>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><ul>
<li>对上面的词法表进行语法分析、生成语法树。</li>
<li>整个分析过程采用上下文无关语法。</li>
<li>语法树以表达式为节点。</li>
</ul>
<h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><ul>
<li>编译器所能分析的语义是静态语义。</li>
<li>静态语义通常包括声明和类型的匹配，类型的转换。</li>
<li>经过语义分析，语法树被标识了类型。</li>
<li>语义分析判断该语法是否合法。</li>
</ul>
<h5 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h5><ul>
<li>直接在语法树上面优化比较困难，所以源代码优化器会先将语法树转换为中间代码。</li>
<li>中间代码是设备无关的。</li>
<li>编译器前端负责产生机器无关的中间代码，后端负责将中间代码转换成目标机器代码。</li>
<li>跨平台编译器就是有一个前端和多个后端的组合。</li>
</ul>
<h5 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h5><ul>
<li>编译器后端主要包括代码生成器和目标代码优化器。</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul>
<li>链接的过程主要包括：地址和空间分配、符号决议、重定向。</li>
<li>目标文件和库一起链接生成可执行文件。</li>
<li>库其实是一种编译后的目标文件。</li>
<li>目标文件之间的函数和变量的访问在链接过程中被重定向。</li>
</ul>
<h4 id="可执行文件的装载（即上面提到的main函数前的部分）"><a href="#可执行文件的装载（即上面提到的main函数前的部分）" class="headerlink" title="可执行文件的装载（即上面提到的main函数前的部分）"></a>可执行文件的装载（即上面提到的main函数前的部分）</h4><p>了解了二进制文件的产生过程后，我们可以利用一些工具来对它们做一些针对性的优化工作：</p>
<h4 id="二进制文件的优化"><a href="#二进制文件的优化" class="headerlink" title="二进制文件的优化"></a>二进制文件的优化</h4><h5 id="查看mach-o文件的大小"><a href="#查看mach-o文件的大小" class="headerlink" title="查看mach.o文件的大小"></a>查看mach.o文件的大小</h5><p>首先，在Xcode（Debug下）中开启编译选项<strong>Write Link Map File</strong>，然后在这个目录下面（这里以OpenCourse为例）找到下面这个txt文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/DerivedData/OpenCourse-gyfdubhkhvixzvetgqbmqrzplarc/Build/Intermediates.noindex/OpenCourse.build/Debug2-iphoneos/OpenCourse.build/OpenCourse-LinkMap-normal-arm64.txt</div></pre></td></tr></table></figure>
<p>这个LinkMap里展示了整个可执行文件的全貌，列出了编译后的每一个.o目标文件的信息（包括静态链接库.a里的），以及每一个目标文件的代码段，数据段存储详情。对于比较大的文件，进行对应的优化即可。</p>
<p><a href="https://github.com/daheli/iOS-linkmap-tools" target="_blank" rel="noopener">查看mach.o文件大小的工具</a></p>
<h5 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h5><ul>
<li>Optimization Level release使用Fastest。</li>
<li>Strip Linked Product release设置为YES。</li>
<li>Symbols Hidden by Default release设置为YES。</li>
</ul>
<h4 id="资源文件的优化"><a href="#资源文件的优化" class="headerlink" title="资源文件的优化"></a>资源文件的优化</h4><ul>
<li>图片资源在打包过程中压缩比很低，基本是原图copy。减少图片数量和大小可以直接降低ipa的大小。</li>
<li>及时删除无用代码（包括无用的类，依赖，方法，测试用例等）。</li>
</ul>
<p><a href="https://tinypng.com" target="_blank" rel="noopener">压缩图片大小的工具</a></p>
<p><a href="https://github.com/tinymind/LSUnusedResource" target="_blank" rel="noopener">检测无用的图片的工具</a></p>
<p><a href="https://github.com/dblock/fui" target="_blank" rel="noopener">检测无用类和依赖的工具</a></p>
<h3 id="编码和架构优化"><a href="#编码和架构优化" class="headerlink" title="编码和架构优化"></a>编码和架构优化</h3><p>好的代码质量和架构设计是项目稳定运行和迭代的基石。而编码高手和低手之间很大一部分区别在于对细节的处理上，要养成良好的编码习惯非一朝一夕，需要时间的积累和大量的练习，同时，也需要一些理论上的支持。下面推荐几本经典书籍，平时编码过程中，需要经常提醒自己甚至强迫自己按照书中这些tips去做，养成良好的编码习惯，提升技术上的综合素质。</p>
<h4 id="代码的设计原则和架构方案《架构整理之道》"><a href="#代码的设计原则和架构方案《架构整理之道》" class="headerlink" title="代码的设计原则和架构方案《架构整理之道》"></a>代码的设计原则和架构方案《架构整理之道》</h4><p>总结一下本书中比较重要的几个章节：</p>
<h5 id="SRP单一职责原则"><a href="#SRP单一职责原则" class="headerlink" title="SRP单一职责原则"></a>SRP单一职责原则</h5><ul>
<li>函数设计也需要遵循SRP原则</li>
<li>任何一个软件模块都应该有且仅有一个被修改的原因</li>
<li>任何一个软件模块都应该只对某一类行为者负责</li>
<li>Employee类中各行为应该被分解</li>
</ul>
<h5 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h5><ul>
<li>良好的设计软件应该易于扩展,同时抗拒修改</li>
<li>如果A组件不想被B组件上发生的修改所影响,那么就应该让B组件依赖于A组件</li>
<li>利用SRP分解功能,利用DIP反转依赖</li>
<li>软件系统不应该依赖不直接使用的组件</li>
</ul>
<h5 id="LSP里氏替换原则"><a href="#LSP里氏替换原则" class="headerlink" title="LSP里氏替换原则"></a>LSP里氏替换原则</h5><ul>
<li>以接口或者多态的形式实现函数调用的可替换性</li>
</ul>
<h5 id="ISP接口隔离原则"><a href="#ISP接口隔离原则" class="headerlink" title="ISP接口隔离原则"></a>ISP接口隔离原则</h5><ul>
<li>利用接口隔离原则隔离掉不需要的依赖关系,因为不需要的依赖会导致不必要的重新编译和重新部署</li>
</ul>
<h5 id="DIP依赖反转原则"><a href="#DIP依赖反转原则" class="headerlink" title="DIP依赖反转原则"></a>DIP依赖反转原则</h5><ul>
<li>如果想要设计一个灵活的系统,在源代码层面的依赖关系中就应该多引用抽象类型而非具体实现</li>
<li>接口比具体实现更稳定,因为如果修改接口必须修改实现,但是反之则不一定.</li>
<li>不要在具体实现类上创建子类,具体实现应该放到子类去做,除非是比较稳定且通用的逻辑.</li>
<li>不要覆盖包含具体实现的函数,如果必须这样,请在覆盖方法中先调用父类方法.</li>
<li>源代码依赖方向永远是控制流方向的反转</li>
</ul>
<h5 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h5><h6 id="复用-发布等同原则-REP"><a href="#复用-发布等同原则-REP" class="headerlink" title="复用/发布等同原则(REP)"></a>复用/发布等同原则(REP)</h6><ul>
<li>软件复用的最小粒度应等同于其发布的最小粒度</li>
<li>ERP原则就是指组件中的类与模块必须是彼此紧密相关的,一个组件不能由一组毫无关联的类和模块组成</li>
<li>一个组件中包含的类与模块还应该是可以同时发布的</li>
</ul>
<h6 id="共同闭包原则-CCP"><a href="#共同闭包原则-CCP" class="headerlink" title="共同闭包原则(CCP)"></a>共同闭包原则(CCP)</h6><ul>
<li>我们应该将那些会同时修改,并且为相同目的而修改的类放到同一个组件中,而将不会同时修改,并且不会为了相同目的而修改的那些类放到不同的组件中</li>
<li>CCP原则是SRP原则和OCP原则的组件版</li>
</ul>
<h6 id="共同复用原则-CRP"><a href="#共同复用原则-CRP" class="headerlink" title="共同复用原则(CRP)"></a>共同复用原则(CRP)</h6><ul>
<li>不要强迫一个组件的用户依赖他们不需要的东西</li>
<li>我们希望组件中的所有类是不可拆分的,不应该出现别人只需要依赖它的某几个类而不需要其他类的情况</li>
<li>CRP的作用不仅是告诉我们应该将哪些类放在一起,更重要的是要告诉我们应该将哪些类分开</li>
<li>CRP原则实际上是ISP原则的一个普适版,ISP建议我们不要依赖不需要的类,CRP建议我们不要依赖不需要的组件</li>
<li>优秀的架构师应该在REP,CCP和CRP原则间找到一个好的平衡点,一个项目的组件结构设计的重心是根据该项目的开发时间和成熟度不断变化的</li>
</ul>
<h5 id="组件耦合"><a href="#组件耦合" class="headerlink" title="组件耦合"></a>组件耦合</h5><h6 id="无依赖环原则"><a href="#无依赖环原则" class="headerlink" title="无依赖环原则"></a>无依赖环原则</h6><ul>
<li>组件依赖关系图中不应该出现环</li>
<li>依赖环会导致组件之间的发布和运行很难稳定下来</li>
<li>每周构建是指team每一周专门抽出一天来进行组件的构建调试工作,而其他时间则忽略组件的构建问题</li>
<li>消除循环依赖的一个解决办法是将研发项目划分成一些可单独发布的组件,这些组件独立完成构建和发布</li>
<li>DIP原则打破循环依赖好的选择</li>
</ul>
<h6 id="自上而下的设计"><a href="#自上而下的设计" class="headerlink" title="自上而下的设计"></a>自上而下的设计</h6><ul>
<li>组件结构图是不可能自上而下被设计出来的,它必须随着软件系统的变化而变化和扩张.</li>
<li>组件结构图并不是用来描述应用程序功能的,它更像是应用程序在构建性与维护性方面的一张地图</li>
<li>组件结构图的一个重要目的是如何隔离频繁的变更</li>
</ul>
<h6 id="稳定依赖原则"><a href="#稳定依赖原则" class="headerlink" title="稳定依赖原则"></a>稳定依赖原则</h6><ul>
<li>依赖关系必须要指向更稳定的方向</li>
<li>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖</li>
<li>稳定性指标的计算方法:出口依赖/(出口依赖+入口依赖). 0最稳定,1最不稳定.</li>
<li>组件并不是都需要稳定</li>
</ul>
<h6 id="稳定抽象原则"><a href="#稳定抽象原则" class="headerlink" title="稳定抽象原则"></a>稳定抽象原则</h6><ul>
<li>一个组件的抽象化程度应该与其稳定性保持一致</li>
<li>组件抽象化的计算方法:组件中的抽象类和接口/组件中类的个数 0表现没有抽象类 1表示全是抽象类</li>
<li>好的组件结构应该在抽象和稳定之间找到一个好的平衡点</li>
</ul>
<h4 id="编码规范和原则《程序员修炼之道》"><a href="#编码规范和原则《程序员修炼之道》" class="headerlink" title="编码规范和原则《程序员修炼之道》"></a>编码规范和原则《程序员修炼之道》</h4><p>从小工到专家，你需要做到下面这些：</p>
<h5 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h5><p><strong>DRY</strong>:系统中的每一项知识都必须具有单一,无歧义,权威的表示.</p>
<p>重复是怎样产生的:</p>
<ul>
<li>强加的重复,开发着觉得无可选择,环境要求.</li>
<li>无意的重复,开发者没有意识到他们在重复.</li>
<li>无耐性的重复,开发者偷懒,copy比较容易.</li>
<li>开发者之间的重复,几个人重复了同样的信息.</li>
</ul>
<h5 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h5><p>正交性是从几何学中借来的术语,如果两条直线相交成直角,它们就是正交的.沿着某一条直线移动,你投影到另一条直线上的位置不变.</p>
<p>正交性的好处:消除无关事物之间的影响(解耦不必要的依赖)</p>
<p><strong>分层设计</strong>是正交系统的强大方式..因为每层都只适用在其下面的层次提供的抽象,在改动底层实现,而又不影响其他代码方面,你拥有极大的灵活性.分层也降低了模块间依赖关系失控的风险.</p>
<p>正交性的简单测试方法:如果我显著的改变某个特定功能背后的需求,有多少模块会受影响?在正交系统中,答案是<strong>一个</strong></p>
<p>正交性在编码中的应用:</p>
<ul>
<li>让你的代码保持解耦</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数</li>
<li>养成不断批判对待自己代码的习惯.寻找任何重新进行组织,以改善其结构和正交性的机会,这个过程叫做重构,它非常重要.</li>
</ul>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>调试的心理学:</p>
<ul>
<li>调试是解决问题,要据此发起进攻</li>
<li>要修正问题,而不是发出指责(bug是你的还是别人的,这不是真的很有关系.)</li>
<li>不要恐慌,如果你看到bug报告的第一反应是<strong>那不可能</strong>,你就完全错了.一个脑细胞都不要浪费在以<strong>“但那时不可能”</strong>起头的思路上,因为很明显,那不仅可能,而且已经发生.</li>
<li>小心近视,要抵制只修正你看到的症状的急迫愿望,更有可能的情况是,实际的故障离你正在观察的地方可能还有几步远,并且可能涉及许多其他的相关事物.</li>
</ul>
<p>调试策略:</p>
<ul>
<li>你需要与qa面谈,搜集比最初给你的数据更多的数据.</li>
<li>qa不可能全覆盖所有的case,你需要系统的进行这样的测试,比如分支语句,你可能需要自己造数据去覆盖所有的分支.</li>
<li>复现bug</li>
<li>数据可视化(log)</li>
<li>堆栈和断点</li>
<li>橡皮鸭,把你的逻辑对着桌上的橡皮鸭描述一遍,看看有没有漏洞.</li>
<li>消除过程,二分调试</li>
<li>遇到自认为不可能的bug时,不要假定,要证明.</li>
</ul>
<h5 id="解耦与得墨忒耳法则"><a href="#解耦与得墨忒耳法则" class="headerlink" title="解耦与得墨忒耳法则"></a>解耦与得墨忒耳法则</h5><p>多模块耦合的危害</p>
<ul>
<li>调用链冗长</li>
<li>对一个模块的简单改动会传遍系统中的一些无关模块</li>
<li>开发者害怕改动代码,因为他们不清楚哪些代码可能受影响</li>
</ul>
<p>函数的得墨忒耳法则规定,某个对象的任何方法都应该只调用以下情形的方法:</p>
<ul>
<li>它自身的方法</li>
<li>传入该方法的任何对象的方法</li>
<li>它创建的任何对象的方法</li>
<li>任何直接持有的组件的对象的方法(比如全局对象)</li>
</ul>
<h5 id="不要靠巧合编程"><a href="#不要靠巧合编程" class="headerlink" title="不要靠巧合编程"></a>不要靠巧合编程</h5><p>深思熟虑的编程,而不是靠运气和偶然的成功.</p>
<p>怎样深思熟虑的编程:</p>
<ul>
<li>总是意识到你在做什么</li>
<li>不要盲目的编程</li>
<li>按照计划行事</li>
<li>依靠可靠的事物,不要依靠巧合或假定</li>
<li>为你的假定建立文档</li>
<li>不要只是测试你的代码,还要测试你的假定</li>
<li>为你的工作划分优先级</li>
<li>不要做历史的奴隶,不要让已有的代码支配将来的代码,如果不再适用,所有的代码都可以被替换.</li>
</ul>
<h5 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h5><p>何时重构:</p>
<ul>
<li>重复,你发现了对DRY原则的违反</li>
<li>非正交的设计</li>
<li>过时的知识</li>
<li>性能问题</li>
</ul>
<p>早重构,常重构</p>
<p>如何重构:</p>
<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前,确保你拥有良好的测试.</li>
<li>采取短小,深思熟虑的步骤.</li>
</ul>
<h5 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h5><ul>
<li>不要留破窗户</li>
<li>不要做温水里的青蛙</li>
<li>交流的重要性</li>
<li>DRY</li>
<li>正交性</li>
</ul>
<h4 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h4><p>早测试,常测试,自动测试</p>
<p>要到通过全部测试,编码才算完成</p>
<p>测试什么:</p>
<ul>
<li><p>单元测试</p>
<p>  模块测试</p>
</li>
<li><p>集成测试</p>
<p>  子系统能很好的系统工作</p>
</li>
<li><p>验证和校验</p>
<p>  用户回归</p>
</li>
<li><p>资源耗尽,错误及恢复</p>
<p>  1.内存空间<br>  2.磁盘空间<br>  3.cpu带宽<br>  4.挂钟时间<br>  5.磁盘带宽<br>  6.网络带宽<br>  7.调色板<br>  8.视频分辨率<br>  9.fps</p>
</li>
<li><p>性能测试</p>
<p>  预期的用户数,连接数或每秒事务数</p>
</li>
<li><p>可用性测试</p>
<p>  qa,灰度…</p>
</li>
</ul>
<h5 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h5><p>在你的作品上签名,你的签名应该被视为质量的保证，如果有一天你离开了网易，是否会因为代码质量问题而把自己的签名换成netease呢？（手动@学姐😁）。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上是一个iOSer项目优化的简单总结，一部分可能是iOS特有的优化项目，还有一部分则具有普适性，因为不管什么技术方向，最终它们的产物都会是二进制。技术的深度和广度这两个方向的发展问题也一直都是程序员们讨论的话题，其实不管是深度和广度，只要找准一个方向一直走下去，就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/10/Runloop源码解析和实践/" itemprop="url">
                  Runloop源码解析和实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-09-10T21:20:28+08:00" content="2018-09-10">
              2018-09-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/09/10/Runloop源码解析和实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/10/Runloop源码解析和实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="RunLoop是干啥的"><a href="#RunLoop是干啥的" class="headerlink" title="RunLoop是干啥的"></a>RunLoop是干啥的</h4><p><strong>官翻：</strong> Run loops是与线程相关的基础设施的一部分，一个Runloop就是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。</p>
<h4 id="疑问？？？"><a href="#疑问？？？" class="headerlink" title="疑问？？？"></a>疑问？？？</h4><ul>
<li>Runloop的运行机制</li>
<li>Runloop是如何唤醒和睡眠线程的，与线程到底是什么关系</li>
<li>Runloop的Source、Timer、Observer和Mode与Runloop到底是什么关系</li>
<li>iOS系统怎么使用Runloop的</li>
<li>如何自定义</li>
</ul>
<h3 id="庖丁解🐂"><a href="#庖丁解🐂" class="headerlink" title="庖丁解🐂"></a>庖丁解🐂</h3><p>一个Runloop接收2中不同类型的sources.<strong>Input source</strong> 发送异步事件，一般是来自其他线程或者是其他应用的；<strong>Timer source</strong>发送同步事件，会在预设好的时间或者重复间隔内触发。这2种source都会通过特殊的处理程序处理事件。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop001.png" alt=""></p>
<p>Input source发送异步事件，这种source runloop在处理的时候会调用runUnitlDate：方法开启一个runloop,并且在运行date时间后退出。Timer source则不会使runloop退出。</p>
<p>在处理input source时，runloops 也会生成相关的通知，你可以注册成为观察者在当前线程来处理其他时间。</p>
<p>#####（补充） runloop 的运行方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)run; </div><div class="line">- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</div><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure>
<ul>
<li><p>run方法对应CFRunloopRef中的CFRunLoopRun并不会退出，除非手动调用CFRunLoopStop();通常如果想要永远不会退出RunLoop才会使用此方法，否则可以使用runUntilDate。</p>
</li>
<li><p>runMode:beforeDate:则对应CFRunLoopRunInMode(mode,limiteDate,true)方法,只执行一次，执行完就退出；通常用于手动控制RunLoop（例如在while循环中）。</p>
</li>
<li><p>runUntilDate:方法其实是CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)，执行完并不会退出，继续下一次RunLoop直到timeout。</p>
</li>
</ul>
<h4 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h4><p>一个runloop mode是input source和timer sources的集合，同时包含一个runloop观察者的合集。每次运行一个runloop时，需要指定一个特别的mode。在runloop 运行的过程中，只有和这个mode相关联source才能发送事件（同样，只有和这个mode关联的观察者才能收到通知）。关联了其他mode的source会被暂停一切新事件的发送直到runloop运行在该mode上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</div><div class="line">    CFMutableSetRef _sources0;    // Set</div><div class="line">    CFMutableSetRef _sources1;    // Set</div><div class="line">    CFMutableArrayRef _observers; // Array</div><div class="line">    CFMutableArrayRef _timers;    // Array</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>modes通过name来区分，可用通过指定mode的name来自定义一个mode,虽然name在自定义的时候可以任意指定，但是其他内容却不行，当你自定义一个mode的时候，必须添加一个或者多个source(input source 或 timer source) ,或者观察者。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop003.png" alt=""></p>
<h4 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h4><p>Input sources 给线程发送异步事件，事件的类型和input source的类型相关。一般有2种:<strong>Port-based input sources 用来监控Mach ports</strong>和<strong>自定义 input sources 用来监控自定义事件</strong>。2者的唯一不同在于如何发送信号：Port-based input sources是kernel内核自动发送信号；自定义 input sources是从其他线程手动发送信号。</p>
<h5 id="Port-Based-Sources"><a href="#Port-Based-Sources" class="headerlink" title="Port-Based Sources"></a>Port-Based Sources</h5><ul>
<li>NSMachPort</li>
<li>NSMessagePort</li>
</ul>
<p>mach 操作系统微内核 在mac os和ios系统中采用。虚拟内存的分配，进程间的通信（基于port）。</p>
<p>每一种服务都是一个进程（http 8080 https 443 ftp 20 21 rtmp 1935），每一个进程都分配一个port(虚拟端口)， </p>
<h5 id="Custom-Input-Sources"><a href="#Custom-Input-Sources" class="headerlink" title="Custom Input Sources"></a>Custom Input Sources</h5><p>自定义一个Input source需要满足如下定义：</p>
<ul>
<li>需要input source处理的信息</li>
<li>让感兴趣的客户端知道怎么联系你的input source</li>
<li>一个处理程序例程来执行任何客户端的发送请求</li>
<li>取消程序</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop004.png" alt=""></p>
<h5 id="Cocoa-Perform-Selector-Sources"><a href="#Cocoa-Perform-Selector-Sources" class="headerlink" title="Cocoa Perform Selector Sources"></a>Cocoa Perform Selector Sources</h5><p>Perform Selector Sources 在执行完以后会从runloop的mode中移除。</p>
<p>当调用这个方法时，target线程必须包含一个活跃的runloop，runloop会在一次loop中处理所有的排队Perform事件而不是只处理一个。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop005.png" alt=""></p>
<h4 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h4><p>timer需要关联一个mode，如果timer不在当前活动的mode上，则不会被触发。如果timer所在的mode执行过程中被切换，则该timer也不会暂停直到mode重新切换回来，这就决定了NSTimer的触发并不是十分可靠的。</p>
<h4 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> /* Run Loop Observer Activities */</div><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),// 即将进入Loop  0x1</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),// 即将处理 Timer </div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source </div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠 0x20</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 </div><div class="line">    </div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出Loop </div><div class="line">    </div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Runloop使用场景"><a href="#Runloop使用场景" class="headerlink" title="Runloop使用场景"></a>Runloop使用场景</h4><ul>
<li>使用mach port或者自定义input source 来与其他线程通信</li>
<li>使用NSTimer</li>
<li>使用performSelector</li>
<li>线程保活</li>
<li>系统默认使用</li>
</ul>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>源码下载<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></p>
<h5 id="Input-Source-amp-amp-CFRunLoopSource-的结构"><a href="#Input-Source-amp-amp-CFRunLoopSource-的结构" class="headerlink" title="Input Source &amp;&amp; CFRunLoopSource 的结构"></a>Input Source &amp;&amp; CFRunLoopSource 的结构</h5><ul>
<li>source0/自定义 source</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">    Boolean	(*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode	(*hash)(const void *info);</div><div class="line">    void	(*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void	(*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void	(*perform)(void *info);</div><div class="line">&#125; CFRunLoopSourceContext;</div></pre></td></tr></table></figure>
<ul>
<li>source1/(mach port source+自定义 source)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">    Boolean	(*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode	(*hash)(const void *info);</div><div class="line">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</div><div class="line">    mach_port_t	(*getPort)(void *info);</div><div class="line">    void *	(*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);</div><div class="line">#else</div><div class="line">    void *	(*getPort)(void *info);</div><div class="line">    void	(*perform)(void *info);</div><div class="line">#endif</div><div class="line">&#125; CFRunLoopSourceContext1;</div></pre></td></tr></table></figure>
<ul>
<li>CFRunLoopSource</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopSource &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint32_t _bits;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFMutableBagRef _runLoops;</div><div class="line">    union &#123;</div><div class="line">	CFRunLoopSourceContext version0;	/* immutable, except invalidation */</div><div class="line">        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */</div><div class="line">    &#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="observer-amp-amp-CFRunLoopObserver-的结构"><a href="#observer-amp-amp-CFRunLoopObserver-的结构" class="headerlink" title="observer &amp;&amp; CFRunLoopObserver 的结构"></a>observer &amp;&amp; CFRunLoopObserver 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">&#125; CFRunLoopObserverContext;</div><div class="line"></div><div class="line">struct __CFRunLoopObserver &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFIndex _rlCount;</div><div class="line">    CFOptionFlags _activities;		/* immutable */</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFRunLoopObserverCallBack _callout;	/* immutable */</div><div class="line">    CFRunLoopObserverContext _context;	/* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="NSTimer-amp-amp-CFRunloopTimer-的结构"><a href="#NSTimer-amp-amp-CFRunloopTimer-的结构" class="headerlink" title="NSTimer &amp;&amp; CFRunloopTimer 的结构"></a>NSTimer &amp;&amp; CFRunloopTimer 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">&#125; CFRunLoopTimerContext;</div><div class="line"></div><div class="line">struct __CFRunLoopTimer &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint16_t _bits;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFMutableSetRef _rlModes;</div><div class="line">    CFAbsoluteTime _nextFireDate;</div><div class="line">    CFTimeInterval _interval;		/* immutable */</div><div class="line">    CFTimeInterval _tolerance;          /* mutable */</div><div class="line">    uint64_t _fireTSR;			/* TSR units */</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFRunLoopTimerCallBack _callout;	/* immutable */</div><div class="line">    CFRunLoopTimerContext _context;	/* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Mode-的结构"><a href="#Mode-的结构" class="headerlink" title="Mode 的结构"></a>Mode 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;//如果是MK_TIMER的话，会通过这个端口唤醒线程</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="runloop-的结构"><a href="#runloop-的结构" class="headerlink" title="runloop 的结构"></a>runloop 的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct _block_item &#123;</div><div class="line">    struct _block_item *_next;</div><div class="line">    CFTypeRef _mode;	// CFString or CFSet</div><div class="line">    void (^_block)(void);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef struct _per_run_data &#123;</div><div class="line">    uint32_t a;</div><div class="line">    uint32_t b;</div><div class="line">    uint32_t stopped;</div><div class="line">    uint32_t ignoreWakeUps;</div><div class="line">&#125; _per_run_data;</div><div class="line"></div><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;			/* locked for accessing mode list */</div><div class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp source0的手动唤醒就是通过给这个端口发消息实现的。</div><div class="line">    Boolean _unused;</div><div class="line">    </div><div class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run  loop 个人理解为runloop的一个配置文件</div><div class="line">    </div><div class="line">    pthread_t _pthread;</div><div class="line">    uint32_t _winthread;</div><div class="line">    </div><div class="line">    CFMutableSetRef _commonModes;//存放 common mode 的集合</div><div class="line">    CFMutableSetRef _commonModeItems;//每个 common mode 都有的 item (source, timer and observer) 集合</div><div class="line">    </div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;//这个 run loop 所有的 mode 集合</div><div class="line">    </div><div class="line">    struct _block_item *_blocks_head;</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    </div><div class="line">    </div><div class="line">    CFAbsoluteTime _runTime;</div><div class="line">    CFAbsoluteTime _sleepTime;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop"><a href="#Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop" class="headerlink" title="Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()"></a>Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//获取主线程runloop</div><div class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class="line">    return __main;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取当前线程runloop</div><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div><div class="line"></div><div class="line">//保存runloop和pthread的全局字典。key = pthreadPointer(t); value = runloop.</div><div class="line">static CFMutableDictionaryRef __CFRunLoops = NULL;</div><div class="line">static CFLock_t loopsLock = CFLockInit;</div><div class="line"></div><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class="line"></div><div class="line">	//如果当前线程为0 则取主线程.</div><div class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">	t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __CFLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    //全局字典为空，则创建字典</div><div class="line">    if (!__CFRunLoops) &#123;</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line"></div><div class="line">	//创建主线程的runloop</div><div class="line">	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line"></div><div class="line">	//将runloop和pthread set到一个临时字典中</div><div class="line">	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">	</div><div class="line">	//将临时字典复制到全局字典，这个是一个原子操作。</div><div class="line">	if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class="line">	    CFRelease(dict);</div><div class="line">	&#125;</div><div class="line">	CFRelease(mainLoop);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //从全局字典中取出当前线程对应的runloop</div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">    __CFUnlock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    //如果runloop为空，新建runloop,并保存到全局字典中</div><div class="line">    if (!loop) &#123;</div><div class="line">	CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">	if (!loop) &#123;</div><div class="line">	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">	    loop = newLoop;</div><div class="line">	&#125;</div><div class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">	CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    if (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//入参为一个线程</div><div class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</div><div class="line">    CFRunLoopRef loop = NULL;</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</div><div class="line">    </div><div class="line">    //创建runloop实例</div><div class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, CFRunLoopGetTypeID(), size, NULL);</div><div class="line">    if (NULL == loop) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //初始化配置</div><div class="line">    (void)__CFRunLoopPushPerRunData(loop);</div><div class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</div><div class="line"></div><div class="line">	//初始化唤醒port</div><div class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</div><div class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</div><div class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</div><div class="line">    </div><div class="line">    //初始化commonModes 并 add kCFRunLoopDefaultMode</div><div class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</div><div class="line">    </div><div class="line">    //初始化其他变量</div><div class="line">    loop-&gt;_commonModeItems = NULL;</div><div class="line">    loop-&gt;_currentMode = NULL;</div><div class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    loop-&gt;_blocks_head = NULL;</div><div class="line">    loop-&gt;_blocks_tail = NULL;</div><div class="line">    loop-&gt;_counterpart = NULL;</div><div class="line">    </div><div class="line">    //绑定线程</div><div class="line">    loop-&gt;_pthread = t;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    loop-&gt;_winthread = GetCurrentThreadId();</div><div class="line">#else</div><div class="line">    loop-&gt;_winthread = 0;</div><div class="line">#endif</div><div class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</div><div class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</div><div class="line">    return loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 线程退出时调用</div><div class="line">CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) &#123;</div><div class="line">    CFRunLoopRef rl = NULL;</div><div class="line">    if (data &lt;= 1) &#123;</div><div class="line">	__CFLock(&amp;loopsLock);</div><div class="line">	if (__CFRunLoops) &#123;</div><div class="line">		</div><div class="line">		//在全局字典中移除该runloop</div><div class="line">	    rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));</div><div class="line">	    if (rl) CFRetain(rl);</div><div class="line">	    CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));</div><div class="line">	&#125;</div><div class="line">	__CFUnlock(&amp;loopsLock);</div><div class="line">    &#125; else &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    if (rl &amp;&amp; CFRunLoopGetMain() != rl) &#123; // protect against cooperative threads</div><div class="line">        if (NULL != rl-&gt;_counterpart) &#123;</div><div class="line">            CFRelease(rl-&gt;_counterpart);</div><div class="line">	    rl-&gt;_counterpart = NULL;</div><div class="line">        &#125;</div><div class="line">	// purge all sources before deallocation</div><div class="line">        CFArrayRef array = CFRunLoopCopyAllModes(rl);</div><div class="line">        </div><div class="line">        //移除该runloop的所有source</div><div class="line">        for (CFIndex idx = CFArrayGetCount(array); idx--;) &#123;</div><div class="line">            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);</div><div class="line">            __CFRunLoopRemoveAllSources(rl, modeName);</div><div class="line">        &#125;</div><div class="line">        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);</div><div class="line">        CFRelease(array);</div><div class="line">    &#125;</div><div class="line">    if (rl) CFRelease(rl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>runloop的创建是懒加载的方式创建，在第一次获取该runloop的时候才会去创建，所以子线程如果没有手动的去获取并运行runloop,是不会自动创建的。</li>
<li>runloop和线程是一一对应的关系，保存在一个全局的字典中。key是线程的指针，value是对应的runloop.</li>
<li>runloop的销毁发生在线程退出时。</li>
</ul>
<h4 id="Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun"><a href="#Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun" class="headerlink" title="Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun"></a>Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div></pre></td><td class="code"><pre><div class="line">struct __timeout_context &#123;</div><div class="line">    dispatch_source_t ds;</div><div class="line">    CFRunLoopRef rl;</div><div class="line">    uint64_t termTSR;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __CFRunLoopTimeoutCancel(void *arg) &#123;</div><div class="line">    struct __timeout_context *context = (struct __timeout_context *)arg;</div><div class="line">    CFRelease(context-&gt;rl);</div><div class="line">    dispatch_release(context-&gt;ds);</div><div class="line">    free(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopTimeout(void *arg) &#123;</div><div class="line">    struct __timeout_context *context = (struct __timeout_context *)arg;</div><div class="line">    context-&gt;termTSR = 0ULL;</div><div class="line">    CFRUNLOOP_WAKEUP_FOR_TIMEOUT();</div><div class="line">    CFRunLoopWakeUp(context-&gt;rl);</div><div class="line">    // The interval is DISPATCH_TIME_FOREVER, so this won&apos;t fire again</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CFRunLoopRun(void) &#123;	/* DOES CALLOUT */</div><div class="line">    int32_t result;</div><div class="line">    do &#123;</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">	Boolean did = false;</div><div class="line">	if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">	// 1.通知观察者runloop即将进入loop</div><div class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">	</div><div class="line">	//run</div><div class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">	</div><div class="line">	// 10. 通知观察者runLoop即将退出</div><div class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">	rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> *  运行run loop</div><div class="line"> *</div><div class="line"> *  @param rl              运行的RunLoop对象</div><div class="line"> *  @param rlm             运行的mode</div><div class="line"> *  @param seconds         run loop超时时间</div><div class="line"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</div><div class="line"> *  @param previousMode    上一次运行的mode</div><div class="line"> *</div><div class="line"> *  @return 返回4种状态</div><div class="line"> */</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line"></div><div class="line">	</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line">    </div><div class="line">    //如果该runloop已停止，直接退出。</div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    //获取GCD的消息端口</div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    </div><div class="line">    //看判断条件，只有当前是主线程，才获取端口。（GCD只能唤醒主线程的runloop）</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">    //使用GCD的source来实现NSTimer</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    //设置runloop的超时时间，second是参数。</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">	timeout_context-&gt;ds = timeout_timer;</div><div class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">	</div><div class="line">	//调用__CFRunLoopTimeout</div><div class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//初始化为true</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;//返回状态</div><div class="line">    </div><div class="line">    //do while循环</div><div class="line">    do &#123;</div><div class="line">    </div><div class="line">    //runloop睡眠的时候会注册这个端口用来接口消息    </div><div class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line"></div><div class="line">	// 设置RunLoop为可以被唤醒状态</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">	// 2.通知observer，即将触发timer回调，处理timer事件</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        </div><div class="line">   	// 3.通知observer，即将触发Source0回调</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line"></div><div class="line"></div><div class="line">	// 执行加入当前 runloop 的 block</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	</div><div class="line">	 	 // 4.处理 source0 事件 有事件处理返回 true，没有事件返回 false</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        </div><div class="line">        // 如果实际处理了 sources 0，再一次处理 blocks（有可能是source0的回调中又给runloop添加了block）</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		 // 如果没有 Sources0 事件处理 并且 没有超时，poll 为 false</div><div class="line">        // 如果有 Sources0 事件处理 或者 超时，poll 都为 true</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line">        </div><div class="line">         if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line"></div><div class="line">         //如果收到source1的消息</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">                goto handle_msg;    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        didDispatchPortLastTime = false;</div><div class="line"></div><div class="line">	// 6.通知观察者RunLoop即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	</div><div class="line">	 // 7.设置RunLoop为休眠状态</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line">	</div><div class="line">	// do not do any user callouts after this point (after notifying of sleeping)</div><div class="line"></div><div class="line">        // Must push the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced.</div><div class="line"></div><div class="line">	//将睡眠等待端口添加到当前mach port活跃列表</div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">		//记录开始睡眠时间</div><div class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class="line"></div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">		// 等待被唤醒，可以被 sources0、source1、Mach port source,timers、CFRunLoopWakeUp 函数和 GCD 事件（如果在主线程）</div><div class="line">        do &#123;</div><div class="line">        </div><div class="line">        	  //清理消息缓存区</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                // objc_clear_stack(0);</div><div class="line">                // &lt;rdar://problem/16393959&gt;</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            </div><div class="line">            // 接收waitSet端口的消息 </div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">            </div><div class="line">			  // 如果是 timer 端口唤醒的，进行一下善后处理，之后再处理 timer</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    // Leave livePort as the queue port, and service timers below</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">            </div><div class="line">            	   // 不是 timer 端口唤醒的，跳出循环，进行接下来的处理</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line"></div><div class="line">		 // 不使用 GCD timer 作为 timer 实现的情况</div><div class="line">		 </div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            // objc_clear_stack(0);</div><div class="line">            // &lt;rdar://problem/16393959&gt;</div><div class="line">            </div><div class="line">            //清理消息缓存区</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">        </div><div class="line">#endif</div><div class="line">      </div><div class="line">      	 //被唤醒了。。。</div><div class="line">      	 </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">		  // 记录增加的睡眠时间</div><div class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class="line"></div><div class="line">        // Must remove the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class="line">        // in there if this function returns.</div><div class="line"></div><div class="line">		 //将等待唤醒的端口从mach port活跃端口列表移除</div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        //设置为忽略唤醒状态</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">		 // 取消runloop的休眠状态</div><div class="line">        // user callouts now OK again</div><div class="line">	__CFRunLoopUnsetSleeping(rl);</div><div class="line">	</div><div class="line">		 // 8.通知观察者runloop被唤醒</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line"></div><div class="line">		 // 9.处理通过端口收到的消息</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">		</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">        	  </div><div class="line">        	  // 不知道哪个端口唤醒的（或者根本没睡），啥也不干</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">            </div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">        		</div><div class="line">        	  // 被 CFRunLoopWakeUp 函数唤醒的，啥也不干</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            // do nothing on Mac OS</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">        	  </div><div class="line">        	  // 被 timers 唤醒，处理 timers</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class="line">            </div><div class="line">            // 被 timers 唤醒，处理 timers</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">			//被GCD唤醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">           __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">        	//以上都不是则是被source1唤醒的</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            </div><div class="line">            // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</div><div class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class="line"></div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            </div><div class="line"></div><div class="line">	        mach_msg_header_t *reply = NULL;</div><div class="line"></div><div class="line">	        //处理source1</div><div class="line">	        sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">	        if (NULL != reply) &#123;</div><div class="line">	            (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">	            CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">	        &#125;</div><div class="line">	            </div><div class="line">	            // Restore the previous voucher</div><div class="line">	            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">            </div><div class="line">        &#125; </div><div class="line">               </div><div class="line">   // 再一次处理 blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">	// 善后</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	</div><div class="line">	// 处理完当前事件 &amp; runloop 执行完就退出</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">	    </div><div class="line">	&#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">        </div><div class="line">        // run loop超时</div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">            </div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">	</div><div class="line">		 // run loop被手动终止</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	    </div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">		</div><div class="line">		// mode被终止</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	    </div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	</div><div class="line">		// mode中的Items都为空，退出。</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">        </div><div class="line">    &#125; while (0 == retVal);</div><div class="line"></div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return retVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//接收mach port消息</div><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *voucherState, voucher_t *voucherCopy) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;		/* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;</div><div class="line">        msg-&gt;msgh_local_port = port;</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class="line">        msg-&gt;msgh_size = buffer_size;</div><div class="line">        msg-&gt;msgh_id = 0;</div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        </div><div class="line">        //接收或发送消息</div><div class="line">        ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class="line"></div><div class="line">        // Take care of all voucher-related work right after mach_msg.</div><div class="line">        // If we don&apos;t release the previous voucher we&apos;re going to leak it.</div><div class="line">        voucher_mach_msg_revert(*voucherState);</div><div class="line">        </div><div class="line">        // Someone will be responsible for calling voucher_mach_msg_revert. This call makes the received voucher the current one.</div><div class="line">        *voucherState = voucher_mach_msg_adopt(msg);</div><div class="line">        </div><div class="line">        if (voucherCopy) &#123;</div><div class="line">            if (*voucherState != VOUCHER_MACH_MSG_STATE_UNCHANGED) &#123;</div><div class="line">                // Caller requested a copy of the voucher at this point. By doing this right next to mach_msg we make sure that no voucher has been set in between the return of mach_msg and the use of the voucher copy.</div><div class="line">                // CFMachPortBoost uses the voucher to drop importance explicitly. However, we want to make sure we only drop importance for a new voucher (not unchanged), so we only set the TSD when the voucher is not state_unchanged.</div><div class="line">                *voucherCopy = voucher_copy();</div><div class="line">            &#125; else &#123;</div><div class="line">                *voucherCopy = NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        CFRUNLOOP_WAKEUP(ret);</div><div class="line">        </div><div class="line">        //接收消息成功</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="runloop运行流程总结入下图"><a href="#runloop运行流程总结入下图" class="headerlink" title="runloop运行流程总结入下图"></a>runloop运行流程总结入下图</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop007.png" alt=""></p>
<p>runloop内部其实就是一个do while()的循环。只是在没有事件需要处理的时候，runloop会调用<strong>__CFRunLoopSetSleeping</strong> 方法将当前线程置为睡眠状态，同时会调用 <strong>__CFRunLoopServiceMachPort</strong> 方法来睡眠线程并等待接收mach发来的唤醒消息。收到消息后，该线程会被唤醒，唤醒后runloop除了处理唤醒它的事件，还需要处理一遍所有等待处理的事件，包括（timer,observer,source,block）。</p>
<h5 id="runloop唤醒事件总结"><a href="#runloop唤醒事件总结" class="headerlink" title="runloop唤醒事件总结"></a>runloop唤醒事件总结</h5><ul>
<li>mach port source</li>
<li>手动唤醒Custom Input Source（CFRunLoopSourceSignal(source)/CFRunLoopWakeUp(runloop)）</li>
<li>dispatch_async(dispatch_get_main_queue)/dispatch_sync(dispatch_get_main_queue)(不要在主线程同步任务，会死锁);</li>
<li>timer</li>
</ul>
<h4 id="Mode和它的四大大王-Source-Timer-Observer-Block"><a href="#Mode和它的四大大王-Source-Timer-Observer-Block" class="headerlink" title="Mode和它的四大大王(Source,Timer,Observer,Block)"></a>Mode和它的四大大王(Source,Timer,Observer,Block)</h4><h5 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h5><p>Mode的创建也是懒加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    struct __CFRunLoopMode srlm;</div><div class="line">    memset(&amp;srlm, 0, sizeof(srlm));</div><div class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, __kCFRunLoopModeTypeID);</div><div class="line">    srlm._name = modeName;</div><div class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</div><div class="line">    </div><div class="line">    //mode不为空直接返回，为空则创建新的</div><div class="line">    if (NULL != rlm) &#123;</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">	return rlm;</div><div class="line">    &#125;</div><div class="line">    if (!create) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);</div><div class="line">    if (NULL == rlm) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //参数的初始化</div><div class="line">    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);</div><div class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    rlm-&gt;_portToV1SourceMap = NULL;</div><div class="line">    rlm-&gt;_sources0 = NULL;</div><div class="line">    rlm-&gt;_sources1 = NULL;</div><div class="line">    rlm-&gt;_observers = NULL;</div><div class="line">    rlm-&gt;_timers = NULL;</div><div class="line">    rlm-&gt;_observerMask = 0;</div><div class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</div><div class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</div><div class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</div><div class="line">    </div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    </div><div class="line">    //初始化timer相关内容</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    rlm-&gt;_timerFired = false;</div><div class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0);</div><div class="line">    </div><div class="line">    //用来唤醒的端口</div><div class="line">    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">    if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1);</div><div class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue);</div><div class="line">    </div><div class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</div><div class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</div><div class="line">        *timerFiredPointer = true;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</div><div class="line">    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);</div><div class="line">    dispatch_resume(rlm-&gt;_timerSource);</div><div class="line">    </div><div class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</div><div class="line">    </div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line"></div><div class="line">    //用来唤醒的端口</div><div class="line">    rlm-&gt;_timerPort = mk_timer_create();</div><div class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</div><div class="line">#endif</div><div class="line">    </div><div class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret);</div><div class="line">    </div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    rlm-&gt;_msgQMask = 0;</div><div class="line">    rlm-&gt;_msgPump = NULL;</div><div class="line">#endif</div><div class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</div><div class="line">    CFRelease(rlm);</div><div class="line">    __CFRunLoopModeLock(rlm);	/* return mode locked */</div><div class="line">    return rlm;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//判断mode是否为空 通过这个函数可以看到，只有当source0、source1、timer和block都为空，mode才会被标记为空（这么看observer应该是低等屁民了，没有什么存在感）</div><div class="line"></div><div class="line">static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (NULL == rlm) return true;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    if (0 != rlm-&gt;_msgQMask) return false;</div><div class="line">#endif</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    </div><div class="line">	//主线程且当前Mode也在CommonMode中，不可能为空，应该是系统有往CommonMode里面添加了东西，会被同步到该Mode中。</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) return false; // represents the libdispatch main queue</div><div class="line">    </div><div class="line">    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false;</div><div class="line">    if (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false;</div><div class="line">    if (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false;</div><div class="line">    struct _block_item *item = rl-&gt;_blocks_head;</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">        Boolean doit = false;</div><div class="line">        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">            doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));</div><div class="line">        &#125; else &#123;</div><div class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));</div><div class="line">        &#125;</div><div class="line">        if (doit) return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line">//source的创建</div><div class="line"></div><div class="line">CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopSourceRef memory;</div><div class="line">    uint32_t size;</div><div class="line">    if (NULL == context) CRASH(&quot;*** NULL context value passed to CFRunLoopSourceCreate(). (%d) ***&quot;, -1);</div><div class="line">    </div><div class="line">    size = sizeof(struct __CFRunLoopSource) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopSourceRef)_CFRuntimeCreateInstance(allocator, CFRunLoopSourceGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopSourceUnsetSignaled(memory);</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_bits = 0;</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    memory-&gt;_runLoops = NULL;</div><div class="line">    size = 0;</div><div class="line">    switch (context-&gt;version) &#123;</div><div class="line">    case 0:</div><div class="line">	size = sizeof(CFRunLoopSourceContext);</div><div class="line">	break;</div><div class="line">    case 1:</div><div class="line">	size = sizeof(CFRunLoopSourceContext1);</div><div class="line">	break;</div><div class="line">    &#125;</div><div class="line">    objc_memmove_collectable(&amp;memory-&gt;_context, context, size);</div><div class="line">    if (context-&gt;retain) &#123;</div><div class="line">	memory-&gt;_context.version0.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//给mode添加source</div><div class="line"></div><div class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;	/* DOES CALLOUT */</div><div class="line"></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rls)) return;</div><div class="line">    Boolean doVer0Callout = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    //如果是common 直接添加到_commonModeItems数组</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rls);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rls&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建source0和source1的集合</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) &#123;</div><div class="line">	    rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	    rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	    rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);</div><div class="line">	&#125;</div><div class="line">	if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</div><div class="line">	</div><div class="line">		//按source类型添加到不同的集合中</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        CFSetAddValue(rlm-&gt;_sources0, rls);</div><div class="line">	    &#125; else if (1 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        CFSetAddValue(rlm-&gt;_sources1, rls);</div><div class="line">		__CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</div><div class="line">		</div><div class="line">		//如果是source1 还需要把source1对应的port添加到mach port的列表中</div><div class="line">		if (CFPORT_NULL != src_port) &#123;</div><div class="line">		    CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</div><div class="line">		    __CFPortSetInsert(src_port, rlm-&gt;_portSet);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    __CFRunLoopSourceLock(rls);</div><div class="line">	    if (NULL == rls-&gt;_runLoops) &#123;</div><div class="line">	        rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); // sources retain run loops!</div><div class="line">	    &#125;</div><div class="line">	    CFBagAddValue(rls-&gt;_runLoops, rl);</div><div class="line">	    __CFRunLoopSourceUnlock(rls);</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        if (NULL != rls-&gt;_context.version0.schedule) &#123;</div><div class="line">	            doVer0Callout = true;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">	rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);	/* CALLOUT */</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理source0</div><div class="line">static Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFTypeRef sources = NULL;</div><div class="line">    Boolean sourceHandled = false;</div><div class="line"></div><div class="line">    /* Fire the version 0 sources */</div><div class="line">    </div><div class="line">    //获取当前mode的source0集合</div><div class="line">    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) &#123;</div><div class="line">	CFSetApplyFunction(rlm-&gt;_sources0, (__CFRunLoopCollectSources0), &amp;sources);</div><div class="line">    &#125;</div><div class="line">    if (NULL != sources) &#123;</div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	// sources is either a single (retained) CFRunLoopSourceRef or an array of (retained) CFRunLoopSourceRef</div><div class="line">	</div><div class="line">	//如果是单个事件</div><div class="line">	if (CFGetTypeID(sources) == CFRunLoopSourceGetTypeID()) &#123;</div><div class="line">	    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;</div><div class="line">	    __CFRunLoopSourceLock(rls);</div><div class="line">	    </div><div class="line">	    //这里在处理完这个source之后，会把这个source标记为不再处理！！！！后面demo里有应用。</div><div class="line">            if (__CFRunLoopSourceIsSignaled(rls)) &#123;</div><div class="line">	        __CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">	        if (__CFIsValid(rls)) &#123;</div><div class="line">	            __CFRunLoopSourceUnlock(rls);</div><div class="line"></div><div class="line">                    //调用source0对应的回调</div><div class="line">                    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</div><div class="line">	            CHECK_FOR_FORK();</div><div class="line">	            sourceHandled = true;</div><div class="line">	        &#125; else &#123;</div><div class="line">	            __CFRunLoopSourceUnlock(rls);</div><div class="line">	        &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                __CFRunLoopSourceUnlock(rls);</div><div class="line">            &#125;</div><div class="line">	&#125; else &#123;</div><div class="line">	</div><div class="line">	//如果是一个事件列表</div><div class="line">	    CFIndex cnt = CFArrayGetCount((CFArrayRef)sources);</div><div class="line">	    CFArraySortValues((CFMutableArrayRef)sources, CFRangeMake(0, cnt), (__CFRunLoopSourceComparator), NULL);</div><div class="line">	    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		CFRunLoopSourceRef rls = (CFRunLoopSourceRef)CFArrayGetValueAtIndex((CFArrayRef)sources, idx);</div><div class="line">		__CFRunLoopSourceLock(rls);</div><div class="line">                if (__CFRunLoopSourceIsSignaled(rls)) &#123;</div><div class="line">		    __CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">		    if (__CFIsValid(rls)) &#123;</div><div class="line">		        __CFRunLoopSourceUnlock(rls);</div><div class="line">                        </div><div class="line">                        //调用source0对应的回调                       __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</div><div class="line">		        CHECK_FOR_FORK();</div><div class="line">		        sourceHandled = true;</div><div class="line">		    &#125; else &#123;</div><div class="line">		        __CFRunLoopSourceUnlock(rls);</div><div class="line">		    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    __CFRunLoopSourceUnlock(rls);</div><div class="line">                &#125;</div><div class="line">		if (stopAfterHandle &amp;&amp; sourceHandled) &#123;</div><div class="line">		    break;</div><div class="line">		&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	CFRelease(sources);</div><div class="line">	__CFRunLoopLock(rl);</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">    &#125;</div><div class="line">    return sourceHandled;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理source1</div><div class="line">static Boolean __CFRunLoopDoSource1(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">                                    , mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply</div><div class="line">#endif</div><div class="line">                                    ) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    Boolean sourceHandled = false;</div><div class="line"></div><div class="line">    /* Fire a version 1 source */</div><div class="line">    CFRetain(rls);</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    __CFRunLoopSourceLock(rls);</div><div class="line">    if (__CFIsValid(rls)) &#123;</div><div class="line">	__CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">	__CFRunLoopSourceUnlock(rls);</div><div class="line">        __CFRunLoopDebugInfoForRunLoopSource(rls);</div><div class="line">        </div><div class="line">        //调用source1对应的回调</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls-&gt;_context.version1.perform,</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            msg, size, reply,</div><div class="line">#endif</div><div class="line">            rls-&gt;_context.version1.info);</div><div class="line">	CHECK_FOR_FORK();</div><div class="line">	sourceHandled = true;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (_LogCFRunLoop) &#123; CFLog(kCFLogLevelDebug, CFSTR(&quot;%p (%s) __CFRunLoopDoSource1 rls %p is invalid&quot;), CFRunLoopGetCurrent(), *_CFGetProgname(), rls); &#125;</div><div class="line">	__CFRunLoopSourceUnlock(rls);</div><div class="line">    &#125;</div><div class="line">    CFRelease(rls);</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line">    return sourceHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="source总结"><a href="#source总结" class="headerlink" title="source总结"></a>source总结</h5><p>通过对比source0和source1的处理函数发现，source0有2种情况，单个事件和事件列表，而source1只有单个事件的处理，个人理解是因为source1的事件是即时处理的，因为source1可以唤醒runloop,只要有source1事件runloop就会去处理，所有不存在处理事件列表的情况，而source0有可能只是标记为待处理而没有手动唤醒runloop,当标记为待处理source0事件后，只会被添加到mode的source0集合中，在runloop被唤醒后统一处理。</p>
<h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (isnan(interval)) &#123;</div><div class="line">        CRSetCrashLogMessage(&quot;NaN was used as an interval for a CFRunLoopTimer&quot;);</div><div class="line">        HALT;</div><div class="line">    &#125;</div><div class="line">    CFRunLoopTimerRef memory;</div><div class="line">    UInt32 size;</div><div class="line">    size = sizeof(struct __CFRunLoopTimer) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopTimerRef)_CFRuntimeCreateInstance(allocator, CFRunLoopTimerGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopTimerUnsetFiring(memory);</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_runLoop = NULL;</div><div class="line">    memory-&gt;_rlModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    if (interval &lt; 0.0) interval = 0.0;</div><div class="line">    memory-&gt;_interval = interval;</div><div class="line">    memory-&gt;_tolerance = 0.0;</div><div class="line">    </div><div class="line">    //fireDate 首次触发的绝对时间</div><div class="line">    if (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;</div><div class="line">    memory-&gt;_nextFireDate = fireDate;</div><div class="line">    memory-&gt;_fireTSR = 0ULL;</div><div class="line">    </div><div class="line">    //获取mach内核和CF内核的绝对时间</div><div class="line">    uint64_t now2 = mach_absolute_time();</div><div class="line">    CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();</div><div class="line">    </div><div class="line">    //_fireTSR为本次应触发的绝对时间点</div><div class="line">    if (fireDate &lt; now1) &#123;</div><div class="line">		memory-&gt;_fireTSR = now2;</div><div class="line">    &#125; else if (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) &#123;</div><div class="line">		memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</div><div class="line">    &#125; else &#123;</div><div class="line">		memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    memory-&gt;_callout = callout;</div><div class="line">    if (NULL != context) &#123;</div><div class="line">	if (context-&gt;retain) &#123;</div><div class="line">	    memory-&gt;_context.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">	&#125; else &#123;</div><div class="line">	    memory-&gt;_context.info = context-&gt;info;</div><div class="line">	&#125;</div><div class="line">	memory-&gt;_context.retain = context-&gt;retain;</div><div class="line">	memory-&gt;_context.release = context-&gt;release;</div><div class="line">	memory-&gt;_context.copyDescription = context-&gt;copyDescription;</div><div class="line">    &#125; else &#123;</div><div class="line">	memory-&gt;_context.info = 0;</div><div class="line">	memory-&gt;_context.retain = 0;</div><div class="line">	memory-&gt;_context.release = 0;</div><div class="line">	memory-&gt;_context.copyDescription = 0;</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    //如果是common mode直接加到_commonModeItems</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rlt);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rlt&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建timers的数组</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm) &#123;</div><div class="line">            if (NULL == rlm-&gt;_timers) &#123;</div><div class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</div><div class="line">                cb.equal = NULL;</div><div class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</div><div class="line">            &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//判断timer是否被添加到当前mode</div><div class="line">	if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</div><div class="line">            __CFRunLoopTimerLock(rlt);</div><div class="line">            if (NULL == rlt-&gt;_runLoop) &#123;</div><div class="line">		rlt-&gt;_runLoop = rl;</div><div class="line">  	    &#125; else if (rl != rlt-&gt;_runLoop) &#123;</div><div class="line">                __CFRunLoopTimerUnlock(rlt);</div><div class="line">	        __CFRunLoopModeUnlock(rlm);</div><div class="line">                __CFRunLoopUnlock(rl);</div><div class="line">		return;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    //timer将当前mode标记为已添加</div><div class="line">  	    CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            __CFRunLoopTimerFireTSRLock();</div><div class="line">            </div><div class="line">            //添加timer到mode</div><div class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</div><div class="line">            __CFRunLoopTimerFireTSRUnlock();</div><div class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</div><div class="line">                // Normally we don&apos;t do this on behalf of clients, but for</div><div class="line">                // backwards compatibility due to the change in timer handling...</div><div class="line">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</div><div class="line">            &#125;</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重新排列这个mode中的所有timer触发时刻</div><div class="line">static void __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) &#123;</div><div class="line">    if (!rlt) return;</div><div class="line">    CFMutableArrayRef timerArray = rlm-&gt;_timers;</div><div class="line">    if (!timerArray) return;</div><div class="line">    Boolean found = false;</div><div class="line">    // If we know in advance that the timer is not in the array (just being added now) then we can skip this search</div><div class="line">    if (isInArray) &#123;</div><div class="line">        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(0, CFArrayGetCount(timerArray)), rlt);</div><div class="line">        if (kCFNotFound != idx) &#123;</div><div class="line">            CFRetain(rlt);</div><div class="line">            CFArrayRemoveValueAtIndex(timerArray, idx);</div><div class="line">            found = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!found &amp;&amp; isInArray) return;</div><div class="line">    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);</div><div class="line">    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);</div><div class="line">    __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop);</div><div class="line">    if (isInArray) CFRelease(rlt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回timer需要插入的索引</div><div class="line">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) &#123;</div><div class="line">    CFIndex cnt = CFArrayGetCount(array);</div><div class="line">    if (cnt &lt;= 0) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //timer大于256 如果最后一个item的fireTSR小于待插入的timer，直接插入到最后一个位置否则如果第一个item的fireTSR大于带插入的timer,直接插入第一个位置。</div><div class="line">    if (256 &lt; cnt) &#123;</div><div class="line">        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);</div><div class="line">        if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</div><div class="line">            return cnt;</div><div class="line">        &#125;</div><div class="line">        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);</div><div class="line">        if (rlt-&gt;_fireTSR &lt; item-&gt;_fireTSR) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//二分查找一个合适的位置。</div><div class="line">    CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</div><div class="line">    CFIndex idx = 0;</div><div class="line">    Boolean lastTestLEQ;</div><div class="line">    do &#123;</div><div class="line">        add = add / 2;</div><div class="line">	lastTestLEQ = false;</div><div class="line">        CFIndex testIdx = idx + add;</div><div class="line">        if (testIdx &lt; cnt) &#123;</div><div class="line">            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);</div><div class="line">            if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</div><div class="line">                idx = testIdx;</div><div class="line">		lastTestLEQ = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; while (0 &lt; add);</div><div class="line"></div><div class="line">    return lastTestLEQ ? idx + 1 : idx;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) &#123;  </div><div class="line">  </div><div class="line">    uint64_t nextHardDeadline = UINT64_MAX;//最晚的时间点</div><div class="line">    uint64_t nextSoftDeadline = UINT64_MAX;//应该触发的时间点</div><div class="line"></div><div class="line">    if (rlm-&gt;_timers) &#123;</div><div class="line">        // Look at the list of timers. We will calculate two TSR values; the next soft and next hard deadline.</div><div class="line">        // The next soft deadline is the first time we can fire any timer. This is the fire date of the first timer in our sorted list of timers.</div><div class="line">        // The next hard deadline is the last time at which we can fire the timer before we&apos;ve moved out of the allowable tolerance of the timers in our list.</div><div class="line">        for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers , idx);</div><div class="line">            // discount timers currently firing</div><div class="line">            if (__CFRunLoopTimerIsFiring(t)) continue;</div><div class="line">            </div><div class="line">            int32_t err = CHECKINT_NO_ERROR;</div><div class="line">            </div><div class="line">            //SoftDeadline是理应触发的时间</div><div class="line">            uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR;</div><div class="line">            </div><div class="line">            //HardDeadline是理应触发的时间加上tolerance（即最晚触发时间）</div><div class="line">            uint64_t oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err);</div><div class="line">            </div><div class="line">            if (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX;</div><div class="line">            </div><div class="line">            // We can stop searching if the soft deadline for this timer exceeds the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines.</div><div class="line">            </div><div class="line">            //通过这几行代码对deadline进行修正，保证前边的长tolerance的timer不会影响后面的timer的触发</div><div class="line">            </div><div class="line">            //应触发的时间点 &gt; 下次最晚触发时间点 直接退出</div><div class="line">            if (oneTimerSoftDeadline &gt; nextHardDeadline) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //应触发的时间点 &lt; 下次最晚触发时间点 </div><div class="line">            if (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123;</div><div class="line">                nextSoftDeadline = oneTimerSoftDeadline;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //最晚触发时间点 &lt; 下次最晚触发时间点</div><div class="line">            if (oneTimerHardDeadline &lt; nextHardDeadline) &#123;</div><div class="line">                nextHardDeadline = oneTimerHardDeadline;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123;</div><div class="line">            if (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) &#123;</div><div class="line">                CFRUNLOOP_NEXT_TIMER_ARMED((unsigned long)(nextSoftDeadline - mach_absolute_time()));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">            // We&apos;re going to hand off the range of allowable timer fire date to dispatch and let it fire when appropriate for the system.</div><div class="line">            uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline);</div><div class="line">            dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline);</div><div class="line">            </div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line"></div><div class="line">				//对于有leeway的情况（有tolerance的情况），只采用_dispatch_source_set_runloop_timer_4CF的方法</div><div class="line">            if (leeway &gt; 0) &#123;</div><div class="line">                // Only use the dispatch timer if we have any leeway</div><div class="line">                // &lt;rdar://problem/14447675&gt;</div><div class="line">                </div><div class="line">                // Cancel the mk timer</div><div class="line">                if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</div><div class="line">                    AbsoluteTime dummy;</div><div class="line">                    mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</div><div class="line">                    rlm-&gt;_mkTimerArmed = false;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // Arm the dispatch timer</div><div class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</div><div class="line">                rlm-&gt;_dispatchTimerArmed = true;</div><div class="line">            &#125; else &#123;</div><div class="line">            </div><div class="line">            // 对于leeway为0的情况（无tolerance的情况）,采用mk_timer的方式</div><div class="line">                // Cancel the dispatch timer</div><div class="line">                if (rlm-&gt;_dispatchTimerArmed) &#123;</div><div class="line">                    // Cancel the dispatch timer</div><div class="line">                    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888);</div><div class="line">                    rlm-&gt;_dispatchTimerArmed = false;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // Arm the mk timer</div><div class="line">                if (rlm-&gt;_timerPort) &#123;</div><div class="line">                    mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));</div><div class="line">                    rlm-&gt;_mkTimerArmed = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">#else</div><div class="line">            _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</div><div class="line">#endif</div><div class="line">#else</div><div class="line">            if (rlm-&gt;_timerPort) &#123;</div><div class="line">                mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125; else if (nextSoftDeadline == UINT64_MAX) &#123;</div><div class="line">            // Disarm the timers - there is no timer scheduled</div><div class="line">            // 移除timer</div><div class="line">            if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</div><div class="line">                AbsoluteTime dummy;</div><div class="line">                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</div><div class="line">                rlm-&gt;_mkTimerArmed = false;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">            if (rlm-&gt;_dispatchTimerArmed) &#123;</div><div class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333);</div><div class="line">                rlm-&gt;_dispatchTimerArmed = false;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    rlm-&gt;_timerHardDeadline = nextHardDeadline;</div><div class="line">    rlm-&gt;_timerSoftDeadline = nextSoftDeadline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理timer</div><div class="line">// mode and rl are locked on entry and exit</div><div class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;	/* DOES CALLOUT */</div><div class="line">    Boolean timerHandled = false;</div><div class="line">    uint64_t oldFireTSR = 0;</div><div class="line"></div><div class="line">    /* Fire a timer */</div><div class="line">    CFRetain(rlt);</div><div class="line">    __CFRunLoopTimerLock(rlt);</div><div class="line">	</div><div class="line">	//一堆判断条件</div><div class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) &#123;</div><div class="line">        void *context_info = NULL;</div><div class="line">        void (*context_release)(const void *) = NULL;</div><div class="line">        if (rlt-&gt;_context.retain) &#123;</div><div class="line">            context_info = (void *)rlt-&gt;_context.retain(rlt-&gt;_context.info);</div><div class="line">            context_release = rlt-&gt;_context.release;</div><div class="line">        &#125; else &#123;</div><div class="line">            context_info = rlt-&gt;_context.info;</div><div class="line">        &#125;</div><div class="line">        Boolean doInvalidate = (0.0 == rlt-&gt;_interval);</div><div class="line">	__CFRunLoopTimerSetFiring(rlt);</div><div class="line">        // Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer.</div><div class="line">        </div><div class="line">        //重置应触发时间和最晚触发时间</div><div class="line">        rlm-&gt;_timerSoftDeadline = UINT64_MAX;</div><div class="line">        rlm-&gt;_timerHardDeadline = UINT64_MAX;</div><div class="line">        __CFRunLoopTimerUnlock(rlt);</div><div class="line">	__CFRunLoopTimerFireTSRLock();</div><div class="line">	oldFireTSR = rlt-&gt;_fireTSR;</div><div class="line">	__CFRunLoopTimerFireTSRUnlock();</div><div class="line"></div><div class="line">        __CFArmNextTimerInMode(rlm, rl);</div><div class="line"></div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	</div><div class="line">	//处理timer的回调</div><div class="line">	__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</div><div class="line">	CHECK_FOR_FORK();</div><div class="line">        if (doInvalidate) &#123;</div><div class="line">            CFRunLoopTimerInvalidate(rlt);      /* DOES CALLOUT */</div><div class="line">        &#125;</div><div class="line">        if (context_release) &#123;</div><div class="line">            context_release(context_info);</div><div class="line">        &#125;</div><div class="line">	__CFRunLoopLock(rl);</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">        __CFRunLoopTimerLock(rlt);</div><div class="line">        </div><div class="line">    //timer处理成功的标记</div><div class="line">	timerHandled = true;</div><div class="line">	__CFRunLoopTimerUnsetFiring(rlt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //本次timer处理成功了 来更新一下下次的触发时间</div><div class="line">    if (__CFIsValid(rlt) &amp;&amp; timerHandled) &#123;</div><div class="line">        /* This is just a little bit tricky: we want to support calling</div><div class="line">         * CFRunLoopTimerSetNextFireDate() from within the callout and</div><div class="line">         * honor that new time here if it is a later date, otherwise</div><div class="line">         * it is completely ignored. */</div><div class="line"></div><div class="line">         //一下次的触发时间已经设置了 而且比上次的时间大 说明设置的没有问题，直接更新。</div><div class="line">        if (oldFireTSR &lt; rlt-&gt;_fireTSR) &#123;</div><div class="line">            /* Next fire TSR was set, and set to a date after the previous</div><div class="line">            * fire date, so we honor it. */</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            // The timer was adjusted and repositioned, during the</div><div class="line">            // callout, but if it was still the min timer, it was</div><div class="line">            // skipped because it was firing.  Need to redo the</div><div class="line">            // min timer calculation in case rlt should now be that</div><div class="line">            // timer instead of whatever was chosen.</div><div class="line">            </div><div class="line">            //这个函数就是更新下次触发时间的</div><div class="line">            __CFArmNextTimerInMode(rlm, rl);</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">        //没有设置下一次的触发时间，进行设置，然后更新列表</div><div class="line">	    uint64_t nextFireTSR = 0LL;</div><div class="line">            uint64_t intervalTSR = 0LL;</div><div class="line">            if (rlt-&gt;_interval &lt;= 0.0) &#123;</div><div class="line">            &#125; else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) &#123;</div><div class="line">        	intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</div><div class="line">            &#125; else &#123;</div><div class="line">        	intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval);</div><div class="line">            &#125;</div><div class="line">            if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) &#123;</div><div class="line">                nextFireTSR = LLONG_MAX;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (intervalTSR == 0) &#123;</div><div class="line">                    // 15304159: Make sure we don&apos;t accidentally loop forever here</div><div class="line">                    CRSetCrashLogMessage(&quot;A CFRunLoopTimer with an interval of 0 is set to repeat&quot;);</div><div class="line">                    HALT;</div><div class="line">                &#125;</div><div class="line">                uint64_t currentTSR = mach_absolute_time();</div><div class="line">                nextFireTSR = oldFireTSR;</div><div class="line">                while (nextFireTSR &lt;= currentTSR) &#123;</div><div class="line">                    nextFireTSR += intervalTSR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            CFRunLoopRef rlt_rl = rlt-&gt;_runLoop;</div><div class="line">            if (rlt_rl) &#123;</div><div class="line">                CFRetain(rlt_rl);</div><div class="line">		CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);</div><div class="line">		STACK_BUFFER_DECL(CFTypeRef, modes, cnt);</div><div class="line">		CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes);</div><div class="line">		// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up</div><div class="line">		// towards the run loop from a source, the timer has to be</div><div class="line">		// unlocked, which means we have to protect from object</div><div class="line">		// invalidation, although that&apos;s somewhat expensive.</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFRetain(modes[idx]);</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerUnlock(rlt);</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFStringRef name = (CFStringRef)modes[idx];</div><div class="line">		    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false);</div><div class="line">		    CFRelease(name);</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerFireTSRLock();</div><div class="line">		</div><div class="line">		//上面算了一堆就是计算一个正确的nextFireTSR，到这里已经拿到正确的值了，可以赋值。</div><div class="line">		rlt-&gt;_fireTSR = nextFireTSR;</div><div class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];</div><div class="line">		    if (rlm) &#123;</div><div class="line">		    </div><div class="line">		    //更新时间触发的列表</div><div class="line">                        __CFRepositionTimerInMode(rlm, rlt, true);</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerFireTSRUnlock();</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);</div><div class="line">		&#125;</div><div class="line">		CFRelease(rlt_rl);</div><div class="line">	    &#125; else &#123;</div><div class="line">	    </div><div class="line">	    //timer没有加到一个runloop里面。这个timer应该不会被触发。下面也没有调整下次触发时间的操作。。。</div><div class="line">		__CFRunLoopTimerUnlock(rlt);</div><div class="line">		__CFRunLoopTimerFireTSRLock();</div><div class="line">		rlt-&gt;_fireTSR = nextFireTSR;</div><div class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</div><div class="line">		__CFRunLoopTimerFireTSRUnlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        __CFRunLoopTimerUnlock(rlt);</div><div class="line">    &#125;</div><div class="line">    CFRelease(rlt);</div><div class="line">    return timerHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="timer总结"><a href="#timer总结" class="headerlink" title="timer总结"></a>timer总结</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop008.png" alt=""></p>
<ul>
<li>对于重复的NSTimer，其多次触发的时刻不是一开始算好的，而是timer触发后计算的。但是计算时参考的是上次应当触发的时间_fireTSR，因此计算出的下次触发的时刻不会有误差。</li>
<li>设置了tolerance的NSTimer，对于iOS和MacOS系统，实质上会采用GCD timer的形式注册到内核中，GCD timer触发后，再由RunLoop处理其回调逻辑。对于没有设置tolerance的timer，则是用mk_timer的形式注册。</li>
<li>RunLoopMode中timer的排序是按照_fireTSR，也就是应当触发的时间排序的。</li>
</ul>
<h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">//创建observer</div><div class="line"></div><div class="line">CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopObserverRef memory;</div><div class="line">    UInt32 size;</div><div class="line">    size = sizeof(struct __CFRunLoopObserver) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopObserverRef)_CFRuntimeCreateInstance(allocator, CFRunLoopObserverGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopObserverUnsetFiring(memory);</div><div class="line">    if (repeats) &#123;</div><div class="line">	__CFRunLoopObserverSetRepeats(memory);</div><div class="line">    &#125; else &#123;</div><div class="line">	__CFRunLoopObserverUnsetRepeats(memory);</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_runLoop = NULL;</div><div class="line">    memory-&gt;_rlCount = 0;</div><div class="line">    memory-&gt;_activities = activities;</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    memory-&gt;_callout = callout;</div><div class="line">    if (context) &#123;</div><div class="line">	if (context-&gt;retain) &#123;</div><div class="line">	    memory-&gt;_context.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">	&#125; else &#123;</div><div class="line">	    memory-&gt;_context.info = context-&gt;info;</div><div class="line">	&#125;</div><div class="line">	memory-&gt;_context.retain = context-&gt;retain;</div><div class="line">	memory-&gt;_context.release = context-&gt;release;</div><div class="line">	memory-&gt;_context.copyDescription = context-&gt;copyDescription;</div><div class="line">    &#125; else &#123;</div><div class="line">	memory-&gt;_context.info = 0;</div><div class="line">	memory-&gt;_context.retain = 0;</div><div class="line">	memory-&gt;_context.release = 0;</div><div class="line">	memory-&gt;_context.copyDescription = 0;</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//给mode添加observer</div><div class="line"></div><div class="line">void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</div><div class="line"></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    </div><div class="line">    //如果是common mode直接加到_commonModeItems</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rlo);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rlo&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建_observers数组</div><div class="line">	rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123;</div><div class="line">	    rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//判断是否已添加</div><div class="line">	if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123;</div><div class="line">            Boolean inserted = false;</div><div class="line">            for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123;</div><div class="line">                CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">                </div><div class="line">                //有一个排序，只有order大于已添加的observer 才会被添加到数组中</div><div class="line">                if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123;</div><div class="line">                    CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);</div><div class="line">                    inserted = true;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //添加失败直接插到第一个位置</div><div class="line">            if (!inserted) &#123;</div><div class="line">	        CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);</div><div class="line">            &#125;</div><div class="line">	    rlm-&gt;_observerMask |= rlo-&gt;_activities;</div><div class="line">	    __CFRunLoopObserverSchedule(rlo, rl, rlm);</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line"></div><div class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0;</div><div class="line">    if (cnt &lt; 1) return;</div><div class="line"></div><div class="line">    /* Fire the observers */</div><div class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1);</div><div class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * sizeof(CFRunLoopObserverRef));</div><div class="line">    CFIndex obs_cnt = 0;</div><div class="line">    </div><div class="line">    //将列表中 活动 &amp;&amp; 可用 &amp;&amp; 未处理 的observer添加到一个临时的数组中</div><div class="line">    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">        if (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123;</div><div class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    for (CFIndex idx = 0; idx &lt; obs_cnt; idx++) &#123;</div><div class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</div><div class="line">        __CFRunLoopObserverLock(rlo);</div><div class="line">        if (__CFIsValid(rlo)) &#123;</div><div class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</div><div class="line">            __CFRunLoopObserverSetFiring(rlo);</div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">            </div><div class="line">            //调用observer的回调</div><div class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info);</div><div class="line">            if (doInvalidate) &#123;</div><div class="line">                CFRunLoopObserverInvalidate(rlo);</div><div class="line">            &#125;</div><div class="line">            __CFRunLoopObserverUnsetFiring(rlo);</div><div class="line">        &#125; else &#123;</div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">        &#125;</div><div class="line">        CFRelease(rlo);</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">    if (collectedObservers != buffer) free(collectedObservers);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//给runloop添加一个block</div><div class="line"></div><div class="line">void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    </div><div class="line">    //保证mode存在</div><div class="line">    </div><div class="line">    if (CFStringGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">	mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure mode exists</div><div class="line">        CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true);</div><div class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">    &#125; else if (CFArrayGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">        CFIndex cnt = CFArrayGetCount((CFArrayRef)mode);</div><div class="line">	const void **values = (const void **)malloc(sizeof(const void *) * cnt);</div><div class="line">        CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values);</div><div class="line">	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure modes exist</div><div class="line">	for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</div><div class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	&#125;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">	free(values);</div><div class="line">    &#125; else if (CFSetGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">        CFIndex cnt = CFSetGetCount((CFSetRef)mode);</div><div class="line">	const void **values = (const void **)malloc(sizeof(const void *) * cnt);</div><div class="line">        CFSetGetValues((CFSetRef)mode, values);</div><div class="line">	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure modes exist</div><div class="line">	for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</div><div class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	&#125;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">	free(values);</div><div class="line">    &#125; else &#123;</div><div class="line">	mode = NULL;</div><div class="line">    &#125;</div><div class="line">    block = Block_copy(block);</div><div class="line">    </div><div class="line">    //如果mode或者block为空 直接返回</div><div class="line">    if (!mode || !block) &#123;</div><div class="line">	if (mode) CFRelease(mode);</div><div class="line">	if (block) Block_release(block);</div><div class="line">	return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //将block添加到列表中</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    struct _block_item *new_item = (struct _block_item *)malloc(sizeof(struct _block_item));</div><div class="line">    new_item-&gt;_next = NULL;</div><div class="line">    new_item-&gt;_mode = mode;</div><div class="line">    new_item-&gt;_block = block;</div><div class="line">    if (!rl-&gt;_blocks_tail) &#123;</div><div class="line">	rl-&gt;_blocks_head = new_item;</div><div class="line">    &#125; else &#123;</div><div class="line">	rl-&gt;_blocks_tail-&gt;_next = new_item;</div><div class="line">    &#125;</div><div class="line">    rl-&gt;_blocks_tail = new_item;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理block</div><div class="line"></div><div class="line">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</div><div class="line">    if (!rl-&gt;_blocks_head) return false;</div><div class="line">    if (!rlm || !rlm-&gt;_name) return false;</div><div class="line">    Boolean did = false;</div><div class="line">    struct _block_item *head = rl-&gt;_blocks_head;</div><div class="line">    struct _block_item *tail = rl-&gt;_blocks_tail;</div><div class="line">    rl-&gt;_blocks_head = NULL;</div><div class="line">    rl-&gt;_blocks_tail = NULL;</div><div class="line">    CFSetRef commonModes = rl-&gt;_commonModes;</div><div class="line">    CFStringRef curMode = rlm-&gt;_name;</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    struct _block_item *prev = NULL;</div><div class="line">    struct _block_item *item = head;</div><div class="line">    </div><div class="line">    //遍历block列表</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">	Boolean doit = false;</div><div class="line">	</div><div class="line">	//当前mode是block所属的mode一样 || 当前mode是common mode且commons中包含了当前mode</div><div class="line">	if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">	    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">        &#125; else &#123;</div><div class="line">	    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">	&#125;</div><div class="line">	if (!doit) prev = curr;</div><div class="line">	if (doit) &#123;</div><div class="line">	    if (prev) prev-&gt;_next = item;</div><div class="line">	    if (curr == head) head = item;</div><div class="line">	    if (curr == tail) tail = prev;</div><div class="line">	    void (^block)(void) = curr-&gt;_block;</div><div class="line">            CFRelease(curr-&gt;_mode);</div><div class="line">            free(curr);</div><div class="line">	    if (doit) &#123;</div><div class="line">	    </div><div class="line">		    //调用block</div><div class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line">	        did = true;</div><div class="line">	    &#125;</div><div class="line">            Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line">    if (head) &#123;</div><div class="line">	tail-&gt;_next = rl-&gt;_blocks_head;</div><div class="line">	rl-&gt;_blocks_head = head;</div><div class="line">        if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;</div><div class="line">    &#125;</div><div class="line">    return did;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="block总结"><a href="#block总结" class="headerlink" title="block总结"></a>block总结</h5><ul>
<li>可以直接给runloop添加block.添加成功后，block会在下一次runloop运行时被触发。</li>
<li>block不能唤醒runloop,只会被添加到链表中，等待下一次runloop被唤醒后才会被执行。</li>
</ul>
<h3 id="Runloop实践"><a href="#Runloop实践" class="headerlink" title="Runloop实践"></a>Runloop实践</h3><h4 id="查看Main-Runloop的结构"><a href="#查看Main-Runloop的结构" class="headerlink" title="查看Main Runloop的结构"></a>查看Main Runloop的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSRunLoop *runloop = [NSRunLoop mainRunLoop];</div><div class="line">NSLog(@&quot;runloop = %@&quot;,runloop);</div></pre></td></tr></table></figure>
<h5 id="具体结构如下："><a href="#具体结构如下：" class="headerlink" title="具体结构如下："></a>具体结构如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">&lt;CFRunLoop 0x60c0001e7800 [0x10805cc80]&gt;&#123;</div><div class="line"></div><div class="line">//唤醒端口 &amp;&amp; 当前状态 &amp;&amp; 是否忽略唤醒</div><div class="line">wakeup port = 0x1803, stopped = false, ignoreWakeUps = false, </div><div class="line"></div><div class="line">//current mode</div><div class="line">current mode = kCFRunLoopDefaultMode,</div><div class="line"></div><div class="line">//common mode 包含2个子mode</div><div class="line">common modes = &lt;CFBasicHash 0x60c00004db90 [0x10805cc80]&gt;&#123;type = mutable set, count = 2,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFString 0x1093cce88 [0x10805cc80]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</div><div class="line">	2 : &lt;CFString 0x108032818 [0x10805cc80]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line">//common mode 的items(包括 timer &amp;&amp; source &amp;&amp; observer)</div><div class="line">//observer activities (0x20 == kCFRunLoopBeforeWaiting)  (0x1 == kCFRunLoopEntry) (0xa0 ==  kCFRunLoopBeforeWaiting || kCFRunLoopExit)</div><div class="line"></div><div class="line">common mode items = &lt;CFBasicHash 0x60c00004df50 [0x10805cc80]&gt;&#123;type = mutable set, count = 13,</div><div class="line">entries =&gt;</div><div class="line"></div><div class="line"></div><div class="line">	//source0 系统事件</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line"></div><div class="line">	//处理手势的通知</div><div class="line">	1 : &lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;</div><div class="line"></div><div class="line">	//autoreleasepool相关通知</div><div class="line">	2 : &lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;0x7fa8a2802048&gt;</div><div class="line">)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;0x7fa8a2802048&gt;</div><div class="line">)&#125;&#125;</div><div class="line"></div><div class="line">	//mach port source</div><div class="line">	4 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line"></div><div class="line">	//处理事件队列的source</div><div class="line">	6 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line"></div><div class="line">	//处理动画事务的通知</div><div class="line">	16 : &lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;</div><div class="line"></div><div class="line">	//mach port source </div><div class="line">	17 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line"></div><div class="line">	//CA动画提交前的通知</div><div class="line">	18 : &lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;</div><div class="line"></div><div class="line">	//处理系统事件 source0</div><div class="line">	19 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">	</div><div class="line">	//处理系统事件 source1</div><div class="line">	20 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line"></div><div class="line">	//CA动画提交后的通知</div><div class="line">	21 : &lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;</div><div class="line"></div><div class="line">	//Front Board Services(前台服务)</div><div class="line">	22 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line"></div><div class="line">modes = &lt;CFBasicHash 0x60c00004dbc0 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line"></div><div class="line"></div><div class="line">	//UITrackingRunLoopMode 的 items</div><div class="line"></div><div class="line">	2 : &lt;CFRunLoopMode 0x60c0001869a0 [0x10805cc80]&gt;&#123;name = UITrackingRunLoopMode, port set = 0x1c03, queue = 0x60c000141e40, source = 0x60c000186a70 (not fired), timer port = 0x5403, </div><div class="line"></div><div class="line">	//source0</div><div class="line"></div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004dfb0 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line">	4 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">	5 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line">	//source1</div><div class="line"></div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004dfe0 [0x10805cc80]&gt;&#123;type = mutable set, count = 3,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line">	1 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	//observer</div><div class="line"></div><div class="line">	observers = (</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;</div><div class="line">),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290423333420) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//GSEventReceiveRunLoopMode 接受系统事件的内部 Mode</div><div class="line">	3 : &lt;CFRunLoopMode 0x60c000186b40 [0x10805cc80]&gt;&#123;name = GSEventReceiveRunLoopMode, port set = 0x5203, queue = 0x60c000141ef0, source = 0x60c000186c10 (not fired), timer port = 0x5103, </div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004e070 [0x10805cc80]&gt;&#123;type = mutable set, count = 1,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004e0a0 [0x10805cc80]&gt;&#123;type = mutable set, count = 1,</div><div class="line">entries =&gt;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167bc0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	observers = (null),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290424620943) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//kCFRunLoopDefaultMode</div><div class="line"></div><div class="line">	4 : &lt;CFRunLoopMode 0x60c000186660 [0x10805cc80]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x2503, queue = 0x60c000141ce0, source = 0x60c000186730 (not fired), timer port = 0x2303, </div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004e010 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line">	4 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">	5 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004e040 [0x10805cc80]&gt;&#123;type = mutable set, count = 3,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line">	1 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	observers = (</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;</div><div class="line">),</div><div class="line">	timers = &lt;CFArray 0x6080000aa5c0 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;CFRunLoopTimer 0x600000168ac0 [0x10805cc80]&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 558352446 (1.35804296 @ 30291784384812), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x106e7e849 / 0x1086fb31b) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/UIKit.framework/UIKit), context = &lt;CFRunLoopTimer context 0x600000076700&gt;&#125;</div><div class="line">)&#125;,</div><div class="line">	currently 558352445 (30290424667708) / soft deadline in: 1.35971708 sec (@ 30291784384812) / hard deadline in: 1.35971705 sec (@ 30291784384812)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//kCFRunLoopCommonModes</div><div class="line">	5 : &lt;CFRunLoopMode 0x60c000186e80 [0x10805cc80]&gt;&#123;name = kCFRunLoopCommonModes, port set = 0x420b, queue = 0x60c000142520, source = 0x60c000186db0 (not fired), timer port = 0x350b, </div><div class="line">	sources0 = (null),</div><div class="line">	sources1 = (null),</div><div class="line">	observers = (null),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290426387800) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer"><a href="#给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer" class="headerlink" title="给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)"></a>给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)</h4><p>为了方便观察添加是否成功，我们不在主线程的runloop中添加，自定义一个新的线程。</p>
<h5 id="添加Custom-Input-Source注意事项"><a href="#添加Custom-Input-Source注意事项" class="headerlink" title="添加Custom Input Source注意事项"></a>添加Custom Input Source注意事项</h5><ul>
<li>custom input source 默认状态为不处理，需要手动唤醒，手动唤醒需要先标记为待处理状态，每次runloop处理完后状态会被置回不处理。</li>
<li>在子线程添加source需要在runloop run的代码之前添加，因为run后该线程会马上休眠（当前runloop中没有能唤醒自己的source）,不再这行run后面的代码。</li>
</ul>
<h5 id="添加Mach-Port-Input-Source注意事项"><a href="#添加Mach-Port-Input-Source注意事项" class="headerlink" title="添加Mach Port Input Source注意事项"></a>添加Mach Port Input Source注意事项</h5><ul>
<li>需要同时记录主线程端口和子线程端口号，需要唤醒对应线程时直接使用该端口发送消息即可，不需要像Custom Input Source那样做标记。</li>
</ul>
<h4 id="给runloop添加自定义mode和items"><a href="#给runloop添加自定义mode和items" class="headerlink" title="给runloop添加自定义mode和items"></a>给runloop添加自定义mode和items</h4><ul>
<li>需要注意的是不能直接调用run这个方法，因为这个方法是运行在DefaultMode下的，不会触发自定义mode中的source,需要调用runMode:beforeDate方法开启runloop.</li>
</ul>
<p><a href="https://github.com/lilingyu0620/LLYRunloopDemo.git" target="_blank" rel="noopener">这里是demo</a></p>
<h4 id="Runloop在iOS中的应用"><a href="#Runloop在iOS中的应用" class="headerlink" title="Runloop在iOS中的应用"></a>Runloop在iOS中的应用</h4><p>这块直接看YY博客吧，已经没法再补充更多了。。。</p>
<p>博客链接<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></p>
<h4 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h4><p>Runloop是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。</p>
<p>Runloop使用Mach内核实现线程的睡眠，通过Source和Timer来唤醒线程，Source和Timer最终都是通过Mach Port来唤醒的线程。</p>
<p>Source有CustomSource和Mach Port Source2种，CustomSource唤醒线程前需要先被标注为待处理，MachPortSource则直接使用端口号发送唤醒消息。</p>
<p>Timer有两种实现方式分别是MK_Timer和GCD Timer,在runloop中Timer被转为了一个存了触发时间的列表，这个触发时间是一个绝对时间，会按时间大小升序排序，在最小的时间被触发后，Runloop会更新列表保证时间始终是升序排列。如果Runloop在某次运行中阻塞了很长时间，Timer的触发会受到影响。过期的时间点会被移除而不会去触发。</p>
<p>Runloop的状态都可以通过添加Observer来得到。Observer在Runloop中是按order优先级升序排序的，排在前面的通知会先被触发（order越小优先级反而越高）。</p>
<p>Mode表示当前Runloop运行在哪个模式上，Runloop必须运行在一种Mode上，Runloop在创建时会有一个DefaultMode,可以通过runmode：beforeDate 切换Runloop当前运行的Mode。</p>
<p>Mode中包含了上面的Source,Timer和Observer三种Items。Runloop运行的时候其实就是在处理这些Items中的内容，如果这三种Items都没有要处理的内容，Runloop就要开始睡了,而当Mode的items为空时，当前Runloop会退出。</p>
<p>CommonMode不是一种真正的Mode,它是一个所有Mode的集合，如果把上面三种Items添加到CommonMode,那这些Items会被添加到集合中所有的Mode中。所以添加到CommonMode中Items,不管当前Runloop运行在哪种Mode上，Items中需要处理的事件都会被触发。（前提是这个Mode已经被添加到了CommonMode集合中）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/22/h-256与h-264的对比/" itemprop="url">
                  h.256与h.264的对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-22T17:35:46+08:00" content="2018-08-22">
              2018-08-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/22/h-256与h-264的对比/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/22/h-256与h-264的对比/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="h-256与h-264的对比"><a href="#h-256与h-264的对比" class="headerlink" title="h.256与h.264的对比"></a>h.256与h.264的对比</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265001.png" alt=""></p>
<h4 id="h-264的技术局限在哪里？"><a href="#h-264的技术局限在哪里？" class="headerlink" title="h.264的技术局限在哪里？"></a>h.264的技术局限在哪里？</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265002.png" alt=""></p>
<h4 id="h-265的优势在哪里"><a href="#h-265的优势在哪里" class="headerlink" title="h.265的优势在哪里"></a>h.265的优势在哪里</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265003.png" alt=""></p>
<h4 id="h-265关键技术"><a href="#h-265关键技术" class="headerlink" title="h.265关键技术"></a>h.265关键技术</h4><h5 id="四叉树编码结构"><a href="#四叉树编码结构" class="headerlink" title="四叉树编码结构"></a>四叉树编码结构</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265004.png" alt=""></p>
<ul>
<li>宏块的划分方式：</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265005.png" alt=""></p>
<ul>
<li>四叉树结构</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265006.png" alt=""></p>
<ul>
<li>实例</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265007.png" alt=""></p>
<h5 id="帧内和帧间预测"><a href="#帧内和帧间预测" class="headerlink" title="帧内和帧间预测"></a>帧内和帧间预测</h5><ul>
<li>帧内预测</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265008.png" alt=""></p>
<ul>
<li>帧间预测</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265009.png" alt=""></p>
<h5 id="环路滤波"><a href="#环路滤波" class="headerlink" title="环路滤波"></a>环路滤波</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265010.png" alt=""></p>
<h5 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265011.png" alt=""></p>
<h5 id="细粒度slice分块边界"><a href="#细粒度slice分块边界" class="headerlink" title="细粒度slice分块边界"></a>细粒度slice分块边界</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265012.png" alt=""></p>
<h4 id="h-264与h-265数据比对"><a href="#h-264与h-265数据比对" class="headerlink" title="h.264与h.265数据比对"></a>h.264与h.265数据比对</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265013.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">72</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
