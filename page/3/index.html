<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/08/iOS性能优化的一些套路/" itemprop="url">
                  iOS性能优化的一些套路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-08T17:56:56+08:00" content="2018-10-08">
              2018-10-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/08/iOS性能优化的一些套路/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/08/iOS性能优化的一些套路/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">程序优化第一法则：不要优化</div><div class="line">							————编程珠玑（续）</div><div class="line">							</div><div class="line">过早的优化是万恶之源</div><div class="line">							————Donald Knuth</div></pre></td></tr></table></figure>
<p>不要过早优化，也不要为了优化而优化，只有在项目真正需要优化的时候再优化。我们实际工作中，在开始一个项目时，应该也不会太多去考虑性能优化的问题。不过随着项目版本的不断迭代，模块和代码量不断增加，研发团队人员变动，以及其他各种原因，难免会出现一些实现不太友好的代码和方案，影响到app的用户体验，这个时候就需要相应的优化来提升app的性能。</p>
<p>iOS的性能优化是一个比较有挑战的工作，有一定的难度，需要着手优化的人有一定的姿势积累，能够分析出各方面可能出现的性能问题。所以一般也是进阶必须掌握的技能。当然，优化的过程和可优化的一些点也是有套路的，综合网上的方案和自身的一些经验，这里做一下简单的总结：</p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>这里说的启动优化指的是冷启动，根据启动的流程，可以分为2部分来分别优化，具体如下：</p>
<h4 id="main函数之前"><a href="#main函数之前" class="headerlink" title="main函数之前"></a>main函数之前</h4><p>ipa实际上就是一堆二进制文件（.o文件）的集合，而这堆二进制文件就是xcode编译我们的代码后生产的最终产物，文件头部会给操作系统留下入口（这个入口不是main，而是@start标识）。当应用被启动，系统首先找到程序入口，将二进制文件分页映射到虚拟内存（mmap），然后加载动态库（load image），然后对需要rel的符号的地址进行rebase和bind，之后就是对使用的oc类和分类的注册和初始化。至此，mian函数前的工作做完了。</p>
<h5 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h5><p>知道了具体流程，我们就可以对流程中各个环节进行有针对性的优化了：</p>
<ul>
<li>利用Xcode的DYLD_PRINT_STATISTICS环境变量监测mian函数前的耗时.</li>
<li>尽可能精简代码量，减少mmap次数。</li>
<li>动态库的使用，移除不必要的动态库依赖。</li>
<li>合并或者删除无用的oc类和分类。</li>
<li>删除没有被调用的方法,减少非唯一selector的个数。</li>
<li>将不必须的初始化方法从+load移到+initialize。</li>
</ul>
<h4 id="main函数之后"><a href="#main函数之后" class="headerlink" title="main函数之后"></a>main函数之后</h4><p>这部分内容就是业务相关的东西了，根据各自app的需求会有不同的优化方案，不像上面的部分具有通用性。启动优化的最终目的肯定都是最快的展示首页内容，这里列举一些常用的优化套路。</p>
<ul>
<li>能延迟执行的就延迟执行。比如SDK的注册，非首页UI的创建等。</li>
<li>不能延迟执行的，尽量放到后台执行。比如网络请求，数据读取，原始JSON数据转对象，日志发送等。</li>
<li>既不能延时又不能后台执行的尽量已懒加载的方式创建实例。</li>
<li>利用检测工具监测启动阶段函数调用的耗时情况，进行针对性优化。</li>
</ul>
<p>具体细节可参考<a href="https://techblog.toutiao.com/2018/05/29/untitled-24/" target="_blank" rel="noopener">今日头条这篇优化文章</a></p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>蒸米大大的<a href="https://mp.weixin.qq.com/s/WQ7rrTJm-cn3Cb6e_zZ4cA" target="_blank" rel="noopener">这一篇文章</a>比较详细的描述了iOS中的虚拟内存和物理内存相关的内容。我们一般说的在程序中分配和回收内存指的都是虚拟内存，程序员一般不直接和物理内存（cpu内存，不包括磁盘）打交道。更多虚拟内存和物理内存的内容可阅读操作系统相关的文章和书籍去学习。</p>
<p>在计算机发展的初期，程序员都是直接访问物理内存，随着计算机技术的飞速发展，这种内存访问方式不再满足程序员的需求，新的内存访问方式出现，这就是被沿用至今的<strong>虚拟内存</strong>。虚拟内存在程序员和物理内存之间提供了一个良好的中间环境，它隔离了程序员直接使用物理内存带来的各种危险操作，提高了物理内存的利用率，简化了内存管理方式，保证了进程的安全。所以有这样一句古话：<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>，看来不是没有道理的。</p>
<p>言归正传，下面我们从创建、复用、回收三个方面总结一下iOS在内存使用过程中的一些需要注意的点：</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>减少大图的使用。</li>
<li>weak strong dance保证self的生命周期。</li>
<li>weak替换unsafe_unretain，保证指针安全。</li>
<li>合理利用自动释放池，避免内存暴涨导致OOM。</li>
<li>尽量使用懒加载的方式创建对象，避免无用和重复创建，减少不必要的内存开销。</li>
<li>在子线程手动申请（malloc）大内存的的时候 ping 一下主线程，因为子线程无法收到内存警告的传递。</li>
</ul>
<h4 id="缓存和复用"><a href="#缓存和复用" class="headerlink" title="缓存和复用"></a>缓存和复用</h4><ul>
<li>合理使用缓存减轻CPU的计算压力。</li>
<li>复用UI对象内存，通过绑定model更新UI。</li>
<li>合理使用缓存数据结构（NSCache VS NSMapTable VS NSHashTable VS NSDictionary）。</li>
</ul>
<h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ul>
<li>保证使用的内存能够被正确的回收掉，避免内存泄露（timer,delegate,block）。</li>
<li>使用适当的工具对内存的回收进行检测，发生内存泄露及时抛出提示。</li>
<li>处理系统的内存警告。</li>
</ul>
<h3 id="UI优化"><a href="#UI优化" class="headerlink" title="UI优化"></a>UI优化</h3><p>先说一下iOS中UI展示的过程。iOS中的视图容器是CALayer,所有的显示在屏幕上的内容最终都是被渲染到CALayer上。CPU计算好需要渲染的内容放入渲染缓冲区，GPU从渲染缓冲区拿到数据，OpenGLES经过顶点着色，光栅化，片元着色，逐片段操作等一系列流程，将处理好的数据（bitmap）丢到后帧缓冲区，前帧缓冲区再从后帧缓冲区更新数据，最终渲染到CALayer。</p>
<p>从上面展示的流程可以看到，UI的展示分为两个部分，CPU处理部分和GPU处理部分。如果某一部分的处理被阻塞的话，UI显示就会出现卡顿。所以，可以从这两部分着手优化。</p>
<h4 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h4><ul>
<li>利用UI卡顿检测工具检测屏幕的fps。</li>
<li>懒加载方式创建UI对象，使用CALayer替换UIView。</li>
<li>减少视图相关属性的修改，避免视图层级的调整，尽量不要动态添加和移除视图。</li>
<li>文本的异步计算和渲染。</li>
<li>尽量提前计算好视图布局并缓存，避免动态计算和更新布局。</li>
<li>异步解码图片和绘制视图。</li>
</ul>
<h4 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h4><ul>
<li>将多个小图合并为一张大图显示，控制图片尺寸不要大于GPU处理上限。</li>
<li>避免带透明度的视图重叠显示，会产生像素的混合。</li>
<li>避免出现离屏渲染。</li>
</ul>
<p>具体细节参考<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">YY的这篇文章</a></p>
<h3 id="ipa包大小优化"><a href="#ipa包大小优化" class="headerlink" title="ipa包大小优化"></a>ipa包大小优化</h3><p>上面提到过，iOS的ipa包实际上就是一堆二进制文件的集合。而这堆二进制文件，就是我们的代码经过Xcode编译之后的产物。这里简单介绍一下Xcode点击run后的整个流程：</p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><ul>
<li>将所有的 <em>#deifne</em> 删除 并展开所有的宏定义。</li>
<li>处理所有的条件编译指令 比如#if #else #ifdef #endif 等等。</li>
<li>处理#include预编译指令 将所包含的文件插入到预编译指令的位置。</li>
<li>删除所有的注释 // /<em> </em>/ 等等。</li>
<li>添加行号和文件名标识。</li>
<li>保留所有#pragma编译器指令。</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译过程就是把预处理完成的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件（词法分析-&gt;语法分析-&gt;语义分析-&gt;源代码优化-&gt;代码生成&gt;目标代码优化）。</p>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul>
<li>利用有限状态机扫描源代码 生成一系列记号（Token）。</li>
<li>记号分类：关键字、标识符、字面量（包括数字，字符串）、特殊符号（+、=）。</li>
<li>每种记号存入对应的表内。</li>
<li>词法规则可以自定义。</li>
</ul>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><ul>
<li>对上面的词法表进行语法分析、生成语法树。</li>
<li>整个分析过程采用上下文无关语法。</li>
<li>语法树以表达式为节点。</li>
</ul>
<h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><ul>
<li>编译器所能分析的语义是静态语义。</li>
<li>静态语义通常包括声明和类型的匹配，类型的转换。</li>
<li>经过语义分析，语法树被标识了类型。</li>
<li>语义分析判断该语法是否合法。</li>
</ul>
<h5 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h5><ul>
<li>直接在语法树上面优化比较困难，所以源代码优化器会先将语法树转换为中间代码。</li>
<li>中间代码是设备无关的。</li>
<li>编译器前端负责产生机器无关的中间代码，后端负责将中间代码转换成目标机器代码。</li>
<li>跨平台编译器就是有一个前端和多个后端的组合。</li>
</ul>
<h5 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h5><ul>
<li>编译器后端主要包括代码生成器和目标代码优化器。</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul>
<li>链接的过程主要包括：地址和空间分配、符号决议、重定向。</li>
<li>目标文件和库一起链接生成可执行文件。</li>
<li>库其实是一种编译后的目标文件。</li>
<li>目标文件之间的函数和变量的访问在链接过程中被重定向。</li>
</ul>
<h4 id="可执行文件的装载（即上面提到的main函数前的部分）"><a href="#可执行文件的装载（即上面提到的main函数前的部分）" class="headerlink" title="可执行文件的装载（即上面提到的main函数前的部分）"></a>可执行文件的装载（即上面提到的main函数前的部分）</h4><p>了解了二进制文件的产生过程后，我们可以利用一些工具来对它们做一些针对性的优化工作：</p>
<h4 id="二进制文件的优化"><a href="#二进制文件的优化" class="headerlink" title="二进制文件的优化"></a>二进制文件的优化</h4><h5 id="查看mach-o文件的大小"><a href="#查看mach-o文件的大小" class="headerlink" title="查看mach.o文件的大小"></a>查看mach.o文件的大小</h5><p>首先，在Xcode（Debug下）中开启编译选项<strong>Write Link Map File</strong>，然后在这个目录下面（这里以OpenCourse为例）找到下面这个txt文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/DerivedData/OpenCourse-gyfdubhkhvixzvetgqbmqrzplarc/Build/Intermediates.noindex/OpenCourse.build/Debug2-iphoneos/OpenCourse.build/OpenCourse-LinkMap-normal-arm64.txt</div></pre></td></tr></table></figure>
<p>这个LinkMap里展示了整个可执行文件的全貌，列出了编译后的每一个.o目标文件的信息（包括静态链接库.a里的），以及每一个目标文件的代码段，数据段存储详情。对于比较大的文件，进行对应的优化即可。</p>
<p><a href="https://github.com/daheli/iOS-linkmap-tools" target="_blank" rel="noopener">查看mach.o文件大小的工具</a></p>
<h5 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h5><ul>
<li>Optimization Level release使用Fastest。</li>
<li>Strip Linked Product release设置为YES。</li>
<li>Symbols Hidden by Default release设置为YES。</li>
</ul>
<h4 id="资源文件的优化"><a href="#资源文件的优化" class="headerlink" title="资源文件的优化"></a>资源文件的优化</h4><ul>
<li>图片资源在打包过程中压缩比很低，基本是原图copy。减少图片数量和大小可以直接降低ipa的大小。</li>
<li>及时删除无用代码（包括无用的类，依赖，方法，测试用例等）。</li>
</ul>
<p><a href="https://tinypng.com" target="_blank" rel="noopener">压缩图片大小的工具</a></p>
<p><a href="https://github.com/tinymind/LSUnusedResource" target="_blank" rel="noopener">检测无用的图片的工具</a></p>
<p><a href="https://github.com/dblock/fui" target="_blank" rel="noopener">检测无用类和依赖的工具</a></p>
<h3 id="编码和架构优化"><a href="#编码和架构优化" class="headerlink" title="编码和架构优化"></a>编码和架构优化</h3><p>好的代码质量和架构设计是项目稳定运行和迭代的基石。而编码高手和低手之间很大一部分区别在于对细节的处理上，要养成良好的编码习惯非一朝一夕，需要时间的积累和大量的练习，同时，也需要一些理论上的支持。下面推荐几本经典书籍，平时编码过程中，需要经常提醒自己甚至强迫自己按照书中这些tips去做，养成良好的编码习惯，提升技术上的综合素质。</p>
<h4 id="代码的设计原则和架构方案《架构整理之道》"><a href="#代码的设计原则和架构方案《架构整理之道》" class="headerlink" title="代码的设计原则和架构方案《架构整理之道》"></a>代码的设计原则和架构方案《架构整理之道》</h4><p>总结一下本书中比较重要的几个章节：</p>
<h5 id="SRP单一职责原则"><a href="#SRP单一职责原则" class="headerlink" title="SRP单一职责原则"></a>SRP单一职责原则</h5><ul>
<li>函数设计也需要遵循SRP原则</li>
<li>任何一个软件模块都应该有且仅有一个被修改的原因</li>
<li>任何一个软件模块都应该只对某一类行为者负责</li>
<li>Employee类中各行为应该被分解</li>
</ul>
<h5 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h5><ul>
<li>良好的设计软件应该易于扩展,同时抗拒修改</li>
<li>如果A组件不想被B组件上发生的修改所影响,那么就应该让B组件依赖于A组件</li>
<li>利用SRP分解功能,利用DIP反转依赖</li>
<li>软件系统不应该依赖不直接使用的组件</li>
</ul>
<h5 id="LSP里氏替换原则"><a href="#LSP里氏替换原则" class="headerlink" title="LSP里氏替换原则"></a>LSP里氏替换原则</h5><ul>
<li>以接口或者多态的形式实现函数调用的可替换性</li>
</ul>
<h5 id="ISP接口隔离原则"><a href="#ISP接口隔离原则" class="headerlink" title="ISP接口隔离原则"></a>ISP接口隔离原则</h5><ul>
<li>利用接口隔离原则隔离掉不需要的依赖关系,因为不需要的依赖会导致不必要的重新编译和重新部署</li>
</ul>
<h5 id="DIP依赖反转原则"><a href="#DIP依赖反转原则" class="headerlink" title="DIP依赖反转原则"></a>DIP依赖反转原则</h5><ul>
<li>如果想要设计一个灵活的系统,在源代码层面的依赖关系中就应该多引用抽象类型而非具体实现</li>
<li>接口比具体实现更稳定,因为如果修改接口必须修改实现,但是反之则不一定.</li>
<li>不要在具体实现类上创建子类,具体实现应该放到子类去做,除非是比较稳定且通用的逻辑.</li>
<li>不要覆盖包含具体实现的函数,如果必须这样,请在覆盖方法中先调用父类方法.</li>
<li>源代码依赖方向永远是控制流方向的反转</li>
</ul>
<h5 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h5><h6 id="复用-发布等同原则-REP"><a href="#复用-发布等同原则-REP" class="headerlink" title="复用/发布等同原则(REP)"></a>复用/发布等同原则(REP)</h6><ul>
<li>软件复用的最小粒度应等同于其发布的最小粒度</li>
<li>ERP原则就是指组件中的类与模块必须是彼此紧密相关的,一个组件不能由一组毫无关联的类和模块组成</li>
<li>一个组件中包含的类与模块还应该是可以同时发布的</li>
</ul>
<h6 id="共同闭包原则-CCP"><a href="#共同闭包原则-CCP" class="headerlink" title="共同闭包原则(CCP)"></a>共同闭包原则(CCP)</h6><ul>
<li>我们应该将那些会同时修改,并且为相同目的而修改的类放到同一个组件中,而将不会同时修改,并且不会为了相同目的而修改的那些类放到不同的组件中</li>
<li>CCP原则是SRP原则和OCP原则的组件版</li>
</ul>
<h6 id="共同复用原则-CRP"><a href="#共同复用原则-CRP" class="headerlink" title="共同复用原则(CRP)"></a>共同复用原则(CRP)</h6><ul>
<li>不要强迫一个组件的用户依赖他们不需要的东西</li>
<li>我们希望组件中的所有类是不可拆分的,不应该出现别人只需要依赖它的某几个类而不需要其他类的情况</li>
<li>CRP的作用不仅是告诉我们应该将哪些类放在一起,更重要的是要告诉我们应该将哪些类分开</li>
<li>CRP原则实际上是ISP原则的一个普适版,ISP建议我们不要依赖不需要的类,CRP建议我们不要依赖不需要的组件</li>
<li>优秀的架构师应该在REP,CCP和CRP原则间找到一个好的平衡点,一个项目的组件结构设计的重心是根据该项目的开发时间和成熟度不断变化的</li>
</ul>
<h5 id="组件耦合"><a href="#组件耦合" class="headerlink" title="组件耦合"></a>组件耦合</h5><h6 id="无依赖环原则"><a href="#无依赖环原则" class="headerlink" title="无依赖环原则"></a>无依赖环原则</h6><ul>
<li>组件依赖关系图中不应该出现环</li>
<li>依赖环会导致组件之间的发布和运行很难稳定下来</li>
<li>每周构建是指team每一周专门抽出一天来进行组件的构建调试工作,而其他时间则忽略组件的构建问题</li>
<li>消除循环依赖的一个解决办法是将研发项目划分成一些可单独发布的组件,这些组件独立完成构建和发布</li>
<li>DIP原则打破循环依赖好的选择</li>
</ul>
<h6 id="自上而下的设计"><a href="#自上而下的设计" class="headerlink" title="自上而下的设计"></a>自上而下的设计</h6><ul>
<li>组件结构图是不可能自上而下被设计出来的,它必须随着软件系统的变化而变化和扩张.</li>
<li>组件结构图并不是用来描述应用程序功能的,它更像是应用程序在构建性与维护性方面的一张地图</li>
<li>组件结构图的一个重要目的是如何隔离频繁的变更</li>
</ul>
<h6 id="稳定依赖原则"><a href="#稳定依赖原则" class="headerlink" title="稳定依赖原则"></a>稳定依赖原则</h6><ul>
<li>依赖关系必须要指向更稳定的方向</li>
<li>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖</li>
<li>稳定性指标的计算方法:出口依赖/(出口依赖+入口依赖). 0最稳定,1最不稳定.</li>
<li>组件并不是都需要稳定</li>
</ul>
<h6 id="稳定抽象原则"><a href="#稳定抽象原则" class="headerlink" title="稳定抽象原则"></a>稳定抽象原则</h6><ul>
<li>一个组件的抽象化程度应该与其稳定性保持一致</li>
<li>组件抽象化的计算方法:组件中的抽象类和接口/组件中类的个数 0表现没有抽象类 1表示全是抽象类</li>
<li>好的组件结构应该在抽象和稳定之间找到一个好的平衡点</li>
</ul>
<h4 id="编码规范和原则《程序员修炼之道》"><a href="#编码规范和原则《程序员修炼之道》" class="headerlink" title="编码规范和原则《程序员修炼之道》"></a>编码规范和原则《程序员修炼之道》</h4><p>从小工到专家，你需要做到下面这些：</p>
<h5 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h5><p><strong>DRY</strong>:系统中的每一项知识都必须具有单一,无歧义,权威的表示.</p>
<p>重复是怎样产生的:</p>
<ul>
<li>强加的重复,开发着觉得无可选择,环境要求.</li>
<li>无意的重复,开发者没有意识到他们在重复.</li>
<li>无耐性的重复,开发者偷懒,copy比较容易.</li>
<li>开发者之间的重复,几个人重复了同样的信息.</li>
</ul>
<h5 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h5><p>正交性是从几何学中借来的术语,如果两条直线相交成直角,它们就是正交的.沿着某一条直线移动,你投影到另一条直线上的位置不变.</p>
<p>正交性的好处:消除无关事物之间的影响(解耦不必要的依赖)</p>
<p><strong>分层设计</strong>是正交系统的强大方式..因为每层都只适用在其下面的层次提供的抽象,在改动底层实现,而又不影响其他代码方面,你拥有极大的灵活性.分层也降低了模块间依赖关系失控的风险.</p>
<p>正交性的简单测试方法:如果我显著的改变某个特定功能背后的需求,有多少模块会受影响?在正交系统中,答案是<strong>一个</strong></p>
<p>正交性在编码中的应用:</p>
<ul>
<li>让你的代码保持解耦</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数</li>
<li>养成不断批判对待自己代码的习惯.寻找任何重新进行组织,以改善其结构和正交性的机会,这个过程叫做重构,它非常重要.</li>
</ul>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>调试的心理学:</p>
<ul>
<li>调试是解决问题,要据此发起进攻</li>
<li>要修正问题,而不是发出指责(bug是你的还是别人的,这不是真的很有关系.)</li>
<li>不要恐慌,如果你看到bug报告的第一反应是<strong>那不可能</strong>,你就完全错了.一个脑细胞都不要浪费在以<strong>“但那时不可能”</strong>起头的思路上,因为很明显,那不仅可能,而且已经发生.</li>
<li>小心近视,要抵制只修正你看到的症状的急迫愿望,更有可能的情况是,实际的故障离你正在观察的地方可能还有几步远,并且可能涉及许多其他的相关事物.</li>
</ul>
<p>调试策略:</p>
<ul>
<li>你需要与qa面谈,搜集比最初给你的数据更多的数据.</li>
<li>qa不可能全覆盖所有的case,你需要系统的进行这样的测试,比如分支语句,你可能需要自己造数据去覆盖所有的分支.</li>
<li>复现bug</li>
<li>数据可视化(log)</li>
<li>堆栈和断点</li>
<li>橡皮鸭,把你的逻辑对着桌上的橡皮鸭描述一遍,看看有没有漏洞.</li>
<li>消除过程,二分调试</li>
<li>遇到自认为不可能的bug时,不要假定,要证明.</li>
</ul>
<h5 id="解耦与得墨忒耳法则"><a href="#解耦与得墨忒耳法则" class="headerlink" title="解耦与得墨忒耳法则"></a>解耦与得墨忒耳法则</h5><p>多模块耦合的危害</p>
<ul>
<li>调用链冗长</li>
<li>对一个模块的简单改动会传遍系统中的一些无关模块</li>
<li>开发者害怕改动代码,因为他们不清楚哪些代码可能受影响</li>
</ul>
<p>函数的得墨忒耳法则规定,某个对象的任何方法都应该只调用以下情形的方法:</p>
<ul>
<li>它自身的方法</li>
<li>传入该方法的任何对象的方法</li>
<li>它创建的任何对象的方法</li>
<li>任何直接持有的组件的对象的方法(比如全局对象)</li>
</ul>
<h5 id="不要靠巧合编程"><a href="#不要靠巧合编程" class="headerlink" title="不要靠巧合编程"></a>不要靠巧合编程</h5><p>深思熟虑的编程,而不是靠运气和偶然的成功.</p>
<p>怎样深思熟虑的编程:</p>
<ul>
<li>总是意识到你在做什么</li>
<li>不要盲目的编程</li>
<li>按照计划行事</li>
<li>依靠可靠的事物,不要依靠巧合或假定</li>
<li>为你的假定建立文档</li>
<li>不要只是测试你的代码,还要测试你的假定</li>
<li>为你的工作划分优先级</li>
<li>不要做历史的奴隶,不要让已有的代码支配将来的代码,如果不再适用,所有的代码都可以被替换.</li>
</ul>
<h5 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h5><p>何时重构:</p>
<ul>
<li>重复,你发现了对DRY原则的违反</li>
<li>非正交的设计</li>
<li>过时的知识</li>
<li>性能问题</li>
</ul>
<p>早重构,常重构</p>
<p>如何重构:</p>
<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前,确保你拥有良好的测试.</li>
<li>采取短小,深思熟虑的步骤.</li>
</ul>
<h5 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h5><ul>
<li>不要留破窗户</li>
<li>不要做温水里的青蛙</li>
<li>交流的重要性</li>
<li>DRY</li>
<li>正交性</li>
</ul>
<h4 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h4><p>早测试,常测试,自动测试</p>
<p>要到通过全部测试,编码才算完成</p>
<p>测试什么:</p>
<ul>
<li><p>单元测试</p>
<p>  模块测试</p>
</li>
<li><p>集成测试</p>
<p>  子系统能很好的系统工作</p>
</li>
<li><p>验证和校验</p>
<p>  用户回归</p>
</li>
<li><p>资源耗尽,错误及恢复</p>
<p>  1.内存空间<br>  2.磁盘空间<br>  3.cpu带宽<br>  4.挂钟时间<br>  5.磁盘带宽<br>  6.网络带宽<br>  7.调色板<br>  8.视频分辨率<br>  9.fps</p>
</li>
<li><p>性能测试</p>
<p>  预期的用户数,连接数或每秒事务数</p>
</li>
<li><p>可用性测试</p>
<p>  qa,灰度…</p>
</li>
</ul>
<h5 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h5><p>在你的作品上签名,你的签名应该被视为质量的保证，如果有一天你离开了网易，是否会因为代码质量问题而把自己的签名换成netease呢？（手动@学姐😁）。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上是一个iOSer项目优化的简单总结，一部分可能是iOS特有的优化项目，还有一部分则具有普适性，因为不管什么技术方向，最终它们的产物都会是二进制。技术的深度和广度这两个方向的发展问题也一直都是程序员们讨论的话题，其实不管是深度和广度，只要找准一个方向一直走下去，就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/10/Runloop源码解析和实践/" itemprop="url">
                  Runloop源码解析和实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-09-10T21:20:28+08:00" content="2018-09-10">
              2018-09-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/09/10/Runloop源码解析和实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/10/Runloop源码解析和实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="RunLoop是干啥的"><a href="#RunLoop是干啥的" class="headerlink" title="RunLoop是干啥的"></a>RunLoop是干啥的</h4><p><strong>官翻：</strong> Run loops是与线程相关的基础设施的一部分，一个Runloop就是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。</p>
<h4 id="疑问？？？"><a href="#疑问？？？" class="headerlink" title="疑问？？？"></a>疑问？？？</h4><ul>
<li>Runloop的运行机制</li>
<li>Runloop是如何唤醒和睡眠线程的，与线程到底是什么关系</li>
<li>Runloop的Source、Timer、Observer和Mode与Runloop到底是什么关系</li>
<li>iOS系统怎么使用Runloop的</li>
<li>如何自定义</li>
</ul>
<h3 id="庖丁解🐂"><a href="#庖丁解🐂" class="headerlink" title="庖丁解🐂"></a>庖丁解🐂</h3><p>一个Runloop接收2中不同类型的sources.<strong>Input source</strong> 发送异步事件，一般是来自其他线程或者是其他应用的；<strong>Timer source</strong>发送同步事件，会在预设好的时间或者重复间隔内触发。这2种source都会通过特殊的处理程序处理事件。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop001.png" alt=""></p>
<p>Input source发送异步事件，这种source runloop在处理的时候会调用runUnitlDate：方法开启一个runloop,并且在运行date时间后退出。Timer source则不会使runloop退出。</p>
<p>在处理input source时，runloops 也会生成相关的通知，你可以注册成为观察者在当前线程来处理其他时间。</p>
<p>#####（补充） runloop 的运行方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)run; </div><div class="line">- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</div><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure>
<ul>
<li><p>run方法对应CFRunloopRef中的CFRunLoopRun并不会退出，除非手动调用CFRunLoopStop();通常如果想要永远不会退出RunLoop才会使用此方法，否则可以使用runUntilDate。</p>
</li>
<li><p>runMode:beforeDate:则对应CFRunLoopRunInMode(mode,limiteDate,true)方法,只执行一次，执行完就退出；通常用于手动控制RunLoop（例如在while循环中）。</p>
</li>
<li><p>runUntilDate:方法其实是CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)，执行完并不会退出，继续下一次RunLoop直到timeout。</p>
</li>
</ul>
<h4 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h4><p>一个runloop mode是input source和timer sources的集合，同时包含一个runloop观察者的合集。每次运行一个runloop时，需要指定一个特别的mode。在runloop 运行的过程中，只有和这个mode相关联source才能发送事件（同样，只有和这个mode关联的观察者才能收到通知）。关联了其他mode的source会被暂停一切新事件的发送直到runloop运行在该mode上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</div><div class="line">    CFMutableSetRef _sources0;    // Set</div><div class="line">    CFMutableSetRef _sources1;    // Set</div><div class="line">    CFMutableArrayRef _observers; // Array</div><div class="line">    CFMutableArrayRef _timers;    // Array</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>modes通过name来区分，可用通过指定mode的name来自定义一个mode,虽然name在自定义的时候可以任意指定，但是其他内容却不行，当你自定义一个mode的时候，必须添加一个或者多个source(input source 或 timer source) ,或者观察者。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop003.png" alt=""></p>
<h4 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h4><p>Input sources 给线程发送异步事件，事件的类型和input source的类型相关。一般有2种:<strong>Port-based input sources 用来监控Mach ports</strong>和<strong>自定义 input sources 用来监控自定义事件</strong>。2者的唯一不同在于如何发送信号：Port-based input sources是kernel内核自动发送信号；自定义 input sources是从其他线程手动发送信号。</p>
<h5 id="Port-Based-Sources"><a href="#Port-Based-Sources" class="headerlink" title="Port-Based Sources"></a>Port-Based Sources</h5><ul>
<li>NSMachPort</li>
<li>NSMessagePort</li>
</ul>
<p>mach 操作系统微内核 在mac os和ios系统中采用。虚拟内存的分配，进程间的通信（基于port）。</p>
<p>每一种服务都是一个进程（http 8080 https 443 ftp 20 21 rtmp 1935），每一个进程都分配一个port(虚拟端口)， </p>
<h5 id="Custom-Input-Sources"><a href="#Custom-Input-Sources" class="headerlink" title="Custom Input Sources"></a>Custom Input Sources</h5><p>自定义一个Input source需要满足如下定义：</p>
<ul>
<li>需要input source处理的信息</li>
<li>让感兴趣的客户端知道怎么联系你的input source</li>
<li>一个处理程序例程来执行任何客户端的发送请求</li>
<li>取消程序</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop004.png" alt=""></p>
<h5 id="Cocoa-Perform-Selector-Sources"><a href="#Cocoa-Perform-Selector-Sources" class="headerlink" title="Cocoa Perform Selector Sources"></a>Cocoa Perform Selector Sources</h5><p>Perform Selector Sources 在执行完以后会从runloop的mode中移除。</p>
<p>当调用这个方法时，target线程必须包含一个活跃的runloop，runloop会在一次loop中处理所有的排队Perform事件而不是只处理一个。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop005.png" alt=""></p>
<h4 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h4><p>timer需要关联一个mode，如果timer不在当前活动的mode上，则不会被触发。如果timer所在的mode执行过程中被切换，则该timer也不会暂停直到mode重新切换回来，这就决定了NSTimer的触发并不是十分可靠的。</p>
<h4 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> /* Run Loop Observer Activities */</div><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),// 即将进入Loop  0x1</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),// 即将处理 Timer </div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source </div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠 0x20</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 </div><div class="line">    </div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出Loop </div><div class="line">    </div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Runloop使用场景"><a href="#Runloop使用场景" class="headerlink" title="Runloop使用场景"></a>Runloop使用场景</h4><ul>
<li>使用mach port或者自定义input source 来与其他线程通信</li>
<li>使用NSTimer</li>
<li>使用performSelector</li>
<li>线程保活</li>
<li>系统默认使用</li>
</ul>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>源码下载<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></p>
<h5 id="Input-Source-amp-amp-CFRunLoopSource-的结构"><a href="#Input-Source-amp-amp-CFRunLoopSource-的结构" class="headerlink" title="Input Source &amp;&amp; CFRunLoopSource 的结构"></a>Input Source &amp;&amp; CFRunLoopSource 的结构</h5><ul>
<li>source0/自定义 source</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">    Boolean	(*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode	(*hash)(const void *info);</div><div class="line">    void	(*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void	(*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void	(*perform)(void *info);</div><div class="line">&#125; CFRunLoopSourceContext;</div></pre></td></tr></table></figure>
<ul>
<li>source1/(mach port source+自定义 source)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">    Boolean	(*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode	(*hash)(const void *info);</div><div class="line">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</div><div class="line">    mach_port_t	(*getPort)(void *info);</div><div class="line">    void *	(*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);</div><div class="line">#else</div><div class="line">    void *	(*getPort)(void *info);</div><div class="line">    void	(*perform)(void *info);</div><div class="line">#endif</div><div class="line">&#125; CFRunLoopSourceContext1;</div></pre></td></tr></table></figure>
<ul>
<li>CFRunLoopSource</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopSource &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint32_t _bits;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFMutableBagRef _runLoops;</div><div class="line">    union &#123;</div><div class="line">	CFRunLoopSourceContext version0;	/* immutable, except invalidation */</div><div class="line">        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */</div><div class="line">    &#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="observer-amp-amp-CFRunLoopObserver-的结构"><a href="#observer-amp-amp-CFRunLoopObserver-的结构" class="headerlink" title="observer &amp;&amp; CFRunLoopObserver 的结构"></a>observer &amp;&amp; CFRunLoopObserver 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">&#125; CFRunLoopObserverContext;</div><div class="line"></div><div class="line">struct __CFRunLoopObserver &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFIndex _rlCount;</div><div class="line">    CFOptionFlags _activities;		/* immutable */</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFRunLoopObserverCallBack _callout;	/* immutable */</div><div class="line">    CFRunLoopObserverContext _context;	/* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="NSTimer-amp-amp-CFRunloopTimer-的结构"><a href="#NSTimer-amp-amp-CFRunloopTimer-的结构" class="headerlink" title="NSTimer &amp;&amp; CFRunloopTimer 的结构"></a>NSTimer &amp;&amp; CFRunloopTimer 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    void *	info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void	(*release)(const void *info);</div><div class="line">    CFStringRef	(*copyDescription)(const void *info);</div><div class="line">&#125; CFRunLoopTimerContext;</div><div class="line"></div><div class="line">struct __CFRunLoopTimer &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint16_t _bits;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFMutableSetRef _rlModes;</div><div class="line">    CFAbsoluteTime _nextFireDate;</div><div class="line">    CFTimeInterval _interval;		/* immutable */</div><div class="line">    CFTimeInterval _tolerance;          /* mutable */</div><div class="line">    uint64_t _fireTSR;			/* TSR units */</div><div class="line">    CFIndex _order;			/* immutable */</div><div class="line">    CFRunLoopTimerCallBack _callout;	/* immutable */</div><div class="line">    CFRunLoopTimerContext _context;	/* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Mode-的结构"><a href="#Mode-的结构" class="headerlink" title="Mode 的结构"></a>Mode 的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;//如果是MK_TIMER的话，会通过这个端口唤醒线程</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="runloop-的结构"><a href="#runloop-的结构" class="headerlink" title="runloop 的结构"></a>runloop 的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct _block_item &#123;</div><div class="line">    struct _block_item *_next;</div><div class="line">    CFTypeRef _mode;	// CFString or CFSet</div><div class="line">    void (^_block)(void);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef struct _per_run_data &#123;</div><div class="line">    uint32_t a;</div><div class="line">    uint32_t b;</div><div class="line">    uint32_t stopped;</div><div class="line">    uint32_t ignoreWakeUps;</div><div class="line">&#125; _per_run_data;</div><div class="line"></div><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;			/* locked for accessing mode list */</div><div class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp source0的手动唤醒就是通过给这个端口发消息实现的。</div><div class="line">    Boolean _unused;</div><div class="line">    </div><div class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run  loop 个人理解为runloop的一个配置文件</div><div class="line">    </div><div class="line">    pthread_t _pthread;</div><div class="line">    uint32_t _winthread;</div><div class="line">    </div><div class="line">    CFMutableSetRef _commonModes;//存放 common mode 的集合</div><div class="line">    CFMutableSetRef _commonModeItems;//每个 common mode 都有的 item (source, timer and observer) 集合</div><div class="line">    </div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;//这个 run loop 所有的 mode 集合</div><div class="line">    </div><div class="line">    struct _block_item *_blocks_head;</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    </div><div class="line">    </div><div class="line">    CFAbsoluteTime _runTime;</div><div class="line">    CFAbsoluteTime _sleepTime;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop"><a href="#Runloop的创建和销毁-CFRunLoopCreate-amp-amp-CFRunLoopGet0-amp-amp-CFRunLoopGetMain-amp-amp-CFRunLoopGetCurrent-amp-amp-CFFinalizeRunLoop" class="headerlink" title="Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()"></a>Runloop的创建和销毁 CFRunLoopCreate() &amp;&amp; CFRunLoopGet0() &amp;&amp; CFRunLoopGetMain() &amp;&amp; CFRunLoopGetCurrent() &amp;&amp; CFFinalizeRunLoop()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//获取主线程runloop</div><div class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class="line">    return __main;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取当前线程runloop</div><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div><div class="line"></div><div class="line">//保存runloop和pthread的全局字典。key = pthreadPointer(t); value = runloop.</div><div class="line">static CFMutableDictionaryRef __CFRunLoops = NULL;</div><div class="line">static CFLock_t loopsLock = CFLockInit;</div><div class="line"></div><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class="line"></div><div class="line">	//如果当前线程为0 则取主线程.</div><div class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">	t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __CFLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    //全局字典为空，则创建字典</div><div class="line">    if (!__CFRunLoops) &#123;</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line"></div><div class="line">	//创建主线程的runloop</div><div class="line">	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line"></div><div class="line">	//将runloop和pthread set到一个临时字典中</div><div class="line">	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">	</div><div class="line">	//将临时字典复制到全局字典，这个是一个原子操作。</div><div class="line">	if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class="line">	    CFRelease(dict);</div><div class="line">	&#125;</div><div class="line">	CFRelease(mainLoop);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //从全局字典中取出当前线程对应的runloop</div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">    __CFUnlock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    //如果runloop为空，新建runloop,并保存到全局字典中</div><div class="line">    if (!loop) &#123;</div><div class="line">	CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">	if (!loop) &#123;</div><div class="line">	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">	    loop = newLoop;</div><div class="line">	&#125;</div><div class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">	CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    if (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//入参为一个线程</div><div class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</div><div class="line">    CFRunLoopRef loop = NULL;</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</div><div class="line">    </div><div class="line">    //创建runloop实例</div><div class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, CFRunLoopGetTypeID(), size, NULL);</div><div class="line">    if (NULL == loop) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //初始化配置</div><div class="line">    (void)__CFRunLoopPushPerRunData(loop);</div><div class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</div><div class="line"></div><div class="line">	//初始化唤醒port</div><div class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</div><div class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</div><div class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</div><div class="line">    </div><div class="line">    //初始化commonModes 并 add kCFRunLoopDefaultMode</div><div class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</div><div class="line">    </div><div class="line">    //初始化其他变量</div><div class="line">    loop-&gt;_commonModeItems = NULL;</div><div class="line">    loop-&gt;_currentMode = NULL;</div><div class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    loop-&gt;_blocks_head = NULL;</div><div class="line">    loop-&gt;_blocks_tail = NULL;</div><div class="line">    loop-&gt;_counterpart = NULL;</div><div class="line">    </div><div class="line">    //绑定线程</div><div class="line">    loop-&gt;_pthread = t;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    loop-&gt;_winthread = GetCurrentThreadId();</div><div class="line">#else</div><div class="line">    loop-&gt;_winthread = 0;</div><div class="line">#endif</div><div class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</div><div class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</div><div class="line">    return loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 线程退出时调用</div><div class="line">CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) &#123;</div><div class="line">    CFRunLoopRef rl = NULL;</div><div class="line">    if (data &lt;= 1) &#123;</div><div class="line">	__CFLock(&amp;loopsLock);</div><div class="line">	if (__CFRunLoops) &#123;</div><div class="line">		</div><div class="line">		//在全局字典中移除该runloop</div><div class="line">	    rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));</div><div class="line">	    if (rl) CFRetain(rl);</div><div class="line">	    CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));</div><div class="line">	&#125;</div><div class="line">	__CFUnlock(&amp;loopsLock);</div><div class="line">    &#125; else &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    if (rl &amp;&amp; CFRunLoopGetMain() != rl) &#123; // protect against cooperative threads</div><div class="line">        if (NULL != rl-&gt;_counterpart) &#123;</div><div class="line">            CFRelease(rl-&gt;_counterpart);</div><div class="line">	    rl-&gt;_counterpart = NULL;</div><div class="line">        &#125;</div><div class="line">	// purge all sources before deallocation</div><div class="line">        CFArrayRef array = CFRunLoopCopyAllModes(rl);</div><div class="line">        </div><div class="line">        //移除该runloop的所有source</div><div class="line">        for (CFIndex idx = CFArrayGetCount(array); idx--;) &#123;</div><div class="line">            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);</div><div class="line">            __CFRunLoopRemoveAllSources(rl, modeName);</div><div class="line">        &#125;</div><div class="line">        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);</div><div class="line">        CFRelease(array);</div><div class="line">    &#125;</div><div class="line">    if (rl) CFRelease(rl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>runloop的创建是懒加载的方式创建，在第一次获取该runloop的时候才会去创建，所以子线程如果没有手动的去获取并运行runloop,是不会自动创建的。</li>
<li>runloop和线程是一一对应的关系，保存在一个全局的字典中。key是线程的指针，value是对应的runloop.</li>
<li>runloop的销毁发生在线程退出时。</li>
</ul>
<h4 id="Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun"><a href="#Runloop的运行-CFRunLoopRun-amp-amp-CFRunLoopRunSpecific-amp-amp-CFRunLoopRun" class="headerlink" title="Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun"></a>Runloop的运行 CFRunLoopRun &amp;&amp; CFRunLoopRunSpecific &amp;&amp; CFRunLoopRun</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div></pre></td><td class="code"><pre><div class="line">struct __timeout_context &#123;</div><div class="line">    dispatch_source_t ds;</div><div class="line">    CFRunLoopRef rl;</div><div class="line">    uint64_t termTSR;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __CFRunLoopTimeoutCancel(void *arg) &#123;</div><div class="line">    struct __timeout_context *context = (struct __timeout_context *)arg;</div><div class="line">    CFRelease(context-&gt;rl);</div><div class="line">    dispatch_release(context-&gt;ds);</div><div class="line">    free(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopTimeout(void *arg) &#123;</div><div class="line">    struct __timeout_context *context = (struct __timeout_context *)arg;</div><div class="line">    context-&gt;termTSR = 0ULL;</div><div class="line">    CFRUNLOOP_WAKEUP_FOR_TIMEOUT();</div><div class="line">    CFRunLoopWakeUp(context-&gt;rl);</div><div class="line">    // The interval is DISPATCH_TIME_FOREVER, so this won&apos;t fire again</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CFRunLoopRun(void) &#123;	/* DOES CALLOUT */</div><div class="line">    int32_t result;</div><div class="line">    do &#123;</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">	Boolean did = false;</div><div class="line">	if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">	// 1.通知观察者runloop即将进入loop</div><div class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">	</div><div class="line">	//run</div><div class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">	</div><div class="line">	// 10. 通知观察者runLoop即将退出</div><div class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">	rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> *  运行run loop</div><div class="line"> *</div><div class="line"> *  @param rl              运行的RunLoop对象</div><div class="line"> *  @param rlm             运行的mode</div><div class="line"> *  @param seconds         run loop超时时间</div><div class="line"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</div><div class="line"> *  @param previousMode    上一次运行的mode</div><div class="line"> *</div><div class="line"> *  @return 返回4种状态</div><div class="line"> */</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line"></div><div class="line">	</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line">    </div><div class="line">    //如果该runloop已停止，直接退出。</div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    //获取GCD的消息端口</div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    </div><div class="line">    //看判断条件，只有当前是主线程，才获取端口。（GCD只能唤醒主线程的runloop）</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">    //使用GCD的source来实现NSTimer</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    //设置runloop的超时时间，second是参数。</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">	timeout_context-&gt;ds = timeout_timer;</div><div class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">	</div><div class="line">	//调用__CFRunLoopTimeout</div><div class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//初始化为true</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;//返回状态</div><div class="line">    </div><div class="line">    //do while循环</div><div class="line">    do &#123;</div><div class="line">    </div><div class="line">    //runloop睡眠的时候会注册这个端口用来接口消息    </div><div class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line"></div><div class="line">	// 设置RunLoop为可以被唤醒状态</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">	// 2.通知observer，即将触发timer回调，处理timer事件</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        </div><div class="line">   	// 3.通知observer，即将触发Source0回调</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line"></div><div class="line"></div><div class="line">	// 执行加入当前 runloop 的 block</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	</div><div class="line">	 	 // 4.处理 source0 事件 有事件处理返回 true，没有事件返回 false</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        </div><div class="line">        // 如果实际处理了 sources 0，再一次处理 blocks（有可能是source0的回调中又给runloop添加了block）</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		 // 如果没有 Sources0 事件处理 并且 没有超时，poll 为 false</div><div class="line">        // 如果有 Sources0 事件处理 或者 超时，poll 都为 true</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line">        </div><div class="line">         if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line"></div><div class="line">         //如果收到source1的消息</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">                goto handle_msg;    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        didDispatchPortLastTime = false;</div><div class="line"></div><div class="line">	// 6.通知观察者RunLoop即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	</div><div class="line">	 // 7.设置RunLoop为休眠状态</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line">	</div><div class="line">	// do not do any user callouts after this point (after notifying of sleeping)</div><div class="line"></div><div class="line">        // Must push the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced.</div><div class="line"></div><div class="line">	//将睡眠等待端口添加到当前mach port活跃列表</div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">		//记录开始睡眠时间</div><div class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class="line"></div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">		// 等待被唤醒，可以被 sources0、source1、Mach port source,timers、CFRunLoopWakeUp 函数和 GCD 事件（如果在主线程）</div><div class="line">        do &#123;</div><div class="line">        </div><div class="line">        	  //清理消息缓存区</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                // objc_clear_stack(0);</div><div class="line">                // &lt;rdar://problem/16393959&gt;</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            </div><div class="line">            // 接收waitSet端口的消息 </div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">            </div><div class="line">			  // 如果是 timer 端口唤醒的，进行一下善后处理，之后再处理 timer</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    // Leave livePort as the queue port, and service timers below</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">            </div><div class="line">            	   // 不是 timer 端口唤醒的，跳出循环，进行接下来的处理</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line"></div><div class="line">		 // 不使用 GCD timer 作为 timer 实现的情况</div><div class="line">		 </div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            // objc_clear_stack(0);</div><div class="line">            // &lt;rdar://problem/16393959&gt;</div><div class="line">            </div><div class="line">            //清理消息缓存区</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">        </div><div class="line">#endif</div><div class="line">      </div><div class="line">      	 //被唤醒了。。。</div><div class="line">      	 </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">		  // 记录增加的睡眠时间</div><div class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class="line"></div><div class="line">        // Must remove the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class="line">        // in there if this function returns.</div><div class="line"></div><div class="line">		 //将等待唤醒的端口从mach port活跃端口列表移除</div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        //设置为忽略唤醒状态</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">		 // 取消runloop的休眠状态</div><div class="line">        // user callouts now OK again</div><div class="line">	__CFRunLoopUnsetSleeping(rl);</div><div class="line">	</div><div class="line">		 // 8.通知观察者runloop被唤醒</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line"></div><div class="line">		 // 9.处理通过端口收到的消息</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">		</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">        	  </div><div class="line">        	  // 不知道哪个端口唤醒的（或者根本没睡），啥也不干</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">            </div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">        		</div><div class="line">        	  // 被 CFRunLoopWakeUp 函数唤醒的，啥也不干</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            // do nothing on Mac OS</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">        	  </div><div class="line">        	  // 被 timers 唤醒，处理 timers</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class="line">            </div><div class="line">            // 被 timers 唤醒，处理 timers</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">			//被GCD唤醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">           __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">        	//以上都不是则是被source1唤醒的</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            </div><div class="line">            // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</div><div class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class="line"></div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            </div><div class="line"></div><div class="line">	        mach_msg_header_t *reply = NULL;</div><div class="line"></div><div class="line">	        //处理source1</div><div class="line">	        sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">	        if (NULL != reply) &#123;</div><div class="line">	            (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">	            CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">	        &#125;</div><div class="line">	            </div><div class="line">	            // Restore the previous voucher</div><div class="line">	            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">            </div><div class="line">        &#125; </div><div class="line">               </div><div class="line">   // 再一次处理 blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">	// 善后</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	</div><div class="line">	// 处理完当前事件 &amp; runloop 执行完就退出</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">	    </div><div class="line">	&#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">        </div><div class="line">        // run loop超时</div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">            </div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">	</div><div class="line">		 // run loop被手动终止</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	    </div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">		</div><div class="line">		// mode被终止</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	    </div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	</div><div class="line">		// mode中的Items都为空，退出。</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">        </div><div class="line">    &#125; while (0 == retVal);</div><div class="line"></div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return retVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//接收mach port消息</div><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *voucherState, voucher_t *voucherCopy) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;		/* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;</div><div class="line">        msg-&gt;msgh_local_port = port;</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class="line">        msg-&gt;msgh_size = buffer_size;</div><div class="line">        msg-&gt;msgh_id = 0;</div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        </div><div class="line">        //接收或发送消息</div><div class="line">        ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class="line"></div><div class="line">        // Take care of all voucher-related work right after mach_msg.</div><div class="line">        // If we don&apos;t release the previous voucher we&apos;re going to leak it.</div><div class="line">        voucher_mach_msg_revert(*voucherState);</div><div class="line">        </div><div class="line">        // Someone will be responsible for calling voucher_mach_msg_revert. This call makes the received voucher the current one.</div><div class="line">        *voucherState = voucher_mach_msg_adopt(msg);</div><div class="line">        </div><div class="line">        if (voucherCopy) &#123;</div><div class="line">            if (*voucherState != VOUCHER_MACH_MSG_STATE_UNCHANGED) &#123;</div><div class="line">                // Caller requested a copy of the voucher at this point. By doing this right next to mach_msg we make sure that no voucher has been set in between the return of mach_msg and the use of the voucher copy.</div><div class="line">                // CFMachPortBoost uses the voucher to drop importance explicitly. However, we want to make sure we only drop importance for a new voucher (not unchanged), so we only set the TSD when the voucher is not state_unchanged.</div><div class="line">                *voucherCopy = voucher_copy();</div><div class="line">            &#125; else &#123;</div><div class="line">                *voucherCopy = NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        CFRUNLOOP_WAKEUP(ret);</div><div class="line">        </div><div class="line">        //接收消息成功</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="runloop运行流程总结入下图"><a href="#runloop运行流程总结入下图" class="headerlink" title="runloop运行流程总结入下图"></a>runloop运行流程总结入下图</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop007.png" alt=""></p>
<p>runloop内部其实就是一个do while()的循环。只是在没有事件需要处理的时候，runloop会调用<strong>__CFRunLoopSetSleeping</strong> 方法将当前线程置为睡眠状态，同时会调用 <strong>__CFRunLoopServiceMachPort</strong> 方法来睡眠线程并等待接收mach发来的唤醒消息。收到消息后，该线程会被唤醒，唤醒后runloop除了处理唤醒它的事件，还需要处理一遍所有等待处理的事件，包括（timer,observer,source,block）。</p>
<h5 id="runloop唤醒事件总结"><a href="#runloop唤醒事件总结" class="headerlink" title="runloop唤醒事件总结"></a>runloop唤醒事件总结</h5><ul>
<li>mach port source</li>
<li>手动唤醒Custom Input Source（CFRunLoopSourceSignal(source)/CFRunLoopWakeUp(runloop)）</li>
<li>dispatch_async(dispatch_get_main_queue)/dispatch_sync(dispatch_get_main_queue)(不要在主线程同步任务，会死锁);</li>
<li>timer</li>
</ul>
<h4 id="Mode和它的四大大王-Source-Timer-Observer-Block"><a href="#Mode和它的四大大王-Source-Timer-Observer-Block" class="headerlink" title="Mode和它的四大大王(Source,Timer,Observer,Block)"></a>Mode和它的四大大王(Source,Timer,Observer,Block)</h4><h5 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h5><p>Mode的创建也是懒加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    struct __CFRunLoopMode srlm;</div><div class="line">    memset(&amp;srlm, 0, sizeof(srlm));</div><div class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, __kCFRunLoopModeTypeID);</div><div class="line">    srlm._name = modeName;</div><div class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</div><div class="line">    </div><div class="line">    //mode不为空直接返回，为空则创建新的</div><div class="line">    if (NULL != rlm) &#123;</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">	return rlm;</div><div class="line">    &#125;</div><div class="line">    if (!create) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);</div><div class="line">    if (NULL == rlm) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //参数的初始化</div><div class="line">    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);</div><div class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    rlm-&gt;_portToV1SourceMap = NULL;</div><div class="line">    rlm-&gt;_sources0 = NULL;</div><div class="line">    rlm-&gt;_sources1 = NULL;</div><div class="line">    rlm-&gt;_observers = NULL;</div><div class="line">    rlm-&gt;_timers = NULL;</div><div class="line">    rlm-&gt;_observerMask = 0;</div><div class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</div><div class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</div><div class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</div><div class="line">    </div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    </div><div class="line">    //初始化timer相关内容</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    rlm-&gt;_timerFired = false;</div><div class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0);</div><div class="line">    </div><div class="line">    //用来唤醒的端口</div><div class="line">    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">    if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1);</div><div class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue);</div><div class="line">    </div><div class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</div><div class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</div><div class="line">        *timerFiredPointer = true;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</div><div class="line">    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);</div><div class="line">    dispatch_resume(rlm-&gt;_timerSource);</div><div class="line">    </div><div class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</div><div class="line">    </div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line"></div><div class="line">    //用来唤醒的端口</div><div class="line">    rlm-&gt;_timerPort = mk_timer_create();</div><div class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</div><div class="line">#endif</div><div class="line">    </div><div class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</div><div class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret);</div><div class="line">    </div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    rlm-&gt;_msgQMask = 0;</div><div class="line">    rlm-&gt;_msgPump = NULL;</div><div class="line">#endif</div><div class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</div><div class="line">    CFRelease(rlm);</div><div class="line">    __CFRunLoopModeLock(rlm);	/* return mode locked */</div><div class="line">    return rlm;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//判断mode是否为空 通过这个函数可以看到，只有当source0、source1、timer和block都为空，mode才会被标记为空（这么看observer应该是低等屁民了，没有什么存在感）</div><div class="line"></div><div class="line">static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (NULL == rlm) return true;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    if (0 != rlm-&gt;_msgQMask) return false;</div><div class="line">#endif</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    </div><div class="line">	//主线程且当前Mode也在CommonMode中，不可能为空，应该是系统有往CommonMode里面添加了东西，会被同步到该Mode中。</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) return false; // represents the libdispatch main queue</div><div class="line">    </div><div class="line">    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false;</div><div class="line">    if (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false;</div><div class="line">    if (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false;</div><div class="line">    struct _block_item *item = rl-&gt;_blocks_head;</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">        Boolean doit = false;</div><div class="line">        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">            doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));</div><div class="line">        &#125; else &#123;</div><div class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));</div><div class="line">        &#125;</div><div class="line">        if (doit) return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line">//source的创建</div><div class="line"></div><div class="line">CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopSourceRef memory;</div><div class="line">    uint32_t size;</div><div class="line">    if (NULL == context) CRASH(&quot;*** NULL context value passed to CFRunLoopSourceCreate(). (%d) ***&quot;, -1);</div><div class="line">    </div><div class="line">    size = sizeof(struct __CFRunLoopSource) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopSourceRef)_CFRuntimeCreateInstance(allocator, CFRunLoopSourceGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopSourceUnsetSignaled(memory);</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_bits = 0;</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    memory-&gt;_runLoops = NULL;</div><div class="line">    size = 0;</div><div class="line">    switch (context-&gt;version) &#123;</div><div class="line">    case 0:</div><div class="line">	size = sizeof(CFRunLoopSourceContext);</div><div class="line">	break;</div><div class="line">    case 1:</div><div class="line">	size = sizeof(CFRunLoopSourceContext1);</div><div class="line">	break;</div><div class="line">    &#125;</div><div class="line">    objc_memmove_collectable(&amp;memory-&gt;_context, context, size);</div><div class="line">    if (context-&gt;retain) &#123;</div><div class="line">	memory-&gt;_context.version0.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//给mode添加source</div><div class="line"></div><div class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;	/* DOES CALLOUT */</div><div class="line"></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rls)) return;</div><div class="line">    Boolean doVer0Callout = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    //如果是common 直接添加到_commonModeItems数组</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rls);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rls&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建source0和source1的集合</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) &#123;</div><div class="line">	    rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	    rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	    rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);</div><div class="line">	&#125;</div><div class="line">	if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</div><div class="line">	</div><div class="line">		//按source类型添加到不同的集合中</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        CFSetAddValue(rlm-&gt;_sources0, rls);</div><div class="line">	    &#125; else if (1 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        CFSetAddValue(rlm-&gt;_sources1, rls);</div><div class="line">		__CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</div><div class="line">		</div><div class="line">		//如果是source1 还需要把source1对应的port添加到mach port的列表中</div><div class="line">		if (CFPORT_NULL != src_port) &#123;</div><div class="line">		    CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</div><div class="line">		    __CFPortSetInsert(src_port, rlm-&gt;_portSet);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    __CFRunLoopSourceLock(rls);</div><div class="line">	    if (NULL == rls-&gt;_runLoops) &#123;</div><div class="line">	        rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); // sources retain run loops!</div><div class="line">	    &#125;</div><div class="line">	    CFBagAddValue(rls-&gt;_runLoops, rl);</div><div class="line">	    __CFRunLoopSourceUnlock(rls);</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        if (NULL != rls-&gt;_context.version0.schedule) &#123;</div><div class="line">	            doVer0Callout = true;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">	rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);	/* CALLOUT */</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理source0</div><div class="line">static Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFTypeRef sources = NULL;</div><div class="line">    Boolean sourceHandled = false;</div><div class="line"></div><div class="line">    /* Fire the version 0 sources */</div><div class="line">    </div><div class="line">    //获取当前mode的source0集合</div><div class="line">    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) &#123;</div><div class="line">	CFSetApplyFunction(rlm-&gt;_sources0, (__CFRunLoopCollectSources0), &amp;sources);</div><div class="line">    &#125;</div><div class="line">    if (NULL != sources) &#123;</div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	// sources is either a single (retained) CFRunLoopSourceRef or an array of (retained) CFRunLoopSourceRef</div><div class="line">	</div><div class="line">	//如果是单个事件</div><div class="line">	if (CFGetTypeID(sources) == CFRunLoopSourceGetTypeID()) &#123;</div><div class="line">	    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;</div><div class="line">	    __CFRunLoopSourceLock(rls);</div><div class="line">	    </div><div class="line">	    //这里在处理完这个source之后，会把这个source标记为不再处理！！！！后面demo里有应用。</div><div class="line">            if (__CFRunLoopSourceIsSignaled(rls)) &#123;</div><div class="line">	        __CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">	        if (__CFIsValid(rls)) &#123;</div><div class="line">	            __CFRunLoopSourceUnlock(rls);</div><div class="line"></div><div class="line">                    //调用source0对应的回调</div><div class="line">                    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</div><div class="line">	            CHECK_FOR_FORK();</div><div class="line">	            sourceHandled = true;</div><div class="line">	        &#125; else &#123;</div><div class="line">	            __CFRunLoopSourceUnlock(rls);</div><div class="line">	        &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                __CFRunLoopSourceUnlock(rls);</div><div class="line">            &#125;</div><div class="line">	&#125; else &#123;</div><div class="line">	</div><div class="line">	//如果是一个事件列表</div><div class="line">	    CFIndex cnt = CFArrayGetCount((CFArrayRef)sources);</div><div class="line">	    CFArraySortValues((CFMutableArrayRef)sources, CFRangeMake(0, cnt), (__CFRunLoopSourceComparator), NULL);</div><div class="line">	    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		CFRunLoopSourceRef rls = (CFRunLoopSourceRef)CFArrayGetValueAtIndex((CFArrayRef)sources, idx);</div><div class="line">		__CFRunLoopSourceLock(rls);</div><div class="line">                if (__CFRunLoopSourceIsSignaled(rls)) &#123;</div><div class="line">		    __CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">		    if (__CFIsValid(rls)) &#123;</div><div class="line">		        __CFRunLoopSourceUnlock(rls);</div><div class="line">                        </div><div class="line">                        //调用source0对应的回调                       __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</div><div class="line">		        CHECK_FOR_FORK();</div><div class="line">		        sourceHandled = true;</div><div class="line">		    &#125; else &#123;</div><div class="line">		        __CFRunLoopSourceUnlock(rls);</div><div class="line">		    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    __CFRunLoopSourceUnlock(rls);</div><div class="line">                &#125;</div><div class="line">		if (stopAfterHandle &amp;&amp; sourceHandled) &#123;</div><div class="line">		    break;</div><div class="line">		&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	CFRelease(sources);</div><div class="line">	__CFRunLoopLock(rl);</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">    &#125;</div><div class="line">    return sourceHandled;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理source1</div><div class="line">static Boolean __CFRunLoopDoSource1(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">                                    , mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply</div><div class="line">#endif</div><div class="line">                                    ) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    Boolean sourceHandled = false;</div><div class="line"></div><div class="line">    /* Fire a version 1 source */</div><div class="line">    CFRetain(rls);</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    __CFRunLoopSourceLock(rls);</div><div class="line">    if (__CFIsValid(rls)) &#123;</div><div class="line">	__CFRunLoopSourceUnsetSignaled(rls);</div><div class="line">	__CFRunLoopSourceUnlock(rls);</div><div class="line">        __CFRunLoopDebugInfoForRunLoopSource(rls);</div><div class="line">        </div><div class="line">        //调用source1对应的回调</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls-&gt;_context.version1.perform,</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            msg, size, reply,</div><div class="line">#endif</div><div class="line">            rls-&gt;_context.version1.info);</div><div class="line">	CHECK_FOR_FORK();</div><div class="line">	sourceHandled = true;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (_LogCFRunLoop) &#123; CFLog(kCFLogLevelDebug, CFSTR(&quot;%p (%s) __CFRunLoopDoSource1 rls %p is invalid&quot;), CFRunLoopGetCurrent(), *_CFGetProgname(), rls); &#125;</div><div class="line">	__CFRunLoopSourceUnlock(rls);</div><div class="line">    &#125;</div><div class="line">    CFRelease(rls);</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line">    return sourceHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="source总结"><a href="#source总结" class="headerlink" title="source总结"></a>source总结</h5><p>通过对比source0和source1的处理函数发现，source0有2种情况，单个事件和事件列表，而source1只有单个事件的处理，个人理解是因为source1的事件是即时处理的，因为source1可以唤醒runloop,只要有source1事件runloop就会去处理，所有不存在处理事件列表的情况，而source0有可能只是标记为待处理而没有手动唤醒runloop,当标记为待处理source0事件后，只会被添加到mode的source0集合中，在runloop被唤醒后统一处理。</p>
<h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (isnan(interval)) &#123;</div><div class="line">        CRSetCrashLogMessage(&quot;NaN was used as an interval for a CFRunLoopTimer&quot;);</div><div class="line">        HALT;</div><div class="line">    &#125;</div><div class="line">    CFRunLoopTimerRef memory;</div><div class="line">    UInt32 size;</div><div class="line">    size = sizeof(struct __CFRunLoopTimer) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopTimerRef)_CFRuntimeCreateInstance(allocator, CFRunLoopTimerGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopTimerUnsetFiring(memory);</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_runLoop = NULL;</div><div class="line">    memory-&gt;_rlModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    if (interval &lt; 0.0) interval = 0.0;</div><div class="line">    memory-&gt;_interval = interval;</div><div class="line">    memory-&gt;_tolerance = 0.0;</div><div class="line">    </div><div class="line">    //fireDate 首次触发的绝对时间</div><div class="line">    if (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;</div><div class="line">    memory-&gt;_nextFireDate = fireDate;</div><div class="line">    memory-&gt;_fireTSR = 0ULL;</div><div class="line">    </div><div class="line">    //获取mach内核和CF内核的绝对时间</div><div class="line">    uint64_t now2 = mach_absolute_time();</div><div class="line">    CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();</div><div class="line">    </div><div class="line">    //_fireTSR为本次应触发的绝对时间点</div><div class="line">    if (fireDate &lt; now1) &#123;</div><div class="line">		memory-&gt;_fireTSR = now2;</div><div class="line">    &#125; else if (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) &#123;</div><div class="line">		memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</div><div class="line">    &#125; else &#123;</div><div class="line">		memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    memory-&gt;_callout = callout;</div><div class="line">    if (NULL != context) &#123;</div><div class="line">	if (context-&gt;retain) &#123;</div><div class="line">	    memory-&gt;_context.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">	&#125; else &#123;</div><div class="line">	    memory-&gt;_context.info = context-&gt;info;</div><div class="line">	&#125;</div><div class="line">	memory-&gt;_context.retain = context-&gt;retain;</div><div class="line">	memory-&gt;_context.release = context-&gt;release;</div><div class="line">	memory-&gt;_context.copyDescription = context-&gt;copyDescription;</div><div class="line">    &#125; else &#123;</div><div class="line">	memory-&gt;_context.info = 0;</div><div class="line">	memory-&gt;_context.retain = 0;</div><div class="line">	memory-&gt;_context.release = 0;</div><div class="line">	memory-&gt;_context.copyDescription = 0;</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    //如果是common mode直接加到_commonModeItems</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rlt);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rlt&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建timers的数组</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm) &#123;</div><div class="line">            if (NULL == rlm-&gt;_timers) &#123;</div><div class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</div><div class="line">                cb.equal = NULL;</div><div class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</div><div class="line">            &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//判断timer是否被添加到当前mode</div><div class="line">	if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</div><div class="line">            __CFRunLoopTimerLock(rlt);</div><div class="line">            if (NULL == rlt-&gt;_runLoop) &#123;</div><div class="line">		rlt-&gt;_runLoop = rl;</div><div class="line">  	    &#125; else if (rl != rlt-&gt;_runLoop) &#123;</div><div class="line">                __CFRunLoopTimerUnlock(rlt);</div><div class="line">	        __CFRunLoopModeUnlock(rlm);</div><div class="line">                __CFRunLoopUnlock(rl);</div><div class="line">		return;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    //timer将当前mode标记为已添加</div><div class="line">  	    CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            __CFRunLoopTimerFireTSRLock();</div><div class="line">            </div><div class="line">            //添加timer到mode</div><div class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</div><div class="line">            __CFRunLoopTimerFireTSRUnlock();</div><div class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</div><div class="line">                // Normally we don&apos;t do this on behalf of clients, but for</div><div class="line">                // backwards compatibility due to the change in timer handling...</div><div class="line">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</div><div class="line">            &#125;</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重新排列这个mode中的所有timer触发时刻</div><div class="line">static void __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) &#123;</div><div class="line">    if (!rlt) return;</div><div class="line">    CFMutableArrayRef timerArray = rlm-&gt;_timers;</div><div class="line">    if (!timerArray) return;</div><div class="line">    Boolean found = false;</div><div class="line">    // If we know in advance that the timer is not in the array (just being added now) then we can skip this search</div><div class="line">    if (isInArray) &#123;</div><div class="line">        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(0, CFArrayGetCount(timerArray)), rlt);</div><div class="line">        if (kCFNotFound != idx) &#123;</div><div class="line">            CFRetain(rlt);</div><div class="line">            CFArrayRemoveValueAtIndex(timerArray, idx);</div><div class="line">            found = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!found &amp;&amp; isInArray) return;</div><div class="line">    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);</div><div class="line">    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);</div><div class="line">    __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop);</div><div class="line">    if (isInArray) CFRelease(rlt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回timer需要插入的索引</div><div class="line">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) &#123;</div><div class="line">    CFIndex cnt = CFArrayGetCount(array);</div><div class="line">    if (cnt &lt;= 0) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //timer大于256 如果最后一个item的fireTSR小于待插入的timer，直接插入到最后一个位置否则如果第一个item的fireTSR大于带插入的timer,直接插入第一个位置。</div><div class="line">    if (256 &lt; cnt) &#123;</div><div class="line">        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);</div><div class="line">        if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</div><div class="line">            return cnt;</div><div class="line">        &#125;</div><div class="line">        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);</div><div class="line">        if (rlt-&gt;_fireTSR &lt; item-&gt;_fireTSR) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//二分查找一个合适的位置。</div><div class="line">    CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</div><div class="line">    CFIndex idx = 0;</div><div class="line">    Boolean lastTestLEQ;</div><div class="line">    do &#123;</div><div class="line">        add = add / 2;</div><div class="line">	lastTestLEQ = false;</div><div class="line">        CFIndex testIdx = idx + add;</div><div class="line">        if (testIdx &lt; cnt) &#123;</div><div class="line">            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);</div><div class="line">            if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</div><div class="line">                idx = testIdx;</div><div class="line">		lastTestLEQ = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; while (0 &lt; add);</div><div class="line"></div><div class="line">    return lastTestLEQ ? idx + 1 : idx;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) &#123;  </div><div class="line">  </div><div class="line">    uint64_t nextHardDeadline = UINT64_MAX;//最晚的时间点</div><div class="line">    uint64_t nextSoftDeadline = UINT64_MAX;//应该触发的时间点</div><div class="line"></div><div class="line">    if (rlm-&gt;_timers) &#123;</div><div class="line">        // Look at the list of timers. We will calculate two TSR values; the next soft and next hard deadline.</div><div class="line">        // The next soft deadline is the first time we can fire any timer. This is the fire date of the first timer in our sorted list of timers.</div><div class="line">        // The next hard deadline is the last time at which we can fire the timer before we&apos;ve moved out of the allowable tolerance of the timers in our list.</div><div class="line">        for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers , idx);</div><div class="line">            // discount timers currently firing</div><div class="line">            if (__CFRunLoopTimerIsFiring(t)) continue;</div><div class="line">            </div><div class="line">            int32_t err = CHECKINT_NO_ERROR;</div><div class="line">            </div><div class="line">            //SoftDeadline是理应触发的时间</div><div class="line">            uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR;</div><div class="line">            </div><div class="line">            //HardDeadline是理应触发的时间加上tolerance（即最晚触发时间）</div><div class="line">            uint64_t oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err);</div><div class="line">            </div><div class="line">            if (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX;</div><div class="line">            </div><div class="line">            // We can stop searching if the soft deadline for this timer exceeds the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines.</div><div class="line">            </div><div class="line">            //通过这几行代码对deadline进行修正，保证前边的长tolerance的timer不会影响后面的timer的触发</div><div class="line">            </div><div class="line">            //应触发的时间点 &gt; 下次最晚触发时间点 直接退出</div><div class="line">            if (oneTimerSoftDeadline &gt; nextHardDeadline) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //应触发的时间点 &lt; 下次最晚触发时间点 </div><div class="line">            if (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123;</div><div class="line">                nextSoftDeadline = oneTimerSoftDeadline;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //最晚触发时间点 &lt; 下次最晚触发时间点</div><div class="line">            if (oneTimerHardDeadline &lt; nextHardDeadline) &#123;</div><div class="line">                nextHardDeadline = oneTimerHardDeadline;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123;</div><div class="line">            if (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) &#123;</div><div class="line">                CFRUNLOOP_NEXT_TIMER_ARMED((unsigned long)(nextSoftDeadline - mach_absolute_time()));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">            // We&apos;re going to hand off the range of allowable timer fire date to dispatch and let it fire when appropriate for the system.</div><div class="line">            uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline);</div><div class="line">            dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline);</div><div class="line">            </div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line"></div><div class="line">				//对于有leeway的情况（有tolerance的情况），只采用_dispatch_source_set_runloop_timer_4CF的方法</div><div class="line">            if (leeway &gt; 0) &#123;</div><div class="line">                // Only use the dispatch timer if we have any leeway</div><div class="line">                // &lt;rdar://problem/14447675&gt;</div><div class="line">                </div><div class="line">                // Cancel the mk timer</div><div class="line">                if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</div><div class="line">                    AbsoluteTime dummy;</div><div class="line">                    mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</div><div class="line">                    rlm-&gt;_mkTimerArmed = false;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // Arm the dispatch timer</div><div class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</div><div class="line">                rlm-&gt;_dispatchTimerArmed = true;</div><div class="line">            &#125; else &#123;</div><div class="line">            </div><div class="line">            // 对于leeway为0的情况（无tolerance的情况）,采用mk_timer的方式</div><div class="line">                // Cancel the dispatch timer</div><div class="line">                if (rlm-&gt;_dispatchTimerArmed) &#123;</div><div class="line">                    // Cancel the dispatch timer</div><div class="line">                    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888);</div><div class="line">                    rlm-&gt;_dispatchTimerArmed = false;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // Arm the mk timer</div><div class="line">                if (rlm-&gt;_timerPort) &#123;</div><div class="line">                    mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));</div><div class="line">                    rlm-&gt;_mkTimerArmed = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">#else</div><div class="line">            _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</div><div class="line">#endif</div><div class="line">#else</div><div class="line">            if (rlm-&gt;_timerPort) &#123;</div><div class="line">                mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125; else if (nextSoftDeadline == UINT64_MAX) &#123;</div><div class="line">            // Disarm the timers - there is no timer scheduled</div><div class="line">            // 移除timer</div><div class="line">            if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</div><div class="line">                AbsoluteTime dummy;</div><div class="line">                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</div><div class="line">                rlm-&gt;_mkTimerArmed = false;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">            if (rlm-&gt;_dispatchTimerArmed) &#123;</div><div class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333);</div><div class="line">                rlm-&gt;_dispatchTimerArmed = false;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    rlm-&gt;_timerHardDeadline = nextHardDeadline;</div><div class="line">    rlm-&gt;_timerSoftDeadline = nextSoftDeadline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理timer</div><div class="line">// mode and rl are locked on entry and exit</div><div class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;	/* DOES CALLOUT */</div><div class="line">    Boolean timerHandled = false;</div><div class="line">    uint64_t oldFireTSR = 0;</div><div class="line"></div><div class="line">    /* Fire a timer */</div><div class="line">    CFRetain(rlt);</div><div class="line">    __CFRunLoopTimerLock(rlt);</div><div class="line">	</div><div class="line">	//一堆判断条件</div><div class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) &#123;</div><div class="line">        void *context_info = NULL;</div><div class="line">        void (*context_release)(const void *) = NULL;</div><div class="line">        if (rlt-&gt;_context.retain) &#123;</div><div class="line">            context_info = (void *)rlt-&gt;_context.retain(rlt-&gt;_context.info);</div><div class="line">            context_release = rlt-&gt;_context.release;</div><div class="line">        &#125; else &#123;</div><div class="line">            context_info = rlt-&gt;_context.info;</div><div class="line">        &#125;</div><div class="line">        Boolean doInvalidate = (0.0 == rlt-&gt;_interval);</div><div class="line">	__CFRunLoopTimerSetFiring(rlt);</div><div class="line">        // Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer.</div><div class="line">        </div><div class="line">        //重置应触发时间和最晚触发时间</div><div class="line">        rlm-&gt;_timerSoftDeadline = UINT64_MAX;</div><div class="line">        rlm-&gt;_timerHardDeadline = UINT64_MAX;</div><div class="line">        __CFRunLoopTimerUnlock(rlt);</div><div class="line">	__CFRunLoopTimerFireTSRLock();</div><div class="line">	oldFireTSR = rlt-&gt;_fireTSR;</div><div class="line">	__CFRunLoopTimerFireTSRUnlock();</div><div class="line"></div><div class="line">        __CFArmNextTimerInMode(rlm, rl);</div><div class="line"></div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line">	</div><div class="line">	//处理timer的回调</div><div class="line">	__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</div><div class="line">	CHECK_FOR_FORK();</div><div class="line">        if (doInvalidate) &#123;</div><div class="line">            CFRunLoopTimerInvalidate(rlt);      /* DOES CALLOUT */</div><div class="line">        &#125;</div><div class="line">        if (context_release) &#123;</div><div class="line">            context_release(context_info);</div><div class="line">        &#125;</div><div class="line">	__CFRunLoopLock(rl);</div><div class="line">	__CFRunLoopModeLock(rlm);</div><div class="line">        __CFRunLoopTimerLock(rlt);</div><div class="line">        </div><div class="line">    //timer处理成功的标记</div><div class="line">	timerHandled = true;</div><div class="line">	__CFRunLoopTimerUnsetFiring(rlt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //本次timer处理成功了 来更新一下下次的触发时间</div><div class="line">    if (__CFIsValid(rlt) &amp;&amp; timerHandled) &#123;</div><div class="line">        /* This is just a little bit tricky: we want to support calling</div><div class="line">         * CFRunLoopTimerSetNextFireDate() from within the callout and</div><div class="line">         * honor that new time here if it is a later date, otherwise</div><div class="line">         * it is completely ignored. */</div><div class="line"></div><div class="line">         //一下次的触发时间已经设置了 而且比上次的时间大 说明设置的没有问题，直接更新。</div><div class="line">        if (oldFireTSR &lt; rlt-&gt;_fireTSR) &#123;</div><div class="line">            /* Next fire TSR was set, and set to a date after the previous</div><div class="line">            * fire date, so we honor it. */</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            // The timer was adjusted and repositioned, during the</div><div class="line">            // callout, but if it was still the min timer, it was</div><div class="line">            // skipped because it was firing.  Need to redo the</div><div class="line">            // min timer calculation in case rlt should now be that</div><div class="line">            // timer instead of whatever was chosen.</div><div class="line">            </div><div class="line">            //这个函数就是更新下次触发时间的</div><div class="line">            __CFArmNextTimerInMode(rlm, rl);</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">        //没有设置下一次的触发时间，进行设置，然后更新列表</div><div class="line">	    uint64_t nextFireTSR = 0LL;</div><div class="line">            uint64_t intervalTSR = 0LL;</div><div class="line">            if (rlt-&gt;_interval &lt;= 0.0) &#123;</div><div class="line">            &#125; else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) &#123;</div><div class="line">        	intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</div><div class="line">            &#125; else &#123;</div><div class="line">        	intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval);</div><div class="line">            &#125;</div><div class="line">            if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) &#123;</div><div class="line">                nextFireTSR = LLONG_MAX;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (intervalTSR == 0) &#123;</div><div class="line">                    // 15304159: Make sure we don&apos;t accidentally loop forever here</div><div class="line">                    CRSetCrashLogMessage(&quot;A CFRunLoopTimer with an interval of 0 is set to repeat&quot;);</div><div class="line">                    HALT;</div><div class="line">                &#125;</div><div class="line">                uint64_t currentTSR = mach_absolute_time();</div><div class="line">                nextFireTSR = oldFireTSR;</div><div class="line">                while (nextFireTSR &lt;= currentTSR) &#123;</div><div class="line">                    nextFireTSR += intervalTSR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            CFRunLoopRef rlt_rl = rlt-&gt;_runLoop;</div><div class="line">            if (rlt_rl) &#123;</div><div class="line">                CFRetain(rlt_rl);</div><div class="line">		CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);</div><div class="line">		STACK_BUFFER_DECL(CFTypeRef, modes, cnt);</div><div class="line">		CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes);</div><div class="line">		// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up</div><div class="line">		// towards the run loop from a source, the timer has to be</div><div class="line">		// unlocked, which means we have to protect from object</div><div class="line">		// invalidation, although that&apos;s somewhat expensive.</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFRetain(modes[idx]);</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerUnlock(rlt);</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFStringRef name = (CFStringRef)modes[idx];</div><div class="line">		    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false);</div><div class="line">		    CFRelease(name);</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerFireTSRLock();</div><div class="line">		</div><div class="line">		//上面算了一堆就是计算一个正确的nextFireTSR，到这里已经拿到正确的值了，可以赋值。</div><div class="line">		rlt-&gt;_fireTSR = nextFireTSR;</div><div class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];</div><div class="line">		    if (rlm) &#123;</div><div class="line">		    </div><div class="line">		    //更新时间触发的列表</div><div class="line">                        __CFRepositionTimerInMode(rlm, rlt, true);</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">		__CFRunLoopTimerFireTSRUnlock();</div><div class="line">		for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">		    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);</div><div class="line">		&#125;</div><div class="line">		CFRelease(rlt_rl);</div><div class="line">	    &#125; else &#123;</div><div class="line">	    </div><div class="line">	    //timer没有加到一个runloop里面。这个timer应该不会被触发。下面也没有调整下次触发时间的操作。。。</div><div class="line">		__CFRunLoopTimerUnlock(rlt);</div><div class="line">		__CFRunLoopTimerFireTSRLock();</div><div class="line">		rlt-&gt;_fireTSR = nextFireTSR;</div><div class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</div><div class="line">		__CFRunLoopTimerFireTSRUnlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        __CFRunLoopTimerUnlock(rlt);</div><div class="line">    &#125;</div><div class="line">    CFRelease(rlt);</div><div class="line">    return timerHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="timer总结"><a href="#timer总结" class="headerlink" title="timer总结"></a>timer总结</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Runloop/runloop008.png" alt=""></p>
<ul>
<li>对于重复的NSTimer，其多次触发的时刻不是一开始算好的，而是timer触发后计算的。但是计算时参考的是上次应当触发的时间_fireTSR，因此计算出的下次触发的时刻不会有误差。</li>
<li>设置了tolerance的NSTimer，对于iOS和MacOS系统，实质上会采用GCD timer的形式注册到内核中，GCD timer触发后，再由RunLoop处理其回调逻辑。对于没有设置tolerance的timer，则是用mk_timer的形式注册。</li>
<li>RunLoopMode中timer的排序是按照_fireTSR，也就是应当触发的时间排序的。</li>
</ul>
<h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">//创建observer</div><div class="line"></div><div class="line">CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopObserverRef memory;</div><div class="line">    UInt32 size;</div><div class="line">    size = sizeof(struct __CFRunLoopObserver) - sizeof(CFRuntimeBase);</div><div class="line">    memory = (CFRunLoopObserverRef)_CFRuntimeCreateInstance(allocator, CFRunLoopObserverGetTypeID(), size, NULL);</div><div class="line">    if (NULL == memory) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    __CFSetValid(memory);</div><div class="line">    __CFRunLoopObserverUnsetFiring(memory);</div><div class="line">    if (repeats) &#123;</div><div class="line">	__CFRunLoopObserverSetRepeats(memory);</div><div class="line">    &#125; else &#123;</div><div class="line">	__CFRunLoopObserverUnsetRepeats(memory);</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</div><div class="line">    memory-&gt;_runLoop = NULL;</div><div class="line">    memory-&gt;_rlCount = 0;</div><div class="line">    memory-&gt;_activities = activities;</div><div class="line">    memory-&gt;_order = order;</div><div class="line">    memory-&gt;_callout = callout;</div><div class="line">    if (context) &#123;</div><div class="line">	if (context-&gt;retain) &#123;</div><div class="line">	    memory-&gt;_context.info = (void *)context-&gt;retain(context-&gt;info);</div><div class="line">	&#125; else &#123;</div><div class="line">	    memory-&gt;_context.info = context-&gt;info;</div><div class="line">	&#125;</div><div class="line">	memory-&gt;_context.retain = context-&gt;retain;</div><div class="line">	memory-&gt;_context.release = context-&gt;release;</div><div class="line">	memory-&gt;_context.copyDescription = context-&gt;copyDescription;</div><div class="line">    &#125; else &#123;</div><div class="line">	memory-&gt;_context.info = 0;</div><div class="line">	memory-&gt;_context.retain = 0;</div><div class="line">	memory-&gt;_context.release = 0;</div><div class="line">	memory-&gt;_context.copyDescription = 0;</div><div class="line">    &#125;</div><div class="line">    return memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//给mode添加observer</div><div class="line"></div><div class="line">void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</div><div class="line"></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    </div><div class="line">    //如果是common mode直接加到_commonModeItems</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">	if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">	&#125;</div><div class="line">	CFSetAddValue(rl-&gt;_commonModeItems, rlo);</div><div class="line">	if (NULL != set) &#123;</div><div class="line">	    CFTypeRef context[2] = &#123;rl, rlo&#125;;</div><div class="line">	    /* add new item to all common-modes */</div><div class="line">	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">	    CFRelease(set);</div><div class="line">	&#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    </div><div class="line">    //创建_observers数组</div><div class="line">	rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">	if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123;</div><div class="line">	    rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//判断是否已添加</div><div class="line">	if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123;</div><div class="line">            Boolean inserted = false;</div><div class="line">            for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123;</div><div class="line">                CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">                </div><div class="line">                //有一个排序，只有order大于已添加的observer 才会被添加到数组中</div><div class="line">                if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123;</div><div class="line">                    CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);</div><div class="line">                    inserted = true;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //添加失败直接插到第一个位置</div><div class="line">            if (!inserted) &#123;</div><div class="line">	        CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);</div><div class="line">            &#125;</div><div class="line">	    rlm-&gt;_observerMask |= rlo-&gt;_activities;</div><div class="line">	    __CFRunLoopObserverSchedule(rlo, rl, rlm);</div><div class="line">	&#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">	    __CFRunLoopModeUnlock(rlm);</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123;	/* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line"></div><div class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0;</div><div class="line">    if (cnt &lt; 1) return;</div><div class="line"></div><div class="line">    /* Fire the observers */</div><div class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1);</div><div class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * sizeof(CFRunLoopObserverRef));</div><div class="line">    CFIndex obs_cnt = 0;</div><div class="line">    </div><div class="line">    //将列表中 活动 &amp;&amp; 可用 &amp;&amp; 未处理 的observer添加到一个临时的数组中</div><div class="line">    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">        if (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123;</div><div class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    for (CFIndex idx = 0; idx &lt; obs_cnt; idx++) &#123;</div><div class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</div><div class="line">        __CFRunLoopObserverLock(rlo);</div><div class="line">        if (__CFIsValid(rlo)) &#123;</div><div class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</div><div class="line">            __CFRunLoopObserverSetFiring(rlo);</div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">            </div><div class="line">            //调用observer的回调</div><div class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info);</div><div class="line">            if (doInvalidate) &#123;</div><div class="line">                CFRunLoopObserverInvalidate(rlo);</div><div class="line">            &#125;</div><div class="line">            __CFRunLoopObserverUnsetFiring(rlo);</div><div class="line">        &#125; else &#123;</div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">        &#125;</div><div class="line">        CFRelease(rlo);</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">    if (collectedObservers != buffer) free(collectedObservers);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//给runloop添加一个block</div><div class="line"></div><div class="line">void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    </div><div class="line">    //保证mode存在</div><div class="line">    </div><div class="line">    if (CFStringGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">	mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure mode exists</div><div class="line">        CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true);</div><div class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">    &#125; else if (CFArrayGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">        CFIndex cnt = CFArrayGetCount((CFArrayRef)mode);</div><div class="line">	const void **values = (const void **)malloc(sizeof(const void *) * cnt);</div><div class="line">        CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values);</div><div class="line">	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure modes exist</div><div class="line">	for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</div><div class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	&#125;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">	free(values);</div><div class="line">    &#125; else if (CFSetGetTypeID() == CFGetTypeID(mode)) &#123;</div><div class="line">        CFIndex cnt = CFSetGetCount((CFSetRef)mode);</div><div class="line">	const void **values = (const void **)malloc(sizeof(const void *) * cnt);</div><div class="line">        CFSetGetValues((CFSetRef)mode, values);</div><div class="line">	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">	// ensure modes exist</div><div class="line">	for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</div><div class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</div><div class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">	&#125;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">	free(values);</div><div class="line">    &#125; else &#123;</div><div class="line">	mode = NULL;</div><div class="line">    &#125;</div><div class="line">    block = Block_copy(block);</div><div class="line">    </div><div class="line">    //如果mode或者block为空 直接返回</div><div class="line">    if (!mode || !block) &#123;</div><div class="line">	if (mode) CFRelease(mode);</div><div class="line">	if (block) Block_release(block);</div><div class="line">	return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //将block添加到列表中</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    struct _block_item *new_item = (struct _block_item *)malloc(sizeof(struct _block_item));</div><div class="line">    new_item-&gt;_next = NULL;</div><div class="line">    new_item-&gt;_mode = mode;</div><div class="line">    new_item-&gt;_block = block;</div><div class="line">    if (!rl-&gt;_blocks_tail) &#123;</div><div class="line">	rl-&gt;_blocks_head = new_item;</div><div class="line">    &#125; else &#123;</div><div class="line">	rl-&gt;_blocks_tail-&gt;_next = new_item;</div><div class="line">    &#125;</div><div class="line">    rl-&gt;_blocks_tail = new_item;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//处理block</div><div class="line"></div><div class="line">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</div><div class="line">    if (!rl-&gt;_blocks_head) return false;</div><div class="line">    if (!rlm || !rlm-&gt;_name) return false;</div><div class="line">    Boolean did = false;</div><div class="line">    struct _block_item *head = rl-&gt;_blocks_head;</div><div class="line">    struct _block_item *tail = rl-&gt;_blocks_tail;</div><div class="line">    rl-&gt;_blocks_head = NULL;</div><div class="line">    rl-&gt;_blocks_tail = NULL;</div><div class="line">    CFSetRef commonModes = rl-&gt;_commonModes;</div><div class="line">    CFStringRef curMode = rlm-&gt;_name;</div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    struct _block_item *prev = NULL;</div><div class="line">    struct _block_item *item = head;</div><div class="line">    </div><div class="line">    //遍历block列表</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">	Boolean doit = false;</div><div class="line">	</div><div class="line">	//当前mode是block所属的mode一样 || 当前mode是common mode且commons中包含了当前mode</div><div class="line">	if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">	    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">        &#125; else &#123;</div><div class="line">	    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">	&#125;</div><div class="line">	if (!doit) prev = curr;</div><div class="line">	if (doit) &#123;</div><div class="line">	    if (prev) prev-&gt;_next = item;</div><div class="line">	    if (curr == head) head = item;</div><div class="line">	    if (curr == tail) tail = prev;</div><div class="line">	    void (^block)(void) = curr-&gt;_block;</div><div class="line">            CFRelease(curr-&gt;_mode);</div><div class="line">            free(curr);</div><div class="line">	    if (doit) &#123;</div><div class="line">	    </div><div class="line">		    //调用block</div><div class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line">	        did = true;</div><div class="line">	    &#125;</div><div class="line">            Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line">    if (head) &#123;</div><div class="line">	tail-&gt;_next = rl-&gt;_blocks_head;</div><div class="line">	rl-&gt;_blocks_head = head;</div><div class="line">        if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;</div><div class="line">    &#125;</div><div class="line">    return did;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="block总结"><a href="#block总结" class="headerlink" title="block总结"></a>block总结</h5><ul>
<li>可以直接给runloop添加block.添加成功后，block会在下一次runloop运行时被触发。</li>
<li>block不能唤醒runloop,只会被添加到链表中，等待下一次runloop被唤醒后才会被执行。</li>
</ul>
<h3 id="Runloop实践"><a href="#Runloop实践" class="headerlink" title="Runloop实践"></a>Runloop实践</h3><h4 id="查看Main-Runloop的结构"><a href="#查看Main-Runloop的结构" class="headerlink" title="查看Main Runloop的结构"></a>查看Main Runloop的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSRunLoop *runloop = [NSRunLoop mainRunLoop];</div><div class="line">NSLog(@&quot;runloop = %@&quot;,runloop);</div></pre></td></tr></table></figure>
<h5 id="具体结构如下："><a href="#具体结构如下：" class="headerlink" title="具体结构如下："></a>具体结构如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">&lt;CFRunLoop 0x60c0001e7800 [0x10805cc80]&gt;&#123;</div><div class="line"></div><div class="line">//唤醒端口 &amp;&amp; 当前状态 &amp;&amp; 是否忽略唤醒</div><div class="line">wakeup port = 0x1803, stopped = false, ignoreWakeUps = false, </div><div class="line"></div><div class="line">//current mode</div><div class="line">current mode = kCFRunLoopDefaultMode,</div><div class="line"></div><div class="line">//common mode 包含2个子mode</div><div class="line">common modes = &lt;CFBasicHash 0x60c00004db90 [0x10805cc80]&gt;&#123;type = mutable set, count = 2,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFString 0x1093cce88 [0x10805cc80]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</div><div class="line">	2 : &lt;CFString 0x108032818 [0x10805cc80]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line">//common mode 的items(包括 timer &amp;&amp; source &amp;&amp; observer)</div><div class="line">//observer activities (0x20 == kCFRunLoopBeforeWaiting)  (0x1 == kCFRunLoopEntry) (0xa0 ==  kCFRunLoopBeforeWaiting || kCFRunLoopExit)</div><div class="line"></div><div class="line">common mode items = &lt;CFBasicHash 0x60c00004df50 [0x10805cc80]&gt;&#123;type = mutable set, count = 13,</div><div class="line">entries =&gt;</div><div class="line"></div><div class="line"></div><div class="line">	//source0 系统事件</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line"></div><div class="line">	//处理手势的通知</div><div class="line">	1 : &lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;</div><div class="line"></div><div class="line">	//autoreleasepool相关通知</div><div class="line">	2 : &lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;0x7fa8a2802048&gt;</div><div class="line">)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;0x7fa8a2802048&gt;</div><div class="line">)&#125;&#125;</div><div class="line"></div><div class="line">	//mach port source</div><div class="line">	4 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line"></div><div class="line">	//处理事件队列的source</div><div class="line">	6 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line"></div><div class="line">	//处理动画事务的通知</div><div class="line">	16 : &lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;</div><div class="line"></div><div class="line">	//mach port source </div><div class="line">	17 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line"></div><div class="line">	//CA动画提交前的通知</div><div class="line">	18 : &lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;</div><div class="line"></div><div class="line">	//处理系统事件 source0</div><div class="line">	19 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">	</div><div class="line">	//处理系统事件 source1</div><div class="line">	20 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line"></div><div class="line">	//CA动画提交后的通知</div><div class="line">	21 : &lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;</div><div class="line"></div><div class="line">	//Front Board Services(前台服务)</div><div class="line">	22 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line"></div><div class="line">modes = &lt;CFBasicHash 0x60c00004dbc0 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line"></div><div class="line"></div><div class="line">	//UITrackingRunLoopMode 的 items</div><div class="line"></div><div class="line">	2 : &lt;CFRunLoopMode 0x60c0001869a0 [0x10805cc80]&gt;&#123;name = UITrackingRunLoopMode, port set = 0x1c03, queue = 0x60c000141e40, source = 0x60c000186a70 (not fired), timer port = 0x5403, </div><div class="line"></div><div class="line">	//source0</div><div class="line"></div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004dfb0 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line">	4 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">	5 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line"></div><div class="line">	//source1</div><div class="line"></div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004dfe0 [0x10805cc80]&gt;&#123;type = mutable set, count = 3,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line">	1 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	//observer</div><div class="line"></div><div class="line">	observers = (</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;</div><div class="line">),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290423333420) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//GSEventReceiveRunLoopMode 接受系统事件的内部 Mode</div><div class="line">	3 : &lt;CFRunLoopMode 0x60c000186b40 [0x10805cc80]&gt;&#123;name = GSEventReceiveRunLoopMode, port set = 0x5203, queue = 0x60c000141ef0, source = 0x60c000186c10 (not fired), timer port = 0x5103, </div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004e070 [0x10805cc80]&gt;&#123;type = mutable set, count = 1,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004e0a0 [0x10805cc80]&gt;&#123;type = mutable set, count = 1,</div><div class="line">entries =&gt;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167bc0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	observers = (null),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290424620943) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//kCFRunLoopDefaultMode</div><div class="line"></div><div class="line">	4 : &lt;CFRunLoopMode 0x60c000186660 [0x10805cc80]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x2503, queue = 0x60c000141ce0, source = 0x60c000186730 (not fired), timer port = 0x2303, </div><div class="line">	sources0 = &lt;CFBasicHash 0x60c00004e010 [0x10805cc80]&gt;&#123;type = mutable set, count = 4,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000167a40 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10cf0675a)&#125;&#125;</div><div class="line">	3 : &lt;CFRunLoopSource 0x604000167ec0 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c000141fa0, callout = __handleEventQueue (0x108b67bb2)&#125;&#125;</div><div class="line">	4 : &lt;CFRunLoopSource 0x6040001687c0 [0x10805cc80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6040000a8d00, callout = FBSSerialQueueRunLoopSourceHandler (0x10c67182f)&#125;&#125;</div><div class="line">	5 : &lt;CFRunLoopSource 0x604000167e00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60c00004e400, callout = __handleHIDEventFetcherDrain (0x108b67bbe)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	sources1 = &lt;CFBasicHash 0x60c00004e040 [0x10805cc80]&gt;&#123;type = mutable set, count = 3,</div><div class="line">entries =&gt;</div><div class="line">	0 : &lt;CFRunLoopSource 0x60c000168b80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22787, subsystem = 0x10939e668, context = 0x60000003adc0&#125;&#125;</div><div class="line">	1 : &lt;CFRunLoopSource 0x604000167f80 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 14599, subsystem = 0x109383fe8, context = 0x0&#125;&#125;</div><div class="line">	2 : &lt;CFRunLoopSource 0x60c000167b00 [0x10805cc80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2c03, callout = PurpleEventCallback (0x10cf08bf7)&#125;&#125;</div><div class="line">&#125;</div><div class="line">,</div><div class="line">	observers = (</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122940 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x608000122bc0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x1087f06b3), context = &lt;CFRunLoopObserver context 0x6080000dfa30&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122a80 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x108239da1), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122b20 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10dd374ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x604000122800 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x108239e1c), context = &lt;CFRunLoopObserver context 0x7fa8a3100000&gt;&#125;&quot;,</div><div class="line">    &quot;&lt;CFRunLoopObserver 0x6040001226c0 [0x10805cc80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10820ad92), context = &lt;CFArray 0x604000044890 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fa8a2802048&gt;\n)&#125;&#125;&quot;</div><div class="line">),</div><div class="line">	timers = &lt;CFArray 0x6080000aa5c0 [0x10805cc80]&gt;&#123;type = mutable-small, count = 1, values = (</div><div class="line">	0 : &lt;CFRunLoopTimer 0x600000168ac0 [0x10805cc80]&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 558352446 (1.35804296 @ 30291784384812), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x106e7e849 / 0x1086fb31b) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/UIKit.framework/UIKit), context = &lt;CFRunLoopTimer context 0x600000076700&gt;&#125;</div><div class="line">)&#125;,</div><div class="line">	currently 558352445 (30290424667708) / soft deadline in: 1.35971708 sec (@ 30291784384812) / hard deadline in: 1.35971705 sec (@ 30291784384812)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">	//kCFRunLoopCommonModes</div><div class="line">	5 : &lt;CFRunLoopMode 0x60c000186e80 [0x10805cc80]&gt;&#123;name = kCFRunLoopCommonModes, port set = 0x420b, queue = 0x60c000142520, source = 0x60c000186db0 (not fired), timer port = 0x350b, </div><div class="line">	sources0 = (null),</div><div class="line">	sources1 = (null),</div><div class="line">	observers = (null),</div><div class="line">	timers = (null),</div><div class="line">	currently 558352445 (30290426387800) / soft deadline in: 1.84467138e+10 sec (@ -1) / hard deadline in: 1.84467138e+10 sec (@ -1)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer"><a href="#给系统mode添加自定义items-timer-amp-amp-source-amp-amp-observer" class="headerlink" title="给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)"></a>给系统mode添加自定义items(timer &amp;&amp; source &amp;&amp; observer)</h4><p>为了方便观察添加是否成功，我们不在主线程的runloop中添加，自定义一个新的线程。</p>
<h5 id="添加Custom-Input-Source注意事项"><a href="#添加Custom-Input-Source注意事项" class="headerlink" title="添加Custom Input Source注意事项"></a>添加Custom Input Source注意事项</h5><ul>
<li>custom input source 默认状态为不处理，需要手动唤醒，手动唤醒需要先标记为待处理状态，每次runloop处理完后状态会被置回不处理。</li>
<li>在子线程添加source需要在runloop run的代码之前添加，因为run后该线程会马上休眠（当前runloop中没有能唤醒自己的source）,不再这行run后面的代码。</li>
</ul>
<h5 id="添加Mach-Port-Input-Source注意事项"><a href="#添加Mach-Port-Input-Source注意事项" class="headerlink" title="添加Mach Port Input Source注意事项"></a>添加Mach Port Input Source注意事项</h5><ul>
<li>需要同时记录主线程端口和子线程端口号，需要唤醒对应线程时直接使用该端口发送消息即可，不需要像Custom Input Source那样做标记。</li>
</ul>
<h4 id="给runloop添加自定义mode和items"><a href="#给runloop添加自定义mode和items" class="headerlink" title="给runloop添加自定义mode和items"></a>给runloop添加自定义mode和items</h4><ul>
<li>需要注意的是不能直接调用run这个方法，因为这个方法是运行在DefaultMode下的，不会触发自定义mode中的source,需要调用runMode:beforeDate方法开启runloop.</li>
</ul>
<p><a href="https://github.com/lilingyu0620/LLYRunloopDemo.git" target="_blank" rel="noopener">这里是demo</a></p>
<h4 id="Runloop在iOS中的应用"><a href="#Runloop在iOS中的应用" class="headerlink" title="Runloop在iOS中的应用"></a>Runloop在iOS中的应用</h4><p>这块直接看YY博客吧，已经没法再补充更多了。。。</p>
<p>博客链接<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></p>
<h4 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h4><p>Runloop是一个事件处理的循环。Runloop的目标是让线程在有事情做的时候保持忙碌、没有事情做的时候保持睡眠。</p>
<p>Runloop使用Mach内核实现线程的睡眠，通过Source和Timer来唤醒线程，Source和Timer最终都是通过Mach Port来唤醒的线程。</p>
<p>Source有CustomSource和Mach Port Source2种，CustomSource唤醒线程前需要先被标注为待处理，MachPortSource则直接使用端口号发送唤醒消息。</p>
<p>Timer有两种实现方式分别是MK_Timer和GCD Timer,在runloop中Timer被转为了一个存了触发时间的列表，这个触发时间是一个绝对时间，会按时间大小升序排序，在最小的时间被触发后，Runloop会更新列表保证时间始终是升序排列。如果Runloop在某次运行中阻塞了很长时间，Timer的触发会受到影响。过期的时间点会被移除而不会去触发。</p>
<p>Runloop的状态都可以通过添加Observer来得到。Observer在Runloop中是按order优先级升序排序的，排在前面的通知会先被触发（order越小优先级反而越高）。</p>
<p>Mode表示当前Runloop运行在哪个模式上，Runloop必须运行在一种Mode上，Runloop在创建时会有一个DefaultMode,可以通过runmode：beforeDate 切换Runloop当前运行的Mode。</p>
<p>Mode中包含了上面的Source,Timer和Observer三种Items。Runloop运行的时候其实就是在处理这些Items中的内容，如果这三种Items都没有要处理的内容，Runloop就要开始睡了,而当Mode的items为空时，当前Runloop会退出。</p>
<p>CommonMode不是一种真正的Mode,它是一个所有Mode的集合，如果把上面三种Items添加到CommonMode,那这些Items会被添加到集合中所有的Mode中。所以添加到CommonMode中Items,不管当前Runloop运行在哪种Mode上，Items中需要处理的事件都会被触发。（前提是这个Mode已经被添加到了CommonMode集合中）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/22/h-256与h-264的对比/" itemprop="url">
                  h.256与h.264的对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-22T17:35:46+08:00" content="2018-08-22">
              2018-08-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/22/h-256与h-264的对比/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/22/h-256与h-264的对比/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="h-256与h-264的对比"><a href="#h-256与h-264的对比" class="headerlink" title="h.256与h.264的对比"></a>h.256与h.264的对比</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265001.png" alt=""></p>
<h4 id="h-264的技术局限在哪里？"><a href="#h-264的技术局限在哪里？" class="headerlink" title="h.264的技术局限在哪里？"></a>h.264的技术局限在哪里？</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265002.png" alt=""></p>
<h4 id="h-265的优势在哪里"><a href="#h-265的优势在哪里" class="headerlink" title="h.265的优势在哪里"></a>h.265的优势在哪里</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265003.png" alt=""></p>
<h4 id="h-265关键技术"><a href="#h-265关键技术" class="headerlink" title="h.265关键技术"></a>h.265关键技术</h4><h5 id="四叉树编码结构"><a href="#四叉树编码结构" class="headerlink" title="四叉树编码结构"></a>四叉树编码结构</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265004.png" alt=""></p>
<ul>
<li>宏块的划分方式：</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265005.png" alt=""></p>
<ul>
<li>四叉树结构</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265006.png" alt=""></p>
<ul>
<li>实例</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265007.png" alt=""></p>
<h5 id="帧内和帧间预测"><a href="#帧内和帧间预测" class="headerlink" title="帧内和帧间预测"></a>帧内和帧间预测</h5><ul>
<li>帧内预测</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265008.png" alt=""></p>
<ul>
<li>帧间预测</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265009.png" alt=""></p>
<h5 id="环路滤波"><a href="#环路滤波" class="headerlink" title="环路滤波"></a>环路滤波</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265010.png" alt=""></p>
<h5 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265011.png" alt=""></p>
<h5 id="细粒度slice分块边界"><a href="#细粒度slice分块边界" class="headerlink" title="细粒度slice分块边界"></a>细粒度slice分块边界</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265012.png" alt=""></p>
<h4 id="h-264与h-265数据比对"><a href="#h-264与h-265数据比对" class="headerlink" title="h.264与h.265数据比对"></a>h.264与h.265数据比对</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/h-256与h-264的对比/h265013.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/09/HLS协议详解/" itemprop="url">
                  HLS协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-09T15:54:42+08:00" content="2018-08-09">
              2018-08-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/09/HLS协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/09/HLS协议详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HLS协议详解"><a href="#HLS协议详解" class="headerlink" title="HLS协议详解"></a>HLS协议详解</h3><p>HLS （HTTP Live Streaming）, 是由 Apple 公司实现的基于 HTTP 的媒体流传输协议。Apple 的全系列产品支持，由于 HLS 是苹果提出的， 所以在 Apple 的全系列产品包括 iphone、 ipad、safari 都不需要安装任何插件就可以原生支持播放 HLS， 现在Android 也加入了对 HLS 的支持。但PC端目前除了Microsoft Edge外，Chrome、Firefox等浏览器均不支持该协议的播放。</p>
<p>HLS跟 DASH 协议的原理非常类似，<strong>通过将整条流切割成一个小的可以通过 HTTP 下载的媒体文件，然后提供一个配套的媒体列表文件给客户端，让客户端顺序地拉取这些媒体文件播放, 来实现看上去是在播放一条流的效果。</strong> HLS 目前广泛地应用于点播和直播领域</p>
<h4 id="HLS-的优势"><a href="#HLS-的优势" class="headerlink" title="HLS 的优势"></a>HLS 的优势</h4><ul>
<li><p>客户端支持简单，只需要支持 HTTP 请求即可，HTTP 协议无状态，只需要按顺序下载媒体片段即可。</p>
</li>
<li><p>使用 HTTP 协议网络兼容性好， HTTP 数据包也可以方便地通过防火墙或者代理服务器，CDN 支持良好。</p>
</li>
<li><p>自带多码率自适应，Apple 在提出 HLS 时，就已经考虑了码率自适应的问题。</p>
</li>
</ul>
<h4 id="HLS-的劣势"><a href="#HLS-的劣势" class="headerlink" title="HLS 的劣势"></a>HLS 的劣势</h4><ul>
<li><p>相比 RTMP 这类长连接协议，延时较高，难以用到互动直播场景。</p>
</li>
<li><p>对于点播服务来说，由于 TS 切片通常较小，海量碎片在文件分发、一致性缓存、存储等方面都有较大挑战。</p>
</li>
</ul>
<h3 id="协议详解"><a href="#协议详解" class="headerlink" title="协议详解"></a>协议详解</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/hls01.png" alt=""></p>
<p>上图可以看出，HLS总共有三个部分: Serve、CDN、Client。HLS 协议的主要内容是关于 M3U8 这个文本协议，其实生成与解析都非常简单，示例如下：</p>
<p>简单的Media Playlist:</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/hls02.png" alt=""></p>
<p>包含多种比特率的 Master Playlist:</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/hls03.png" alt=""></p>
<ul>
<li>HLS 通过 URI(RFC3986) 指向的一个 Playlist 来表示一个媒体流.</li>
<li>一个 Playlist 可以是一个 Media Playlist 或者 Master Playlist, 使用 UTF-8 编码的文本文件, 包含一些 URI 跟描述性的 tags.</li>
<li>一个 Media Playlist 包含一个 Media Segments 列表,当顺序播放时, 能播放整个完整的流.</li>
<li>要想播放这个 Playlist, 客户端需要首先下载他, 然后播放里面的每一个 Media Segment.</li>
<li>更加复杂的情况是, Playlist 是一个 Master Playlist, 包含一个 Variant Stream 集合, 通常每个 Variant Stream 里面是同一个流的多个不同版本(如: 分辨率, 码率不同).</li>
</ul>
<h4 id="HLS-Media-Segments"><a href="#HLS-Media-Segments" class="headerlink" title="HLS Media Segments"></a>HLS Media Segments</h4><ul>
<li>每一个 Media Segment 通过一个 URI 指定, 可能包含一个 byte range.</li>
<li>每一个 Media Segment 的 duration 通过 EXTINF tag 指定.</li>
<li>每一个 Media Segment 有一个唯一的整数 Media Segment Number.</li>
<li>有些媒体格式需要一个 format-specific sequence 来初始化一个 parser, 在 Media Segment 被 parse 之前. 这个字段叫做 Media Initialization Section, 通过 EXT-X-MAP tag 来指定. </li>
</ul>
<h4 id="支持的Media-Segment格式"><a href="#支持的Media-Segment格式" class="headerlink" title="支持的Media Segment格式"></a>支持的Media Segment格式</h4><h5 id="MPEG-2-Transport-Streams"><a href="#MPEG-2-Transport-Streams" class="headerlink" title="MPEG-2 Transport Streams"></a>MPEG-2 Transport Streams</h5><ul>
<li>即最常见的 TS 文件.</li>
<li>RFC: ISO_13818.</li>
<li>Media Initialization Section: PAT(Program Association Table) 跟 PMT(Program Map Table).</li>
<li>每个 TS segment 必须值含一个 MPEG-2 Program.</li>
<li>每个 TS segment 包含一个 PAT 和 PMT, 最好在 segment 的开始处, 或者通过一个 EXT-X-MAP tag 来指定.</li>
</ul>
<h5 id="Fragmented-MPEG-4"><a href="#Fragmented-MPEG-4" class="headerlink" title="Fragmented MPEG-4"></a>Fragmented MPEG-4</h5><ul>
<li>即常提到的 fMP4.</li>
<li>RFC: ISOBMFF.</li>
<li>Media Initialization Section: ftyp box(包含一个高于 ios6 的 brand), ftyp box 必须紧跟在 moov box 之后. moov box 必须包含一个 trak box(对于每个 fMP4 segment 里面的 traf box, 包含匹配的 track_ID). 每个 trak box 应该包含一个 sample table, 但是他的 sample count 必须为 0. mvhd box 跟 tkhd 的 duration 必须为 0. mvex box 必须跟在上一个 trak box 后面.</li>
<li>不像普通的 MP4 文件包含一个 moov box(包含 sample tables) 和一个 mdat box(包含对应的 samples), 一个 fMP4 包含一个 moof box (包含 sample table 的子集), 和一个 mdat box(包含对应的 samples).</li>
<li>在每一个 fMP4 segment 里面, 每一个 traf box 必须包含一个 tfdt box, fMP4 segment 必须使用 movie-fragment relative addressing. fMP4 segments 绝对不能使用外部的 data references.</li>
<li>每一个 fMP4 segment 必须有一个 EXT-X-MAP tag.</li>
</ul>
<h5 id="Packed-Audio"><a href="#Packed-Audio" class="headerlink" title="Packed Audio"></a>Packed Audio</h5><ul>
<li>一个 Packed Audio Segment 包含编码的 audio samples 和 ID3 tags. 简单的打包到一起, 包含最小的 framing, 并且没有 per-sample timestamp.</li>
<li>支持的 Packed Audio: AAC with ADTS framing [ISO_13818_7], MP3 [ISO_13818_3], AC-3 [AC_3], Enhanced AC-3 [AC_3].</li>
<li>一个 Packed Audio Segment 没有 Media Initialization Section.</li>
<li>每一个 Packed Audio Segment 必须在他的第一个 sample 指定 timestamp 通过一个 ID3 PRIV tag.</li>
<li>ID3 PRIV owner identifier 必须是 com.apple.streaming.transportStreamTimestamp.</li>
<li>ID3 payload 必须是一个 33-bit MPEG-2 Program Elementary Stream timestamp 的大端 eight-octet number, 高 31 为设置为 0.</li>
</ul>
<h5 id="WebVTT"><a href="#WebVTT" class="headerlink" title="WebVTT"></a>WebVTT</h5><ul>
<li>一个 WebVTT Segment 是一个 WebVTT 文件的一个 section, WebVTT Segment 包含 subtitles.</li>
<li>Media Initialization Section: WebVTT header.</li>
<li>每一个 WebVTT Segment 必须有以一个 WebVTT header 开始, 或者有一个 EXT-X-MAP tag 来指定.</li>
<li>每一个 WebVTT header 应该有一个 X-TIMESTAMP-MAP 来保证音视频同步.</li>
</ul>
<h4 id="HLS-Playlists"><a href="#HLS-Playlists" class="headerlink" title="HLS Playlists"></a>HLS Playlists</h4><ul>
<li>Playlist 文件的格式是起源于 M3U, 并且继承两个 tag: EXTM3U 和 EXTINF</li>
<li>下面的 tags 通过 BNF-style 语法来指定.</li>
<li>一个 Playlist 文件必须通过 URI(.m3u8 或 m3u) 或者 HTTP Content-Type 来识别(application/vnd.apple.mpegurl 或 audio/mpegurl).</li>
<li>换行符可以用 \n 或者 \r\n.</li>
<li>以 # 开头的是 tag 或者注释, 以 #EXT 开头的是 tag, 其余的为注释, 在解析时应该忽略.</li>
<li>Playlist 里面的 URI 可以用绝对地址或者相对地址, 如果使用相对地址, 那么是相对于 Playlist 文件的地址.</li>
</ul>
<h5 id="Attribute-Lists"><a href="#Attribute-Lists" class="headerlink" title="Attribute Lists"></a>Attribute Lists</h5><ul>
<li>有的 tags 的值是 Attribute Lists.</li>
<li>一个 Attribute List 是一个用逗号分隔的 attribute/value 对列表.</li>
<li>格式为: AttributeName=AttributeValue.</li>
</ul>
<h5 id="Basic-Tags"><a href="#Basic-Tags" class="headerlink" title="Basic Tags"></a>Basic Tags</h5><p>Basic Tags 可以用在 Media Playlist 和 Master Playlist 里面.</p>
<ul>
<li>EXTM3U: 必须在文件的第一行, 标识是一个 Extended M3U Playlist 文件.</li>
<li>EXT-X-VERSION: 表示 Playlist 兼容的版本.</li>
</ul>
<h5 id="Media-Segment-Tags"><a href="#Media-Segment-Tags" class="headerlink" title="Media Segment Tags"></a>Media Segment Tags</h5><p>每一个 Media Segment 通过一系列的 Media Segment tags 跟一个 URI 来指定. 有的 Media Segment tags 只应用与下一个 segment, 有的则是应用所有下面的 segments. 一个 Media Segment tag 只能出现在 Media Playlist 里面.</p>
<ul>
<li>EXTINF: 用于指定 Media Segment 的 duration</li>
<li>EXT-X-BYTERANGE: 用于指定 URI 的 sub-range</li>
<li>EXT-X-DISCONTINUITY: 表示不连续.</li>
<li>EXT-X-KEY: 表示 Media Segment 已加密, 该值用于解密.</li>
<li>EXT-X-MAP: 用于指定 Media Initialization Section.</li>
<li>EXT-X-PROGRAM-DATE-TIME: 和 Media Segment 的第一个 sample 一起来确定时间戳.</li>
<li>EXT-X-DATERANGE: 将一个时间范围和一组属性键值对结合到一起.</li>
</ul>
<h5 id="Media-Playlist-Tags"><a href="#Media-Playlist-Tags" class="headerlink" title="Media Playlist Tags"></a>Media Playlist Tags</h5><p>Media Playlist tags 描述 Media Playlist 的全局参数. 同样地, Media Playlist tags 只能出现在 Media Playlist 里面.</p>
<ul>
<li>EXT-X-TARGETDURATION: 用于指定最大的 Media Segment duration.</li>
<li>EXT-X-MEDIA-SEQUENCE: 用于指定第一个 Media Segment 的 Media Sequence Number.</li>
<li>EXT-X-DISCONTINUITY-SEQUENCE: 用于不同 Variant Stream 之间同步.</li>
<li>EXT-X-ENDLIST: 表示结束.</li>
<li>EXT-X-PLAYLIST-TYPE: 可选, 指定整个 Playlist 的类型.</li>
<li>EXT-X-I-FRAMES-ONLY: 表示每个 Media Segment 描述一个单一的 I-frame.</li>
</ul>
<h5 id="Master-Playlist-Tags"><a href="#Master-Playlist-Tags" class="headerlink" title="Master Playlist Tags"></a>Master Playlist Tags</h5><p>Master Playlist tags 定义 Variant Streams, Renditions 和 其他显示的全局参数. Master Playlist tags 只能出现在 Master Playlist 中.</p>
<ul>
<li>EXT-X-MEDIA: 用于关联同一个内容的多个 Media Playlist 的多种 renditions.</li>
<li>EXT-X-STREAM-INF: 用于指定一个 Variant Stream.</li>
<li>EXT-X-I-FRAME-STREAM-INF: 用于指定一个 Media Playlist 包含媒体的 I-frames.</li>
<li>EXT-X-SESSION-DATA: 存放一些 session 数据.</li>
<li>EXT-X-SESSION-KEY: 用于解密.</li>
</ul>
<h5 id="Media-or-Master-Playlist-Tags"><a href="#Media-or-Master-Playlist-Tags" class="headerlink" title="Media or Master Playlist Tags"></a>Media or Master Playlist Tags</h5><p>这里的 tags 可以出现在 Media Playlist 或者 Master Playlist 中. 但是如果同时出现在同一个 Master Playlist 和 Media Playlist 中时, 必须为相同值.</p>
<ul>
<li>EXT-X-INDEPENDENT-SEGMENTS: 表示每个 Media Segment 可以独立解码.</li>
<li>EXT-X-START: 标识一个优选的点来播放这个 Playlist.</li>
</ul>
<h3 id="服务器端与客户端逻辑"><a href="#服务器端与客户端逻辑" class="headerlink" title="服务器端与客户端逻辑"></a>服务器端与客户端逻辑</h3><p>以下流程仅供参考, 其实不同的播放器客户端以及服务器端的拉取规则都有很多细节差异.</p>
<h4 id="服务器端逻辑"><a href="#服务器端逻辑" class="headerlink" title="服务器端逻辑"></a>服务器端逻辑</h4><ul>
<li>将媒体源切片成 Media Segment, 应该优先从可以高效解码的时间点来进行切片(如: I-frame).</li>
<li>为每一个 Media Segment 生成 URI.</li>
<li>Server 需要支持 “gzip” 方式压缩文本内容.</li>
<li>创建一个 Media Playlist 索引文件, EXT-X-VERSION 不要高于他需要的版本, 来提供更好的兼容性.</li>
<li>Server 不能随便修改 Media Playlist, 除了 Append 文本到文件末尾, 按顺序移除 Media Segment URIs, 增长 EXT-X-MEDIA-SEQUENCE 和 EXT-X-DISCONTINUITY-SEQUENCE, 添加 EXT-X-ENDLIST 到文件尾.</li>
<li>在最后添加 EXT-X-ENDLIST tag, 来减少 Client reload Playlist 的次数.</li>
<li>注意点播与直播服务器不同的地方是, 直播的 m3u8 文件会不断更新, 而点播的 m3u8 文件是不会变的, 只需要客户端在开始时请求一次即可.</li>
</ul>
<h4 id="客户端逻辑"><a href="#客户端逻辑" class="headerlink" title="客户端逻辑"></a>客户端逻辑</h4><ul>
<li>客户端通过 URI 获取 Playlist. 如果是 Master Playlist, 客户端可以选择一个 Variant Stream 来播放.</li>
<li>客户端检查 EXT-X-VERSION 版本是否满足.</li>
<li>客户端应该忽略不可识别的 tags, 忽略不可识别的属性键值对.</li>
<li>加载 Media Playlist file.</li>
<li>播放 Media Playlist file.</li>
<li>重加载 Media Playlist file.</li>
<li>决定下一次要加载的 Media Segment.</li>
</ul>
<h3 id="HLS优化技术"><a href="#HLS优化技术" class="headerlink" title="HLS优化技术"></a>HLS优化技术</h3><p>由于客户端每次请求 TS 或 M3U8 有可能都是一个新的连接请求，所以,我们无法有效的标识客户端，一旦出现问题，基本无法有效的定位问题，因此一般工业级的服务器都会对传统的 HLS 做一些改进。</p>
<h4 id="302"><a href="#302" class="headerlink" title="302"></a>302</h4><p>首先在客户端第一次进行拉流请求的时候，服务器会做一个302的跳转。</p>
<h4 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h4><p>在302跳转后产生的新的url上，服务器会给url加上一个uuid，用来定位可能的问题。</p>
<h3 id="TS文件详解"><a href="#TS文件详解" class="headerlink" title="TS文件详解"></a>TS文件详解</h3><p>m3u8只是一个传输格式，一个典型的m3u8文件，最终的音视频数据流都是封装在.ts文件中，ts文件的全称是<strong>MPEG-2 Transport Streams</strong>，下面来分析一下这个文件的具体结构。</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>视频编码主要格式是h264/mpeg4,音频编码格式主要是acc/mp3</p>
<p>ts文件分为三层：</p>
<ul>
<li>ts(TransportStream)主要是音视频数据</li>
<li>pes(PacketElementalStream)在音视频数据（ts）上加了时间戳等数据说明信息</li>
<li>es(ElementaryStream)在（pes）上加入数据流的识别和传输必须信息</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/hlsts.png" alt=""></p>
<p>下面来分析一下每一层具体的格式。</p>
<h4 id="ts-TransportStream"><a href="#ts-TransportStream" class="headerlink" title="ts(TransportStream)"></a>ts(TransportStream)</h4><p>ts数据大小固定为188个字节，ts又分为三个组成部分，分别是 <strong>ts header</strong>,<strong>adaptation field</strong>和<strong>payload</strong>.<br>其中ts header固定为4个字节，adaptation field可能存在也可能不存在，主要作用是给不足188字节的数据做填充，payload是pes数据。</p>
<h5 id="ts-header"><a href="#ts-header" class="headerlink" title="ts header"></a>ts header</h5><p>ts header中包含一下字段：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/hlstsheader.png" alt=""></p>
<p>ts层的内容是通过<strong>pid</strong>值来标识的，主要内容包括：PAT表、PMT表、音频流、视频流。解析ts流要先找到PAT表，只要找到PAT就可以找到PMT，然后就可以找到音视频流了。<strong>PAT表的pid值固定为0</strong>。PAT表和PMT表需要定期插入ts流，因为用户随时可能加入ts流，这个间隔比较小，通常每隔几个视频帧就要加入PAT和PMT。PAT和PMT表是必须的，还可以加入其它表如SDT（业务描述表）等，不过hls流只要有PAT和PMT就可以播放了。</p>
<h5 id="adaptation-field"><a href="#adaptation-field" class="headerlink" title="adaptation field"></a>adaptation field</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/tsadaptation.png" alt=""></p>
<p>自适应区的长度要包含传输错误指示符标识的一个字节。pcr是节目时钟参考，pcr、dts、pts都是对同一个系统时钟的采样值，pcr是递增的，因此可以将其设置为dts值，音频数据不需要pcr。如果没有字段，ipad是可以播放的，但vlc无法播放。打包ts流时PAT和PMT表是没有adaptation field的，不够的长度直接补0xff即可。视频流和音频流都需要加adaptation field，通常加在一个帧的第一个ts包和最后一个ts包里，中间的ts包不加。</p>
<h5 id="PAT-amp-PMT"><a href="#PAT-amp-PMT" class="headerlink" title="PAT &amp; PMT"></a>PAT &amp; PMT</h5><p>这2个类型都是ts的一种，通过pid来区分。</p>
<p><strong>PAT主要的作用就是指明了PMT表的pid值</strong>，下图是PAT包含的字段：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/tspat.png" alt=""></p>
<p><strong>PMT主要的作用就是指明了音视频流的pid值</strong>，下图是PMT包含的字段：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/tspmt.png" alt=""></p>
<h4 id="pes-PacketElementalStream"><a href="#pes-PacketElementalStream" class="headerlink" title="pes(PacketElementalStream)"></a>pes(PacketElementalStream)</h4><p>pes层是在每一个视频/音频帧上加入了时间戳等信息，pes包内容很多，我们只留下最常用的字段，如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/hlspes.png" alt=""></p>
<p><strong>pts是显示时间戳</strong>、<strong>dts是解码时间戳</strong>，视频数据两种时间戳都需要，音频数据的pts和dts相同，所以只需要pts。<strong>有pts和dts两种时间戳是B帧引起的</strong>，I帧和P帧的pts等于dts。如果一个视频没有B帧，则pts永远和dts相同。从文件中顺序读取视频帧，取出的帧顺序和dts顺序相同。dts算法比较简单，初始值 + 增量即可，pts计算比较复杂，需要在dts的基础上加偏移量。</p>
<p>音频的pes中只有pts（同dts），视频的I、P帧两种时间戳都要有，视频B帧只要pts（同dts）。打包pts和dts就需要知道视频帧类型，但是通过容器格式我们是无法判断帧类型的，必须解析h.264内容才可以获取帧类型。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/HLS/ptsdts.png" alt=""></p>
<p>点播视频dts算法：</p>
<p>dts = 初始值 + 90000 / video_frame_rate，初始值可以随便指定，但是最好不要取0，video_frame_rate就是帧率，比如23、30。</p>
<p>pts和dts是以timescale为单位的，1s = 90000 time scale , 一帧就应该是90000/video_frame_rate 个timescale。</p>
<p>用一帧的timescale除以采样频率就可以转换为一帧的播放时长</p>
<p>点播音频dts算法：</p>
<p>dts = 初始值 + (90000 <em> audio_samples_per_frame) / audio_sample_rate，audio_samples_per_frame这个值与编解码相关，aac取值1024，mp3取值1158，audio_sample_rate是采样率，比如24000、41000。AAC一帧解码出来是每声道1024个sample，也就是说一帧的时长为1024/sample_rate秒。所以每一帧时间戳依次0，1024/sample_rate，…，1024</em>n/sample_rate秒。</p>
<p>直播视频的dts和pts应该直接用直播数据流中的时间，不应该按公式计算。</p>
<h4 id="es-ElementaryStream"><a href="#es-ElementaryStream" class="headerlink" title="es(ElementaryStream)"></a>es(ElementaryStream)</h4><p>es层指的就是音视频数据，我们只介绍h.264视频和aac音频。</p>
<h5 id="h-264"><a href="#h-264" class="headerlink" title="h.264"></a>h.264</h5><p>打包h.264数据我们必须给视频数据加上一个nalu（Network Abstraction Layer unit），nalu包括nalu header和nalu type，nalu header固定为0x00000001（帧开始）或0x000001（帧中）。h.264的数据是由slice组成的，slice的内容包括：视频、sps、pps等。nalu type决定了后面的h.264数据内容。</p>
<p>对h264格式不太了解可以参考<a href="http://llyblog.com/2017/03/16/H-264文件结构学习笔记/" target="_blank" rel="noopener">h.264文件结构学习笔记</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/20/UIViewController的内存泄露检测实践/" itemprop="url">
                  UIViewController的内存泄露检测实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-20T11:02:55+08:00" content="2018-07-20">
              2018-07-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/20/UIViewController的内存泄露检测实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/20/UIViewController的内存泄露检测实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>内存泄露在性能优化中一直是一个老生常谈的问题，而且最常出现在UIViewController的使用过程中。一般当VC退出UI堆栈后，如果使用过的内存没有被释放，就会产生内存泄露。所以在使用UIViewController的时候需要特别注意。</p>
<h3 id="内存泄露原理及解决方案"><a href="#内存泄露原理及解决方案" class="headerlink" title="内存泄露原理及解决方案"></a>内存泄露原理及解决方案</h3><p>一般在VC中出现内存泄露主要原理是产生了循环引用导致内存得不到释放，而循环引用产生的主要case大概了以下三种情况：</p>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>在使用NSTimer的时候一般会把target设置为self，而timer本身又是self的成员变量，这样就会产生循环引用的问题。</p>
<p>打破循环的方式是在VC退出时停掉timer并将timer成员变量置空。</p>
<h4 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h4><p>delegate产生循环引用的原理和timer类同，一般我们会将delegate修饰为weak来打破循环</p>
<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>block也是最容易产生循环引用的地方，稍不注意就会造成内存泄露。所以在使用block的时候也需要格外留神。block产生循环引用的原理主要还得从它的内存说起，这里不细说（网上讲这个case的情况不要太多）。</p>
<p>有2中方法可以打破block的循环引用：</p>
<ol>
<li>使用weak修饰self</li>
<li>使用__block修饰self，在block内部将self置空</li>
</ol>
<p>不过方案2有个小问题，如果该block没有被调用的话这个循环引用就没法被打破了，所以通常我们都使用第一种方案。</p>
<p>但是在开发业务的过程中难免会有疏漏的地方，经验丰富的老鸟还好，如果组内有小萌新的话，这种问题就很可能会出现，这里写这个工具也是做一个保护。</p>
<h3 id="内存泄露检测原理"><a href="#内存泄露检测原理" class="headerlink" title="内存泄露检测原理"></a>内存泄露检测原理</h3><p>当VC被pop或者dismiss后，正常的流程是走到dealloc，然后使用的内存会被释放，self会为nil,如果有循环引用，则不会走dealloc,内存得不到释放，self也不会为nil.</p>
<p>这里我们就利用了释放后self会被置空，而不释放self不会为nil的原理来实现内存泄露的警告。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先我们需要hook UIViewController的下面几个方法：</p>
<ul>
<li>viewWillAppear</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)swizzledViewWillAppear&#123;</div><div class="line">    </div><div class="line">    Class class = [self class];</div><div class="line">    </div><div class="line">    SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">    SEL swizzledSelector = @selector(ocn_viewWillAppear:);</div><div class="line">    </div><div class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">    </div><div class="line">    BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">    if (success) &#123;</div><div class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>viewDidDisappear</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)swizzledViewDidDisappear&#123;</div><div class="line">    </div><div class="line">    Class class = [self class];</div><div class="line">    </div><div class="line">    SEL originalSelector = @selector(viewDidDisappear:);</div><div class="line">    SEL swizzledSelector = @selector(ocn_viewDidDisappear:);</div><div class="line">    </div><div class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">    </div><div class="line">    BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">    if (success) &#123;</div><div class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dismissViewControllerAnimated</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)swizzledDismissViewController&#123;</div><div class="line">    </div><div class="line">    Class class = [self class];</div><div class="line">    </div><div class="line">    SEL originalSelector = @selector(dismissViewControllerAnimated:completion:);</div><div class="line">    SEL swizzledSelector = @selector(ocn_dismissViewControllerAnimated:completion:);</div><div class="line">    </div><div class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">    </div><div class="line">    BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">    if (success) &#123;</div><div class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时我们还需要hook 一下UINavigationController的pop方法:</p>
<ul>
<li>popViewControllerAnimated</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)swizzledPopViewControllerAnimated&#123;</div><div class="line">    </div><div class="line">    Class class = [self class];</div><div class="line">    </div><div class="line">    SEL originalSelector = @selector(popViewControllerAnimated:);</div><div class="line">    SEL swizzledSelector = @selector(ocn_popViewControllerAnimated:);</div><div class="line">    </div><div class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">    </div><div class="line">    BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">    if (success) &#123;</div><div class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里当然选择在分类中进行hook最方便了。我们把hook的代码放在load函数中执行，具体原因参考<a href="https://nshipster.cn/method-swizzling/" target="_blank" rel="noopener">这里</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (void)load&#123;</div><div class="line">    </div><div class="line">#if defined(DATAONLINE) &amp;&amp; DATAONLINE == 0</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        </div><div class="line">        [self swizzledViewWillAppear];</div><div class="line">        [self swizzledViewDidDisappear];</div><div class="line">        [self swizzledDismissViewController];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">#endif</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    </div><div class="line">#if defined(DATAONLINE) &amp;&amp; DATAONLINE == 0 </div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        [self swizzledPopViewControllerAnimated];</div><div class="line">    &#125;);</div><div class="line">#endif</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的宏表示是测试环境。</p>
<p>在viewWillAppear中，我们记录一下当前VC的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)ocn_viewWillAppear:(BOOL)animated&#123;</div><div class="line">    </div><div class="line">    [self ocn_viewWillAppear:animated];</div><div class="line">    </div><div class="line">    [self setOcn_hasBeenPopped:NO];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在viewDidDisappear时，我们判断一下当前VC的状态，如果VC被pop或者dismiss了，我们调用一下内存泄露提醒的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)ocn_viewDidDisappear:(BOOL)animated&#123;</div><div class="line">    </div><div class="line">    [self ocn_viewDidDisappear:animated];</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        if ([weakSelf ocn_hasBeenPopped]) &#123;</div><div class="line">            [weakSelf alertWithClassName:NSStringFromClass([weakSelf class])];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们做了一个延时调用，前面已经说过，如果VC走正常流程，内存被释放，self会被置空，所以这里如果没有内存泄露的话，weakself应该是为nil，我们使用nil对象调用这两个方法不会有提醒，而如果发生了内存泄露，weakself不会为nil，这时调用者这2个方法就会弹出内存泄露的警告了。</p>
<p>当然，我们还需要再dismiss和pop的时候设置当前vc的状态为已pop的状态，只有是已经被pop了，才会去尝试调用提醒事件。因为当vc的调用栈被push到下一级，也就是上面有新的vc时，viewDidDisappear也会被调用，但是此时vc的内存还会保存在内存中，只有在被pop或者dismiss后，vc的内存才有可能被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)ocn_dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion &#123;</div><div class="line">    </div><div class="line">    [self ocn_dismissViewControllerAnimated:flag completion:completion];</div><div class="line">    [self setOcn_hasBeenPopped:YES];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIViewController *)ocn_popViewControllerAnimated:(BOOL)animated &#123;</div><div class="line">    UIViewController *poppedViewController = [self ocn_popViewControllerAnimated:animated];</div><div class="line">    </div><div class="line">    if (!poppedViewController) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    return poppedViewController;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>这个工具目前只能检测UIViewController的内存泄露问题，后续还可以再加上其他类型的检测方法。写这个工具也算是对runtime学习的一个实践。</p>
<p><a href="https://github.com/lilingyu0620/LLYMemoryLeakDetector" target="_blank" rel="noopener">这里是demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/04/FDFullscreenPopGesture全屏返回实现原理解析/" itemprop="url">
                  FDFullscreenPopGesture实现原理解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-04T14:47:58+08:00" content="2018-07-04">
              2018-07-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/04/FDFullscreenPopGesture全屏返回实现原理解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/04/FDFullscreenPopGesture全屏返回实现原理解析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在项目中处理了一个UIScrollView右滑返回上级页的问题，刚好项目中也使用了<a href="https://github.com/forkingdog/FDFullscreenPopGesture" target="_blank" rel="noopener">FDFullscreenPopGesture</a>这个全屏返回的库，于是来分析它的实现吧。</p>
<p>这个库是sunngxx之前在百度的时候弄的，已经好久没有更新了，不过目前还能用，star也已经有5k多了，而且sunngxx这种runtime小王子，写的这个库几乎所有函数都是runtime实现，还是很有学习的价值的。</p>
<p>FDFullscreenPopGesture是以一个分类文件的形式提供给使用者，在内部重写了<strong>+(void)load;</strong>方法，只要把代码集成到项目中就可以使用全屏返回了。</p>
<p>先来看一下头文件中的内容，首先是UINavigationController的分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface UINavigationController (FDFullscreenPopGesture)</div><div class="line"></div><div class="line">/// The gesture recognizer that actually handles interactive pop.</div><div class="line">@property (nonatomic, strong, readonly) UIPanGestureRecognizer *fd_fullscreenPopGestureRecognizer;</div><div class="line"></div><div class="line">/// A view controller is able to control navigation bar&apos;s appearance by itself,</div><div class="line">/// rather than a global way, checking &quot;fd_prefersNavigationBarHidden&quot; property.</div><div class="line">/// Default to YES, disable it if you don&apos;t want so.</div><div class="line">@property (nonatomic, assign) BOOL fd_viewControllerBasedNavigationBarAppearanceEnabled;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>第一个属性是当前实际相应右滑的手势对象，这个对象替换了系统的手势对象，具体咋替换的后面在说。</p>
<p>第二个属性设置是否使用fd的方法去控制导航栏的显示隐藏。</p>
<p>然后我们看一下UIViewController的分类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/// Allows any view controller to disable interactive pop gesture, which might</div><div class="line">/// be necessary when the view controller itself handles pan gesture in some</div><div class="line">/// cases.</div><div class="line">@interface UIViewController (FDFullscreenPopGesture)</div><div class="line"></div><div class="line">/// Whether the interactive pop gesture is disabled when contained in a navigation</div><div class="line">/// stack.</div><div class="line">@property (nonatomic, assign) BOOL fd_interactivePopDisabled;</div><div class="line"></div><div class="line">/// Indicate this view controller prefers its navigation bar hidden or not,</div><div class="line">/// checked when view controller based navigation bar&apos;s appearance is enabled.</div><div class="line">/// Default to NO, bars are more likely to show.</div><div class="line">@property (nonatomic, assign) BOOL fd_prefersNavigationBarHidden;</div><div class="line"></div><div class="line">/// Max allowed initial distance to left edge when you begin the interactive pop</div><div class="line">/// gesture. 0 by default, which means it will ignore this limit.</div><div class="line">@property (nonatomic, assign) CGFloat fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>fd_interactivePopDisabled:当前页面是否支持右滑返回</li>
<li>fd_prefersNavigationBarHidden:控制当前页面导航栏的显示隐藏</li>
<li>fd_interactivePopMaxAllowedInitialDistanceToLeftEdge:右滑返回触发的位置，这里是距离左边距的距离。</li>
</ul>
<h3 id="全屏返回"><a href="#全屏返回" class="headerlink" title="全屏返回"></a>全屏返回</h3><p>我们先来看一下全屏返回的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">@interface _FDFullscreenPopGestureRecognizerDelegate : NSObject &lt;UIGestureRecognizerDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, weak) UINavigationController *navigationController;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation _FDFullscreenPopGestureRecognizerDelegate</div><div class="line"></div><div class="line">//判断是否处理返回手势</div><div class="line">- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer</div><div class="line">&#123;</div><div class="line">    // Ignore when no view controller is pushed into the navigation stack.</div><div class="line">    if (self.navigationController.viewControllers.count &lt;= 1) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Ignore when the active view controller doesn&apos;t allow interactive pop.</div><div class="line">    UIViewController *topViewController = self.navigationController.viewControllers.lastObject;</div><div class="line">    if (topViewController.fd_interactivePopDisabled) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Ignore when the beginning location is beyond max allowed initial distance to left edge.</div><div class="line">    CGPoint beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view];</div><div class="line">    CGFloat maxAllowedInitialDistance = topViewController.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;</div><div class="line">    if (maxAllowedInitialDistance &gt; 0 &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Ignore pan gesture when the navigation controller is currently in transition.</div><div class="line">    if ([[self.navigationController valueForKey:@&quot;_isTransitioning&quot;] boolValue]) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Prevent calling the handler when the gesture begins in an opposite direction.</div><div class="line">    CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view];</div><div class="line">    BOOL isLeftToRight = [UIApplication sharedApplication].userInterfaceLayoutDirection == UIUserInterfaceLayoutDirectionLeftToRight;</div><div class="line">    CGFloat multiplier = isLeftToRight ? 1 : - 1;</div><div class="line">    if ((translation.x * multiplier) &lt;= 0) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化返回手势</div><div class="line">- (UIPanGestureRecognizer *)fd_fullscreenPopGestureRecognizer</div><div class="line">&#123;</div><div class="line">    UIPanGestureRecognizer *panGestureRecognizer = objc_getAssociatedObject(self, _cmd);</div><div class="line"></div><div class="line">    if (!panGestureRecognizer) &#123;</div><div class="line">        panGestureRecognizer = [[UIPanGestureRecognizer alloc] init];</div><div class="line">        panGestureRecognizer.maximumNumberOfTouches = 1;</div><div class="line">        </div><div class="line">        objc_setAssociatedObject(self, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    return panGestureRecognizer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化返回手势的代理</div><div class="line">- (_FDFullscreenPopGestureRecognizerDelegate *)fd_popGestureRecognizerDelegate</div><div class="line">&#123;</div><div class="line">    _FDFullscreenPopGestureRecognizerDelegate *delegate = objc_getAssociatedObject(self, _cmd);</div><div class="line"></div><div class="line">    if (!delegate) &#123;</div><div class="line">        delegate = [[_FDFullscreenPopGestureRecognizerDelegate alloc] init];</div><div class="line">        delegate.navigationController = self;</div><div class="line">        </div><div class="line">        objc_setAssociatedObject(self, _cmd, delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    return delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//hook系统的pushViewController方法，每个vc在被push后都会调用fd的fd_pushViewController方法</div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    // Inject &quot;-pushViewController:animated:&quot;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(pushViewController:animated:);</div><div class="line">        SEL swizzledSelector = @selector(fd_pushViewController:animated:);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">        if (success) &#123;</div><div class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重要代码部分，这里替换系统右滑手势为fd自己的对象，并给对象设置fd自定义的delegate</div><div class="line">- (void)fd_pushViewController:(UIViewController *)viewController animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123;</div><div class="line">        </div><div class="line">        // Add our own gesture recognizer to where the onboard screen edge pan gesture recognizer is attached to.</div><div class="line">        [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer];</div><div class="line"></div><div class="line">        // Forward the gesture events to the private handler of the onboard gesture recognizer.</div><div class="line">        NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@&quot;targets&quot;];</div><div class="line">        id internalTarget = [internalTargets.firstObject valueForKey:@&quot;target&quot;];</div><div class="line">        SEL internalAction = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;);</div><div class="line">        self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate;</div><div class="line">        [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction];</div><div class="line"></div><div class="line">        // Disable the onboard gesture recognizer.</div><div class="line">        self.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Handle perferred navigation bar appearance.</div><div class="line">    [self fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController];</div><div class="line">    </div><div class="line">    // Forward to primary implementation.</div><div class="line">    if (![self.viewControllers containsObject:viewController]) &#123;</div><div class="line">        [self fd_pushViewController:viewController animated:animated];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码展示了fd是怎么一步步的替换了系统的右滑手势的，其他部分比较好理解，这里我们来重点看一下替换代理的部分，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123;</div><div class="line">    </div><div class="line">    // Add our own gesture recognizer to where the onboard screen edge pan gesture recognizer is attached to.</div><div class="line">    [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer];</div><div class="line"></div><div class="line">    // Forward the gesture events to the private handler of the onboard gesture recognizer.</div><div class="line">    NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@&quot;targets&quot;];</div><div class="line">    id internalTarget = [internalTargets.firstObject valueForKey:@&quot;target&quot;];</div><div class="line">    SEL internalAction = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;);</div><div class="line">    self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate;</div><div class="line">    [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction];</div><div class="line"></div><div class="line">    // Disable the onboard gesture recognizer.</div><div class="line">    self.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，先判断当前view的手势列表中是否包含我们自定义的右滑手势，如果不包含，先将自定义手势add到手势列表中，然后重点来了，获取interactivePopGestureRecognizer这个系统右滑返回手势的所有target,然后取出该手势的第一响应者，然后生成系统返回手势处理函数（handleNavigationTransition）的SEL结构体，然后设置自定义手势的代理，最后将系统的target和SEL添加给自定义的手势对象，并将系统的返回手势关闭。这样，fd就可以通过自定义的代理控制右滑返回了。</p>
<h3 id="隐藏导航栏"><a href="#隐藏导航栏" class="headerlink" title="隐藏导航栏"></a>隐藏导航栏</h3><p>看完了右滑返回，再看一下fd是如何隐藏系统导航栏的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(fd_viewWillAppear:);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">        if (success) &#123;</div><div class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fd_viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    // Forward to primary implementation.</div><div class="line">    [self fd_viewWillAppear:animated];</div><div class="line">    </div><div class="line">    if (self.fd_willAppearInjectBlock) &#123;</div><div class="line">        self.fd_willAppearInjectBlock(self, animated);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (_FDViewControllerWillAppearInjectBlock)fd_willAppearInjectBlock</div><div class="line">&#123;</div><div class="line">    return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setFd_willAppearInjectBlock:(_FDViewControllerWillAppearInjectBlock)block</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(fd_willAppearInjectBlock), block, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(UIViewController *)appearingViewController</div><div class="line">&#123;</div><div class="line">    if (!self.fd_viewControllerBasedNavigationBarAppearanceEnabled) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    _FDViewControllerWillAppearInjectBlock block = ^(UIViewController *viewController, BOOL animated) &#123;</div><div class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">        if (strongSelf) &#123;</div><div class="line">            [strongSelf setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    // Setup will appear inject block to appearing view controller.</div><div class="line">    // Setup disappearing view controller as well, because not every view controller is added into</div><div class="line">    // stack by pushing, maybe by &quot;-setViewControllers:&quot;.</div><div class="line">    appearingViewController.fd_willAppearInjectBlock = block;</div><div class="line">    UIViewController *disappearingViewController = self.viewControllers.lastObject;</div><div class="line">    if (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) &#123;</div><div class="line">        disappearingViewController.fd_willAppearInjectBlock = block;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>隐藏这个就比较简单了，也是在fd_pushViewController里面处理的，具体说一下，这里先生成一个用来隐藏导航栏的block，使用的方法还是系统的setNavigationBarHidden：animation 方式。然后将这个block赋值给self.fd_willAppearInjectBlock，然后再每次fd_viewWillAppear时，会调用一下这个block。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，代码大量的使用runtime来编写，学习一遍下来对应runtime相关的内容会有更深刻的认识。然后就是fd替换系统方法的这种骚操作，如果有类似的需求的话也是可以参考的。这个库代码也不太多，内容也比较好理解，个人觉得有学习的价值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/19/SDWebImage学习笔记/" itemprop="url">
                  SDWebImage学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-19T11:09:20+08:00" content="2018-06-19">
              2018-06-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/19/SDWebImage学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/19/SDWebImage学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/SDWebImage/sd1.png" alt=""></p>
<p>上图按模块整理了sd各模块的类</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/SDWebImage/sd2.png" alt=""></p>
<p>上图则表示了各模块和类在整理项目中的层级关系。</p>
<p>根据上面的模块图，我这里先按照模块对源码进行学习和分析。</p>
<h3 id="下载模块"><a href="#下载模块" class="headerlink" title="下载模块"></a>下载模块</h3><p>因为之前看了af，sd的下载模块应该也是基于NSUrlSession封装的，所以先看下载模块。</p>
<h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>SDWebImageDownloaderOperation是继承自系统的NSOperation,然后自己实现了一套异步操作的相关操作。这里不展开讲自定义NSOpration需要做哪些事情，网上应该有很多相关demo和文章。</p>
<p>SDWebImageDownloaderOperation的内部通过NSUrlSession创建task进行图片的下载，每个request的httpmethod默认为GET方式，这也方便拿到下载过程中的图片数据。</p>
<p>SDWebImageDownloaderOperation里面使用NSURLCache对URL的resopne进行缓存，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">    // Grab the cached data for later check</div><div class="line">    NSURLCache *URLCache = session.configuration.URLCache;</div><div class="line">    if (!URLCache) &#123;</div><div class="line">        URLCache = [NSURLCache sharedURLCache];</div><div class="line">    &#125;</div><div class="line">    NSCachedURLResponse *cachedResponse;</div><div class="line">    // NSURLCache&apos;s `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483</div><div class="line">    @synchronized (URLCache) &#123;</div><div class="line">        cachedResponse = [URLCache cachedResponseForRequest:self.request];</div><div class="line">    &#125;</div><div class="line">    if (cachedResponse) &#123;</div><div class="line">        self.cachedData = cachedResponse.data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>URLCache相关内容可以<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="noopener">参考这一篇文章</a></p>
<p>SDWebImageDownloaderOperation同时支持了后台下载，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</div><div class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">    __weak __typeof__ (self) wself = self;</div><div class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</div><div class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">        __strong __typeof (wself) sself = wself;</div><div class="line"></div><div class="line">        if (sself) &#123;</div><div class="line">            [sself cancel];</div><div class="line"></div><div class="line">            [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">            sself.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SDWebImageDownloaderOperation将每个task的progress回调和Complete回调存放在一个 <em>callbackBlocks</em> 的数组中，方便在收到NSURLSessionDelegate的代理时调用相对应的block,将数据传出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//添加了查找block</div><div class="line"></div><div class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</div><div class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</div><div class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</div><div class="line">    LOCK(self.callbacksLock);</div><div class="line">    [self.callbackBlocks addObject:callbacks];</div><div class="line">    UNLOCK(self.callbacksLock);</div><div class="line">    return callbacks;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123;</div><div class="line">    LOCK(self.callbacksLock);</div><div class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</div><div class="line">    UNLOCK(self.callbacksLock);</div><div class="line">    // We need to remove [NSNull null] because there might not always be a progress block for each callback</div><div class="line">    [callbacks removeObjectIdenticalTo:[NSNull null]];</div><div class="line">    return [callbacks copy]; // strip mutability here</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用Progress block</div><div class="line">for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">    progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用Complete block</div><div class="line"></div><div class="line">[self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</div><div class="line"></div><div class="line">- (void)callCompletionBlocksWithImage:(nullable UIImage *)image</div><div class="line">                            imageData:(nullable NSData *)imageData</div><div class="line">                                error:(nullable NSError *)error</div><div class="line">                             finished:(BOOL)finished &#123;</div><div class="line">    NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey];</div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123;</div><div class="line">            completedBlock(image, imageData, error, finished);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在收到didReceiveData回调后，如果当前options为SDWebImageDownloaderProgressiveDownload的话，还需要将收到的这部分图片数据进行解码后显示，显然这不是完整的数据，不过这部分数据也是可以正常显示的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if (!self.progressiveCoder) &#123;</div><div class="line">    // We need to create a new instance for progressive decoding to avoid conflicts</div><div class="line">    for (id&lt;SDWebImageCoder&gt;coder in [SDWebImageCodersManager sharedInstance].coders) &#123;</div><div class="line">        if ([coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)] &amp;&amp;</div><div class="line">            [((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</div><div class="line">            self.progressiveCoder = [[[coder class] alloc] init];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">// progressive decode the image in coder queue</div><div class="line">dispatch_async(self.coderQueue, ^&#123;</div><div class="line">    UIImage *image = [self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</div><div class="line">    if (image) &#123;</div><div class="line">        NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">        image = [self scaledImageForKey:key image:image];</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</div><div class="line">        </div><div class="line">        [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在收到didCompleteWithError回调后，会异步解码收到的image数据,gif和webp除外，这两会走另外的解码接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// decode the image in coder queue</div><div class="line">dispatch_async(self.coderQueue, ^&#123;</div><div class="line">    UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</div><div class="line">    NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">    image = [self scaledImageForKey:key image:image];</div><div class="line">    </div><div class="line">    BOOL shouldDecode = YES;</div><div class="line">    // Do not force decoding animated GIFs and WebPs</div><div class="line">    if (image.images) &#123;</div><div class="line">        shouldDecode = NO;</div><div class="line">    &#125; else &#123;</div><div class="line">#ifdef SD_WEBP</div><div class="line">        SDImageFormat imageFormat = [NSData sd_imageFormatForImageData:imageData];</div><div class="line">        if (imageFormat == SDImageFormatWebP) &#123;</div><div class="line">            shouldDecode = NO;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (shouldDecode) &#123;</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            BOOL shouldScaleDown = self.options &amp; SDWebImageDownloaderScaleDownLargeImages;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    CGSize imageSize = image.size;</div><div class="line">    if (imageSize.width == 0 || imageSize.height == 0) &#123;</div><div class="line">        [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];</div><div class="line">    &#125;</div><div class="line">    [self done];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>sd做https的证书验证方法很简单，如果自定义的证书不为空，则返回自定义的证书，为空的话，直接将服务器的证书返回并标识验证成功，所以实际上它这里只是简单的返回证书，并没有对证书做一个校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</div><div class="line">    </div><div class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">    __block NSURLCredential *credential = nil;</div><div class="line">    </div><div class="line">    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">        if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125; else &#123;</div><div class="line">            credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">            disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (challenge.previousFailureCount == 0) &#123;</div><div class="line">            if (self.credential) &#123;</div><div class="line">                credential = self.credential;</div><div class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p>SDWebImageDownloader是SDWebImageDownloaderOperation的管理类，和af不同的是，SDWebImageDownloader创建了一个NSOperationQueue，管理每个nsoperation。当nsoperation被标记为finish或者cancel后，会自动从Queue中移除。</p>
<p>看一下SDWebImageDownloader是如何管理operation的，比较重要的就是下面这一段代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(nullable NSURL *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</div><div class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</div><div class="line">    if (url == nil) &#123;</div><div class="line">        if (completedBlock != nil) &#123;</div><div class="line">            completedBlock(nil, nil, nil, NO);</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LOCK(self.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</div><div class="line">    // There is a case that the operation may be marked as finished, but not been removed from `self.URLOperations`.</div><div class="line">    if (!operation || operation.isFinished) &#123;</div><div class="line">        operation = createCallback();</div><div class="line">        __weak typeof(self) wself = self;</div><div class="line">        operation.completionBlock = ^&#123;</div><div class="line">            __strong typeof(wself) sself = wself;</div><div class="line">            if (!sself) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            LOCK(sself.operationsLock);</div><div class="line">            [sself.URLOperations removeObjectForKey:url];</div><div class="line">            UNLOCK(sself.operationsLock);</div><div class="line">        &#125;;</div><div class="line">        [self.URLOperations setObject:operation forKey:url];</div><div class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</div><div class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</div><div class="line">        [self.downloadQueue addOperation:operation];</div><div class="line">    &#125;</div><div class="line">    UNLOCK(self.operationsLock);</div><div class="line"></div><div class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">    </div><div class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</div><div class="line">    token.downloadOperation = operation;</div><div class="line">    token.url = url;</div><div class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line"></div><div class="line">    return token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sd将每一个operation存在URLOperations里面，key是url，value是operation,当需要创建一个下载任务时，先从这个URLOperations的字典中查找是否已经有对应的下载任务，如果没有的话，将createCallback（）这个block的返回值赋值给一个新的operation对象（并在opration的完成块中将它从URLOperations字典中移除），给opration添加相应的progressBlock和completeBlock,后将它存入URLOperations中，并创建opration对应的SDWebImageDownloadToken对象，再将该token对象返回。</p>
<p>上面这段描述中有2个地方需要注意下：</p>
<p>第一个是createCallback（）这个是个啥？看看下面这段代码就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __weak SDWebImageDownloader *wself = self;</div><div class="line"></div><div class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        __strong __typeof (wself) sself = wself;</div><div class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</div><div class="line">        if (timeoutInterval == 0.0) &#123;</div><div class="line">            timeoutInterval = 15.0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</div><div class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</div><div class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</div><div class="line">                                                                    cachePolicy:cachePolicy</div><div class="line">                                                                timeoutInterval:timeoutInterval];</div><div class="line">        </div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = YES;</div><div class="line">        if (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</div><div class="line">        &#125;</div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        if (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>createCallback其实就是创建一个新的downloadoperation，然后将这个downloadoperation返回。</p>
<p>第二个问题是SDWebImageDownloadToken这个类是用来干嘛的，也是看一下下面这个方法应该就清楚了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token &#123;</div><div class="line">    NSURL *url = token.url;</div><div class="line">    if (!url) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</div><div class="line">    if (operation) &#123;</div><div class="line">        BOOL canceled = [operation cancel:token.downloadOperationCancelToken];</div><div class="line">        if (canceled) &#123;</div><div class="line">            [self.URLOperations removeObjectForKey:url];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    UNLOCK(self.operationsLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>token.url为下载的文件url,operation为当前下载这个文件的任务，downloadOperationCancelToken实际上是一个字典，里面存了这个任务的progressBlock和completedBlock，保存这个主要是为了取消的时候把operation中保存的这两block给移除掉。</p>
<p>总结一下就是，这个SDWebImageDownloadToken对象其实就是用在cancel的时候移除之前保存在相关字典中的数据的。在SDWebImageManager中也是这么用的。</p>
<h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>看完下载模块，再来看一下缓存模块。大家都知道sd里面的缓存用到了NSCache,那它到底是咋用的呢，我们具体看一下吧。</p>
<h4 id="SDImageCacheConfig"><a href="#SDImageCacheConfig" class="headerlink" title="SDImageCacheConfig"></a>SDImageCacheConfig</h4><p>先来看一下这个config类中都定义了哪些变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</div><div class="line"></div><div class="line">@implementation SDImageCacheConfig</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">    	//需要解码</div><div class="line">        _shouldDecompressImages = YES;</div><div class="line">        //不适用iCloud存储</div><div class="line">        _shouldDisableiCloud = YES;</div><div class="line">        //存到内存</div><div class="line">        _shouldCacheImagesInMemory = YES;</div><div class="line">        //系统读写相关属性</div><div class="line">        _diskCacheReadingOptions = 0;</div><div class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</div><div class="line">        //过期时间</div><div class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</div><div class="line">        //最大存储空间 0则为没有限制</div><div class="line">        _maxCacheSize = 0;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>NSCache相关内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// A memory cache which auto purge the cache on memory warning and support weak cache.</div><div class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// Private</div><div class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</div><div class="line"></div><div class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</div><div class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可以看到sd自定义了一个继承自NSCache的类，并申明了一个NSMapTable类型的属性weakCache，直接用NSCache不就可以存储变量到内存了吗，这里为啥还要加一个NSMapTable呢。我们先看一下这个NSMapTable的初始化（<a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">NSMapTable相关内容参考这里</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</div></pre></td></tr></table></figure>
<p>可以看到，NSMapTable中存在值都是weak的，如果value被释放，则存的值将变为空，然后我们看一下自定义的SDMemoryCache类的get和set方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// `setObject:forKey:` just call this with 0 cost. Override this is enough</div><div class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</div><div class="line">    [super setObject:obj forKey:key cost:g];</div><div class="line">    if (key &amp;&amp; obj) &#123;</div><div class="line">        // Store weak cache</div><div class="line">        LOCK(self.weakCacheLock);</div><div class="line">        [self.weakCache setObject:obj forKey:key];</div><div class="line">        UNLOCK(self.weakCacheLock);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)objectForKey:(id)key &#123;</div><div class="line">    id obj = [super objectForKey:key];</div><div class="line">    if (key &amp;&amp; !obj) &#123;</div><div class="line">        // Check weak cache</div><div class="line">        LOCK(self.weakCacheLock);</div><div class="line">        obj = [self.weakCache objectForKey:key];</div><div class="line">        UNLOCK(self.weakCacheLock);</div><div class="line">        if (obj) &#123;</div><div class="line">            // Sync cache</div><div class="line">            NSUInteger cost = 0;</div><div class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</div><div class="line">                cost = SDCacheCostForImage(obj);</div><div class="line">            &#125;</div><div class="line">            [super setObject:obj forKey:key cost:cost];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对内存中图片的存取都是做了2次操作，一次是存到NSCache中，一次是存到NSMapTable中，大家都知道NSCache有一个特性就是当系统内存不足的时候会首先回收NSCache的内存，看这段get的代码，这里作者应该是考虑如果NSCache中内存被回收了可以从NSMapTable中继续找到该图片数据，不用去读磁盘数据或者重新下载。</p>
<p>然后我们来看一下存储到disk的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">if (toDisk) &#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            NSData *data = imageData;</div><div class="line">            if (!data &amp;&amp; image) &#123;</div><div class="line">                // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format</div><div class="line">                SDImageFormat format;</div><div class="line">                if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</div><div class="line">                    format = SDImageFormatPNG;</div><div class="line">                &#125; else &#123;</div><div class="line">                    format = SDImageFormatJPEG;</div><div class="line">                &#125;</div><div class="line">                data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</div><div class="line">            &#125;</div><div class="line">            [self _storeImageDataToDisk:data forKey:key];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的图片data不为空则直接存在磁盘，如果为空而且图片对象不为空，则需要先对图片进行编码处理转为data在存到磁盘中,这是因为data是直接从服务器拿到的数据，是编码过的，而image则是已经解码了的，是原始数据，数据量会比较大，所以需要先编码在存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</div><div class="line">    if (!imageData || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // get cache Path for image key</div><div class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">    // transform to NSUrl</div><div class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line">    </div><div class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</div><div class="line">    </div><div class="line">    // disable iCloud backup</div><div class="line">    if (self.config.shouldDisableiCloud) &#123;</div><div class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>存储过程很简单，就是一个文件写入就OK了。写入前先判断一下文件夹是否存在，不存在的话先创建一个。</p>
<p>然后我们看一下比较重要的一个方法，图片的查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">// First check the in-memory cache...</div><div class="line">UIImage *image = [self imageFromMemoryCacheForKey:key];</div><div class="line">BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</div><div class="line">if (shouldQueryMemoryOnly) &#123;</div><div class="line">    if (doneBlock) &#123;</div><div class="line">        doneBlock(image, nil, SDImageCacheTypeMemory);</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">NSOperation *operation = [NSOperation new];</div><div class="line">void(^queryDiskBlock)(void) =  ^&#123;</div><div class="line">    if (operation.isCancelled) &#123;</div><div class="line">        // do not call the completion if cancelled</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        UIImage *diskImage;</div><div class="line">        SDImageCacheType cacheType = SDImageCacheTypeDisk;</div><div class="line">        if (image) &#123;</div><div class="line">            // the image is from in-memory cache</div><div class="line">            diskImage = image;</div><div class="line">            cacheType = SDImageCacheTypeMemory;</div><div class="line">        &#125; else if (diskData) &#123;</div><div class="line">            // decode image data only if in-memory cache missed</div><div class="line">            diskImage = [self diskImageForKey:key data:diskData options:options];</div><div class="line">            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (doneBlock) &#123;</div><div class="line">            if (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">                doneBlock(diskImage, diskData, cacheType);</div><div class="line">            &#125; else &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, cacheType);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">if (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">    queryDiskBlock();</div><div class="line">&#125; else &#123;</div><div class="line">    dispatch_async(self.ioQueue, queryDiskBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先从nscache中查找，如果查找成功且options为SDImageCacheQueryDataWhenInMemory，则返回nscache中的结果<br>如果nscache查找失败，则查找disk中的data,并解码该data同时将解码后的image塞到nscache中,然后返回。</p>
<p>sd还提供了一个删除缓存文件的方法，在该方法中，一共使用了2种删除策略，第一种是按过期时间删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</div><div class="line">NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</div><div class="line">NSUInteger currentCacheSize = 0;</div><div class="line"></div><div class="line">// Enumerate all of the files in the cache directory.  This loop has two purposes:</div><div class="line">//</div><div class="line">//  1. Removing files that are older than the expiration date.</div><div class="line">//  2. Storing file attributes for the size-based cleanup pass.</div><div class="line">NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</div><div class="line">for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">    NSError *error;</div><div class="line">    NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</div><div class="line"></div><div class="line">    // Skip directories and errors.</div><div class="line">    if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Remove files that are older than the expiration date;</div><div class="line">    NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</div><div class="line">    if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">        [urlsToDelete addObject:fileURL];</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Store a reference to this file and account for its total size.</div><div class="line">    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">    currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</div><div class="line">    cacheFiles[fileURL] = resourceValues;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">for (NSURL *fileURL in urlsToDelete) &#123;</div><div class="line">    [self.fileManager removeItemAtURL:fileURL error:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果按过期时间删除后的文件大小还是大于最大缓存空间（maxCacheSize）的话，还有一种删除策略，就是删除现有文件大小的一半的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// If our remaining disk cache exceeds a configured maximum size, perform a second</div><div class="line">// size-based cleanup pass.  We delete the oldest files first.</div><div class="line">if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</div><div class="line">    // Target half of our maximum cache size for this cleanup pass.</div><div class="line">    const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</div><div class="line"></div><div class="line">    // Sort the remaining cache files by their last modification time (oldest first).</div><div class="line">    NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</div><div class="line">                                                             usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</div><div class="line">                                                                 return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</div><div class="line">                                                             &#125;];</div><div class="line"></div><div class="line">    // Delete files until we fall below our desired cache size.</div><div class="line">    for (NSURL *fileURL in sortedFiles) &#123;</div><div class="line">        if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</div><div class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</div><div class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">            currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</div><div class="line"></div><div class="line">            if (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="图片编解码模块"><a href="#图片编解码模块" class="headerlink" title="图片编解码模块"></a>图片编解码模块</h3><p>图片的编解码模块也是sd中比较重要也比较难吃透的模块，涉及到一些图片相关的姿势，需要慢慢学习理解。</p>
<h4 id="SDWebImageCoder"><a href="#SDWebImageCoder" class="headerlink" title="SDWebImageCoder"></a>SDWebImageCoder</h4><p>先来看一下这个协议类，这个类中定义了一些编解码的协议和几个静态函数。</p>
<p>静态函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//返回图片的颜色空间，这里返回RGB</div><div class="line">CGColorSpaceRef SDCGColorSpaceGetDeviceRGB(void) &#123;</div><div class="line">    static CGColorSpaceRef colorSpace;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    &#125;);</div><div class="line">    return colorSpace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//判断图片是否有透明度</div><div class="line">BOOL SDCGImageRefContainsAlpha(CGImageRef imageRef) &#123;</div><div class="line">    if (!imageRef) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef);</div><div class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    return hasAlpha;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageImageIOCoder"><a href="#SDWebImageImageIOCoder" class="headerlink" title="SDWebImageImageIOCoder"></a>SDWebImageImageIOCoder</h4><p>这个是图片编解码的核心类，相关方法和协议都在这个类中实现。看头文件的注释，sd支持PNG,JPEG,TIFF和HEIC(需要判断设备是否支持)这几种图片格式的编解码。gif和webp有单独的编解码类。</p>
<p>因为sd是支持图片边下载边显示的，而这个显示操作需要先将接受到的部分图片解码后才可以显示，这里看一下这个解码部分图片是如何实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</div><div class="line">    if (!_imageSource) &#123;</div><div class="line">        _imageSource = CGImageSourceCreateIncremental(NULL);</div><div class="line">    &#125;</div><div class="line">    UIImage *image;</div><div class="line">    </div><div class="line">    // The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/</div><div class="line">    // Thanks to the author @Nyx0uf</div><div class="line">    </div><div class="line">    // Update the data source, we must pass ALL the data, not just the new bytes</div><div class="line">    CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished);</div><div class="line">    </div><div class="line">    if (_width + _height == 0) &#123;</div><div class="line">        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</div><div class="line">        if (properties) &#123;</div><div class="line">            NSInteger orientationValue = 1;</div><div class="line">            CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height);</div><div class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width);</div><div class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">            CFRelease(properties);</div><div class="line">            </div><div class="line">            // When we draw to Core Graphics, we lose orientation information,</div><div class="line">            // which means the image below born of initWithCGIImage will be</div><div class="line">            // oriented incorrectly sometimes. (Unlike the image born of initWithData</div><div class="line">            // in didCompleteWithError.) So save it here and pass it on later.</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_width + _height &gt; 0) &#123;</div><div class="line">        // Create the image</div><div class="line">        CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL);</div><div class="line">        </div><div class="line">        if (partialImageRef) &#123;</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef scale:1 orientation:_orientation];</div><div class="line">#elif SD_MAC</div><div class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">            CGImageRelease(partialImageRef);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (finished) &#123;</div><div class="line">        if (_imageSource) &#123;</div><div class="line">            CFRelease(_imageSource);</div><div class="line">            _imageSource = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先创建一个imagesource,然后更新imagesource的data，注意这里的data是目前接收到的图片的所有数据，不止是新增的部分，这里在下载的图片的时候sd已经处理好了，保存了之前下载的那部分数据。然后获取图片宽高属性和方向，最后生成图片后返回。</p>
<p>接着看正常图片的解码过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</div><div class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</div><div class="line">#if SD_MAC</div><div class="line">    return image;</div><div class="line">#endif</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    BOOL shouldScaleDown = NO;</div><div class="line">    if (optionsDict != nil) &#123;</div><div class="line">        NSNumber *scaleDownLargeImagesOption = nil;</div><div class="line">        if ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[NSNumber class]]) &#123;</div><div class="line">            scaleDownLargeImagesOption = (NSNumber *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</div><div class="line">        &#125;</div><div class="line">        if (scaleDownLargeImagesOption != nil) &#123;</div><div class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!shouldScaleDown) &#123;</div><div class="line">        return [self sd_decompressedImageWithImage:image];</div><div class="line">    &#125; else &#123;</div><div class="line">        UIImage *scaledDownImage = [self sd_decompressedAndScaledDownImageWithImage:image];</div><div class="line">        if (scaledDownImage &amp;&amp; !CGSizeEqualToSize(scaledDownImage.size, image.size)) &#123;</div><div class="line">            // if the image is scaled down, need to modify the data pointer as well</div><div class="line">            SDImageFormat format = [NSData sd_imageFormatForImageData:*data];</div><div class="line">            NSData *imageData = [self encodedDataWithImage:scaledDownImage format:format];</div><div class="line">            if (imageData) &#123;</div><div class="line">                *data = imageData;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return scaledDownImage;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要判断一下图片是否需要被缩放，因为在下载完以后的图片也是根据图片后缀是否带@2x@3x这种标识进行过缩放的，并不是图片的实际尺寸。</p>
<p>如果不需要缩放，直接调用下面的解码方法解码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</div><div class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</div><div class="line">    @autoreleasepool&#123;</div><div class="line">        </div><div class="line">        CGImageRef imageRef = image.CGImage;</div><div class="line">        // device color space</div><div class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef);</div><div class="line">        // iOS display alpha info (BRGA8888/BGRX8888)</div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        size_t width = CGImageGetWidth(imageRef);</div><div class="line">        size_t height = CGImageGetHeight(imageRef);</div><div class="line">        </div><div class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</div><div class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</div><div class="line">        // to create bitmap graphics contexts without alpha info.</div><div class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</div><div class="line">                                                     width,</div><div class="line">                                                     height,</div><div class="line">                                                     kBitsPerComponent,</div><div class="line">                                                     0,</div><div class="line">                                                     colorspaceRef,</div><div class="line">                                                     bitmapInfo);</div><div class="line">        if (context == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Draw the image into the context and retrieve the new bitmap image without alpha</div><div class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</div><div class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</div><div class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</div><div class="line">        CGContextRelease(context);</div><div class="line">        CGImageRelease(imageRefWithoutAlpha);</div><div class="line">        </div><div class="line">        return imageWithoutAlpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码很经典，很多图片解码相关的库都会用到，如果你想自己写一个异步的图片解码函数，也可以直接拿去用。这里用的参数及相关解释网上有很多文章分析过，<a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="noopener">比如这篇就解释的挺清楚</a>。</p>
<p>如果是需要缩放的图片，则走下面这个方法解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (![[self class] shouldScaleDownImage:image]) &#123;</div><div class="line">        return [self sd_decompressedImageWithImage:image];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CGContextRef destContext;</div><div class="line">    </div><div class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</div><div class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        CGImageRef sourceImageRef = image.CGImage;</div><div class="line">        </div><div class="line">        CGSize sourceResolution = CGSizeZero;</div><div class="line">        sourceResolution.width = CGImageGetWidth(sourceImageRef);</div><div class="line">        sourceResolution.height = CGImageGetHeight(sourceImageRef);</div><div class="line">        float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">        // Determine the scale ratio to apply to the input image</div><div class="line">        // that results in an output image of the defined size.</div><div class="line">        // see kDestImageSizeMB, and how it relates to destTotalPixels.</div><div class="line">        float imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">        CGSize destResolution = CGSizeZero;</div><div class="line">        destResolution.width = (int)(sourceResolution.width*imageScale);</div><div class="line">        destResolution.height = (int)(sourceResolution.height*imageScale);</div><div class="line">        </div><div class="line">        // device color space</div><div class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</div><div class="line">        // iOS display alpha info (BGRA8888/BGRX8888)</div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</div><div class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</div><div class="line">        // to create bitmap graphics contexts without alpha info.</div><div class="line">        destContext = CGBitmapContextCreate(NULL,</div><div class="line">                                            destResolution.width,</div><div class="line">                                            destResolution.height,</div><div class="line">                                            kBitsPerComponent,</div><div class="line">                                            0,</div><div class="line">                                            colorspaceRef,</div><div class="line">                                            bitmapInfo);</div><div class="line">        </div><div class="line">        if (destContext == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</div><div class="line">        </div><div class="line">        // Now define the size of the rectangle to be used for the</div><div class="line">        // incremental blits from the input image to the output image.</div><div class="line">        // we use a source tile width equal to the width of the source</div><div class="line">        // image due to the way that iOS retrieves image data from disk.</div><div class="line">        // iOS must decode an image from disk in full width &apos;bands&apos;, even</div><div class="line">        // if current graphics context is clipped to a subrect within that</div><div class="line">        // band. Therefore we fully utilize all of the pixel data that results</div><div class="line">        // from a decoding opertion by achnoring our tile size to the full</div><div class="line">        // width of the input image.</div><div class="line">        CGRect sourceTile = CGRectZero;</div><div class="line">        sourceTile.size.width = sourceResolution.width;</div><div class="line">        // The source tile height is dynamic. Since we specified the size</div><div class="line">        // of the source tile in MB, see how many rows of pixels high it</div><div class="line">        // can be given the input image width.</div><div class="line">        sourceTile.size.height = (int)(kTileTotalPixels / sourceTile.size.width );</div><div class="line">        sourceTile.origin.x = 0.0f;</div><div class="line">        // The output tile is the same proportions as the input tile, but</div><div class="line">        // scaled to image scale.</div><div class="line">        CGRect destTile;</div><div class="line">        destTile.size.width = destResolution.width;</div><div class="line">        destTile.size.height = sourceTile.size.height * imageScale;</div><div class="line">        destTile.origin.x = 0.0f;</div><div class="line">        // The source seem overlap is proportionate to the destination seem overlap.</div><div class="line">        // this is the amount of pixels to overlap each tile as we assemble the ouput image.</div><div class="line">        float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</div><div class="line">        CGImageRef sourceTileImageRef;</div><div class="line">        // calculate the number of read/write operations required to assemble the</div><div class="line">        // output image.</div><div class="line">        int iterations = (int)( sourceResolution.height / sourceTile.size.height );</div><div class="line">        // If tile height doesn&apos;t divide the image height evenly, add another iteration</div><div class="line">        // to account for the remaining pixels.</div><div class="line">        int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;</div><div class="line">        if(remainder) &#123;</div><div class="line">            iterations++;</div><div class="line">        &#125;</div><div class="line">        // Add seem overlaps to the tiles, but save the original tile height for y coordinate calculations.</div><div class="line">        float sourceTileHeightMinusOverlap = sourceTile.size.height;</div><div class="line">        sourceTile.size.height += sourceSeemOverlap;</div><div class="line">        destTile.size.height += kDestSeemOverlap;</div><div class="line">        for( int y = 0; y &lt; iterations; ++y ) &#123;</div><div class="line">            @autoreleasepool &#123;</div><div class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</div><div class="line">                destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</div><div class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</div><div class="line">                if( y == iterations - 1 &amp;&amp; remainder ) &#123;</div><div class="line">                    float dify = destTile.size.height;</div><div class="line">                    destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale;</div><div class="line">                    dify -= destTile.size.height;</div><div class="line">                    destTile.origin.y += dify;</div><div class="line">                &#125;</div><div class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</div><div class="line">                CGImageRelease( sourceTileImageRef );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</div><div class="line">        CGContextRelease(destContext);</div><div class="line">        if (destImageRef == NULL) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</div><div class="line">        CGImageRelease(destImageRef);</div><div class="line">        if (destImage == nil) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">        return destImage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里先判断图片的总像素是否比sd设置的最大像素值大，如果总像素超出了设置的最大像素值，则需要先缩放图片再解码，不然解码需要的内存空间太大，可能造成内存暴涨等问题。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</div><div class="line">    BOOL shouldScaleDown = YES;</div><div class="line">    </div><div class="line">    CGImageRef sourceImageRef = image.CGImage;</div><div class="line">    CGSize sourceResolution = CGSizeZero;</div><div class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</div><div class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</div><div class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">    if (imageScale &lt; 1) &#123;</div><div class="line">        shouldScaleDown = YES;</div><div class="line">    &#125; else &#123;</div><div class="line">        shouldScaleDown = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return shouldScaleDown;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sd这里应该也是用了帧内压缩算法去压缩图片的尺寸，通过计算像素差值的方式将多余的像素剔除，然后sd使用了一个tile的东东去存储每次计算出来的数据，并将这些数据写入到设备上下文中。计算完成后再从上下文中取出一张位图。这个压缩解码函数的详细注释可以<a href="https://www.jianshu.com/p/dfa47380fc05" target="_blank" rel="noopener">参考这一篇文章</a>.</p>
<p>然后就是编码部分，什么时候需要编码呢？就是在存入disk的时候，因为之前用到的image可能是解码之后的图片，直接存入的话会占用比较大的内存空间，所以sd这里都是先将image编码后再存的。</p>
<p>编码的函数和解码相比还是比较简单的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (format == SDImageFormatUndefined) &#123;</div><div class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</div><div class="line">        if (hasAlpha) &#123;</div><div class="line">            format = SDImageFormatPNG;</div><div class="line">        &#125; else &#123;</div><div class="line">            format = SDImageFormatJPEG;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:format];</div><div class="line">    </div><div class="line">    // Create an image destination.</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableDictionary *properties = [NSMutableDictionary dictionary];</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSInteger exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</div><div class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge_transfer NSString *)kCGImagePropertyOrientation];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    // Add your image to the destination.</div><div class="line">    CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties);</div><div class="line">    </div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        imageData = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(imageDestination);</div><div class="line">    </div><div class="line">    return [imageData copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先创建一个CGImageDestinationRef，并绑定一个imagedata,然后获取图片的相关属性，然后将图片数据和相关属性一起add到CGImageDestinationRef中，获取之前绑定的imagedata并返回，整个编码过程结束。</p>
<h4 id="SDWebImageGIFCoder"><a href="#SDWebImageGIFCoder" class="headerlink" title="SDWebImageGIFCoder"></a>SDWebImageGIFCoder</h4><p>这个类主要做gif的编解码。直接看解码函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">#if SD_MAC</div><div class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</div><div class="line">    NSImage *animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</div><div class="line">    [animatedImage addRepresentation:imageRep];</div><div class="line">    return animatedImage;</div><div class="line">#else</div><div class="line">    </div><div class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</div><div class="line">    if (!source) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    size_t count = CGImageSourceGetCount(source);</div><div class="line">    </div><div class="line">    UIImage *animatedImage;</div><div class="line">    </div><div class="line">    if (count &lt;= 1) &#123;</div><div class="line">        animatedImage = [[UIImage alloc] initWithData:data];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</div><div class="line">            CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);</div><div class="line">            if (!imageRef) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            float duration = [self sd_frameDurationAtIndex:i source:source];</div><div class="line">            UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</div><div class="line">            CGImageRelease(imageRef);</div><div class="line">            </div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSUInteger loopCount = 1;</div><div class="line">        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(source, nil);</div><div class="line">        NSDictionary *gifProperties = [imageProperties valueForKey:(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">        if (gifProperties) &#123;</div><div class="line">            NSNumber *gifLoopCount = [gifProperties valueForKey:(__bridge_transfer NSString *)kCGImagePropertyGIFLoopCount];</div><div class="line">            if (gifLoopCount != nil) &#123;</div><div class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">        animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(source);</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sd这里自定义了一个SDWebImageFrame类用来存放每一帧图片的数据，然后将所有帧存放在一个数组中，然后通过下面这个方法将帧数组转为一个image对象,这个方法等下在分析helper类的时候再一起分析一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div></pre></td></tr></table></figure>
<p>上面还用到一个方法是如何获取每一帧的时长方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source &#123;</div><div class="line">    float frameDuration = 0.1f;</div><div class="line">    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);</div><div class="line">    if (!cfFrameProperties) &#123;</div><div class="line">        return frameDuration;</div><div class="line">    &#125;</div><div class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;</div><div class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">    </div><div class="line">    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];</div><div class="line">    if (delayTimeUnclampedProp != nil) &#123;</div><div class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];</div><div class="line">        if (delayTimeProp != nil) &#123;</div><div class="line">            frameDuration = [delayTimeProp floatValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.</div><div class="line">    // We follow Firefox&apos;s behavior and use a duration of 100 ms for any frames that specify</div><div class="line">    // a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;</div><div class="line">    // for more information.</div><div class="line">    </div><div class="line">    if (frameDuration &lt; 0.011f) &#123;</div><div class="line">        frameDuration = 0.100f;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(cfFrameProperties);</div><div class="line">    return frameDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认每一帧的时长是0.1，如果获取propertydic失败直接返回默认值，否则的话从propertydic取对应的value。</p>
<p>然后看一下gif的编码过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (format != SDImageFormatGIF) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</div><div class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</div><div class="line">    </div><div class="line">    // Create an image destination. GIF does not support EXIF image orientation</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (frames.count == 0) &#123;</div><div class="line">        // for static single GIF images</div><div class="line">        CGImageDestinationAddImage(imageDestination, image.CGImage, nil);</div><div class="line">    &#125; else &#123;</div><div class="line">        // for animated GIF images</div><div class="line">        NSUInteger loopCount = image.sd_imageLoopCount;</div><div class="line">        NSDictionary *gifProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary: @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</div><div class="line">        CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties);</div><div class="line">        </div><div class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</div><div class="line">            SDWebImageFrame *frame = frames[i];</div><div class="line">            float frameDuration = frame.duration;</div><div class="line">            CGImageRef frameImageRef = frame.image.CGImage;</div><div class="line">            NSDictionary *frameProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</div><div class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        imageData = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRelease(imageDestination);</div><div class="line">    </div><div class="line">    return [imageData copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码的时候也是需要先获取到SDWebImageFrame数组，然后和普通图片编码过程一样，也是创建一个CGImageDestinationRef，绑定imagedata,然后遍历SDWebImageFrame数组将每一帧写入CGImageDestinationRef中，然后获取imagedata并返回。</p>
<h4 id="SDWebImageWebPCoder"><a href="#SDWebImageWebPCoder" class="headerlink" title="SDWebImageWebPCoder"></a>SDWebImageWebPCoder</h4><p><a href="https://developers.google.com/speed/webp/docs/compression" target="_blank" rel="noopener">这篇文章介绍了webp的压缩算法</a></p>
<p>使用webp相关的编解码方法，需要pod中添加一个依赖仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;SDWebImage/WebP&apos;</div></pre></td></tr></table></figure>
<p>sd为webp提供了2种解码方法，分别是部分数据的解码和完整数据的解码。</p>
<p>先看完整的数据解码函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    WebPData webpData;</div><div class="line">    WebPDataInit(&amp;webpData);</div><div class="line">    webpData.bytes = data.bytes;</div><div class="line">    webpData.size = data.length;</div><div class="line">    WebPDemuxer *demuxer = WebPDemux(&amp;webpData);</div><div class="line">    if (!demuxer) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint32_t flags = WebPDemuxGetI(demuxer, WEBP_FF_FORMAT_FLAGS);</div><div class="line">    int loopCount = WebPDemuxGetI(demuxer, WEBP_FF_LOOP_COUNT);</div><div class="line">    int canvasWidth = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_WIDTH);</div><div class="line">    int canvasHeight = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_HEIGHT);</div><div class="line">    CGBitmapInfo bitmapInfo;</div><div class="line">    // `CGBitmapContextCreate` does not support RGB888 on iOS. Where `CGImageCreate` supports.</div><div class="line">    if (!(flags &amp; ALPHA_FLAG)) &#123;</div><div class="line">        // RGBX8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;</div><div class="line">    &#125; else &#123;</div><div class="line">        // RGBA8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    CGContextRef canvas = CGBitmapContextCreate(NULL, canvasWidth, canvasHeight, 8, 0, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">    if (!canvas) &#123;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!(flags &amp; ANIMATION_FLAG)) &#123;</div><div class="line">        // for static single webp image</div><div class="line">        UIImage *staticImage = [self sd_rawWebpImageWithData:webpData];</div><div class="line">        if (staticImage) &#123;</div><div class="line">            // draw on CGBitmapContext can reduce memory usage</div><div class="line">            CGImageRef imageRef = staticImage.CGImage;</div><div class="line">            size_t width = CGImageGetWidth(imageRef);</div><div class="line">            size_t height = CGImageGetHeight(imageRef);</div><div class="line">            CGContextDrawImage(canvas, CGRectMake(0, 0, width, height), imageRef);</div><div class="line">            CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">            staticImage = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#else</div><div class="line">            staticImage = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">            CGImageRelease(newImageRef);</div><div class="line">        &#125;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">        return staticImage;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // for animated webp image</div><div class="line">    WebPIterator iter;</div><div class="line">    if (!WebPDemuxGetFrame(demuxer, 1, &amp;iter)) &#123;</div><div class="line">        WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">    </div><div class="line">    do &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            UIImage *image = [self sd_drawnWebpImageWithCanvas:canvas iterator:iter];</div><div class="line">            if (!image) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            int duration = iter.duration;</div><div class="line">            if (duration &lt;= 10) &#123;</div><div class="line">                // WebP standard says 0 duration is used for canvas updating but not showing image, but actually Chrome and other implementations set it to 100ms if duration is lower or equal than 10ms</div><div class="line">                // Some animated WebP images also created without duration, we should keep compatibility</div><div class="line">                duration = 100;</div><div class="line">            &#125;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration / 1000.f];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; while (WebPDemuxNextFrame(&amp;iter));</div><div class="line">    </div><div class="line">    WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">    WebPDemuxDelete(demuxer);</div><div class="line">    CGContextRelease(canvas);</div><div class="line">    </div><div class="line">    UIImage *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">    animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也是分了2种类型去解码，一种是静态图片，直接使用下面这个方法或者静态图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_rawWebpImageWithData:(WebPData)webpData &#123;</div><div class="line">    WebPDecoderConfig config;</div><div class="line">    if (!WebPInitDecoderConfig(&amp;config)) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (WebPGetFeatures(webpData.bytes, webpData.size, &amp;config.input) != VP8_STATUS_OK) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    config.output.colorspace = config.input.has_alpha ? MODE_rgbA : MODE_RGB;</div><div class="line">    config.options.use_threads = 1;</div><div class="line">    </div><div class="line">    // Decode the WebP image data into a RGBA value array</div><div class="line">    if (WebPDecode(webpData.bytes, webpData.size, &amp;config) != VP8_STATUS_OK) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int width = config.input.width;</div><div class="line">    int height = config.input.height;</div><div class="line">    if (config.options.use_scaling) &#123;</div><div class="line">        width = config.options.scaled_width;</div><div class="line">        height = config.options.scaled_height;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Construct a UIImage from the decoded RGBA value array</div><div class="line">    CGDataProviderRef provider =</div><div class="line">    CGDataProviderCreateWithData(NULL, config.output.u.RGBA.rgba, config.output.u.RGBA.size, FreeImageData);</div><div class="line">    CGColorSpaceRef colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">    CGBitmapInfo bitmapInfo;</div><div class="line">    // `CGBitmapContextCreate` does not support RGB888 on iOS. Where `CGImageCreate` supports.</div><div class="line">    if (!config.input.has_alpha) &#123;</div><div class="line">        // RGB888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNone;</div><div class="line">    &#125; else &#123;</div><div class="line">        // RGBA8888</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    size_t components = config.input.has_alpha ? 4 : 3;</div><div class="line">    CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;</div><div class="line">    CGImageRef imageRef = CGImageCreate(width, height, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</div><div class="line">    </div><div class="line">    CGDataProviderRelease(provider);</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</div><div class="line">#else</div><div class="line">    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">    CGImageRelease(imageRef);</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是动图的话，和GIF的解码一样，需要获取一个SDWebImageFrame的数组，先使用下面这个函数获取每一帧的图片数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (nullable UIImage *)sd_drawnWebpImageWithCanvas:(CGContextRef)canvas iterator:(WebPIterator)iter &#123;</div><div class="line">    UIImage *image = [self sd_rawWebpImageWithData:iter.fragment];</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t canvasWidth = CGBitmapContextGetWidth(canvas);</div><div class="line">    size_t canvasHeight = CGBitmapContextGetHeight(canvas);</div><div class="line">    CGSize size = CGSizeMake(canvasWidth, canvasHeight);</div><div class="line">    CGFloat tmpX = iter.x_offset;</div><div class="line">    CGFloat tmpY = size.height - iter.height - iter.y_offset;</div><div class="line">    CGRect imageRect = CGRectMake(tmpX, tmpY, iter.width, iter.height);</div><div class="line">    BOOL shouldBlend = iter.blend_method == WEBP_MUX_BLEND;</div><div class="line">    </div><div class="line">    // If not blend, cover the target image rect. (firstly clear then draw)</div><div class="line">    if (!shouldBlend) &#123;</div><div class="line">        CGContextClearRect(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    CGContextDrawImage(canvas, imageRect, image.CGImage);</div><div class="line">    CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    image = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#elif SD_MAC</div><div class="line">    image = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    CGImageRelease(newImageRef);</div><div class="line">    </div><div class="line">    if (iter.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) &#123;</div><div class="line">        CGContextClearRect(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数里面先调用静态获取图片的方法生成一张图片，然后判断是否需要混合当前上下文中的内容，如果不需要就清空之前的内容，如果需要的话将刚生成的图片再写入之前的上下文中混合成一张新的图。</p>
<p>然后使用之前gif中使用过的下面这个函数将帧数组转为一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIImage *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div></pre></td></tr></table></figure>
<p>部分数据的解码函数如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</div><div class="line">    if (!_idec) &#123;</div><div class="line">        // Progressive images need transparent, so always use premultiplied RGBA</div><div class="line">        _idec = WebPINewRGB(MODE_rgbA, NULL, 0, 0);</div><div class="line">        if (!_idec) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIImage *image;</div><div class="line">    </div><div class="line">    VP8StatusCode status = WebPIUpdate(_idec, data.bytes, data.length);</div><div class="line">    if (status != VP8_STATUS_OK &amp;&amp; status != VP8_STATUS_SUSPENDED) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int width = 0;</div><div class="line">    int height = 0;</div><div class="line">    int last_y = 0;</div><div class="line">    int stride = 0;</div><div class="line">    uint8_t *rgba = WebPIDecGetRGB(_idec, &amp;last_y, &amp;width, &amp;height, &amp;stride);</div><div class="line">    // last_y may be 0, means no enough bitmap data to decode, ignore this</div><div class="line">    if (width + height &gt; 0 &amp;&amp; last_y &gt; 0 &amp;&amp; height &gt;= last_y) &#123;</div><div class="line">        // Construct a UIImage from the decoded RGBA value array</div><div class="line">        size_t rgbaSize = last_y * stride;</div><div class="line">        CGDataProviderRef provider =</div><div class="line">        CGDataProviderCreateWithData(NULL, rgba, rgbaSize, NULL);</div><div class="line">        CGColorSpaceRef colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        </div><div class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">        size_t components = 4;</div><div class="line">        CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;</div><div class="line">        // Why to use last_y for image height is because of libwebp&apos;s bug (https://bugs.chromium.org/p/webp/issues/detail?id=362)</div><div class="line">        // It will not keep memory barrier safe on x86 architechure (macOS &amp; iPhone simulator) but on ARM architecture (iPhone &amp; iPad &amp; tv &amp; watch) it works great</div><div class="line">        // If different threads use WebPIDecGetRGB to grab rgba bitmap, it will contain the previous decoded bitmap data</div><div class="line">        // So this will cause our drawed image looks strange(above is the current part but below is the previous part)</div><div class="line">        // We only grab the last_y height and draw the last_y heigh instead of total height image</div><div class="line">        // Besides fix, this can enhance performance since we do not need to create extra bitmap</div><div class="line">        CGImageRef imageRef = CGImageCreate(width, last_y, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</div><div class="line">        </div><div class="line">        CGDataProviderRelease(provider);</div><div class="line">        </div><div class="line">        if (!imageRef) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGContextRef canvas = CGBitmapContextCreate(NULL, width, height, 8, 0, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">        if (!canvas) &#123;</div><div class="line">            CGImageRelease(imageRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Only draw the last_y image height, keep remains transparent, in Core Graphics coordinate system</div><div class="line">        CGContextDrawImage(canvas, CGRectMake(0, height - last_y, width, last_y), imageRef);</div><div class="line">        CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);</div><div class="line">        CGImageRelease(imageRef);</div><div class="line">        if (!newImageRef) &#123;</div><div class="line">            CGContextRelease(canvas);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">        image = [[UIImage alloc] initWithCGImage:newImageRef];</div><div class="line">#else</div><div class="line">        image = [[UIImage alloc] initWithCGImage:newImageRef size:NSZeroSize];</div><div class="line">#endif</div><div class="line">        CGImageRelease(newImageRef);</div><div class="line">        CGContextRelease(canvas);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (finished) &#123;</div><div class="line">        if (_idec) &#123;</div><div class="line">            WebPIDelete(_idec);</div><div class="line">            _idec = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>流程都和之前的其他格式部分解码函数差不多吧，只是有写api的小差异。</p>
<p>解码的部分差不多就这些，接着看一下编码的部分是如何实现的，直接上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSData *data;</div><div class="line">    </div><div class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</div><div class="line">    if (frames.count == 0) &#123;</div><div class="line">        // for static single webp image</div><div class="line">        data = [self sd_encodedWebpDataWithImage:image];</div><div class="line">    &#125; else &#123;</div><div class="line">        // for animated webp image</div><div class="line">        WebPMux *mux = WebPMuxNew();</div><div class="line">        if (!mux) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</div><div class="line">            SDWebImageFrame *currentFrame = frames[i];</div><div class="line">            NSData *webpData = [self sd_encodedWebpDataWithImage:currentFrame.image];</div><div class="line">            int duration = currentFrame.duration * 1000;</div><div class="line">            WebPMuxFrameInfo frame = &#123; .bitstream.bytes = webpData.bytes,</div><div class="line">                .bitstream.size = webpData.length,</div><div class="line">                .duration = duration,</div><div class="line">                .id = WEBP_CHUNK_ANMF,</div><div class="line">                .dispose_method = WEBP_MUX_DISPOSE_BACKGROUND, // each frame will clear canvas</div><div class="line">                .blend_method = WEBP_MUX_NO_BLEND</div><div class="line">            &#125;;</div><div class="line">            if (WebPMuxPushFrame(mux, &amp;frame, 0) != WEBP_MUX_OK) &#123;</div><div class="line">                WebPMuxDelete(mux);</div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        int loopCount = (int)image.sd_imageLoopCount;</div><div class="line">        WebPMuxAnimParams params = &#123; .bgcolor = 0,</div><div class="line">            .loop_count = loopCount</div><div class="line">        &#125;;</div><div class="line">        if (WebPMuxSetAnimationParams(mux, &amp;params) != WEBP_MUX_OK) &#123;</div><div class="line">            WebPMuxDelete(mux);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        WebPData outputData;</div><div class="line">        WebPMuxError error = WebPMuxAssemble(mux, &amp;outputData);</div><div class="line">        WebPMuxDelete(mux);</div><div class="line">        if (error != WEBP_MUX_OK) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        data = [NSData dataWithBytes:outputData.bytes length:outputData.size];</div><div class="line">        WebPDataClear(&amp;outputData);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和gif的编码流程相似，先获取到这张图的所有帧，（静态图片只有一帧，直接调用处理每一帧的编码函数进行处理），然后循环处理每一帧的数据，然后将处理完的每一帧数据存放到WebPMuxFrameInfo这个结构体，再将每个结构体add到WebPMux这个类里面，循环结束从WebPMux这个类中取出数据并返回。</p>
<p>下面这个函数是具体处理每一帧的数据的编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">- (nullable NSData *)sd_encodedWebpDataWithImage:(nullable UIImage *)image &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSData *webpData;</div><div class="line">    CGImageRef imageRef = image.CGImage;</div><div class="line">    </div><div class="line">    size_t width = CGImageGetWidth(imageRef);</div><div class="line">    size_t height = CGImageGetHeight(imageRef);</div><div class="line">    if (width == 0 || width &gt; WEBP_MAX_DIMENSION) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (height == 0 || height &gt; WEBP_MAX_DIMENSION) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t bytesPerRow = CGImageGetBytesPerRow(imageRef);</div><div class="line">    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</div><div class="line">    CGImageAlphaInfo alphaInfo = bitmapInfo &amp; kCGBitmapAlphaInfoMask;</div><div class="line">    CGBitmapInfo byteOrderInfo = bitmapInfo &amp; kCGBitmapByteOrderMask;</div><div class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    BOOL byteOrderNormal = NO;</div><div class="line">    switch (byteOrderInfo) &#123;</div><div class="line">        case kCGBitmapByteOrderDefault: &#123;</div><div class="line">            byteOrderNormal = YES;</div><div class="line">        &#125; break;</div><div class="line">        case kCGBitmapByteOrder32Little: &#123;</div><div class="line">        &#125; break;</div><div class="line">        case kCGBitmapByteOrder32Big: &#123;</div><div class="line">            byteOrderNormal = YES;</div><div class="line">        &#125; break;</div><div class="line">        default: break;</div><div class="line">    &#125;</div><div class="line">    // If we can not get bitmap buffer, early return</div><div class="line">    CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);</div><div class="line">    if (!dataProvider) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CFDataRef dataRef = CGDataProviderCopyData(dataProvider);</div><div class="line">    if (!dataRef) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint8_t *rgba = NULL;</div><div class="line">    // We could not assume that input CGImage&apos;s color mode is always RGB888/RGBA8888. Convert all other cases to target color mode using vImage</div><div class="line">    if (byteOrderNormal &amp;&amp; ((alphaInfo == kCGImageAlphaNone) || (alphaInfo == kCGImageAlphaLast))) &#123;</div><div class="line">        // If the input CGImage is already RGB888/RGBA8888</div><div class="line">        rgba = (uint8_t *)CFDataGetBytePtr(dataRef);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Convert all other cases to target color mode using vImage</div><div class="line">        vImageConverterRef convertor = NULL;</div><div class="line">        vImage_Error error = kvImageNoError;</div><div class="line">        </div><div class="line">        vImage_CGImageFormat srcFormat = &#123;</div><div class="line">            .bitsPerComponent = (uint32_t)CGImageGetBitsPerComponent(imageRef),</div><div class="line">            .bitsPerPixel = (uint32_t)CGImageGetBitsPerPixel(imageRef),</div><div class="line">            .colorSpace = CGImageGetColorSpace(imageRef),</div><div class="line">            .bitmapInfo = bitmapInfo</div><div class="line">        &#125;;</div><div class="line">        vImage_CGImageFormat destFormat = &#123;</div><div class="line">            .bitsPerComponent = 8,</div><div class="line">            .bitsPerPixel = hasAlpha ? 32 : 24,</div><div class="line">            .colorSpace = SDCGColorSpaceGetDeviceRGB(),</div><div class="line">            .bitmapInfo = hasAlpha ? kCGImageAlphaLast | kCGBitmapByteOrderDefault : kCGImageAlphaNone | kCGBitmapByteOrderDefault // RGB888/RGBA8888 (Non-premultiplied to works for libwebp)</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        convertor = vImageConverter_CreateWithCGImageFormat(&amp;srcFormat, &amp;destFormat, NULL, kvImageNoFlags, &amp;error);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        vImage_Buffer src = &#123;</div><div class="line">            .data = (uint8_t *)CFDataGetBytePtr(dataRef),</div><div class="line">            .width = width,</div><div class="line">            .height = height,</div><div class="line">            .rowBytes = bytesPerRow</div><div class="line">        &#125;;</div><div class="line">        vImage_Buffer dest;</div><div class="line">        </div><div class="line">        error = vImageBuffer_Init(&amp;dest, height, width, destFormat.bitsPerPixel, kvImageNoFlags);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Convert input color mode to RGB888/RGBA8888</div><div class="line">        error = vImageConvert_AnyToAny(convertor, &amp;src, &amp;dest, NULL, kvImageNoFlags);</div><div class="line">        if (error != kvImageNoError) &#123;</div><div class="line">            CFRelease(dataRef);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        rgba = dest.data; // Converted buffer</div><div class="line">        bytesPerRow = dest.rowBytes; // Converted bytePerRow</div><div class="line">        CFRelease(dataRef);</div><div class="line">        dataRef = NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint8_t *data = NULL; // Output WebP data</div><div class="line">    float qualityFactor = 100; // WebP quality is 0-100</div><div class="line">    // Encode RGB888/RGBA8888 buffer to WebP data</div><div class="line">    size_t size;</div><div class="line">    if (hasAlpha) &#123;</div><div class="line">        size = WebPEncodeRGBA(rgba, (int)width, (int)height, (int)bytesPerRow, qualityFactor, &amp;data);</div><div class="line">    &#125; else &#123;</div><div class="line">        size = WebPEncodeRGB(rgba, (int)width, (int)height, (int)bytesPerRow, qualityFactor, &amp;data);</div><div class="line">    &#125;</div><div class="line">    if (dataRef) &#123;</div><div class="line">        CFRelease(dataRef); // free non-converted rgba buffer</div><div class="line">        dataRef = NULL;</div><div class="line">    &#125; else &#123;</div><div class="line">        free(rgba); // free converted rgba buffer</div><div class="line">        rgba = NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (size) &#123;</div><div class="line">        // success</div><div class="line">        webpData = [NSData dataWithBytes:data length:size];</div><div class="line">    &#125;</div><div class="line">    if (data) &#123;</div><div class="line">        WebPFree(data);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return webpData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和之前的其他图片的编码不一样，它这里没有使用CGImageDestinationRef这个结构处理编码，而是使用的webp库提供的编码方法。先创建vImageConverterRef这个对象，然后设置编码前的格式和编码后的格式，然后初始化vImageConverterRef对象，然后初始化vImage_Buffer，最后调用vImageConvert_AnyToAny方法进行格式转换，最后调用WebPEncodeRGBA生成最终需要返回的数据。<br>整个过程和使用AudioUnit进行音频格式转换很相似。</p>
<h4 id="SDWebImageCodersManager"><a href="#SDWebImageCodersManager" class="headerlink" title="SDWebImageCodersManager"></a>SDWebImageCodersManager</h4><p>这个类就是对上面这几个编解码类的使用的一个封装，看初始化函数默认只使用了SDWebImageImageIOCoder这个类作为当前编解码类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        // initialize with default coders</div><div class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</div><div class="line">#ifdef SD_WEBP</div><div class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</div><div class="line">#endif</div><div class="line">        _coders = [mutableCoders copy];</div><div class="line">        _codersLock = dispatch_semaphore_create(1);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你可以通过下面这个方法手动的添加和移除你需要的编解码类，比如gif的Coder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</div><div class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</div><div class="line">    if (!mutableCoders) &#123;</div><div class="line">        mutableCoders = [NSMutableArray array];</div><div class="line">    &#125;</div><div class="line">    [mutableCoders addObject:coder];</div><div class="line">    self.coders = [mutableCoders copy];</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</div><div class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</div><div class="line">    [mutableCoders removeObject:coder];</div><div class="line">    self.coders = [mutableCoders copy];</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后它提供了直接对数据进行编解码的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canDecodeFromData:data]) &#123;</div><div class="line">            return [coder decodedImageWithData:data];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</div><div class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canDecodeFromData:*data]) &#123;</div><div class="line">            return [coder decompressedImageWithImage:image data:data options:optionsDict];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</div><div class="line">    if (!image) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    LOCK(self.codersLock);</div><div class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</div><div class="line">    UNLOCK(self.codersLock);</div><div class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</div><div class="line">        if ([coder canEncodeToFormat:format]) &#123;</div><div class="line">            return [coder encodedDataWithImage:image format:format];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过判断传入的数据是否支持编解码，如果支持就调用对应的编解码函数，如果不支持直接返回空。</p>
<h4 id="SDWebImageCoderHelper"><a href="#SDWebImageCoderHelper" class="headerlink" title="SDWebImageCoderHelper"></a>SDWebImageCoderHelper</h4><p>最后来看一下这个Helper,该类提供了几个通用的方法，主要有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//使用SDWebImageFrame帧序列创建图片</div><div class="line">+ (UIImage * _Nullable)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; * _Nullable)frames;</div><div class="line">//获取图片的所有帧数据</div><div class="line">+ (NSArray&lt;SDWebImageFrame *&gt; * _Nullable)framesFromAnimatedImage:(UIImage * _Nullable)animatedImage;</div><div class="line">//判断图片的朝向</div><div class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation;</div><div class="line">//将sd的朝向转为文件中应该的值</div><div class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation;</div></pre></td></tr></table></figure>
<p>看一下具体实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; *)frames &#123;</div><div class="line">    NSUInteger frameCount = frames.count;</div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIImage *animatedImage;</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSUInteger durations[frameCount];</div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        durations[i] = frames[i].duration * 1000;</div><div class="line">    &#125;</div><div class="line">    NSUInteger const gcd = gcdArray(frameCount, durations);</div><div class="line">    __block NSUInteger totalDuration = 0;</div><div class="line">    NSMutableArray&lt;UIImage *&gt; *animatedImages = [NSMutableArray arrayWithCapacity:frameCount];</div><div class="line">    [frames enumerateObjectsUsingBlock:^(SDWebImageFrame * _Nonnull frame, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        UIImage *image = frame.image;</div><div class="line">        NSUInteger duration = frame.duration * 1000;</div><div class="line">        totalDuration += duration;</div><div class="line">        NSUInteger repeatCount;</div><div class="line">        if (gcd) &#123;</div><div class="line">            repeatCount = duration / gcd;</div><div class="line">        &#125; else &#123;</div><div class="line">            repeatCount = 1;</div><div class="line">        &#125;</div><div class="line">        for (size_t i = 0; i &lt; repeatCount; ++i) &#123;</div><div class="line">            [animatedImages addObject:image];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    animatedImage = [UIImage animatedImageWithImages:animatedImages duration:totalDuration / 1000.f];</div><div class="line">    </div><div class="line">#else</div><div class="line">    </div><div class="line">    NSMutableData *imageData = [NSMutableData data];</div><div class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</div><div class="line">    // Create an image destination. GIF does not support EXIF image orientation</div><div class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frameCount, NULL);</div><div class="line">    if (!imageDestination) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            SDWebImageFrame *frame = frames[i];</div><div class="line">            float frameDuration = frame.duration;</div><div class="line">            CGImageRef frameImageRef = frame.image.CGImage;</div><div class="line">            NSDictionary *frameProperties = @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge_transfer NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</div><div class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Finalize the destination.</div><div class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</div><div class="line">        // Handle failure.</div><div class="line">        CFRelease(imageDestination);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CFRelease(imageDestination);</div><div class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:imageData];</div><div class="line">    animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</div><div class="line">    [animatedImage addRepresentation:imageRep];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return animatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>帧数组转图片，如果是iOS平台，主要调用UIImage的<strong>animatedImageWithImages:duration</strong>方法创建，mac平台上我们看到了熟悉的身影CGImageDestinationRef，这个之前在做编码的时候用到过。</p>
<p>然后是图片转帧数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">+ (NSArray&lt;SDWebImageFrame *&gt; *)framesFromAnimatedImage:(UIImage *)animatedImage &#123;</div><div class="line">    if (!animatedImage) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</div><div class="line">    NSUInteger frameCount = 0;</div><div class="line">    </div><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">    NSArray&lt;UIImage *&gt; *animatedImages = animatedImage.images;</div><div class="line">    frameCount = animatedImages.count;</div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSTimeInterval avgDuration = animatedImage.duration / frameCount;</div><div class="line">    if (avgDuration == 0) &#123;</div><div class="line">        avgDuration = 0.1; // if it&apos;s a animated image but no duration, set it to default 100ms (this do not have that 10ms limit like GIF or WebP to allow custom coder provide the limit)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block NSUInteger index = 0;</div><div class="line">    __block NSUInteger repeatCount = 1;</div><div class="line">    __block UIImage *previousImage = animatedImages.firstObject;</div><div class="line">    [animatedImages enumerateObjectsUsingBlock:^(UIImage * _Nonnull image, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        // ignore first</div><div class="line">        if (idx == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if ([image isEqual:previousImage]) &#123;</div><div class="line">            repeatCount++;</div><div class="line">        &#125; else &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">            repeatCount = 1;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        previousImage = image;</div><div class="line">        // last one</div><div class="line">        if (idx == frameCount - 1) &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">#else</div><div class="line">    </div><div class="line">    NSBitmapImageRep *bitmapRep;</div><div class="line">    for (NSImageRep *imageRep in animatedImage.representations) &#123;</div><div class="line">        if ([imageRep isKindOfClass:[NSBitmapImageRep class]]) &#123;</div><div class="line">            bitmapRep = (NSBitmapImageRep *)imageRep;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (bitmapRep) &#123;</div><div class="line">        frameCount = [[bitmapRep valueForProperty:NSImageFrameCount] unsignedIntegerValue];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (frameCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">            // NSBitmapImageRep need to manually change frame. &quot;Good taste&quot; API</div><div class="line">            [bitmapRep setProperty:NSImageCurrentFrame withValue:@(i)];</div><div class="line">            float frameDuration = [[bitmapRep valueForProperty:NSImageCurrentFrameDuration] floatValue];</div><div class="line">            NSImage *frameImage = [[NSImage alloc] initWithCGImage:bitmapRep.CGImage size:CGSizeZero];</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:frameImage duration:frameDuration];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return frames;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也是分了iOS和mac2个平台，iOS上直接去UIImage的images属性遍历一遍，mac上使用了NSBitmapImageRep这个对象获取图片的所有帧数据，然后在循环中从这个对象中取出所有的帧数据。</p>
<p>下面这2个是朝向转换的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#if SD_UIKIT || SD_WATCH</div><div class="line">// Convert an EXIF image orientation to an iOS one.</div><div class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation &#123;</div><div class="line">    // CGImagePropertyOrientation is available on iOS 8 above. Currently kept for compatibility</div><div class="line">    UIImageOrientation imageOrientation = UIImageOrientationUp;</div><div class="line">    switch (exifOrientation) &#123;</div><div class="line">        case 1:</div><div class="line">            imageOrientation = UIImageOrientationUp;</div><div class="line">            break;</div><div class="line">        case 3:</div><div class="line">            imageOrientation = UIImageOrientationDown;</div><div class="line">            break;</div><div class="line">        case 8:</div><div class="line">            imageOrientation = UIImageOrientationLeft;</div><div class="line">            break;</div><div class="line">        case 6:</div><div class="line">            imageOrientation = UIImageOrientationRight;</div><div class="line">            break;</div><div class="line">        case 2:</div><div class="line">            imageOrientation = UIImageOrientationUpMirrored;</div><div class="line">            break;</div><div class="line">        case 4:</div><div class="line">            imageOrientation = UIImageOrientationDownMirrored;</div><div class="line">            break;</div><div class="line">        case 5:</div><div class="line">            imageOrientation = UIImageOrientationLeftMirrored;</div><div class="line">            break;</div><div class="line">        case 7:</div><div class="line">            imageOrientation = UIImageOrientationRightMirrored;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return imageOrientation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Convert an iOS orientation to an EXIF image orientation.</div><div class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation &#123;</div><div class="line">    // CGImagePropertyOrientation is available on iOS 8 above. Currently kept for compatibility</div><div class="line">    NSInteger exifOrientation = 1;</div><div class="line">    switch (imageOrientation) &#123;</div><div class="line">        case UIImageOrientationUp:</div><div class="line">            exifOrientation = 1;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationDown:</div><div class="line">            exifOrientation = 3;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationLeft:</div><div class="line">            exifOrientation = 8;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationRight:</div><div class="line">            exifOrientation = 6;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationUpMirrored:</div><div class="line">            exifOrientation = 2;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationDownMirrored:</div><div class="line">            exifOrientation = 4;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationLeftMirrored:</div><div class="line">            exifOrientation = 5;</div><div class="line">            break;</div><div class="line">        case UIImageOrientationRightMirrored:</div><div class="line">            exifOrientation = 7;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return exifOrientation;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sd中是使用下面的代码拿到在图片数据中朝向的值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</div><div class="line">NSInteger orientationValue = 1;</div><div class="line">CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</div><div class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</div></pre></td></tr></table></figure>
<p>以上所有编解码相关的类就分析完毕了。这里我们在设计模块的时候可应该参考sd里面的做法，首先通过协议的方式放开需要的接口，各模块按根据需求决定是否实现对应协议，虽然都是编解码，但是针对不同的格式创建不同的类去实现，然后在manager中通过判断不同的格式调用不同的模块去做具体的事情，减少逻辑的耦合。</p>
<h3 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h3><p>看完了下载，缓存和编解码这三个主要的模块，在来看看它们的manager，这个其实就比较简单了，就是对上面几个模块的相关方法进行了一些封装。</p>
<p>先看一下这个私有类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</div><div class="line"></div><div class="line">@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;</div><div class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</div><div class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</div><div class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在manager中定义了相关属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</div></pre></td></tr></table></figure>
<p>这里，manager将每一个download返回的SDWebImageDownloadToken封装为一个SDWebImageCombinedOperation，存放在runningOperations这个数组里面，主要是为了在取消的时候方便操作（这个在之前介绍下载模块的时候已经有说明）。</p>
<p>manager创建了一个集合如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</div></pre></td></tr></table></figure>
<p>主要用来存储下载失败的url，如果url下载失败会被添加到上面的集合中，如果当前url在该合集中，且option不是SDWebImageRetryFailed（这个option是消除黑名单用的），则直接返回下载失败。如果option是SDWebImageRetryFailed，则会去重新下载。</p>
<p>manager还提供了2个block，让使用者有机会修改一下内容。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef NSString * _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL * _Nullable url);</div><div class="line"></div><div class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</div></pre></td></tr></table></figure>
<p>这个block可以修改当前图片缓存时的键值，默认是使用url.absoluteString作为键值进行缓存的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef NSData * _Nullable(^SDWebImageCacheSerializerBlock)(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL);</div><div class="line"></div><div class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</div></pre></td></tr></table></figure>
<p>这个block可以用来修改缓存图片的数据。它接收当前下载的图片的image对象，data对象和url，返回一个data.你可以在block对传入的图片数据做一些处理，比如做一下编码或者格式转化什么的。</p>
<p>manager中最主要的还是下面这个loadimageurl的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">    // Invoking this method without a completedBlock is pointless</div><div class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</div><div class="line"></div><div class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t</div><div class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</div><div class="line">    if ([url isKindOfClass:NSString.class]) &#123;</div><div class="line">        url = [NSURL URLWithString:(NSString *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</div><div class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</div><div class="line">        url = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    operation.manager = self;</div><div class="line"></div><div class="line">    BOOL isFailedUrl = NO;</div><div class="line">    if (url) &#123;</div><div class="line">        LOCK(self.failedURLsLock);</div><div class="line">        isFailedUrl = [self.failedURLs containsObject:url];</div><div class="line">        UNLOCK(self.failedURLsLock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</div><div class="line">        return operation;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LOCK(self.runningOperationsLock);</div><div class="line">    [self.runningOperations addObject:operation];</div><div class="line">    UNLOCK(self.runningOperationsLock);</div><div class="line">    NSString *key = [self cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    SDImageCacheOptions cacheOptions = 0;</div><div class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</div><div class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</div><div class="line">    if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</div><div class="line">    </div><div class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</div><div class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Check whether we should download image from network</div><div class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</div><div class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</div><div class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</div><div class="line">        if (shouldDownload) &#123;</div><div class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</div><div class="line">                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</div><div class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</div><div class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</div><div class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</div><div class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</div><div class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</div><div class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</div><div class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</div><div class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</div><div class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</div><div class="line">            </div><div class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                // force progressive off if image already cached but forced refreshing</div><div class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</div><div class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</div><div class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</div><div class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</div><div class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</div><div class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</div><div class="line">                    // Do nothing if the operation was cancelled</div><div class="line">                    // See #699 for more details</div><div class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</div><div class="line">                &#125; else if (error) &#123;</div><div class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</div><div class="line">                    BOOL shouldBlockFailedURL;</div><div class="line">                    // Check whether we should block failed url</div><div class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</div><div class="line">                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</div><div class="line">                    &#125; else &#123;</div><div class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</div><div class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    if (shouldBlockFailedURL) &#123;</div><div class="line">                        LOCK(self.failedURLsLock);</div><div class="line">                        [self.failedURLs addObject:url];</div><div class="line">                        UNLOCK(self.failedURLsLock);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        LOCK(self.failedURLsLock);</div><div class="line">                        [self.failedURLs removeObject:url];</div><div class="line">                        UNLOCK(self.failedURLsLock);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">                    </div><div class="line">                    // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</div><div class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</div><div class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</div><div class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            if (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                NSData *cacheData;</div><div class="line">                                // pass nil if the image was transformed, so we can recalculate the data from the image</div><div class="line">                                if (self.cacheSerializer) &#123;</div><div class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</div><div class="line">                                &#125;</div><div class="line">                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            if (self.cacheSerializer) &#123;</div><div class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</div><div class="line">                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                                &#125;);</div><div class="line">                            &#125; else &#123;</div><div class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (finished) &#123;</div><div class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125; else if (cachedImage) &#123;</div><div class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</div><div class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">        &#125; else &#123;</div><div class="line">            // Image not in cache and download disallowed by delegate</div><div class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</div><div class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是一个先查找缓存，如果没有命中再去下载的过程，是一个比较经典的逻辑，网上一般说sd都会说到这里的这个逻辑。这里就不细说了。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>sd大家用的最多的其实是分类，特别是UIImageView的分类，这里我挑2个比较有内容的分类说一下，其他分类都比较简单，就是纯调api了。</p>
<h4 id="NSData-ImageContentType"><a href="#NSData-ImageContentType" class="headerlink" title="NSData + ImageContentType"></a>NSData + ImageContentType</h4><p>这个分类比较重要的知识点就是如何通过图片文件判断图片格式，看一下主要代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</div><div class="line">    if (!data) &#123;</div><div class="line">        return SDImageFormatUndefined;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // File signatures table: http://www.garykessler.net/library/file_sigs.html</div><div class="line">    uint8_t c;</div><div class="line">    [data getBytes:&amp;c length:1];</div><div class="line">    switch (c) &#123;</div><div class="line">        case 0xFF:</div><div class="line">            return SDImageFormatJPEG;</div><div class="line">        case 0x89:</div><div class="line">            return SDImageFormatPNG;</div><div class="line">        case 0x47:</div><div class="line">            return SDImageFormatGIF;</div><div class="line">        case 0x49:</div><div class="line">        case 0x4D:</div><div class="line">            return SDImageFormatTIFF;</div><div class="line">        case 0x52: &#123;</div><div class="line">            if (data.length &gt;= 12) &#123;</div><div class="line">                //RIFF....WEBP</div><div class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</div><div class="line">                if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</div><div class="line">                    return SDImageFormatWebP;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case 0x00: &#123;</div><div class="line">            if (data.length &gt;= 12) &#123;</div><div class="line">                //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</div><div class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</div><div class="line">                if ([testString isEqualToString:@&quot;ftypheic&quot;]</div><div class="line">                    || [testString isEqualToString:@&quot;ftypheix&quot;]</div><div class="line">                    || [testString isEqualToString:@&quot;ftyphevc&quot;]</div><div class="line">                    || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</div><div class="line">                    return SDImageFormatHEIC;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return SDImageFormatUndefined;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到代码就应该很明了了，通过文件数据的第一个字节来判断文件格式，这里用2个十六进制数表示一个字节。这个函数如果有需要可以直接拿来用。</p>
<h4 id="UIView-WebCache"><a href="#UIView-WebCache" class="headerlink" title="UIView + WebCache"></a>UIView + WebCache</h4><p>这个算是所有分类的父类了，大部分UI相关的分类最后都是调用的这个分类里面的一个方法，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</div><div class="line">                  placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(nullable NSString *)operationKey</div><div class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</div><div class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context &#123;</div><div class="line">    NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</div><div class="line">    [self sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">        if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</div><div class="line">            dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</div><div class="line">            dispatch_group_enter(group);</div><div class="line">        &#125;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (url) &#123;</div><div class="line">#if SD_UIKIT</div><div class="line">        // check if activityView is enabled or not</div><div class="line">        if ([self sd_showActivityIndicatorView]) &#123;</div><div class="line">            [self sd_addActivityIndicator];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        </div><div class="line">        // reset the progress</div><div class="line">        self.sd_imageProgress.totalUnitCount = 0;</div><div class="line">        self.sd_imageProgress.completedUnitCount = 0;</div><div class="line">        </div><div class="line">        SDWebImageManager *manager;</div><div class="line">        if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</div><div class="line">            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</div><div class="line">        &#125; else &#123;</div><div class="line">            manager = [SDWebImageManager sharedManager];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        __weak __typeof(self)wself = self;</div><div class="line">        SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</div><div class="line">            wself.sd_imageProgress.totalUnitCount = expectedSize;</div><div class="line">            wself.sd_imageProgress.completedUnitCount = receivedSize;</div><div class="line">            if (progressBlock) &#123;</div><div class="line">                progressBlock(receivedSize, expectedSize, targetURL);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</div><div class="line">            __strong __typeof (wself) sself = wself;</div><div class="line">            if (!sself) &#123; return; &#125;</div><div class="line">#if SD_UIKIT</div><div class="line">            [sself sd_removeActivityIndicator];</div><div class="line">#endif</div><div class="line">            // if the progress not been updated, mark it to complete state</div><div class="line">            if (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == 0 &amp;&amp; sself.sd_imageProgress.completedUnitCount == 0) &#123;</div><div class="line">                sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</div><div class="line">                sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</div><div class="line">            &#125;</div><div class="line">            BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</div><div class="line">            BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</div><div class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</div><div class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</div><div class="line">                if (!sself) &#123; return; &#125;</div><div class="line">                if (!shouldNotSetImage) &#123;</div><div class="line">                    [sself sd_setNeedsLayout];</div><div class="line">                &#125;</div><div class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            </div><div class="line">            // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set</div><div class="line">            // OR</div><div class="line">            // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set</div><div class="line">            if (shouldNotSetImage) &#123;</div><div class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            UIImage *targetImage = nil;</div><div class="line">            NSData *targetData = nil;</div><div class="line">            if (image) &#123;</div><div class="line">                // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</div><div class="line">                targetImage = image;</div><div class="line">                targetData = data;</div><div class="line">            &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</div><div class="line">                // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</div><div class="line">                targetImage = placeholder;</div><div class="line">                targetData = nil;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">            // check whether we should use the image transition</div><div class="line">            SDWebImageTransition *transition = nil;</div><div class="line">            if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</div><div class="line">                transition = sself.sd_imageTransition;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">            if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</div><div class="line">                dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</div><div class="line">                dispatch_group_enter(group);</div><div class="line">                dispatch_main_async_safe(^&#123;</div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</div><div class="line">#else</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">#endif</div><div class="line">                &#125;);</div><div class="line">                // ensure completion block is called after custom setImage process finish</div><div class="line">                dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">                    callCompletedBlockClojure();</div><div class="line">                &#125;);</div><div class="line">            &#125; else &#123;</div><div class="line">                dispatch_main_async_safe(^&#123;</div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</div><div class="line">#else</div><div class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">#endif</div><div class="line">                    callCompletedBlockClojure();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        [self sd_setImageLoadOperation:operation forKey:validOperationKey];</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">#if SD_UIKIT</div><div class="line">            [self sd_removeActivityIndicator];</div><div class="line">#endif</div><div class="line">            if (completedBlock) &#123;</div><div class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</div><div class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接看加载图片部分吧，图片下载完成后，如果当前是MAC平台的话，还创建了一个转场动画SDWebImageTransition，这个转场动画比较简单，都是最基本的转场效果。</p>
<p>然后我们看一下设置图片给UI的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">//不带转场动画的方法</div><div class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock &#123;</div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">    [self sd_setImage:image imageData:imageData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:nil cacheType:0 imageURL:nil];</div><div class="line">#else</div><div class="line">    // watchOS does not support view transition. Simplify the logic</div><div class="line">    if (setImageBlock) &#123;</div><div class="line">        setImageBlock(image, imageData);</div><div class="line">    &#125; else if ([self isKindOfClass:[UIImageView class]]) &#123;</div><div class="line">        UIImageView *imageView = (UIImageView *)self;</div><div class="line">        [imageView setImage:image];</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">//带转场动画的方法</div><div class="line"></div><div class="line">#if SD_UIKIT || SD_MAC</div><div class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL &#123;</div><div class="line">    UIView *view = self;</div><div class="line">    SDSetImageBlock finalSetImageBlock;</div><div class="line">    if (setImageBlock) &#123;</div><div class="line">        finalSetImageBlock = setImageBlock;</div><div class="line">    &#125; else if ([view isKindOfClass:[UIImageView class]]) &#123;</div><div class="line">        UIImageView *imageView = (UIImageView *)view;</div><div class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData) &#123;</div><div class="line">            imageView.image = setImage;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">#if SD_UIKIT</div><div class="line">    else if ([view isKindOfClass:[UIButton class]]) &#123;</div><div class="line">        UIButton *button = (UIButton *)view;</div><div class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData)&#123;</div><div class="line">            [button setImage:setImage forState:UIControlStateNormal];</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    if (transition) &#123;</div><div class="line">#if SD_UIKIT</div><div class="line">        [UIView transitionWithView:view duration:0 options:0 animations:^&#123;</div><div class="line">            // 0 duration to let UIKit render placeholder and prepares block</div><div class="line">            if (transition.prepares) &#123;</div><div class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</div><div class="line">            &#125;</div><div class="line">        &#125; completion:^(BOOL finished) &#123;</div><div class="line">            [UIView transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</div><div class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</div><div class="line">                    finalSetImageBlock(image, imageData);</div><div class="line">                &#125;</div><div class="line">                if (transition.animations) &#123;</div><div class="line">                    transition.animations(view, image);</div><div class="line">                &#125;</div><div class="line">            &#125; completion:transition.completion];</div><div class="line">        &#125;];</div><div class="line">#elif SD_MAC</div><div class="line">        [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull prepareContext) &#123;</div><div class="line">            // 0 duration to let AppKit render placeholder and prepares block</div><div class="line">            prepareContext.duration = 0;</div><div class="line">            if (transition.prepares) &#123;</div><div class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</div><div class="line">            &#125;</div><div class="line">        &#125; completionHandler:^&#123;</div><div class="line">            [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull context) &#123;</div><div class="line">                context.duration = transition.duration;</div><div class="line">                context.timingFunction = transition.timingFunction;</div><div class="line">                context.allowsImplicitAnimation = (transition.animationOptions &amp; SDWebImageAnimationOptionAllowsImplicitAnimation);</div><div class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</div><div class="line">                    finalSetImageBlock(image, imageData);</div><div class="line">                &#125;</div><div class="line">                if (transition.animations) &#123;</div><div class="line">                    transition.animations(view, image);</div><div class="line">                &#125;</div><div class="line">            &#125; completionHandler:^&#123;</div><div class="line">                if (transition.completion) &#123;</div><div class="line">                    transition.completion(YES);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;];</div><div class="line">#endif</div><div class="line">    &#125; else &#123;</div><div class="line">        if (finalSetImageBlock) &#123;</div><div class="line">            finalSetImageBlock(image, imageData);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这里看一下具体的转场动画是咋做的吧，如果是iOS，使用UIView的transitionWithView方法添加动画，具体的添加动画的代码再transition.animations这个block中，就是给当前view的layer添加一个animation.在mac上则是使用NSAnimationContext的runAnimationGroup方法添加动画，具体添加方法和iOS一样。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>初看sd的代码时，觉得有点杂乱无章，命名也不太友好，然后模块层级也不太明确，和af比起来在架构方面差好多。不过在按模块分析和研读sd的代码后，还有能学到很多而且是可以运用到实际开发中的姿势点的，比如自定义一个下载器部分，可以学习sd是如何自定义封装一个NSOpearion，如何管理每一个NSOpearion的生命周期，如何回调下载中的数据等。对于编解码能学到的东西也很多，比如针对不同编解码器如何使用同一套接口去编程，最主要的当然是对不同图片数据的编解码方式，这个也是该模块最核心的功能。对于缓存模块可以学到NSCache以及NSMapTable的使用，NSURLCache的使用，对于缓存内存的限制，以及缓存不足时的删除策略等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" itemprop="url">
                  使用AudioQueue实现一个音频播放(二)--边播边缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T16:01:06+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/使用AudioQueue实现一个音频播放-二-边播边缓存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://llyblog.com/2018/05/07/使用AudioQueue实现一个音频播放器/" target="_blank" rel="noopener">前一篇文章</a>中介绍了使用AuidoQueue实现一个音频播放器的功能,最近我又把这个项目完善了一下，做了一个边播边缓存的功能。</p>
<p>因为播放部分的逻辑我们已经完成，这里主要是怎么缓存数据的问题，实现之前我想到了2种方案。</p>
<h3 id="方案一-在didReceiveDataBlock中缓存文件"><a href="#方案一-在didReceiveDataBlock中缓存文件" class="headerlink" title="方案一 在didReceiveDataBlock中缓存文件"></a>方案一 在didReceiveDataBlock中缓存文件</h3><p>直接在拿到音频数据进行播放的同时就将数据写入文件，这种方案的优点是实时性，播放过的音频数据都会被缓存起来，缺点就是缓存的文件可能并不是一个完整的音频，比如播了1分钟后seek到2分钟的地方继续播，中间1分钟的数据可能就没有收到，这就导致缓存的文件是有问题的，如果下次直接播这个本地文件可能就凉凉了。。。</p>
<h3 id="方案二-在success的回调中缓存数据"><a href="#方案二-在success的回调中缓存数据" class="headerlink" title="方案二 在success的回调中缓存数据"></a>方案二 在success的回调中缓存数据</h3><p>在success中回调回来的数据就是完整的音频数据，缓存这个数据不会出现数据不完整的情况，但是这个回调并不是实时返回的，会在整个音频的数据都获取到以后才会返回，有一个延迟，如果网络不太好，可能直到音频播放完了才会返回。</p>
<p>考虑到方案的可行性和数据的可用性，这里我选择了方案二，毕竟完整的数据比缓存的实时性更重要一些。当然，这个方案一我觉得还是有优化的空间，如果能够优化到保证了数据的完整性，会比方案二更优。</p>
<h3 id="增加的模块"><a href="#增加的模块" class="headerlink" title="增加的模块"></a>增加的模块</h3><p>这里我增加了2个模块，一个是文件的操作模块，还有一个是网络模块。</p>
<h4 id="LLYFileManager"><a href="#LLYFileManager" class="headerlink" title="LLYFileManager"></a>LLYFileManager</h4><p>文件操作模块是对音频数据的存储相关操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@interface LLYFileManager : NSObject</div><div class="line"></div><div class="line">//网络地址转本地地址</div><div class="line">+ (NSString *)pathWithUrl:(NSString *)fileUrl;</div><div class="line">//将数据保存到本地目录下</div><div class="line">+ (BOOL)saveFileWithPath:(NSString *)path fileObject:(id)fileObject;</div><div class="line">//判断当前url对应的文件是否已经缓存</div><div class="line">+ (BOOL)isFileExit:(NSString *)url;</div><div class="line">//获取文件大小</div><div class="line">+ (unsigned long long)fileSizeWithFilePath:(NSString *)filePath;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="LLYHttpSessionManager"><a href="#LLYHttpSessionManager" class="headerlink" title="LLYHttpSessionManager"></a>LLYHttpSessionManager</h4><p>网络模块是基于AFNetworking做的一个二次封装<a href="http://llyblog.com/2018/06/14/AFNetworking学习笔记与实践/" target="_blank" rel="noopener">(参考这篇文章)</a>，主要就是请求音频数据。</p>
<h3 id="播放优化"><a href="#播放优化" class="headerlink" title="播放优化"></a>播放优化</h3><p>在播放前，我们需判断一下当前url对应的文件是否已经下载到本地了，如果已经下载就直接播本地的文件，否则还是走网络播放的逻辑。</p>
<p>这个判断逻辑我是这样处理的，先发送一个http head请求，拿到对应url文件的countOfBytesExpectedToReceive，然后将countOfBytesExpectedToReceive和本地文件大小（fileSize）进行比较，如果fileSize &gt;= contentExceptLength，则说明本地文件是完整的音频文件，可以直接播放，否则的话还是走网络播放的逻辑，并在success回调中覆盖之前的不完整文件。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioPlayer.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/AFNetworking学习笔记与实践/" itemprop="url">
                  AFNetworking学习笔记与实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T09:58:47+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/AFNetworking学习笔记与实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/AFNetworking学习笔记与实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从AF使用NSURLSession重写之后，还没有看过源码，NSURLSession是基于NSURLConnection的封装，应该是汲取了AF之前的设计，内部封装了一个NSOperation来实现异步请求。最近要做一个音频播放的边播边缓存的功能，网路请求这块需要封装一下，随便研究一下AF的源码，这里我按模块逐个分析一下。</p>
<h4 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h4><p>这个模块是AF中最大也是最重要的一个模块，它封装了一个session,提供了一系列的初始化方法和创建task的方法。如果大家对session和task的概念还不太理解，可以先看一下NSURLSession这个类的相关内容（这个大概说一下，session是管理所有网络请求的，每一个网络请求是一个task，task是使用session创建的，所有task共享session的相关设置）。</p>
<p>先来看一下创建task的方法，这里总共有datatask,uploadtask和downloadtask三种task，不过他们的创建逻辑都是一样的，以datatask为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看看上面这个宏的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</div><div class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</div><div class="line">        // Fix of bug</div><div class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</div><div class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</div><div class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</div><div class="line">    &#125; else &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static dispatch_queue_t url_session_manager_creation_queue() &#123;</div><div class="line">    static dispatch_queue_t af_url_session_manager_creation_queue;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return af_url_session_manager_creation_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里这样做主要是为了解决ios8之前的一个bug，如果异步同时创建task的话，task的id有可能是一样的，这会导致回调时出现问题（completionHandler被替换），为了解决这个问题，创建task的操作都放在一个串行队列中执行。</p>
<p>然后看一下添加代理这个又是要干嘛</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，af为每一个task都创建了一个delegate，然后将代理存在了self.mutableTaskDelegatesKeyedByTaskIdentifier这个字典中，键值是task的id,这里也解释了上面的为啥要同步创建task,那么它为啥要为每个task添加一个代理呢，我们继续往下看。</p>
<p>看完task的创建，然后我们再来看一下数据的回调。<strong>af为每个NSURLSession的回调函数创建了对应block和setBlock的方法，如果你需要哪个代理里面的数据，直接创建对应的block即可。</strong></p>
<p>我们先来看最常用的回调方法，即请求完成的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line">        </div><div class="line">        //将该task的代理从字典中移除</div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看有点奇怪，这2方法名一毛一样啊。没有错，这两个方法是同一个代理方法，只是他们的实现对象是不一样的，第一个的实现对象是AFURLSessionManager类,第二个的实现对象则是AFURLSessionManagerTaskDelegate这个类，这里就解释上面的为啥要为每一个task设置一个代理，af这里其实是吧NSURLSession的代理又包了一层，将NSURLSession的数据都传到AFURLSessionManagerTaskDelegate这个类里面去处理了。</p>
<p>然后我们看一下这个回调中对数据的处理，可以看到回调的返回都是放在一个gcd的group中处理的，如果我们设置了返回处理线程的话就使用设置的线程，否则会在主线程中处理数据的返回，如果有错误是直接返回了，没有错误的话，会先使用responeseSerializer去验证一下返回的数据格式是否合法，这个类我们下面在细看。</p>
<p>继续看其他几个我觉得比较常用的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">          dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">didReceiveResponse:(NSURLResponse *)response</div><div class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</div><div class="line">&#123;</div><div class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</div><div class="line"></div><div class="line">    if (self.dataTaskDidReceiveResponse) &#123;</div><div class="line">        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">          dataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</div><div class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</div><div class="line"></div><div class="line">    if (self.dataTaskDidReceiveData) &#123;</div><div class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</div><div class="line">    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</div><div class="line"></div><div class="line">	//这里保存的数据会在complete的回调中使用</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这2个回调一个是收到responese被触发，这个回调可以拿到相应头部信息，比如接收文件的大小，格式等，一个是收到数据时被触发，进度相关的信息就在通过这个回调拿到的。<strong>还有一点就是，download的task不会走datatask的代理，意味着download的数据只能在下载完成后通过文件的方式拿到。</strong></p>
<h4 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h4><p>这个类就是继承了AFURLSessionManager，然后提供了一些封装好的创建task的方法。平时二次封装也是使用这个类就行。</p>
<p>然后这个类有三个比较重要的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;</div></pre></td></tr></table></figure>
<p>这里简单介绍每个属性的用途，下面还有详解。<br>requestSerializer主要用来设置httpheader，responseSerializer主要用来解析返回数据是否合法，<br>securityPolicy主要用来验证服务器证书。</p>
<h4 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h4><p>先来看一下AFHTTPRequestSerializer在AFHTTPSessionManager中是如何使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在调用AFURLSessionManager的创建task方法前，会先调用一下下面这个方法生成一个request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div></pre></td></tr></table></figure>
<p>那我们来具体看一下这个方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</div><div class="line">                                 URLString:(NSString *)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(method);</div><div class="line">    NSParameterAssert(URLString);</div><div class="line"></div><div class="line">    NSURL *url = [NSURL URLWithString:URLString];</div><div class="line"></div><div class="line">    NSParameterAssert(url);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</div><div class="line">    mutableRequest.HTTPMethod = method;</div><div class="line"></div><div class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</div><div class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</div><div class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</div><div class="line"></div><div class="line">	return mutableRequest;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSString *query = nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                case AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</div><div class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体流程：</p>
<ul>
<li>使用url和method创建一个mutableRequest，</li>
<li>kvo相关属性，如果不为空则kvc到mutableRequest</li>
<li>设置HTTPRequestHeaders数组中相关属性到mutableRequest</li>
<li>将传入的参数做一下url编码</li>
<li>如果是get，head,delete方式，将参数加到url后面，否则，将参数设置为mutableRequest的body，同时设置mutableRequest的Content-Type.</li>
</ul>
<p>可以看出，这个类的主要作用就是创建request，给request设置相应的header和body,对url和参数进行编码(url使用URLEncode,body使用UNICode编码).</p>
<h4 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h4><p>这个类在上面的complete回调中有提到，这里具体分析。</p>
<p>af一共提供了7种ResponseSerializer，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">AFHTTPResponseSerializer</div><div class="line"></div><div class="line">AFJSONResponseSerializer</div><div class="line"></div><div class="line">AFXMLParserResponseSerializer</div><div class="line"></div><div class="line">AFXMLDocumentResponseSerializer</div><div class="line"></div><div class="line">AFPropertyListResponseSerializer</div><div class="line"></div><div class="line">AFImageResponseSerializer</div><div class="line"></div><div class="line">AFCompoundResponseSerializer</div></pre></td></tr></table></figure>
<p>不同的response针对不同的数据类型。</p>
<p>他们的主要区别其实就在acceptableContentTypes这个属性上，它是一个集合，用来存储我们需要接受的数据类型。</p>
<p>比如JSON的acceptableContentTypes为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</div></pre></td></tr></table></figure>
<p>IMAGE的acceptableContentTypes为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;image/tiff&quot;, @&quot;image/jpeg&quot;, @&quot;image/gif&quot;, @&quot;image/png&quot;, @&quot;image/ico&quot;, @&quot;image/x-icon&quot;, @&quot;image/bmp&quot;, @&quot;image/x-bmp&quot;, @&quot;image/x-xbitmap&quot;, @&quot;image/x-win-bitmap&quot;, nil];</div></pre></td></tr></table></figure>
<p>我们可以通过NSHTTPSessionManager的responseSerializer修改你需要的数据类型。</p>
<p>回到之前的complete回调，看看具体怎么使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</div><div class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</div><div class="line"></div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[response MIMEType] 这个type就是当前服务器返回的数据的格式，需要self.acceptableContentTypes这个集合中包含上面的type，解析数据的时候才会返回成功，所以，如果遇到解析失败的话，可以断点到这里看一下这个type然后手动添加到acceptableContentTypes这个集合中。</p>
<h4 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h4><p>af提供了三种验证证书的方式，第一种不需要本地证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123;</div><div class="line">    AFSSLPinningModeNone,//默认方式，只需要验证服务器返回的证书是否合法</div><div class="line">    AFSSLPinningModePublicKey,//需要验证本地证书中的公钥是否包含服务器返回的证书中的公钥</div><div class="line">    AFSSLPinningModeCertificate,//需要验证本地证书是否在服务器证书的证书链中</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对应的有几种不同的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123;</div><div class="line">    NSArray *paths = [bundle pathsForResourcesOfType:@&quot;cer&quot; inDirectory:@&quot;.&quot;];</div><div class="line"></div><div class="line">    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];</div><div class="line">    for (NSString *path in paths) &#123;</div><div class="line">        NSData *certificateData = [NSData dataWithContentsOfFile:path];</div><div class="line">        [certificates addObject:certificateData];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [NSSet setWithSet:certificates];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)defaultPinnedCertificates &#123;</div><div class="line">    static NSSet *_defaultPinnedCertificates = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSBundle *bundle = [NSBundle bundleForClass:[self class]];</div><div class="line">        _defaultPinnedCertificates = [self certificatesInBundle:bundle];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _defaultPinnedCertificates;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)defaultPolicy &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</div><div class="line">    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = pinningMode;</div><div class="line"></div><div class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们看一下到底是如何进行证书验证的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(NSString *)domain</div><div class="line">&#123;</div><div class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</div><div class="line">        // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</div><div class="line">        //  According to the docs, you should only trust your provided certs for evaluation.</div><div class="line">        //  Pinned certificates are added to the trust. Without pinned certificates,</div><div class="line">        //  there is nothing to evaluate against.</div><div class="line">        //</div><div class="line">        //  From Apple Docs:</div><div class="line">        //          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</div><div class="line">        //           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</div><div class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableArray *policies = [NSMutableArray array];</div><div class="line">    if (self.validatesDomainName) &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</div><div class="line">    &#125; else &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</div><div class="line"></div><div class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    switch (self.SSLPinningMode) &#123;</div><div class="line">        case AFSSLPinningModeNone:</div><div class="line">        default:</div><div class="line">            return NO;</div><div class="line">        case AFSSLPinningModeCertificate: &#123;</div><div class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</div><div class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</div><div class="line"></div><div class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                return NO;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</div><div class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">            </div><div class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    return YES;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        case AFSSLPinningModePublicKey: &#123;</div><div class="line">            NSUInteger trustedPublicKeyCount = 0;</div><div class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            for (id trustChainPublicKey in publicKeys) &#123;</div><div class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</div><div class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += 1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return trustedPublicKeyCount &gt; 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</div><div class="line">    BOOL isValid = NO;</div><div class="line">    SecTrustResultType result;</div><div class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out);</div><div class="line"></div><div class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</div><div class="line"></div><div class="line">_out:</div><div class="line">    return isValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重点看一下self.allowInvalidCertificates这个参数，可以看到，如果使用默认的验证策略，同时self.allowInvalidCertificates = YES的话，会直接返回YES，相当于没有验证，所有这里我们一般将self.allowInvalidCertificates = NO。self.validatesDomainName这个参数默认为YES就可以了。</p>
<p>验证服务器证书是否合法的方法为AFServerTrustIsValid，这个方法里面就是调用的系统的方法。</p>
<p>那这个验证方法到底在哪里调用的呢，我们看一下下面这个代理，在NSURLSessionManager中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</div><div class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</div><div class="line">&#123;</div><div class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">    __block NSURLCredential *credential = nil;</div><div class="line"></div><div class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</div><div class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</div><div class="line">    &#125; else &#123;</div><div class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">                if (credential) &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">                &#125; else &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的https请求都会先进这个代理，这个challenge.protectionSpace对象中就是服务器发过来的需要客户端验证的证书，域名等相关重要信息，然后af调用evaluateServerTrust这个方法对相关信息进行验证。</p>
<h3 id="实战，简单的二次封装"><a href="#实战，简单的二次封装" class="headerlink" title="实战，简单的二次封装"></a>实战，简单的二次封装</h3><p>我这边使用一个单例来管理AFHTTPSessionManager,在init方法中，设置相关delegate对应的block.这里设置block主要是满足我需要在开始获取到音频数据的时候就对数据进行处理，不需要等到整个请求完成再处理数据的需求。如果需要其他delegate的信息，添加相应的block即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)shareInstance&#123;</div><div class="line">    static LLYHttpSessionManager *_llyHttpSessionManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _llyHttpSessionManager = [[LLYHttpSessionManager alloc]init];</div><div class="line">    &#125;);</div><div class="line">    return _llyHttpSessionManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init&#123;</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        _httpSessionManager = [[AFHTTPSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">        _httpSessionManager.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line">//        [_httpSessionManager.requestSerializer setValue:[self generateXUserAgent] forHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">//        [_httpSessionManager.requestSerializer setValue:[self generateClientCookie] forHTTPHeaderField:@&quot;Cookie&quot;];</div><div class="line">        </div><div class="line">        __weak __typeof(self)weakSelf = self;</div><div class="line">        </div><div class="line">        [_httpSessionManager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) &#123;</div><div class="line">            if (weakSelf.didReceiveResponseBlock) &#123;</div><div class="line">                weakSelf.didReceiveResponseBlock(session, dataTask, response);</div><div class="line">            &#125;</div><div class="line">            return NSURLSessionResponseAllow;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        [_httpSessionManager setDataTaskDidReceiveDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSData * _Nonnull data) &#123;</div><div class="line">            if (weakSelf.didReceiveDataBlock) &#123;</div><div class="line">                weakSelf.didReceiveDataBlock(session, dataTask, data);</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        //默认json</div><div class="line">        self.fileType = LLYHttpFileType_JSON;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为我这边需要请求音视频的数据，af提供的几种responese默认是不支持音视频格式的，所有我封装了几种文件type，每种type对应不同的responese</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, LLYHttpFileType) &#123;</div><div class="line">    LLYHttpFileType_JSON = 0,</div><div class="line">    LLYHttpFileType_IMAGE,</div><div class="line">    LLYHttpFileType_AUDIO,</div><div class="line">    LLYHttpFileType_VIDEO</div><div class="line">&#125;;</div><div class="line"></div><div class="line">- (void)setResponseSerializer:(LLYHttpFileType)fileType&#123;</div><div class="line">    </div><div class="line">    switch (fileType) &#123;</div><div class="line">        case LLYHttpFileType_JSON:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_IMAGE:</div><div class="line">        &#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFImageResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_AUDIO:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">            _httpSessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;audio/mpeg&quot;,nil];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case LLYHttpFileType_VIDEO:&#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">            _httpSessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;video/mp4&quot;,@&quot;video/mpeg&quot;,nil];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">        &#123;</div><div class="line">            _httpSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后提供了2个block，分别是didReceiveResponseBlock和didReceiveDataBlock，如果需要拿到请求过程中的相关数据和信息，直接实现这2个block就ok了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) DidReceiveResponseBlock didReceiveResponseBlock;</div><div class="line">@property (nonatomic, copy) DidReceiveDataBlock didReceiveDataBlock;</div></pre></td></tr></table></figure>
<p>针对不同的数据类型，我这边提供了相应的task的创建方法，然后还提供了一个总的创建task的方法和一个下载方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestJSONWithMethod:(LLYHttpMethod)method</div><div class="line">                                       urlString:(nullable NSString *)URLString</div><div class="line">                                      parameters:(nullable id)parameters</div><div class="line">                                        progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                         success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                             failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestIMAGEWithMethod:(LLYHttpMethod)method</div><div class="line">                                           urlString:(nullable NSString *)URLString</div><div class="line">                                          parameters:(nullable id)parameters</div><div class="line">                                            progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                             success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                             failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestAUDIOWithMethod:(LLYHttpMethod)method</div><div class="line">                                            urlString:(nullable NSString *)URLString</div><div class="line">                                           parameters:(nullable id)parameters</div><div class="line">                                             progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                              success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                              failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestVIDEOWithMethod:(LLYHttpMethod)method</div><div class="line">                                            urlString:(nullable NSString *)URLString</div><div class="line">                                           parameters:(nullable id)parameters</div><div class="line">                                             progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                              success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                              failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure;</div><div class="line"></div><div class="line"></div><div class="line">- (nullable NSURLSessionTask *)requestWithMethod:(LLYHttpMethod)method</div><div class="line">                                        fileType:(LLYHttpFileType)fileType</div><div class="line">                              urlString:(nullable NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask * _Nullable task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError * _Nullable error))failure</div><div class="line">;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDownloadTask *)downloadWithUrl:(nullable NSString *)urlString</div><div class="line">                                     progress:(nullable void (^)(NSProgress * _Nullable downloadProgress))downloadProgressBlock</div><div class="line">                                  destination:(nullable NSURL * _Nullable(^)(NSURL * _Nullable targetPath, NSURLResponse * _Nullable response))destination</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse * _Nullable response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>实现部分就比较简单了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionTask *)requestWithMethod:(LLYHttpMethod)method</div><div class="line">                                        fileType:(LLYHttpFileType)fileType</div><div class="line">                                       urlString:(NSString *)URLString</div><div class="line">                                      parameters:(nullable id)parameters</div><div class="line">                                        progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    self.fileType = fileType;</div><div class="line">    </div><div class="line">    NSURLSessionTask *task = nil;</div><div class="line">    </div><div class="line">    switch (method) &#123;</div><div class="line">        case LLYHttpMethod_GET:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager GET:URLString parameters:parameters progress:downloadProgress success:success failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case LLYHttpMethod_POST:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager POST:URLString parameters:parameters progress:downloadProgress success:success failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case LLYHttpMethod_HEAD:</div><div class="line">        &#123;</div><div class="line">            task = [_httpSessionManager HEAD:URLString parameters:parameters success:^(NSURLSessionDataTask * _Nonnull task) &#123;</div><div class="line">                if (success) &#123;</div><div class="line">                    success(task,nil);</div><div class="line">                &#125;</div><div class="line">            &#125; failure:failure];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return task;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadWithUrl:(NSString *)urlString</div><div class="line">                                     progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                  destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler&#123;</div><div class="line">    NSURLSessionDownloadTask *task = nil;</div><div class="line">    </div><div class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];</div><div class="line">    </div><div class="line">    task = [_httpSessionManager downloadTaskWithRequest:request progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</div><div class="line">    </div><div class="line">    [task resume];</div><div class="line">    </div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lilingyu0620/LLYAFNetworking.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/15/使用FFMPEG解码之-音频解码/" itemprop="url">
                  使用FFMPEG解码之--音频解码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-15T11:15:41+08:00" content="2018-05-15">
              2018-05-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/15/使用FFMPEG解码之-音频解码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/15/使用FFMPEG解码之-音频解码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天一直在写使用ffmpeg完成一个视频播放器的demo,因为对音频这一块比较熟悉，所以先从音频解码开始下手，也熟悉一下ffmpeg的使用流程。音频解码这块已经完成了，所以这里先简单总结一下整个音频解码的流程。这里只说大概流程，具体实现细节参考下面的demo就可以。</p>
<h4 id="1-注册ffmpeg"><a href="#1-注册ffmpeg" class="headerlink" title="1.注册ffmpeg"></a>1.注册ffmpeg</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">av_register_all()</div></pre></td></tr></table></figure>
<h4 id="2-初始化AVFormatContext"><a href="#2-初始化AVFormatContext" class="headerlink" title="2.初始化AVFormatContext"></a>2.初始化AVFormatContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AVFormatContext *formatCtx = avformat_alloc_context();</div></pre></td></tr></table></figure>
<h4 id="3-可以注册一个打断回调"><a href="#3-可以注册一个打断回调" class="headerlink" title="3.可以注册一个打断回调"></a>3.可以注册一个打断回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AVIOInterruptCB int_cb = &#123;interrupt_callback,(__bridge void *)self&#125;;</div><div class="line">    formatCtx-&gt;interrupt_callback = int_cb;</div></pre></td></tr></table></figure>
<p>其中 interrupt_callback 是一个函数指针 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static int interrupt_callback(void *ctx)&#123;</div><div class="line">    if (!ctx) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    __unsafe_unretained LLYDecoder *decoder = (__bridge LLYDecoder *)ctx;</div><div class="line">    const BOOL bRet = [decoder detectInterrupted];</div><div class="line">    if (bRet) &#123;</div><div class="line">        NSLog(@&quot;DEBUG: INTERRUPT_CALLBACK!&quot;);</div><div class="line">    &#125;</div><div class="line">    return bRet;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打断状态</div><div class="line">- (BOOL)detectInterrupted&#123;</div><div class="line">    //打断超时</div><div class="line">    if ([[NSDate date] timeIntervalSince1970] - _readLastestFrameTime &gt; _subscribeTimeOutTimeInSecs) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return _interrupted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使返回一个是否被打断的状态。</p>
<h4 id="4-打开流地址"><a href="#4-打开流地址" class="headerlink" title="4.打开流地址"></a>4.打开流地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (int)openInputWithFormatCtx:(AVFormatContext **)formatCtx path:(NSString *)path parameter:(NSDictionary *)parameters&#123;</div><div class="line">    const char *inputURL = [path cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    AVDictionary *options = NULL;</div><div class="line">    //TCURL应该与流的CDN相关 如果原始的req中有tcUrl，就使用原始的</div><div class="line">    NSString *rtmpTCURLStr = parameters[RTMP_TCURL_KEY];</div><div class="line">    if (rtmpTCURLStr.length &gt; 0) &#123;</div><div class="line">        const char *rtmpTcURL = [rtmpTCURLStr cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">        av_dict_set(&amp;options, &quot;rtmp_tcurl&quot;, rtmpTcURL, 0);</div><div class="line">    &#125;</div><div class="line">    return avformat_open_input(formatCtx, inputURL, NULL, &amp;options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个是否打开成功的状态。0表示成功</p>
<h4 id="5-设置解析参数probesize-amp-max-analyze-duration"><a href="#5-设置解析参数probesize-amp-max-analyze-duration" class="headerlink" title="5.设置解析参数probesize &amp; max_analyze_duration"></a>5.设置解析参数probesize &amp; max_analyze_duration</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//个人理解是开始读取数据的延时和缓存空间（默认5M）</div><div class="line">- (void)initAnalyzeDurationAndProbeSize:(AVFormatContext *)formatCtx parameter:(NSDictionary *)parameters&#123;</div><div class="line">    float probeSize = [parameters[PROBE_SIZE] floatValue];</div><div class="line">    formatCtx-&gt;probesize = probeSize ?: 50 * 1024;</div><div class="line">    NSArray *durations = parameters[MAX_ANALYZE_DURATION_ARRAY];</div><div class="line">    if (durations &amp;&amp; durations.count &gt; _connectionRetry) &#123;</div><div class="line">        formatCtx-&gt;max_analyze_duration = [durations[_connectionRetry] floatValue];</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        //pow(x,y) x的y次方</div><div class="line">        float multiplier = 0.5 + (double)pow(2.0, (double)_connectionRetry) * 0.25;</div><div class="line">        formatCtx-&gt;max_analyze_duration = multiplier;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //帧率</div><div class="line">    BOOL fpsProbeSizeConfiged = [parameters[FPS_PROBE_SIZE_CONFIGURED] floatValue];</div><div class="line">    if (fpsProbeSizeConfiged) &#123;</div><div class="line">        formatCtx-&gt;fps_probe_size = 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-获取音视频信息"><a href="#6-获取音视频信息" class="headerlink" title="6.获取音视频信息"></a>6.获取音视频信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int findStreamErrorCode = 0;</div><div class="line">double startFindStreamTimeMills = CFAbsoluteTimeGetCurrent() * 1000;</div><div class="line">if ((findStreamErrorCode = avformat_find_stream_info(formatCtx, NULL)) &lt; 0) &#123;</div><div class="line">    avformat_close_input(&amp;formatCtx);</div><div class="line">    avformat_free_context(formatCtx);</div><div class="line">    NSLog(@&quot;Video decoder find stream info failed... find stream ErrCode is %s&quot;, av_err2str(findStreamErrorCode));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取的信息都在formatCtx这个参数里存着，后面很多地方要用。</p>
<h4 id="7-获取流数据的索引数组"><a href="#7-获取流数据的索引数组" class="headerlink" title="7.获取流数据的索引数组"></a>7.获取流数据的索引数组</h4><p>通过流的类型获取流的索引，有时候可能音频或者视频都有好几路流数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//获取流数据的索引</div><div class="line">static NSArray *collectionStreams(AVFormatContext *formatCtx,enum AVMediaType codecType)&#123;</div><div class="line">    NSMutableArray *ma = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; formatCtx-&gt;nb_streams; i++) &#123;</div><div class="line">        if (codecType == formatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type) &#123;</div><div class="line">            [ma addObject:@(i)];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-通过流的索引，获取每一路流的AVCodecContext-amp-AVCodec"><a href="#8-通过流的索引，获取每一路流的AVCodecContext-amp-AVCodec" class="headerlink" title="8.通过流的索引，获取每一路流的AVCodecContext &amp; AVCodec"></a>8.通过流的索引，获取每一路流的AVCodecContext &amp; AVCodec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AVCodecContext *codecCtx = _formatCtx-&gt;streams[streamIndex]-&gt;codec;</div><div class="line">//获取该stream对应的解码器</div><div class="line">AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</div><div class="line">if(!codec)&#123;</div><div class="line">    NSLog(@&quot;Find Audio Decoder Failed codec_id %d CODEC_ID_AAC is %d&quot;, codecCtx-&gt;codec_id, AV_CODEC_ID_AAC);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="9-打开解码器"><a href="#9-打开解码器" class="headerlink" title="9.打开解码器"></a>9.打开解码器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int openCodecErrorCode = 0;</div><div class="line">if ((openCodecErrorCode = avcodec_open2(codecCtx, codec, NULL)) &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;open Audio Codec Failed openCodecErr is %s&quot;, av_err2str(openCodecErrorCode));</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-如果不支持当前流的采样格式，需要做一下重新采样"><a href="#10-如果不支持当前流的采样格式，需要做一下重新采样" class="headerlink" title="10.如果不支持当前流的采样格式，需要做一下重新采样"></a>10.如果不支持当前流的采样格式，需要做一下重新采样</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//是否需要重采样</div><div class="line">SwrContext *swrContext = NULL;</div><div class="line">if (![self audioCodecIsSupported:codecCtx]) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;because of audio Codec Is Not Supported so we will init swresampler...&quot;);</div><div class="line">    /**</div><div class="line">     * 初始化resampler</div><div class="line">     * @param s               Swr context, can be NULL</div><div class="line">     * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)</div><div class="line">     * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).</div><div class="line">     * @param out_sample_rate output sample rate (frequency in Hz)</div><div class="line">     * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)</div><div class="line">     * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).</div><div class="line">     * @param in_sample_rate  input sample rate (frequency in Hz)</div><div class="line">     * @param log_offset      logging level offset</div><div class="line">     * @param log_ctx         parent logging context, can be NULL</div><div class="line">     */</div><div class="line">    swrContext = swr_alloc_set_opts(NULL, av_get_default_channel_layout(codecCtx-&gt;channels), AV_SAMPLE_FMT_S16, codecCtx-&gt;sample_rate, av_get_default_channel_layout(codecCtx-&gt;channels), codecCtx-&gt;sample_fmt, codecCtx-&gt;sample_rate, 0, NULL);</div><div class="line">    if (!swrContext || swr_init(swrContext)) &#123;</div><div class="line">        if (swrContext)</div><div class="line">            swr_free(&amp;swrContext);</div><div class="line">        avcodec_close(codecCtx);</div><div class="line">        NSLog(@&quot;init resampler failed...&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (BOOL)audioCodecIsSupported:(AVCodecContext *) audioCodecCtx;&#123;</div><div class="line">    if (audioCodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S16) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11-初始化一个AVFrame"><a href="#11-初始化一个AVFrame" class="headerlink" title="11.初始化一个AVFrame"></a>11.初始化一个AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_audioFrame = av_frame_alloc();</div><div class="line">if (!_audioFrame) &#123;</div><div class="line">    NSLog(@&quot;Alloc Audio Frame Failed...&quot;);</div><div class="line">    if (swrContext)</div><div class="line">        swr_free(&amp;swrContext);</div><div class="line">    avcodec_close(codecCtx);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="12-获取AVPacket"><a href="#12-获取AVPacket" class="headerlink" title="12.获取AVPacket"></a>12.获取AVPacket</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AVPacket packet;</div><div class="line">if (av_read_frame(_formatCtx, &amp;packet) &lt; 0) &#123;</div><div class="line">        _isEOF = YES;</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="13-获取AVFrame"><a href="#13-获取AVFrame" class="headerlink" title="13.获取AVFrame"></a>13.获取AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int gotFrame = 0;</div><div class="line">//len =  number of bytes consumed from the input *AVPacket</div><div class="line">int len = avcodec_decode_audio4(_audioCodecCtx, _audioFrame, &amp;gotFrame, &amp;packet);</div><div class="line">if (len &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;decode audio error, skip packet&quot;);</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="14-将AVFrame转为自定义的LLYAudioFrame"><a href="#14-将AVFrame转为自定义的LLYAudioFrame" class="headerlink" title="14.将AVFrame转为自定义的LLYAudioFrame"></a>14.将AVFrame转为自定义的LLYAudioFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (LLYAudioFrame *)handleAudioFrame&#123;</div><div class="line">    </div><div class="line">    if (!_audioFrame-&gt;data[0]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    const NSUInteger numChannels = _audioCodecCtx-&gt;channels;</div><div class="line">    NSInteger numFrames;</div><div class="line">    </div><div class="line">    void *audioData;</div><div class="line">    </div><div class="line">    if (_swrContext) &#123;</div><div class="line">        const NSUInteger ratio = 2;</div><div class="line">        const int bufSize = av_samples_get_buffer_size(NULL, (int)numChannels ,(int)(_audioFrame-&gt;nb_samples * ratio), AV_SAMPLE_FMT_S16, 1);</div><div class="line">        if (!_swrBuffer || _swrBufferSize &lt; bufSize) &#123;</div><div class="line">            _swrBufferSize = bufSize;</div><div class="line">            _swrBuffer = realloc(_swrBuffer, _swrBufferSize);</div><div class="line">        &#125;</div><div class="line">        Byte *outbuf[2] = &#123;_swrBuffer,0&#125;;</div><div class="line">        numFrames = swr_convert(_swrContext, outbuf, (int)(_audioFrame-&gt;nb_samples * ratio), (const uint8_t **)_audioFrame-&gt;data, _audioFrame-&gt;nb_samples);</div><div class="line">        if (numFrames &lt; 0) &#123;</div><div class="line">            NSLog(@&quot;fail resample audio&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        audioData = _swrBuffer;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (_audioCodecCtx-&gt;sample_fmt != AV_SAMPLE_FMT_S16) &#123;</div><div class="line">            NSLog(@&quot;Audio format is invalid&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        audioData = _audioFrame-&gt;data[0];</div><div class="line">        numFrames = _audioFrame-&gt;nb_samples;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //总帧数 = 一条信道的帧数*信道数</div><div class="line">    const NSUInteger numElements = numFrames * numChannels;</div><div class="line">    NSMutableData *pcmData = [NSMutableData dataWithLength:numElements * sizeof(SInt16)];</div><div class="line">    memcpy(pcmData.mutableBytes, audioData, numElements * sizeof(SInt16));</div><div class="line">    LLYAudioFrame *frame = [[LLYAudioFrame alloc]init];</div><div class="line">    frame.position = av_frame_get_best_effort_timestamp(_audioFrame) * _audioTimeBase;</div><div class="line">    frame.duration = av_frame_get_pkt_duration(_audioFrame) * _audioTimeBase;</div><div class="line">    frame.sampleData = pcmData;</div><div class="line">    frame.frameType = LLYFrameType_Audio;</div><div class="line">    </div><div class="line">    return frame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里判断一下如果是重采样的，需要做一个转换。</p>
<h3 id="视频解码（补充）"><a href="#视频解码（补充）" class="headerlink" title="视频解码（补充）"></a>视频解码（补充）</h3><p>视频解码的工作也做完了，流程和音频大同小异，只是在最后几步的时候会有差异</p>
<h4 id="获取AVFrame"><a href="#获取AVFrame" class="headerlink" title="获取AVFrame"></a>获取AVFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int gotFrmae = 0;</div><div class="line">int len = avcodec_decode_video2(_videoCodecCtx, _videoFrame, &amp;gotFrmae, &amp;packet);</div><div class="line">if (len &lt; 0) &#123;</div><div class="line">    NSLog(@&quot;decode video error, skip packet %s&quot;, av_err2str(len));</div><div class="line">    *errorState = 1;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用video的解码api.</p>
<h4 id="将AVFrame转为自定义的LLYVideoFrame"><a href="#将AVFrame转为自定义的LLYVideoFrame" class="headerlink" title="将AVFrame转为自定义的LLYVideoFrame"></a>将AVFrame转为自定义的LLYVideoFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (LLYVideoFrame *)handleVideoFrame&#123;</div><div class="line">    </div><div class="line">    if (!_videoFrame-&gt;data[0]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LLYVideoFrame *videoFrame = [[LLYVideoFrame alloc]init];</div><div class="line">    //将yuv数据取出来</div><div class="line">    if (_videoCodecCtx-&gt;pix_fmt == AV_PIX_FMT_YUV420P || _videoCodecCtx-&gt;pix_fmt == AV_PIX_FMT_YUVJ420P) &#123;</div><div class="line">        videoFrame.luma = copyFrameData(_videoFrame-&gt;data[0], _videoFrame-&gt;linesize[0], _videoCodecCtx-&gt;width, _videoCodecCtx-&gt;height);</div><div class="line">        videoFrame.chromaB = copyFrameData(_videoFrame-&gt;data[1], _videoFrame-&gt;linesize[1], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">        videoFrame.chromaR = copyFrameData(_videoFrame-&gt;data[2], _videoFrame-&gt;linesize[2], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">    &#125;else&#123;</div><div class="line">        //不是yuv格式先要将格式转为yuv的</div><div class="line">        if (!_swsContext &amp;&amp;</div><div class="line">            ![self setupScaler]) &#123;</div><div class="line">            NSLog(@&quot;fail setup video scaler&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sws_scale(_swsContext,</div><div class="line">                  (const uint8_t **)_videoFrame-&gt;data,</div><div class="line">                  _videoFrame-&gt;linesize,</div><div class="line">                  0,</div><div class="line">                  _videoCodecCtx-&gt;height,</div><div class="line">                  _picture.data,</div><div class="line">                  _picture.linesize);</div><div class="line">        videoFrame.luma = copyFrameData(_picture.data[0], _videoFrame-&gt;linesize[0], _videoCodecCtx-&gt;width, _videoCodecCtx-&gt;height);</div><div class="line">        videoFrame.chromaB = copyFrameData(_picture.data[1], _videoFrame-&gt;linesize[1], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">        videoFrame.chromaR = copyFrameData(_picture.data[2], _videoFrame-&gt;linesize[2], _videoCodecCtx-&gt;width/2, _videoCodecCtx-&gt;height/2);</div><div class="line">    &#125;</div><div class="line">    videoFrame.width = _videoCodecCtx-&gt;width;</div><div class="line">    videoFrame.height = _videoCodecCtx-&gt;height;</div><div class="line">    videoFrame.lineSize = _videoFrame-&gt;linesize[0];</div><div class="line">    videoFrame.frameType = LLYFrameType_Video;</div><div class="line">    videoFrame.position = av_frame_get_best_effort_timestamp(_videoFrame) * _videoTimeBase;</div><div class="line">    const int64_t frameDuration = av_frame_get_pkt_duration(_videoFrame);</div><div class="line">    if (frameDuration) &#123;</div><div class="line">        videoFrame.duration = frameDuration * _videoTimeBase;</div><div class="line">        videoFrame.duration += _videoFrame-&gt;repeat_pict * _videoTimeBase * 0.5;</div><div class="line">    &#125; else &#123;</div><div class="line">        // sometimes, ffmpeg unable to determine a frame duration</div><div class="line">        // as example yuvj420p stream from web camera</div><div class="line">        videoFrame.duration = 1.0 / _fps;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return videoFrame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里转为自定义的LLYVideoFrame时需要将YUV的数据都取出来。</p>
<p>主要流程大概就是上面这些了。当然还有一些细节的东西，这里没有一一列出来，可以从demo中寻找答案。</p>
<p><a href="https://github.com/lilingyu0620/LLYFFMPEGPlayer.git" target="_blank" rel="noopener">LLYFFMPEGPlayer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">64</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
