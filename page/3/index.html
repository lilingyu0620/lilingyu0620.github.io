<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/21/Python的一些高级特性/" itemprop="url">
                  Python的一些高级特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-21T10:26:11+08:00" content="2017-08-21">
              2017-08-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/08/21/Python的一些高级特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/21/Python的一些高级特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Python的一些高级特性"><a href="#Python的一些高级特性" class="headerlink" title="Python的一些高级特性"></a>Python的一些高级特性</h3><h4 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h4><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def person(name, age, **kw):</div><div class="line">    print &apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw</div></pre></td></tr></table></figure>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">person(&apos;Michael&apos;, 30)</div><div class="line"></div><div class="line">person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</div><div class="line"></div><div class="line">person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kw = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">person(&apos;Jack&apos;, 24, **kw)</div></pre></td></tr></table></figure>
<h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p><strong>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数</strong></p>
<ul>
<li>变量可以指向函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = abs</div><div class="line"></div><div class="line">f(-10)</div></pre></td></tr></table></figure>
<ul>
<li>函数名也是变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abs = 10</div><div class="line"></div><div class="line">abs</div><div class="line"></div><div class="line">abs(-10)</div></pre></td></tr></table></figure>
<ul>
<li>传入参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f = abs</div><div class="line"></div><div class="line">def add(x,y,f):</div><div class="line">	return f(x) + f(y)</div></pre></td></tr></table></figure>
<ul>
<li><p>内建map()</p>
<p>  <strong>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def f(x):</div><div class="line">	return x * x</div><div class="line"></div><div class="line">map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div class="line"></div><div class="line">map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div class="line"></div><div class="line">//&apos;&apos; &quot;&quot; 区别</div></pre></td></tr></table></figure>
<ul>
<li><p>内建reduce()</p>
<p>  <strong>reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</strong></p>
</li>
</ul>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def add(x,y):</div><div class="line">	return x + y</div><div class="line"></div><div class="line">reduce(add,range(1,10))</div><div class="line"></div><div class="line">sum(range(1,10))</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def fn(x,y)</div><div class="line">	return x * 10 + y</div><div class="line"></div><div class="line">reduce(fn,[1,3,5,7,9])</div></pre></td></tr></table></figure>
<ul>
<li><p>内建filter()</p>
<p>  <strong>filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//奇数</div><div class="line">def is_odd(n):</div><div class="line">    return n % 2 == 1</div><div class="line"></div><div class="line">filter(is_odd,range(1,10))</div></pre></td></tr></table></figure>
<ul>
<li>内建sorted()</li>
</ul>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 逆序</div><div class="line">def reversed_cmp(x, y):</div><div class="line">    if x &gt; y:</div><div class="line">        return -1</div><div class="line">    if x &lt; y:</div><div class="line">        return 1</div><div class="line">    return 0</div><div class="line"></div><div class="line">sorted([36, 5, 12, 9, 21], reversed_cmp)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 字符串忽略大小写排序</div><div class="line">def cmp_ignore_case(s1, s2):</div><div class="line">    u1 = s1.upper()</div><div class="line">    u2 = s2.upper()</div><div class="line">    if u1 &lt; u2:</div><div class="line">        return -1</div><div class="line">    if u1 &gt; u2:</div><div class="line">        return 1</div><div class="line">    return 0</div><div class="line"></div><div class="line">sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)</div></pre></td></tr></table></figure>
<h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def lazy_sum(L=[]):</div><div class="line">    def sum():</div><div class="line">        ax = 0</div><div class="line">        for n in L:</div><div class="line">            ax = ax + n</div><div class="line">        return ax</div><div class="line">    return sum</div><div class="line">    </div><div class="line">f = lazy_sum(range(1,10))</div><div class="line"></div><div class="line">f</div><div class="line"></div><div class="line">f()</div></pre></td></tr></table></figure>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p><strong>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</strong></p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print &apos;call %s():&apos; % func.__name__</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line">    </div><div class="line">@log</div><div class="line">def name():</div><div class="line">    print &apos;lly&apos;</div></pre></td></tr></table></figure>
<p>把<em>@log</em>放到<em>now()</em>函数的定义处，相当于执行了语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now = log(now)</div></pre></td></tr></table></figure>
<p>由于<em>log()</em>是一个<strong>decorator</strong>，返回一个函数，所以，原来的<em>now()</em>函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用<em>now()</em>将执行新函数，即在<em>log()</em>函数中返回的<em>wrapper()</em>函数。</p>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def log(text):</div><div class="line">    def decorator(func):</div><div class="line">        def wrapper(*args, **kw):</div><div class="line">            print &apos;%s %s():&apos; % (text, func.__name__)</div><div class="line">            return func(*args, **kw)</div><div class="line">        return wrapper</div><div class="line">    return decorator</div><div class="line">    </div><div class="line">@log(&apos;netease&apos;)</div><div class="line">def name():</div><div class="line">    print &apos;lly&apos;</div></pre></td></tr></table></figure>
<p>示例三:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line"></div><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print &apos;call %s():&apos; % func.__name__</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="属性、方法的动态绑定和限制"><a href="#属性、方法的动态绑定和限制" class="headerlink" title="属性、方法的动态绑定和限制"></a>属性、方法的动态绑定和限制</h5><p>一、属性的动态绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">s = Student()</div><div class="line">s.name = &apos;lly&apos;</div><div class="line"></div><div class="line">print s.name</div></pre></td></tr></table></figure>
<p>二、方法的动态绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">def set_age(self, age): # 定义一个函数作为实例方法</div><div class="line">	self.age = age</div><div class="line"></div><div class="line">from types import MethodType</div><div class="line"></div><div class="line">s.set_age = MethodType(set_age, s, Student)</div><div class="line">s.set_age(25)</div><div class="line"></div><div class="line">s.age</div></pre></td></tr></table></figure>
<p>三、类的方法绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">def set_score(self, score):</div><div class="line">	self.score = score</div><div class="line"></div><div class="line">from types import MethodType</div><div class="line"></div><div class="line">Student.set_score = MethodType(set_score, None, Student)</div></pre></td></tr></table></figure>
<p>四、限制动态添加</p>
<p><strong>Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class能添加的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	__slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 插槽</div><div class="line"></div><div class="line">s = Student() # 创建新的实例</div><div class="line">s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</div><div class="line">s.age = 25 # 绑定属性&apos;age&apos;</div><div class="line">s.score = 99 # 绑定属性&apos;score&apos;</div></pre></td></tr></table></figure>
<p><em><strong>slots</strong>定义的属性仅对当前类起作用，对继承的子类是不起作用</em></p>
<h5 id="安全简洁的属性"><a href="#安全简洁的属性" class="headerlink" title="安全简洁的属性"></a>安全简洁的属性</h5><p><strong>Python内置的@property装饰器就是负责把一个方法变成属性调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line"></div><div class="line">    @property</div><div class="line">    def score(self):</div><div class="line">        return self._score</div><div class="line"></div><div class="line">    @score.setter</div><div class="line">    def score(self, value):</div><div class="line">        if not isinstance(value, int):</div><div class="line">            raise ValueError(&apos;score must be an integer!&apos;)</div><div class="line">        if value &lt; 0 or value &gt; 100:</div><div class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</div><div class="line">        self._score = value</div><div class="line">        </div><div class="line">s = Student()</div><div class="line">s.score = 60 # OK，实际转化为s.set_score(60)</div><div class="line">s.score # OK，实际转化为s.get_score()</div></pre></td></tr></table></figure>
<h4 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h4><h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">print &apos;Process (%s) start...&apos; % os.getpid()</div><div class="line">pid = os.fork()</div><div class="line">if pid==0:</div><div class="line">    print &apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getppid())</div><div class="line">else:</div><div class="line">    print &apos;I (%s) just created a child process (%s).&apos; % (os.getpid(), pid)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def run_proc(name):</div><div class="line">    print &apos;Run child process %s (%s)...&apos; % (name, os.getpid())</div><div class="line"></div><div class="line">if __name__==&apos;__main__&apos;:</div><div class="line">    print &apos;Parent process %s.&apos; % os.getpid()</div><div class="line">    p = multiprocessing.Process(target=run_proc, args=(&apos;test&apos;,))</div><div class="line">    print &apos;Process will start.&apos;</div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    print &apos;Process end.&apos;</div></pre></td></tr></table></figure>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import time, threading</div><div class="line"></div><div class="line"># 新线程执行的代码:</div><div class="line">def loop():</div><div class="line">    print &apos;thread %s is running...&apos; % threading.current_thread().name</div><div class="line">    n = 0</div><div class="line">    while n &lt; 5:</div><div class="line">        n = n + 1</div><div class="line">        print &apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)</div><div class="line">        time.sleep(1)</div><div class="line">    print &apos;thread %s ended.&apos; % threading.current_thread().name</div><div class="line"></div><div class="line">print &apos;thread %s is running...&apos; % threading.current_thread().name</div><div class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</div><div class="line">t.start()</div><div class="line">t.join()</div><div class="line">print &apos;thread %s ended.&apos; % threading.current_thread().name</div></pre></td></tr></table></figure>
<p>线程加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">balance = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def run_thread(n):</div><div class="line">    for i in range(100000):</div><div class="line">        # 先要获取锁:</div><div class="line">        lock.acquire()</div><div class="line">        try:</div><div class="line">            # 放心地改吧:</div><div class="line">            change_it(n)</div><div class="line">        finally:</div><div class="line">            # 改完了一定要释放锁:</div><div class="line">            lock.release()</div></pre></td></tr></table></figure>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<h4 id="简单爬虫"><a href="#简单爬虫" class="headerlink" title="简单爬虫"></a>简单爬虫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import urllib</div><div class="line"></div><div class="line">uf = urllib.urlopen(&apos;https://baidu.com&apos;)</div><div class="line"></div><div class="line">uf.read()</div><div class="line"></div><div class="line">urllib.urlretrieve(&apos;urlpath&apos;,&apos;filename&apos;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/" itemprop="url">
                  高性能iOS应用开发读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-07T10:02:22+08:00" content="2017-07-07">
              2017-07-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/%E9%AB%98%E6%80%A7%E8%83%BDiOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.png" alt=""></p>
<h3 id="第一章-移动应用的性能"><a href="#第一章-移动应用的性能" class="headerlink" title="第一章 移动应用的性能"></a>第一章 移动应用的性能</h3><ul>
<li>应用首次工作出错以后，79%的用户只会再重试一两次</li>
<li>当应用载入时间超过3秒时，25%的用户会放弃使用该应用。</li>
<li>31%的用户会将糟糕的体验转告他人。</li>
</ul>
<h4 id="定义性能"><a href="#定义性能" class="headerlink" title="定义性能"></a>定义性能</h4><p>高性能有着多重的含义和丰富的解释方式。</p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul>
<li>内存</li>
<li>电池消耗</li>
<li>程序初始化时间</li>
<li>执行速度</li>
<li>响应速度</li>
<li>本地存储</li>
<li>互操作性</li>
<li>网络环境</li>
<li>带宽</li>
<li>数据刷新</li>
<li>多用户支持</li>
<li>单点登录</li>
<li>安全</li>
<li>崩溃</li>
</ul>
<h4 id="应用性能分析"><a href="#应用性能分析" class="headerlink" title="应用性能分析"></a>应用性能分析</h4><ul>
<li>采样</li>
<li>埋点</li>
</ul>
<h4 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h4><p>过早优化是编程领域的万恶之源–高德纳？？？</p>
<p><a href="https://github.com/gvaish/hpios" target="_blank" rel="noopener">测试代码地址</a></p>
<h3 id="第二章-内存管理"><a href="#第二章-内存管理" class="headerlink" title="第二章 内存管理"></a>第二章 内存管理</h3><p>90%的应用崩溃与内存管理有关，其中最主要的原因是错误的内存访问和保留环所引起的内存泄露 – Apple Dev</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/06/程序员的自我修养-链接、装载和库读书笔记/" itemprop="url">
                  程序员的自我修养--链接、装载和库读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-06T18:14:55+08:00" content="2017-07-06">
              2017-07-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/06/程序员的自我修养-链接、装载和库读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/06/程序员的自我修养-链接、装载和库读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.png" alt=""></p>
<h3 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h3><h4 id="从-Hello-World说起"><a href="#从-Hello-World说起" class="headerlink" title="从 Hello World说起"></a>从 Hello World说起</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">int mian()</div><div class="line">&#123;</div><div class="line">	printf(&quot;Hello World\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Hello World 被输出的整个流程的思考…</li>
</ul>
<h4 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h4><ul>
<li>计算机的关键部件：中央处理器CPU,内存和I/O控制芯片</li>
<li>北桥和南桥的概念</li>
<li>SMP（对称多处理器）和多核</li>
</ul>
<h4 id="站得高，望得远"><a href="#站得高，望得远" class="headerlink" title="站得高，望得远"></a>站得高，望得远</h4><ul>
<li>系统软件分类：平台性的（系统工具类）和开发类的（IDE,汇编器，链接器等）</li>
<li><p>计算机软件体系结构</p>
<pre><code>从上到下
应用--&gt;运行时库--&gt;操作系统内核--&gt;硬件
</code></pre></li>
<li><p>运行时库使用系统接口一般使用软件中断实现        </p>
</li>
<li>硬件相关接口（驱动程序）即硬件规格</li>
</ul>
<h4 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a>操作系统做什么</h4><h5 id="不让CPU打盹"><a href="#不让CPU打盹" class="headerlink" title="不让CPU打盹"></a>不让CPU打盹</h5><ul>
<li>分时系统，多任务系统</li>
<li>进程的概念，进程有自己的地址空间，互相隔离。根据优先级由操作系统统一分配CPU运行时间</li>
<li>抢占式的分配方式</li>
<li>CPU在多个进程间快速切换，从而造成很多进程在同时运行的假象。</li>
</ul>
<h5 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h5><ul>
<li>硬件驱动程序的开发由硬件生产商完成。</li>
<li><p>硬盘的结构，每个扇区512k</p>
<pre><code>扇片-磁道（65536）-扇区（1024）
</code></pre></li>
</ul>
<h4 id="内存不够怎么办"><a href="#内存不够怎么办" class="headerlink" title="内存不够怎么办"></a>内存不够怎么办</h4><p>直接顺序分配的问题：</p>
<ol>
<li>地址空间不隔离</li>
<li>内存使用率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p>解决方法：添加中间层（虚拟地址）</p>
<h5 id="关于隔离"><a href="#关于隔离" class="headerlink" title="关于隔离"></a>关于隔离</h5><ul>
<li>虚拟地址空间和物理地址空间</li>
<li>虚拟地址空间是指虚拟的、人们想象出来的地址空间，其实他并不存在，每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程隔离。</li>
</ul>
<h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><ul>
<li>将内存分为多段，每段对应一个进程。</li>
<li>物理地址空间和虚拟地址空间相对应。</li>
<li>分段使用效率低</li>
</ul>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><ul>
<li>每页大小为4K</li>
<li>MMU页面映射</li>
</ul>
<h4 id="众人拾柴火焰高"><a href="#众人拾柴火焰高" class="headerlink" title="众人拾柴火焰高"></a>众人拾柴火焰高</h4><h5 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h5><ul>
<li>线程有时被称为轻量级进程。</li>
<li>由线程ID,当前指令指针（PC），寄存器集合和堆栈组成。</li>
<li>一个进程由一个到多个线程组成，每个线程共享进程的内存空间（代码段，数据段，堆等）。</li>
<li>线程的私有存储空间包括栈，线程局部存储（TLS）和寄存器。</li>
<li>线程的访问权限有私有权限和线程共享权限两种。</li>
<li>私有权限包括局部变量，函数的参数和TLS数据</li>
<li>线程的状态包括运行，就绪和等待。</li>
<li>处于运行中的线程拥有一段可以执行的时间称为时间片。</li>
<li>线程调度方案包括优先级调度和轮转法调度。</li>
<li>I/O密集型线程（频繁等待的线程）优先级更容易改变</li>
<li>CPU密集型线程（很少等待的线程）容易饿死其他低优先级的线程</li>
<li><p>改变优先级的方式有三种：</p>
<pre><code>1.用户指定优先级
2.根据进入等待状态的频繁程度提升或降低优先级
3.长时间得不到执行而被提升优先级
</code></pre></li>
<li>可抢占线程（一般为可抢占）和不可抢占线程（线程利用率低）</li>
</ul>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><ul>
<li>多线程访问一个共享资源时</li>
<li>原子操作（单指令操作）</li>
<li>同步锁（Synchronization）</li>
<li>二元信号量是一种简单的锁，只有两种状态（占有和非占有）适合只能被一个线程独占的资源。</li>
<li>Semaphore(信号量)N个信号量允许N个线程并发访问</li>
<li>互斥量（Mutex）和二元信号量很类似，不同处是互斥量需要在哪个线程获取必须在哪个线程释放。而信号量可以被任意线程获取并释放。</li>
<li>临界区是比互斥量更加严格的同步手段。临界区的作用范围只在本进程。其他进程无法获取该锁。而互斥量可以被其他线程获取（但不能被其他线程释放）。</li>
<li>读写锁。其他线程可读但是不可写。</li>
<li>条件变量，使用条件变量可以让许多线程等待同一个条件的发生。</li>
</ul>
<h5 id="多线程内部情况"><a href="#多线程内部情况" class="headerlink" title="多线程内部情况"></a>多线程内部情况</h5><p>用户线程和内核线程（CPU）的对应关系</p>
<ul>
<li>一对一，线程并发是真正的并发，线程数受内核限制，上线文切换开销大。</li>
<li>多对一，如果一个用户线程堵塞，其他用户线程也会阻塞。</li>
<li>多对多，结合了上面两种的优点。（常用）</li>
</ul>
<h3 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h3><p>编译和链接合并到一起的过程叫构建（Build）</p>
<h4 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h4><p>helloworld输出可以分解为4个步骤，分别是 <em>预处理</em> <em>编译</em> <em>汇编</em> <em>链接</em></p>
<h5 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h5><ul>
<li>将所有的 <em>#deifne</em> 删除 并展开所有的宏定义</li>
<li>处理所有的条件编译指令 比如#if #else #ifdef #endif 等等。</li>
<li>处理#include预编译指令 将所包含的文件插入到预编译指令的位置</li>
<li>删除所有的注释 // /<em> </em>/ 等等</li>
<li>添加行号和文件名标识</li>
<li>保留所有#pragma编译器指令</li>
</ul>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>编译过程就是把预处理完成的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件。</p>
<h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令</p>
<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>模块的拼接过程 下面还会详细讲。</p>
<h4 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h4><ul>
<li>直观角度讲，编译器就是将高级语言翻译为机器语言。</li>
<li>流程：词法分析-&gt;语法分析-&gt;语义分析-&gt;源代码优化-&gt;代码生成&gt;目标代码优化.</li>
</ul>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul>
<li>扫描源代码 生成一系列记号（Token）</li>
<li>记号分类：关键字、标识符、字面量（包括数字，字符串）、特殊符号（+、=）。</li>
<li>每种记号存入对应的表内</li>
<li>词法规则可以自定义</li>
</ul>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><ul>
<li>对上面的词法表进行语法分析、生成语法树</li>
<li>整个分析过程采用上下文无关语法</li>
<li>语法树以表达式为节点</li>
<li>语法树是一种二叉树的应用（个人理解）</li>
</ul>
<h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><ul>
<li>编译器所能分析的语义是静态语义</li>
<li>静态语义通常包括声明和类型的匹配，类型的转换。</li>
<li>经过语义分析，语法树被标识了类型</li>
<li>语义分析判断该语法是否合法（个人理解）</li>
</ul>
<h5 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h5><ul>
<li>直接在语法树上面优化比较困难，所以源代码优化器会先将语法树转换为中间代码</li>
<li>中间代码是设备无关的</li>
<li>编译器前端负责产生机器无关的中间代码，后端负责将中间代码转换成目标机器代码。</li>
<li>跨平台编译器就是有一个前端和多个后端的组合</li>
</ul>
<h5 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h5><ul>
<li>编译器后端主要包括代码生成器和目标代码优化器</li>
</ul>
<h4 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h4><ul>
<li>重新计算各个目标的地址过程被叫做重定向。</li>
<li>模块的拼接过程在这里被叫做链接</li>
</ul>
<h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><ul>
<li>链接的过程主要包括：地址和空间分配、符号决议、重定向。</li>
<li>目标文件和库一起链接生成可执行文件</li>
<li>库其实是一种编译后的目标文件</li>
<li>目标文件之间的函数和变量的访问在链接过程中被重定向。</li>
</ul>
<h3 id="第三章-目标文件里有什么？"><a href="#第三章-目标文件里有什么？" class="headerlink" title="第三章 目标文件里有什么？"></a>第三章 目标文件里有什么？</h3><p>编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，目标文件从结构上讲是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能还有一些符号或者有些地址还没有被调整。</p>
<h4 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h4><ul>
<li>windows下是叫PE-COFF文件格式，Linux下叫ELF文件。</li>
<li>动态链接库和静态链接库也是以上格式。</li>
</ul>
<h4 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h4><ul>
<li>目标文件由各种段（Section）组成。</li>
<li>段类型有.text .data .bss .commment等</li>
<li>.text主要存放源代码</li>
<li>.data主要存放已初始化的全局变量和局部变量</li>
<li>.bss存放未初始化的全局和静态变量</li>
</ul>
<h5 id="数据段和指令段分开存储的好处："><a href="#数据段和指令段分开存储的好处：" class="headerlink" title="数据段和指令段分开存储的好处："></a>数据段和指令段分开存储的好处：</h5><ul>
<li>读写权限的不同，数据段是可读写的，指令段是只读的，当程序被装载后，数据和指令会被映射到不同的虚存区域。这样可以防止程序的指令被有意或者无意的改写。</li>
<li>提高了缓存的命中率</li>
<li>最主要的原因：当系统运行多个该程序的副本时，它们的指令都是一样的，所以在内存中只需要保存一份程序的指令部分，而数据会有多份。</li>
</ul>
<h4 id="挖掘SimpleSection-o"><a href="#挖掘SimpleSection-o" class="headerlink" title="挖掘SimpleSection.o"></a>挖掘SimpleSection.o</h4><ul>
<li>.rodata存放的是只读数据（ROM）。</li>
<li>部分编译器不存放为初始化变量，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在.bss段分配空间</li>
</ul>
<h5 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h5><ul>
<li>.rodata </li>
<li>.comment</li>
<li>.debug</li>
<li>.dynamic</li>
<li>.hash </li>
<li>.line </li>
<li>.note </li>
<li>.strtab </li>
<li>.symtab </li>
<li>.shstrtab </li>
<li>.plt </li>
<li>.got </li>
<li>.init </li>
<li>.fini</li>
</ul>
<h4 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h4><h5 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h5><ul>
<li>ELF魔数</li>
<li>文件机器字节长度</li>
<li>数据存储方式</li>
<li>版本</li>
<li>运行平台</li>
<li>ABI版本</li>
<li>ELF重定位类型</li>
<li>硬件平台</li>
<li>硬件平台版本</li>
<li>入口地址</li>
<li>程序头入口和长度</li>
<li>段表的位置和长度</li>
<li>段的数量</li>
</ul>
<h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><ul>
<li>段表就是保存各个段的基本属性的结构</li>
<li>每个段的基本属性保存在一个叫段描述符的结构体里。</li>
<li>.rel.data和.rel.text 重定向的段。</li>
<li>.strtabl和.shstrtab 字符串表和段表字符串表。</li>
</ul>
<h4 id="链接的接口–符号"><a href="#链接的接口–符号" class="headerlink" title="链接的接口–符号"></a>链接的接口–符号</h4><ul>
<li>在链接中，目标文件之间的相互拼合实际上是目标文件之间对地址的引用，我们将函数和变量统称为符号，函数名和变量名就是符号名。</li>
<li>每一个目标文件都有一个相应的符号表，这个表里面记录了目标文件中所用到的所有的符号</li>
<li>每个对应的符号有一个对应值叫做符号值，对于变量和函数来说，符号值就是他们的地址。</li>
</ul>
<h5 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h5><ul>
<li>全局符号</li>
<li>外部符号</li>
<li>段名</li>
<li>局部符号</li>
<li>行号信息</li>
</ul>
<h5 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h5><ul>
<li>symtab</li>
<li>每个符号对应一个结构体（Elf32_Sym）</li>
</ul>
<h5 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h5><ul>
<li>程序起始地址</li>
<li>text段结束地址</li>
<li>data段结束地址</li>
<li>程序结束地址</li>
<li>以上地址都是程序被装载时的虚拟地址</li>
</ul>
<h5 id="符号修饰和函数签名"><a href="#符号修饰和函数签名" class="headerlink" title="符号修饰和函数签名"></a>符号修饰和函数签名</h5><ul>
<li>加前缀下划线和后缀下划线</li>
<li>通过命名空间</li>
<li>函数签名信息包括：函数名、参数类型、所在类、命名空间等。</li>
</ul>
<h5 id="extren-“C”"><a href="#extren-“C”" class="headerlink" title="extren “C”"></a>extren “C”</h5><p>extern修饰的代码段编译器会按C语言的编译规则来处理</p>
<h5 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h5><ul>
<li>函数和初始化了的全局变量为强符号</li>
<li>未初始化的变量为弱符号</li>
</ul>
<h3 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h3><p>当我们有两个目标文件时，如何将它们链接起来形成一个可执行文件？这个过程中发生了什么？这基本上就是链接的核心内容：静态链接</p>
<h4 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h4><p>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件?</p>
<h5 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h5><ul>
<li>缺点：浪费空间，文件零散。</li>
<li>段的装载地址和空间对齐单位是<strong>页</strong>，每一页有4096个字节。</li>
</ul>
<h5 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h5><p>我们这里谈的空间地址分配只关注虚拟地址空间的分配，不关心输出在可执行文件中的空间</p>
<p>两步链接：</p>
<ul>
<li><p>空间与地址分配</p>
</li>
<li><p>符号解析与重定向</p>
</li>
</ul>
<h5 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h5><p>存储在符号表内</p>
<h4 id="符号解析与重定向"><a href="#符号解析与重定向" class="headerlink" title="符号解析与重定向"></a>符号解析与重定向</h4><p>静态链接的核心内容是符号解析和重定向</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>重定向需要参考重定位表</p>
<h5 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h5><p>每一个要被重定位的地方叫一个重定位入口，重定位入口的偏移表示该入口在要被重定位的段中的位置。</p>
<h5 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h5><p>重定位的过程中，每一个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确认这个符号的目标地址，这个时候链接器就会去查找所有目标文件的符号表，这个过程叫做符号解析。</p>
<h5 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h5><p>不同的处理器指令对于地址的格式和方式都不一样。</p>
<ul>
<li><p>绝对寻址修正</p>
</li>
<li><p>相对寻址修正</p>
</li>
</ul>
<p>区别：绝对地址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差</p>
<h4 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h4><ul>
<li><p>存放弱符号的块</p>
</li>
<li><p>当不同的目标文件需要的COMMON块的空间大小不一致时，以最大的那块为准。</p>
</li>
</ul>
<h4 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h4><h5 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h5><ul>
<li>模板、外部内联函数、虚函数表都有可能在不同的编译单元生成相同的代码</li>
</ul>
<p>弊端：</p>
<ul>
<li>空间的浪费</li>
<li>地址较易出错</li>
<li>指令运行效率较低</li>
</ul>
<p><strong>函数级别链接</strong>的作用就是让所有的函数都像模板一样单独的保存到一个段里面。</p>
<h5 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h5><p>c++的全局对象构造函数在main()之前被执行，c++的全局对象析构函数在main()之后被执行</p>
<ul>
<li><p>.init段 全局构造</p>
</li>
<li><p>.fini段 全局析构</p>
</li>
</ul>
<h5 id="c-与ABI"><a href="#c-与ABI" class="headerlink" title="c++与ABI"></a>c++与ABI</h5><p>ABI：符号修饰标准，变量内存布局方式，函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI</p>
<h4 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h4><p>将多个静态库链接到一个可执行文件中的过程。</p>
<h4 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h4><h5 id="链接控制脚本"><a href="#链接控制脚本" class="headerlink" title="链接控制脚本"></a>链接控制脚本</h5><ul>
<li><p>使用命令行来给链接器指定参数</p>
</li>
<li><p>将链接指令存放在目标文件里面</p>
</li>
<li><p>使用链接控制脚本</p>
</li>
</ul>
<p>c++把这种控制脚本叫做模块定义文件，它们的扩展名一般为.def</p>
<h5 id="使用ld链接脚本"><a href="#使用ld链接脚本" class="headerlink" title="使用ld链接脚本"></a>使用ld链接脚本</h5><p>控制链接过程无非是控制输入段如何变成输出段，比如哪些输入段要合并一个输出段，哪些输入段要丢弃，指定输出段的名字，装载地址，属性等。</p>
<p>有人专门研究过最小的ELF可执行文件的大小为45个字节。</p>
<h5 id="ld链接脚本语法简介"><a href="#ld链接脚本语法简介" class="headerlink" title="ld链接脚本语法简介"></a>ld链接脚本语法简介</h5><ul>
<li><p>语句之间使用；号作为分隔符</p>
</li>
<li><p>表达式与运算符</p>
</li>
<li><p>注释和字符引用</p>
</li>
</ul>
<h4 id="BFD库"><a href="#BFD库" class="headerlink" title="BFD库"></a>BFD库</h4><p>BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件格式。</p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>本章介绍了静态链接中的第一个步骤，即目标文件在被连接成最终可执行文件时，输入目标文件的各个段是如何被合并到输出文件中的，链接器如何为他们分配在输出文件中空间和地址。</p>
<h3 id="第六章-可执行文件的装载"><a href="#第六章-可执行文件的装载" class="headerlink" title="第六章 可执行文件的装载"></a>第六章 可执行文件的装载</h3><h4 id="进程虚拟空间地址"><a href="#进程虚拟空间地址" class="headerlink" title="进程虚拟空间地址"></a>进程虚拟空间地址</h4><h5 id="程序和进程的区别"><a href="#程序和进程的区别" class="headerlink" title="程序和进程的区别"></a>程序和进程的区别</h5><p>程序是一个静态的概念，是一些预先编译好的指令和数据集合的一个文件。进程是一个动态的概念，它是程序运行时的一个过程。</p>
<p>每个程序运行起来后，都有自己的虚拟地址空间，这个虚拟地址空间的大小由计算机的硬件平台决定，具体由CPU的位数决定。</p>
<p>32位的虚拟地址空间为2的32次方，64位的虚拟地址空间为2的64次方。。。</p>
<h4 id="装载方式"><a href="#装载方式" class="headerlink" title="装载方式"></a>装载方式</h4><h5 id="覆盖装入（out）"><a href="#覆盖装入（out）" class="headerlink" title="覆盖装入（out）"></a>覆盖装入（out）</h5><p>没有发明虚拟存储前应用广泛，现在已经基本被淘汰了。</p>
<h5 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h5><p>页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。</p>
<p>映射过程已页为单位进行，硬件规定的页的大小有4096字节，8192字节，2MB,4MB等。</p>
<h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><h5 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h5><p>进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件，建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ul>
<h5 id="进程栈初始化"><a href="#进程栈初始化" class="headerlink" title="进程栈初始化"></a>进程栈初始化</h5><p>进程在启动的时候，须知道一些进程运行的环境（环境变量）和进程的运行参数。<br>这也是main函数的2个参数的来源，<strong>argc</strong> 为参数数量 <strong>argv</strong><br> 为参数字符串指针数组</p>
<h4 id="ipa的大致启动过程"><a href="#ipa的大致启动过程" class="headerlink" title="ipa的大致启动过程"></a>ipa的大致启动过程</h4><ul>
<li>读取ipa文件头部</li>
<li>分配虚拟内存空间</li>
<li>建立虚拟内存与ipa文件的映射关系</li>
<li>加载动态库</li>
<li>初始化runtime</li>
<li>initialzers文件</li>
<li>创建主线程，启动进程</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/27/SceneKit的那些坑/" itemprop="url">
                  SceneKit的那些坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-27T16:27:35+08:00" content="2017-05-27">
              2017-05-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/27/SceneKit的那些坑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/27/SceneKit的那些坑/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SceneKit是苹果爸爸自带的一个3D引擎，应该是高度封装了OpenGL ES相关的内容，使用起来比OpenGL方便了不止100倍，当然功能上肯定不能和手撸OpenGL相比较啦，但是一些简单的3D场景用它做起来还是比较方便的。比如加载显示个3D模型啥的。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>产品想在咱的app里面加一套勋章体系，这个也不是啥新鲜功能啦，纵观各大直播app,勋章体系做的都是66的，但是呢，咱们产品大大看上了QQ的勋章展示方式，如下图：</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/qqmedel.gif" alt=""></p>
<p>第一反应是OpenGL ES，后来同事推荐了SceneKit这个框架，于是有了这一篇踩坑之旅。</p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="http://www.jianshu.com/u/1c37e216663b" target="_blank" rel="noopener">这位同学</a> 的入门教程还不错，不过现在他把教程转为了收费项目，但是代码还是可以在<a href="https://github.com/XJALYN/SceneKit_Learn" target="_blank" rel="noopener">他的Github上</a>下载到的，而且看他的提交记录.md文件里面会有惊喜哦。</p>
<p>so 我这里就直说我踩过的一些坑啦，想学习整个流程的童鞋可以参考上面的教程。在这里先谢谢这位同学啦~~~</p>
<h3 id="坑s"><a href="#坑s" class="headerlink" title="坑s"></a>坑s</h3><p>SceneKit是支持两个格式的文件的.scn和.dae 但是 这两种格式好像并没有太大的区别，都可以通过下面2中方式加载到程序中：</p>
<p>通过记事本打开文件，就会发现每个模型（node）都有一个id和name</p>
<h4 id="通过id加载"><a href="#通过id加载" class="headerlink" title="通过id加载"></a>通过id加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSURL *bundlePathUrl = [[NSBundle mainBundle] bundleURL];</div><div class="line">bundlePathUrl = [bundlePathUrl URLByAppendingPathComponent:@&quot;art.scnassets/medle1.dae&quot;];</div><div class="line">            </div><div class="line">SCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:bundlePathUrl options:nil];</div><div class="line">SCNNode *myNode = [sceneSource entryWithIdentifier:@&quot;ID4&quot; withClass:[SCNNode class]];</div></pre></td></tr></table></figure>
<h4 id="通过name加载"><a href="#通过name加载" class="headerlink" title="通过name加载"></a>通过name加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SCNScene *scene = [SCNScene sceneNamed:@&quot;art.scnassets/medle1.dae&quot;];</div><div class="line">SCNNode *myNode = [scene.rootNode childNodeWithName:@&quot;medle1&quot; recursively:YES];</div></pre></td></tr></table></figure>
<h4 id="自定义材质-Material"><a href="#自定义材质-Material" class="headerlink" title="自定义材质(Material)"></a>自定义材质(Material)</h4><p>想要自定义模型的材质，就需要获取到模型的几何属性(geometry),but 自定义的模型加载进来的时候默认的geometry属性是nil的你敢信吗。。。google了一番之后，找到了一个解决方案 先遍历一下这个模型的childNodes 然后修改child的geometry的firstMaterial。。。这也算曲线救国了</p>
<p>这里还有一个坑，美工导出的模型可能会有好几个child我擦嘞。。。这个时候咋办呢 ，取哪个都不对啊， 每个child可能都只是整个模型的一部分而已，让美工的同学先把这几个child合并为一个child，然后再导出试试吧。</p>
<h4 id="材质叠加"><a href="#材质叠加" class="headerlink" title="材质叠加"></a>材质叠加</h4><p>美工同学可能建好了模型，并成功导出正确的模型格式，还把材质也一起导出来了，是不是很完美。拿来直接用就可以啦。but 我要再添加一个材质到模型上该如何实现呢（比如我要贴一张图片到模型上），如果我直接修改firstMaterial的话，那么不好意思哦，原来美工导出的材质就被remove掉了。</p>
<p>这个时候就不能直接修改firstMaterial啦，需要修改firstMaterial的diffuse和multiply属性来实现，美工同学导出的材质图片= diffuse.contents  自定义贴图 = multiply.contents。 然后就是微调图片的位置啥的了，通过修改contentsTransform这个属性来实现。</p>
<h4 id="添加射灯"><a href="#添加射灯" class="headerlink" title="添加射灯"></a>添加射灯</h4><p>可以看到，qq的勋章在滑动的时候，上面有高亮的金属光泽，这个应该是可以通过添加灯光来实现的。SceneKit有提供4中灯光，分别是环境光，点光源，方向光和聚光灯（我这里叫他射灯）。</p>
<p>首先 环境光和点光源都是必须的 实现高光的话，还需要再添加一个射灯，然后调整照射的位置到你满意就可以啦。见如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (SCNNode *)spotNode&#123;</div><div class="line"></div><div class="line">    if (!_spotNode) &#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        SCNLight *spotLight = [SCNLight light];// 创建光对象</div><div class="line">        spotLight.type = SCNLightTypeSpot;// 设置类型</div><div class="line">        spotLight.color = [UIColor whiteColor]; // 设置光的颜色</div><div class="line">        spotLight.castsShadow = TRUE;// 捕捉阴影</div><div class="line">        spotLight.attenuationStartDistance = 0;</div><div class="line">        spotLight.attenuationEndDistance = 100;</div><div class="line">        spotLight.attenuationFalloffExponent = 2;</div><div class="line">        spotLight.spotInnerAngle = 0;</div><div class="line">        spotLight.spotOuterAngle = 30;</div><div class="line">        _spotNode = [SCNNode node];</div><div class="line">        _spotNode.position = SCNVector3Make(0, 2, 10); //设置光源节点的位置</div><div class="line">        _spotNode.light  = spotLight;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _spotNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="勋章的旋转"><a href="#勋章的旋转" class="headerlink" title="勋章的旋转"></a>勋章的旋转</h4><p>勋章需要支持手势，主要是通过滑动手势旋转勋章，而且需要在不同滑动力度时旋转不同的角度，当然，最后旋转的角度都是M_PI的整数倍，所以勋章才会始终保持正面或者背面面向屏幕而不是侧面面向屏幕了。</p>
<h5 id="手势的选择"><a href="#手势的选择" class="headerlink" title="手势的选择"></a>手势的选择</h5><p>手势识别我尝试了2种方案，第一种是touchBegan系列响应事件，还有一种是添加UIPanGestureRecognizer手势，其实二者的处理方案是差不多的，但是使用touch系列方法不能检测到滑动的速度，而UIPanGestureRecognizer有提供检测速率的方法，so 当然是选择UIPanGestureRecognizer啦~</p>
<h5 id="属性的选择"><a href="#属性的选择" class="headerlink" title="属性的选择"></a>属性的选择</h5><p>然后就是选择改变node的哪个属性来实现旋转了，SCNNode有好几个属性都是可以旋转node，比如transform,pivot,rotation等,不同点是前两个是矩阵运算，后一个是向量运算。这里我也做了2种尝试，最初我使用的是pivot，在处理旋转角度小于M_PI时还行，但是如果想让勋章旋转一圈或者几圈时，无论我的角度设置的是多大，最终效果都只能旋转M_PI。好吧，然后我就转向使用rotation旋转勋章，这里还有一点需要注意的，要保证勋章是平滑的转动而不会出现突出旋转到某个方向，必须要在勋章的初始角度上进行加减，并保存勋章旋转后的角度以便下一次旋转时计算角度值。</p>
<h5 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h5><p>当手指离开屏幕后，勋章会根据手指滑动的速率和方向做一个旋转的弹簧动画，因为SCNNode本身是支持CA动画的，所以我首先想到的就是使用CA动画去做，ok,第一次旋转是木有问题的，但是动画结束之后，如果你再去旋转勋章你会发现，勋章完全不动了，不管你的旋转角度是多少。。。我想可能是因为CA动画本身并没有改变rotation的值，所以当我再次旋转时计算的角度值并不是从当前勋章的其实角度开始的。</p>
<p>CA动画不行，还好Scenekit提供了另外一种动画的实现方式，SCNTransaction动画，类似于CATransaction的使用方式。好吧 动画这块的效果终于差不多搞定了。</p>
<h4 id="自定义贴图"><a href="#自定义贴图" class="headerlink" title="自定义贴图"></a>自定义贴图</h4><p>勋章的背面需要显示用户的相关信息，这些信息都是动态的，不可能是美工同学在建模的时候加，只能是通过代码的方式动态的加上去。</p>
<p>因为图片可以直接作为材质的contents，so 我将需要显示的信息放到一个label上，然后对这个label做截图操作就可以得到我想要的图片文件了。</p>
<p>SCNNode有很多的材质相关的属性，而且还有一个材质列表，模型所有使用的材质都在这个列表中可以找到，所以我的做法就是取出你需要改变的材质，将自定义贴图和当前材质做一个合并，然后使用合并后的材质替换之前的。</p>
<p>这里有点需要注意的就是调试贴图到正确的位置，因为图片的坐标系是01坐标系，所以在调试的时候参数需要尽量小，慢慢调，如果你合并材质和替换都成功了但是在模型上面看不到图片，可能就是图片的位置不对。</p>
<h4 id="模型的动态加载"><a href="#模型的动态加载" class="headerlink" title="模型的动态加载"></a>模型的动态加载</h4><p>Xcode在build的时候，会把项目中引用了的.dae模型(这里指本地模型)通过一个脚本copy到.ipa中，copy的过程中可能对模型的格式进行了特殊处理，因为copy后的文件比原文件小了很多。</p>
<p>如果我们要动态加载模型的话，Xcode是没有对模型进行copy操作的，我们直接使用设计给的模型文件，在模型被保存到沙盒中后，通过文件路径加载无法正常加载出模型，后来在网上找到<a href="https://the-nerd.be/2014/11/07/dynamically-load-collada-files-in-scenekit-at-runtime/#more-457" target="_blank" rel="noopener">这个解决方案</a>，<a href="http://www.jianshu.com/p/78be2688ef4c" target="_blank" rel="noopener">这里还有一篇中文的，内容差不多</a>，先将模型用Xcode在build时使用的脚步copy一份，然后把copy的模型文件给服务器，下载后就可以正常显示了。</p>
<p>相当于我们帮Xcode做了copy的操作。</p>
<p><a href="https://github.com/lilingyu0620/LLYSceneKitDemo" target="_blank" rel="noopener">这是我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/26/RTMP拉流播放详解/" itemprop="url">
                  RTMP拉流播放详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-26T17:05:12+08:00" content="2017-04-26">
              2017-04-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/26/RTMP拉流播放详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/26/RTMP拉流播放详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面已经介绍了RTMP推流的整个流程，今天我们再来梳理一下拉流端以及播放的整个过程。</p>
<p>我们先来看一下拉流端整个流程的抓包数据，然后分析一下每一个数据包的具体内容。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/rtmppull.png" alt=""></p>
<p>从上面的抓包数据可以看出，和推流端的整个流程基本上是一致的，只是在connect结束之后有一点不一样的操作，推流端是发送publish命令，而拉流端发送的是play命令。</p>
<h3 id="play"><a href="#play" class="headerlink" title="play"></a>play</h3><p>既然如此，那其他的数据包我在这里就不再一一分析，可以参考我之前写的<a href="http://llyblog.com/2017/03/24/RTMP推流流程详解/" target="_blank" rel="noopener">推流详解</a>这篇博客，现在我主要来解析一样play这个命令。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/rtmpplay.png" alt=""></p>
<p>结合下面的代码来说明一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//play</div><div class="line">- (void)sendPlay&#123;</div><div class="line"></div><div class="line">    RTMPChunk_0 metadata = &#123;0&#125;;</div><div class="line">    metadata.msg_stream_id = LLYStreamIDPlay;</div><div class="line">    metadata.msg_type_id = LLYMSGTypeID_INVOKE;</div><div class="line">    </div><div class="line">    NSMutableData *buff = [NSMutableData data];</div><div class="line">    [buff appendString:@&quot;play&quot;];</div><div class="line">    [buff appendDouble:(++_numOfInvokes)];</div><div class="line">    self.trackedCommands[@(_numOfInvokes)] = @&quot;play&quot;;</div><div class="line">    [buff appendByte:kAMFNull];</div><div class="line">    [buff appendString:_url.playPath];</div><div class="line">    </div><div class="line">    metadata.msg_length.data = (int)buff.length;</div><div class="line">    [self sendPacket:buff :metadata];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实和publish命令差不多的 ，只是将关键字改为 play.</p>
<h3 id="SetBufferTime"><a href="#SetBufferTime" class="headerlink" title="SetBufferTime"></a>SetBufferTime</h3><p><img src="http://ofy1hyquv.bkt.clouddn.com/playsettime.png" alt=""></p>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)sendSetBufferTime:(int)milliseconds&#123;</div><div class="line">    dispatch_sync(_packageQueue, ^&#123;</div><div class="line">        int streamId = 0;</div><div class="line">        </div><div class="line">        NSMutableData *data = [NSMutableData data];</div><div class="line">        [data appendByte:2];</div><div class="line">        [data appendByte24:0];</div><div class="line">        [data appendByte24:10];</div><div class="line">        [data appendByte:LLYMSGTypeID_PING];</div><div class="line">        [data appendBytes:(uint8_t*)&amp;streamId length:sizeof(int32_t)];</div><div class="line">        </div><div class="line">        [data appendByte16:3];</div><div class="line">        [data appendByte32:_streamID];</div><div class="line">        [data appendByte32:milliseconds];</div><div class="line">        </div><div class="line">        [self writeData:data];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在收到play的回调消息，我们还需要设置一下发送时间，这一句很重要哦，设置不成功或者不设置的话服务器是不会给你推音视频的数据的。</p>
<h3 id="视频流的解析"><a href="#视频流的解析" class="headerlink" title="视频流的解析"></a>视频流的解析</h3><p>ok 现在我们开始收到源源不断的视频流数据，那么我们怎么把他们解析成原始的数据格式播放出来呢，下面来分析一下这个过程。</p>
<p><img src="http://ofy1hyquv.bkt.clouddn.com/rtmpvideo.png" alt=""></p>
<p>如上图，我们先来看一下一帧视频流数据长啥样吧。</p>
<p>首先是头部信息，在rtmp格式中已经详细的分析了，这里不再介绍。</p>
<p>重点来看一下Body中的数据：</p>
<h4 id="Control-0x17-keyframe-H-264"><a href="#Control-0x17-keyframe-H-264" class="headerlink" title="Control : 0x17(keyframe H.264)"></a>Control : 0x17(keyframe H.264)</h4><p>这个0X17是个啥呢，如果还记得推流时我们怎么封装数据的应该对这个有印象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">body[index++] = 0x17;//RTMP Body Control FrameType:1表示key frame  CodecID:7: AVC</div></pre></td></tr></table></figure>
<p>就是这行代码所表示的数据了。</p>
<p>通过这个数据，我们就能分析当前帧是不是关键帧，需不需要解析里面的SPS和PPS信息。</p>
<h4 id="video-data"><a href="#video-data" class="headerlink" title="video data"></a>video data</h4><p>这个里面就是我们想要的视频数据了，但是又并不全是我们想要的视频数据，因为我们在推流封装的时候，是根据AVC格式来，所以其实这个body data里面还有一部分AVC的数据，我们需要把这一部分的数据剔除掉，剩下的才是我们需要的原始的视频流数据（好复杂的感觉有木有）。</p>
<p>先把代码贴上来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">- (void)updateFrame&#123;</div><div class="line"></div><div class="line">    dispatch_sync(mDecodeQueue, ^&#123;</div><div class="line">        if(packetBuffer == NULL) &#123;</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        uint8_t avcType = packetBuffer[0];</div><div class="line">        long totalLength = packetSize;</div><div class="line">        </div><div class="line">        while (avcType == 0x17 || avcType == 0x27) &#123;</div><div class="line">            </div><div class="line">            uint8_t type = packetBuffer[1];</div><div class="line">            if (type == 0) &#123;</div><div class="line">                </div><div class="line">                //获取sps</div><div class="line">//                int spsnum = packetBuffer[10]&amp;0x1f;</div><div class="line">                int number_sps = 11;</div><div class="line">                int count_sps = 1;</div><div class="line">                int spsTotalLen = 0;</div><div class="line">                uint8_t *spsTmp;</div><div class="line">                </div><div class="line">//                if (count_sps &lt;= spsnum)</div><div class="line">                &#123;</div><div class="line">                    int spslen =(packetBuffer[number_sps]&amp;0x000000FF)&lt;&lt;8 | (packetBuffer[number_sps+1]&amp;0x000000FF);</div><div class="line">                    number_sps += 2;</div><div class="line">                    </div><div class="line">                    spsTmp = malloc(spslen + 4);</div><div class="line">                    memcpy(spsTmp, lyStartCode, 4);</div><div class="line">                    spsTotalLen += 4;</div><div class="line">                    </div><div class="line">                    memcpy(spsTmp+4,packetBuffer + number_sps , spslen);</div><div class="line">                    spsTotalLen += spslen;</div><div class="line">                    </div><div class="line">                    number_sps += spslen;</div><div class="line">                    </div><div class="line">                    totalLength -= number_sps;</div><div class="line">                    count_sps ++;</div><div class="line">                &#125;</div><div class="line">                [self decodeNalu:spsTmp withSize:spsTotalLen];</div><div class="line">                </div><div class="line">                packetBuffer += number_sps+1;</div><div class="line">                //获取pps</div><div class="line">//                int ppsnum = packetBuffer[number_sps]&amp;0x1f;</div><div class="line">                int number_pps = 0;</div><div class="line">                int count_pps = 1;</div><div class="line">                int ppsTotalLen = 0;</div><div class="line">                uint8_t *ppsTmp;</div><div class="line">//                if (count_pps &lt;= ppsnum)</div><div class="line">                &#123;</div><div class="line">                    int ppslen =(packetBuffer[number_pps]&amp;0x000000FF)&lt;&lt;8 | (packetBuffer[number_pps+1]&amp;0x000000FF);</div><div class="line">                    number_pps += 2;</div><div class="line">                    </div><div class="line">                    ppsTmp = malloc(ppslen + 4);</div><div class="line">                    memcpy(ppsTmp, lyStartCode, 4);</div><div class="line">                    ppsTotalLen += 4;</div><div class="line">                    memcpy(ppsTmp +  4,packetBuffer + number_pps,ppslen);</div><div class="line">                    ppsTotalLen += ppslen;</div><div class="line">                    number_pps += ppslen;</div><div class="line">                    </div><div class="line">                    totalLength -= number_pps;</div><div class="line">                    count_pps ++;</div><div class="line">                &#125;</div><div class="line">                [self decodeNalu:ppsTmp withSize:ppsTotalLen];</div><div class="line">                </div><div class="line">                packetBuffer += number_pps;</div><div class="line">                avcType = packetBuffer[0];</div><div class="line">            &#125;</div><div class="line">            else if(type == 1)&#123;</div><div class="line">                </div><div class="line">                BOOL isNalu = YES;</div><div class="line">                </div><div class="line">                //获取avc nalu</div><div class="line">                int len =0;</div><div class="line">                int num =5;</div><div class="line">                int naluTotalLen = 0;</div><div class="line">                </div><div class="line">                while (isNalu)</div><div class="line">                &#123;</div><div class="line">                    </div><div class="line">                    len = (packetBuffer[num]&amp;0x000000FF)&lt;&lt;24 | (packetBuffer[num+1]&amp;0x000000FF)&lt;&lt;16</div><div class="line">                    | (packetBuffer[num+2]&amp;0x000000FF)&lt;&lt;8 | (packetBuffer[num+3]&amp;0x000000FF);</div><div class="line">                    </div><div class="line">                    naluBuffer = malloc(len + 4);</div><div class="line">                    naluTotalLen += 4;</div><div class="line">                    naluTotalLen += len;</div><div class="line"></div><div class="line">                    memcpy(naluBuffer,packetBuffer + num,len + 4);</div><div class="line">                    </div><div class="line">                    num = num + len + 4;</div><div class="line">                    totalLength -= num;</div><div class="line">                    </div><div class="line">                    [self decodeNalu:naluBuffer withSize:naluTotalLen];</div><div class="line">                    packetBuffer += num;</div><div class="line">                    num = 0;</div><div class="line">                    naluTotalLen = 0;</div><div class="line">                    free(naluBuffer);</div><div class="line">                    </div><div class="line">                    //可能存在下一个NALU</div><div class="line">                    if (totalLength &gt; 4) &#123;</div><div class="line">                        avcType = packetBuffer[0];</div><div class="line">                        if (avcType == 0x17 || avcType == 0x27) &#123;</div><div class="line">                            isNalu = NO;</div><div class="line">                        &#125;</div><div class="line">                        else&#123;</div><div class="line">                            len = (packetBuffer[num]&amp;0x000000FF)&lt;&lt;24 | (packetBuffer[num+1]&amp;0x000000FF)&lt;&lt;16</div><div class="line">                            | (packetBuffer[num+2]&amp;0x000000FF)&lt;&lt;8 | (packetBuffer[num+3]&amp;0x000000FF);</div><div class="line">                            </div><div class="line">                            if (len &gt;= (totalLength - 4)) &#123;</div><div class="line">                                return;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    else&#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从最上面开始分析</p>
<p>packetBuffer 即为上图中的RTMP Body数据，注意这里是剔除了RTMP Head的哦。</p>
<p>怎么剔除Head可以参考我的demo中下面这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)parseData:(NSData *)data</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//RTMP Body Control FrameType:1表示key frame  CodecID:7: AVC</div><div class="line">uint8_t avcType = packetBuffer[0];</div></pre></td></tr></table></figure>
<p>然后我们取出Control信息 它可能包括0x17或者是0x27,其中17是关键帧，27不是关键帧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//    IF AVCPacketType ==0 AVCDecoderConfigurationRecord（AVC sequence header）</div><div class="line">//    IF AVCPacketType == 1 One or more NALUs (Full frames are required)</div><div class="line"></div><div class="line">uint8_t type = packetBuffer[1];</div></pre></td></tr></table></figure>
<p>然后是AVCType字段。</p>
<p>如果Type = 0 ，我们需要取出的是SPS和PPS信息，如果没有这部分信息是无法将H.264文件解码的。</p>
<p>当Type = 1，我们获取当前avc的NALU单元信息，这个数据就是我们需要显示的视频数据了。</p>
<p>然后我把取到的数据用下面方法解码为CVPixelBufferRef数据进行显示(播放)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">-(void) decodeNalu:(uint8_t *)frame withSize:(uint32_t)frameSize</div><div class="line">&#123;</div><div class="line">    //    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始解码&quot;);</div><div class="line">    int nalu_type = (frame[4] &amp; 0x1F);</div><div class="line">    CVPixelBufferRef pixelBuffer = NULL;</div><div class="line">    </div><div class="line">//    uint32_t nalSize = (uint32_t)(frameSize - 4);</div><div class="line">//    uint8_t *pNalSize = (uint8_t*)(&amp;nalSize);</div><div class="line">//    frame[0] = *(pNalSize + 3);</div><div class="line">//    frame[1] = *(pNalSize + 2);</div><div class="line">//    frame[2] = *(pNalSize + 1);</div><div class="line">//    frame[3] = *(pNalSize);</div><div class="line">    //传输的时候。关键帧不能丢数据 否则绿屏   B/P可以丢  这样会卡顿</div><div class="line">    switch (nalu_type)</div><div class="line">    &#123;</div><div class="line">        case 0x05:</div><div class="line">            //NSLog(@&quot;nalu_type:%d Nal type is IDR frame&quot;,nalu_type);  //关键帧</div><div class="line">            &#123;</div><div class="line">                uint32_t dataLength32 = htonl (frameSize - 4);</div><div class="line">                memcpy (frame, &amp;dataLength32, sizeof (uint32_t));</div><div class="line">                </div><div class="line">                [self initVideoToolBox];</div><div class="line">                pixelBuffer = [self decode:frame withSize:frameSize];</div><div class="line">                [self displayDecodedFrame:pixelBuffer];</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case 0x07:</div><div class="line">            //NSLog(@&quot;nalu_type:%d Nal type is SPS&quot;,nalu_type);   //sps</div><div class="line">            mSPSSize = frameSize - 4;</div><div class="line">            mSPS = malloc(mSPSSize);</div><div class="line">            memcpy(mSPS, frame + 4, mSPSSize);</div><div class="line">            break;</div><div class="line">        case 0x08:</div><div class="line">        &#123;</div><div class="line">            //NSLog(@&quot;nalu_type:%d Nal type is PPS&quot;,nalu_type);   //pps</div><div class="line">            mPPSSize = frameSize - 4;</div><div class="line">            mPPS = malloc(mPPSSize);</div><div class="line">            memcpy(mPPS, frame + 4, mPPSSize);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        default:</div><div class="line">        &#123;</div><div class="line">            //NSLog(@&quot;Nal type is B/P frame&quot;);//其他帧</div><div class="line">            &#123;</div><div class="line">                uint32_t dataLength32 = htonl (frameSize - 4);</div><div class="line">                memcpy (frame, &amp;dataLength32, sizeof (uint32_t));</div><div class="line">                </div><div class="line">                [self initVideoToolBox];</div><div class="line">                pixelBuffer = [self decode:frame withSize:frameSize];</div><div class="line">                [self displayDecodedFrame:pixelBuffer];</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">//    if(pixelBuffer)</div><div class="line">//    &#123;</div><div class="line">//        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">//            [self.mOpenGLView displayPixelBuffer:pixelBuffer];</div><div class="line">//            CVPixelBufferRelease(pixelBuffer);</div><div class="line">//        &#125;);</div><div class="line">//    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h4><p>这里我用的是苹果官网给的一个类AAPLEAGLLayer。</p>
<p><a href="https://github.com/lilingyu0620/LLYRtmpDemo" target="_blank" rel="noopener">我是demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/03/iOS-Socket编程学习笔记/" itemprop="url">
                  iOS Socket编程学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-03T23:06:10+08:00" content="2017-04-03">
              2017-04-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/03/iOS-Socket编程学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/03/iOS-Socket编程学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Socket是基于传输层TCP、UDP协议封装的一套API接口，它本身并不是一种协议。</p>
<h3 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/networkmodel.png" alt=""></p>
<h3 id="传输层中的协议"><a href="#传输层中的协议" class="headerlink" title="传输层中的协议"></a>传输层中的协议</h3><h4 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 (TCP)"></a>传输控制协议 (TCP)</h4><p>TCP全称是Transmission Control Protocol，中文名为传输控制协议，它可以提供可靠的、面向连接的网络数据传递服务。</p>
<h5 id="传输控制协议主要包含下列任务和功能："><a href="#传输控制协议主要包含下列任务和功能：" class="headerlink" title="传输控制协议主要包含下列任务和功能："></a>传输控制协议主要包含下列任务和功能：</h5><ul>
<li><p>确保IP数据报的成功传递</p>
</li>
<li><p>对程序发送的大块数据进行分段和重组</p>
</li>
<li><p>确保正确排序及按顺序传递分段的数据</p>
</li>
<li><p>通过计算校验和，进行传输数据的完整性检查</p>
</li>
<li><p>根据数据是否接收成功发送肯定消息。通过使用选择性确认，也对没有收到的数据发送否定确认</p>
</li>
</ul>
<h5 id="TCP工作流程"><a href="#TCP工作流程" class="headerlink" title="TCP工作流程"></a>TCP工作流程</h5><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/socketflow.png" alt=""></p>
<p>TCP的连接建立过程又称为TCP三次握手</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/tcpconnect.png" alt=""></p>
<p>一旦初始的三次握手完成，client和server就可以相互发送信息。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/tcpdisconnect.png" alt=""></p>
<p>而断开连接时，就不分client和server了，先请求断开的即为主动方，主动方会先发送断开请求，被动发在收到断开请求后会先给主动方一个确认，然后待被动方处理完所有的传输事务后，再给主动方一个断开连接的请求，<br>主动方收到被动方的断开请求，给被动方一个断开确认。至此断开成功。</p>
<p>TCP工作过程比较复杂，包括的内容如下:</p>
<ul>
<li><p>TCP连接关闭：发送方主机和目的主机建立TCP连接并完成数据传输后，会发送一个将结束标记置1的数据包，以关闭这个TCP连接，并同时释放该连接占用的缓冲区空间。</p>
</li>
<li><p>TCP重置：TCP允许在传输的过程中突然中断连接。</p>
</li>
<li><p>TCP数据排序和确认*：在传输的过程中使用序列号和确认号来跟踪数据的接收情况。</p>
</li>
<li><p>TCP重传：在TCP的传输过程中，如果在重传超时时间内没有收到接收方主机对某数据包的确认回复，发送方主机就认为此数据包丢失，并再次发送这个数据包给接收方。</p>
</li>
<li><p>TCP延迟确认：TCP并不总是在接收到数据后立即对其进行确认，它允许主机在接收数据的同时发送自己的确认信息给对方。</p>
</li>
<li><p>TCP数据保护（校验）：TCP是可靠传输的协议，它提供校验和计算来实现数据在传输过程中的完整性。</p>
</li>
</ul>
<h4 id="tcp报文格式"><a href="#tcp报文格式" class="headerlink" title="tcp报文格式"></a>tcp报文格式</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/tcpformat.jpeg" alt=""></p>
<ul>
<li><p>源端口、目标端口：计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。</p>
</li>
<li><p>序列号：表示本报文段所发送数据的第一个字节的编号。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始。那如何区分两个相同序列号的不同TCP报文段就是一个问题了，后面会有答案，暂时可以不管。</p>
</li>
<li><p>确认号：表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。也就是告诉发送发：我希望你（指发送方）下次发送的数据的第一个字节数据的编号是这个确认号。也就是告诉发送方：我希望你（指发送方）下次发送给我的TCP报文段的序列号字段的值是这个确认号。</p>
</li>
<li><p>TCP首部长度：由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。</p>
</li>
<li><p>URG：表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。</p>
</li>
<li><p>ACK：表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。</p>
</li>
<li><p>PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。</p>
</li>
<li><p>RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。</p>
</li>
<li><p>SYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。</p>
</li>
<li><p>FIN：标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了”</p>
</li>
<li><p>窗口大小：表示现在运行对方发送的数据量。也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量。</p>
</li>
<li><p>校验和：提供额外的可靠性。具体如何校验，参考其他资料。</p>
</li>
<li><p>紧急指针：标记紧急数据在数据字段中的位置。</p>
</li>
<li><p>选项部分：其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节。</p>
</li>
</ul>
<h5 id="选项部分的应用："><a href="#选项部分的应用：" class="headerlink" title="选项部分的应用："></a>选项部分的应用：</h5><ul>
<li><p>MSS最大报文段长度(Maxium Segment Size)：指明数据字段的最大长度，数据字段的长度加上TCP首部的长度才等于整个TCP报文段的长度。MSS值指示自己期望对方发送TCP报文段时那个数据字段的长度。通信双方可以有不同的MSS值。如果未填写，默认采用536字节。MSS只出现在SYN报文中。即：MSS出现在SYN=1的报文段中。</p>
</li>
<li><p>窗口扩大选项(Windows Scaling)：由于TCP首部的窗口大小字段长度是16位，所以其表示的最大数是65535。但是随着时延和带宽比较大的通信产生（如卫星通信），需要更大的窗口来满足性能和吞吐率，所以产生了这个窗口扩大选项。</p>
</li>
<li><p>SACK选择确认项(Selective Acknowledgements)：用来确保只重传缺少的报文段，而不是重传所有报文段。比如主机A发送报文段1、2、3，而主机B仅收到报文段1、3。那么此时就需要使用SACK选项来告诉发送方只发送丢失的数据。那么又如何指明丢失了哪些报文段呢？使用SACK需要两个功能字节。一个表示要使用SACK选项，另一个指明这个选项占用多少字节。描述丢失的报文段2，是通过描述它的左右边界报文段1、3来完成的。而这个1、3实际上是表示序列号，所以描述一个丢失的报文段需要64位即8个字节的空间。那么可以推算整个选项字段最多描述(40-2)/8=4个丢失的报文段。</p>
</li>
<li><p>时间戳选项（Timestamps）：可以用来计算RTT(往返时间)，发送方发送TCP报文时，把当前的时间值放入时间戳字段，接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，当发送方收到确认报文后即可计算出RTT。也可以用来防止回绕序号PAWS，也可以说可以用来区分相同序列号的不同报文。因为序列号用32为表示，每2^32个序列号就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文。</p>
</li>
<li><p>NOP(NO-Operation)：它要求选项部分中的每种选项长度必须是4字节的倍数，不足的则用NOP填充。同时也可以用来分割不同的选项字段。如窗口扩大选项和SACK之间用NOP隔开。</p>
</li>
</ul>
<h4 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h4><p>UDP全称是User Datagram Protocol，中文名为用户数据报协议。UDP 提供无连接的网络服务，该服务对消息中传输的数据提供不可靠的、最大努力传送。这意味着它不保证数据报的到达，也不保证所传送数据包的顺序是否正确。</p>
<p>虽然TCP中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大地降低了执行时间，使速度得到了保证。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/udpflow.png" alt=""></p>
<h3 id="Socket编程-Client"><a href="#Socket编程-Client" class="headerlink" title="Socket编程-Client"></a>Socket编程-Client</h3><p>iOS中实现Socekt编程有下面几种方式：</p>
<ul>
<li>BSDSocket iOS系统基于unix，所以支持底层的BSD Socket。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//相关api位于下面这个文件中</div><div class="line">#import &lt;sys/socket.h&gt;</div></pre></td></tr></table></figure>
<ul>
<li>CFSocket 对底层BSD Socket进行轻量级的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//相关api位于下面这个文件中</div><div class="line">#import &lt;CoreFoundation/CFSocket.h&gt;</div></pre></td></tr></table></figure>
<ul>
<li>CocoaAsyncSocket 使用OC封装的一个socket框架（支持TCP和UDP）<br><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">github</a></li>
</ul>
<p>这里使用的是CFSocket结合BSDSocket</p>
<h4 id="创建socket对象并连接服务器"><a href="#创建socket对象并连接服务器" class="headerlink" title="创建socket对象并连接服务器"></a>创建socket对象并连接服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (void)connectServerWithServerIP:(NSString *)serverIP&#123;</div><div class="line"></div><div class="line">    CFSocketContext socketContext = &#123;</div><div class="line">        0,//结构体的版本，必须为0</div><div class="line">        (__bridge void *)(self),</div><div class="line">        NULL,</div><div class="line">        NULL,</div><div class="line">        NULL,</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _mSocket = CFSocketCreate(kCFAllocatorDefault,//为新对象分配内存，可以为nil</div><div class="line">                              PF_INET,//协议族，如果为0或者负数，则默认为PF_INET</div><div class="line">                              SOCK_STREAM,//套接字类型，如果协议族为PF_INET,则它会默认为SOCK_STREAM</div><div class="line">                              IPPROTO_TCP,//套接字协议，如果协议族是PF_INET且协议是0或者负数，它会默认为IPPROTO_TCP</div><div class="line">                              kCFSocketConnectCallBack,//触发回调函数的socket消息类型，具体见Callback Types</div><div class="line">                              socketMessageCallBack,//上面情况下触发的回调函数</div><div class="line">                              &amp;socketContext);//一个持有CFSocket结构信息的对象，可以为nil</div><div class="line">    if (_mSocket != NULL) &#123;</div><div class="line">        struct sockaddr_in addr4;//IPV4</div><div class="line">        memset(&amp;addr4, 0, sizeof(addr4));</div><div class="line">        addr4.sin_len = sizeof(addr4);</div><div class="line">        addr4.sin_family = AF_INET;</div><div class="line">        addr4.sin_port = htons(8888);</div><div class="line">        addr4.sin_addr.s_addr = inet_addr([serverIP UTF8String]);//把字符串的地址转换为机器可识别的网络地址</div><div class="line"></div><div class="line">        //把sockaddr_in结构体中的地址转换为Data</div><div class="line">        CFDataRef address = CFDataCreate(kCFAllocatorDefault,</div><div class="line">                                         (UInt8 *)&amp;addr4, sizeof(addr4));</div><div class="line">        CFSocketConnectToAddress(_mSocket,//当前连接的socket</div><div class="line">                                 address,//CFDataRef类型的包含上面socket的远程地址的对象</div><div class="line">                                 -1);//连接超时时间，如果为负，则不尝试连接，而是把连接放在后台进行，如果_socket消息类型为kCFSocketConnectCallBack，将会在连接成功或失败的时候在后台触发回调函数</div><div class="line">        </div><div class="line">        CFRunLoopRef cRunRef = CFRunLoopGetCurrent();//获取当前线程的循环</div><div class="line">        //创建一个循环，但并没有真正加如到循环中，需要调用CFRunLoopAddSource</div><div class="line">        CFRunLoopSourceRef sourceRef = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _mSocket, 0);</div><div class="line">        CFRunLoopAddSource(cRunRef, sourceRef, kCFRunLoopCommonModes);</div><div class="line">        CFRelease(cRunRef);</div><div class="line">        CFRelease(sourceRef);</div><div class="line">        </div><div class="line">        NSLog(@&quot;start connect&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">case kCFSocketConnectCallBack:</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;connect callback&quot;);</div><div class="line">            //data为回调的错误码,为NULL则为成功</div><div class="line">            if (data != NULL)</div><div class="line">            &#123;</div><div class="line">                NSLog(@&quot;连接失败&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                //更新界面需要在主线程</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [mSelf ShowMsg:@&quot;服务器连接成功,现在可以开始通信了!!!&quot;];</div><div class="line">                &#125;);</div><div class="line">                //持续的接收数据，不能在主线程做，会阻塞当前线程，放到一个子线程去做。</div><div class="line">                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                    [mSelf readMessageLoop];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div></pre></td></tr></table></figure>
<p>判断当前连接成功后，可以开一个线程监听是否接收到数据。</p>
<p>注意这里的监听需要在子线程中进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)readMessageLoop&#123;</div><div class="line"></div><div class="line">    while (1) &#123;</div><div class="line">        char buffer[1024];</div><div class="line">        ssize_t recvLen = recv(CFSocketGetNative(_mSocket), buffer, sizeof(buffer), 0);</div><div class="line">        if (recvLen &gt; 0) &#123;</div><div class="line">            @autoreleasepool &#123;</div><div class="line">                NSString *str = @&quot;服务器发来数据：&quot;;</div><div class="line">                NSData *data = [NSData dataWithBytes:buffer length:recvLen];</div><div class="line">                str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</div><div class="line">                //回界面显示信息</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [self ShowMsg:str];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 发送数据</div><div class="line">- (void)sendMessage &#123;</div><div class="line">    const char *sData = [self.sendContentTextField.text UTF8String];</div><div class="line">    send(CFSocketGetNative(_mSocket), sData, strlen(sData) + 1, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (IBAction)closeServerConnectBtnClicked:(id)sender &#123;</div><div class="line">	if(CFSocketIsValid(_mSocket))</div><div class="line">    &#123;</div><div class="line">        close(CFSocketGetNative(_mSocket));//关闭socket</div><div class="line">        CFSocketInvalidate(_mSocket);</div><div class="line">        CFRelease(_mSocket);</div><div class="line">    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="Socket编程-Server"><a href="#Socket编程-Server" class="headerlink" title="Socket编程-Server"></a>Socket编程-Server</h3><p>在本机搭建一个MAC APP模拟Server，实现和Client的通信。</p>
<h4 id="创建Socket对象绑定端口"><a href="#创建Socket对象绑定端口" class="headerlink" title="创建Socket对象绑定端口"></a>创建Socket对象绑定端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (int)setupSocket&#123;</div><div class="line">    </div><div class="line">    int bRet = 0;</div><div class="line">    </div><div class="line">    CFSocketContext sockContext = &#123;0, // 结构体的版本，必须为0</div><div class="line">        (__bridge void *)(self),</div><div class="line">        NULL, // 一个定义在上面指针中的retain的回调， 可以为NULL</div><div class="line">        NULL,</div><div class="line">        NULL&#125;;</div><div class="line">    </div><div class="line">    _mSocket = CFSocketCreate(kCFAllocatorDefault, PF_INET, SOCK_STREAM, IPPROTO_TCP, kCFSocketAcceptCallBack, serverAcceptCallBack, &amp;sockContext);</div><div class="line">    if (NULL == _mSocket) &#123;</div><div class="line">        NSLog(@&quot;Cannot create socket!&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int optval = 1;</div><div class="line">    setsockopt(CFSocketGetNative(_mSocket), SOL_SOCKET, SO_REUSEADDR, // 允许重用本地地址和端口</div><div class="line">               (void *)&amp;optval, sizeof(optval));</div><div class="line">    struct sockaddr_in addr4;</div><div class="line">    memset(&amp;addr4, 0, sizeof(addr4));</div><div class="line">    addr4.sin_len = sizeof(addr4);</div><div class="line">    addr4.sin_family = AF_INET;</div><div class="line">    addr4.sin_port = htons(6666);</div><div class="line">    addr4.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line">    CFDataRef address = CFDataCreate(kCFAllocatorDefault, (UInt8 *)&amp;addr4, sizeof(addr4));</div><div class="line">    </div><div class="line">    if (kCFSocketSuccess != CFSocketSetAddress(_mSocket, address))</div><div class="line">    &#123;</div><div class="line">        NSLog(@&quot;Bind to address failed!&quot;);</div><div class="line">        if (_mSocket)</div><div class="line">            CFRelease(_mSocket);</div><div class="line">        _mSocket = NULL;</div><div class="line">        bRet = 0;</div><div class="line">        return bRet;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CFRunLoopRef cfRunLoop = CFRunLoopGetCurrent();</div><div class="line">    CFRunLoopSourceRef source = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _mSocket, 0);</div><div class="line">    CFRunLoopAddSource(cfRunLoop, source, kCFRunLoopCommonModes);</div><div class="line">    CFRelease(source);</div><div class="line"></div><div class="line">    bRet = 1;</div><div class="line">    </div><div class="line">    return bRet;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和Client相比多了一个setsockopt的过程。</p>
<h4 id="Accept回调处理"><a href="#Accept回调处理" class="headerlink" title="Accept回调处理"></a>Accept回调处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">if (type == kCFSocketAcceptCallBack) &#123;</div><div class="line">     </div><div class="line">        // 本地套接字句柄</div><div class="line">        CFSocketNativeHandle nativeSocketHandle = *(CFSocketNativeHandle *)data;</div><div class="line">        uint8_t name[SOCK_MAXADDRLEN];</div><div class="line">        socklen_t nameLen = sizeof(name);</div><div class="line">        if (0 != getpeername(nativeSocketHandle, (struct sockaddr *)name, &amp;nameLen)) &#123;</div><div class="line">            NSLog(@&quot;error&quot;);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        CFReadStreamRef iStream;</div><div class="line">        CFWriteStreamRef oStream;</div><div class="line">        // 创建一个可读写的socket连接</div><div class="line">        CFStreamCreatePairWithSocket(kCFAllocatorDefault, nativeSocketHandle, &amp;iStream, &amp;oStream);</div><div class="line">        if (iStream &amp;&amp; oStream)</div><div class="line">        &#123;</div><div class="line">            CFStreamClientContext streamContext = &#123;0, info, NULL, NULL&#125;;</div><div class="line">            if (!CFReadStreamSetClient(iStream, kCFStreamEventHasBytesAvailable,readStream, &amp;streamContext))</div><div class="line">            &#123;</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (!CFWriteStreamSetClient(oStream, kCFStreamEventCanAcceptBytes, writeStream, &amp;streamContext))</div><div class="line">            &#123;</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">            CFReadStreamScheduleWithRunLoop(iStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</div><div class="line">            CFWriteStreamScheduleWithRunLoop(oStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</div><div class="line">            CFReadStreamOpen(iStream);</div><div class="line">            CFWriteStreamOpen(oStream);</div><div class="line">        &#125; else</div><div class="line">        &#123;</div><div class="line">            close(nativeSocketHandle);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>创建一个可读写的Socket连接，当接收或者发送数据时，都会走到回调接口中。</p>
<p>读数据回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 读取数据</div><div class="line">void readStream(CFReadStreamRef stream, CFStreamEventType eventType, void *clientCallBackInfo)</div><div class="line">&#123;</div><div class="line">    UInt8 buff[255];</div><div class="line">    CFReadStreamRead(stream, buff, 255);</div><div class="line">    ///根据delegate显示到主界面去</div><div class="line">    NSString *strMsg = [[NSString alloc]initWithFormat:@&quot;客户端传来消息：%s&quot;,buff];</div><div class="line">    ViewController *mSelf = (__bridge ViewController*)clientCallBackInfo;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [mSelf ShowMsg:strMsg];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写数据回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void writeStream (CFWriteStreamRef stream, CFStreamEventType eventType, void *clientCallBackInfo)</div><div class="line">&#123;</div><div class="line">    outputStream = stream;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>保存当前写数据的实例。</p>
<h4 id="发送数据-1"><a href="#发送数据-1" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (IBAction)sendMessage:(id)sender &#123;</div><div class="line">    </div><div class="line">    const char *str = [self.sendTextField.stringValue UTF8String];</div><div class="line">    uint8_t *sendS = (uint8_t *)str;</div><div class="line">    if (outputStream != NULL) &#123;</div><div class="line">        CFWriteStreamWrite(outputStream, sendS, strlen(str) + 1);</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        NSLog(@&quot;send failed&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通信过程如下图：<br><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/Socket/socketclient%26server.png" alt=""></p>
<p><a href="https://github.com/lilingyu0620/LLYSocketDemo.git" target="_blank" rel="noopener">iOS Socket Demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/DNS解析学习笔记/" itemprop="url">
                  DNS解析学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-01T17:57:48+08:00" content="2017-04-01">
              2017-04-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/01/DNS解析学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/01/DNS解析学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h3><p>Internet上的计算机是通过IP地址来定位的，给出一个IP地址，就可以找到Internet上的某台主机。而因为IP地址难于记忆，又发明了域名来代替IP地址。但通过域名并不能直接找到要访问的主机，中间要加一个从域名查找IP地址的过程，这个过程就是域名解析。</p>
<p>负责将域名解析成为IP地址的服务器，叫做域名解析服务器，英文简称是DNS。Internet上所有的DNS通过域的层次关系连接在一起。</p>
<p>当Internet用户打开浏览器，输入一个网址的时候，比如<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 用户的计算机并不知道www.google.com是哪一台主机，因此计算机向Internet的DNS发出查询请求，DNS将查询到的IP地址返回给用户的计算机，用户计算机就可以根据IP地址连接www.google.com主机，把网页下载下来。</p>
<h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3><h4 id="根域"><a href="#根域" class="headerlink" title="根域"></a>根域</h4><p>就是所谓的“.”，其实我们的网址www.google.com在配置当中应该是www.google.com.（最后有一点），一般我们在浏览器里输入时会省略后面的点，而这也已经成为了习惯。</p>
<p>根域服务器我们知道有13台，但是这是错误的观点。</p>
<p>根域服务器只是具有13个IP地址，但机器数量却不是13台，因为这些IP地址借助了任播的技术，所以我们可以在全球设立这些IP的镜像站点，你访问到的这个IP并不是唯一的那台主机。</p>
<h4 id="域的划分"><a href="#域的划分" class="headerlink" title="域的划分"></a>域的划分</h4><p>根域下面就是顶级域或者叫一级域.</p>
<p>有两种划分方式，一种互联网刚兴起时的按照行业性质划分的com. net.等，一种是按国家划分的如cn. jp.等。</p>
<p>每个域都会有域名服务器，也叫权威域名服务器。</p>
<p>google.com就是一个顶级域名，而www.google.com却不是顶级域名，是在google.com这个域里的一叫做www的主机。</p>
<p>一级域之后还有二级域，三级域，只要我买了一个顶级域，并且我搭建了自己BIND服务器（或者其他软件搭建的）注册到互联网中，那么我就可以随意在前面多加几个域了（当然长度是有限制的）。</p>
<p>比如lly.www.google.com，在这个网址中，www.google.com变成了一个二级域而不是一台主机，主机名是lly。</p>
<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>能提供域名解析的服务器，上面的记录类型可以是A(address)记录，NS记录（name server），MX（mail），CNAME等。</p>
<p>A记录是什么意思呢，就是记录一个IP地址和一个主机名字，比如我这个域名服务器所在的域test.google.com，我们知道这是一个二级的域名，然后我在里面有一条A记录,记录了主机为lly的IP，查到了就返回给你了。</p>
<p>如果我现在要想google.com这个域名服务器查询lly.test.google.com，那么这个顶级域名服务器就会发现你请求的这个网址在test.google.com这个域中，我这里记录了这个二级域的域名服务器test.google.com的NS的IP。我返回给你这个地址你再去查主机名为lly的主机。</p>
<h3 id="DNS解析原理"><a href="#DNS解析原理" class="headerlink" title="DNS解析原理"></a>DNS解析原理</h3><p>DNS解析主要有递归查询，就是在某个DNS服务器缓存中查找不到相应的域名与IP地址对应关系时，自动跳转到到下一步骤通过下一个DNS服务器进行查找。具体可见如下两图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/dns/dnsflow.jpg" alt=""></p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/dns/dnssearchflow.jpg" alt=""></p>
<h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p>以下步骤中，当DNS缓存中存在域名对应IP时则DNS解析成功，用户计算机将直接访问服务器，若DNS服务器缓存中不存在域名对应IP，则自动进入下一步。</p>
<ul>
<li>浏览器缓存</li>
</ul>
<p>当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p>
<ul>
<li>系统缓存</li>
</ul>
<p>当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；</p>
<ul>
<li>路由器缓存</li>
</ul>
<p>当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</p>
<ul>
<li>ISP（互联网服务提供商）DNS缓存</li>
</ul>
<p>当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</p>
<ul>
<li>根域名服务器</li>
</ul>
<p>当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；</p>
<ul>
<li>顶级域名服务器</li>
</ul>
<p>顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名（如google.com）服务器的IP地址告诉本地DNS服务器；</p>
<ul>
<li>主域名服务器</li>
</ul>
<p>主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器（www.google.com）进行查找，并重复该步骤直至找到正确纪录；</p>
<ul>
<li>保存结果至缓存</li>
</ul>
<p>本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p>
<h3 id="DNS优化如何实现"><a href="#DNS优化如何实现" class="headerlink" title="DNS优化如何实现"></a>DNS优化如何实现</h3><p>一般域名商或服务器商都会提供免费的DNS服务，然而，很多情况下这些免费的DNS服务器速度较慢，故可做一定优化，具体可从以下几方面：</p>
<ul>
<li>增加DNS服务器数量</li>
</ul>
<p>减小服务器压力，当单位服务器需要处理的DNS请求数量较少时速度会更快；</p>
<ul>
<li>全国多地分布DNS服务器</li>
</ul>
<p>用户网络访问速度跟用户计算机到服务器的距离有关，若可以让用户就近访问所在省份的服务器便可以加速DNS解析速度；</p>
<ul>
<li>识别用户线路反馈相应线路IP</li>
</ul>
<p>当用户网络线路跟服务器网络线路一致时速度较快，而不一致时则较慢，如：用户使用电信的线路但服务器是联通的线路，这样就会造成用户访问网站速度下降，如果可以识别用户访问线路并反馈相应IP则会加速网站访问。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/SSL-TLS协议学习笔记/" itemprop="url">
                  SSL/TLS协议学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-01T15:15:42+08:00" content="2017-04-01">
              2017-04-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/01/SSL-TLS协议学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/01/SSL-TLS协议学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTPS的安全机制，建立在SSL/TLS协议的基础上。每一次会话前，会通过SSL/TLS协议为客户端和服务器生成一个会话密钥，来进行数据的对称加密。下面来看看SSL/TLS协议的具体流程。</p>
<h3 id="SSL协议的握手过程"><a href="#SSL协议的握手过程" class="headerlink" title="SSL协议的握手过程"></a>SSL协议的握手过程</h3><p>开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。<br>假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程可以用下图说明：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ssl/sslshake.png" alt=""></p>
<p>握手阶段分成五步:</p>
<ul>
<li><p>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</p>
</li>
<li><p>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</p>
</li>
<li><p>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</p>
</li>
<li><p>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</p>
</li>
<li><p>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p>
</li>
</ul>
<p>上面的五步，画成一张图，就是下面这样:</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ssl/sslflow.png" alt=""></p>
<h4 id="客户端如何验证接收到的证书"><a href="#客户端如何验证接收到的证书" class="headerlink" title="客户端如何验证接收到的证书"></a>客户端如何验证接收到的证书</h4><p>其中第三步是最重要的，爱丽丝是如何确认鲍勃发来的数字证书有效的而不是被别人篡改的呢，先看看如何篡改证书，流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">客户端&lt;------------攻击者&lt;------------服务端</div><div class="line">        伪造证书            拦截请求</div></pre></td></tr></table></figure>
<p>为了回答这个问题，需要引入数字签名(Digital Signature)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+---------------------+</div><div class="line">| A digital signature |</div><div class="line">|(not to be confused  |</div><div class="line">|with a digital       |</div><div class="line">|certificate)         |            +---------+              +--------+</div><div class="line">| is a mathematical   |----哈希---&gt;| 消息摘要  |---私钥加密---&gt;| 数字签名 |</div><div class="line">|technique used       |            +---------+              +--------+</div><div class="line">|to validate the      |</div><div class="line">|authenticity and     |</div><div class="line">|integrity of a       |</div><div class="line">|message, software    |</div><div class="line">|or digital document. |</div><div class="line">+---------------------+</div></pre></td></tr></table></figure>
<p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名</p>
<p>假设消息传递在Bob，Susan和Pat三人之间发生。Susan将消息连同数字签名一起发送给Bob，Bob接收到消息后，可以这样验证接收到的消息就是Susan发送的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+---------------------+</div><div class="line">| A digital signature |</div><div class="line">|(not to be confused  |</div><div class="line">|with a digital       |</div><div class="line">|certificate)         |            +---------+</div><div class="line">| is a mathematical   |----哈希---&gt;|  消息摘要 |</div><div class="line">|technique used       |            +---------+</div><div class="line">|to validate the      |                 |</div><div class="line">|authenticity and     |                 |</div><div class="line">|integrity of a       |                 |</div><div class="line">|message, software    |                 对</div><div class="line">|or digital document. |                 比</div><div class="line">+---------------------+                 |</div><div class="line">                                        |</div><div class="line">                                        |</div><div class="line">          +--------+               +---------+</div><div class="line">          | 数字签名 |---公钥解密---&gt;|  消息摘要 |</div><div class="line">          +--------+               +---------+</div></pre></td></tr></table></figure>
<p>当然，这个前提是Bob知道Susan的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Bob。</p>
<p>此时就引入了证书颁发机构（Certificate Authority，简称CA），CA数量并不多，Bob客户端内置了所有受信任CA的证书。CA对Susan的公钥（和其他信息）数字签名后生成证书。</p>
<p>Susan将证书发送给Bob后，Bob通过CA证书的公钥验证证书签名。</p>
<p>事实上，Bob客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ssl/digitalca.png" alt=""></p>
<p><a href="https://cattail.me/tech/2015/11/30/how-https-works.html" target="_blank" rel="noopener">扩展链接-HTTPS工作原理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/iOS-Runtime-动态消息解析和消息转发机制/" itemprop="url">
                  iOS Runtime-动态消息解析和消息转发机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-01T10:29:00+08:00" content="2017-04-01">
              2017-04-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/01/iOS-Runtime-动态消息解析和消息转发机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/01/iOS-Runtime-动态消息解析和消息转发机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h3><p>你可以动态地提供一个方法的实现。例如我们可以用@dynamic关键字在类的实现文件中修饰一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure>
<p>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成setPropertyName:和propertyName方法，而需要我们自己实现或者动态提供。</p>
<p>我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。</p>
<p>我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</div><div class="line">    // implementation ....</div><div class="line">&#125;</div><div class="line">@implementation MyClass</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</div><div class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</div><div class="line">          return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数.</p>
<p>PS：动态方法解析会在消息转发机制浸入前执行。如果 respondsToSelector: 或 instancesRespondToSelector:方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的IMP的机会。如果你想让该方法选择器被传送到转发机制，那么就让resolveInstanceMethod:返回NO。</p>
<h4 id="实例方法和类方法的解析对比"><a href="#实例方法和类方法的解析对比" class="headerlink" title="实例方法和类方法的解析对比"></a>实例方法和类方法的解析对比</h4><p>.h文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Student : NSObject</div><div class="line">+ (void)learnClass:(NSString *) string;</div><div class="line">- (void)goToSchool:(NSString *) name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>.m文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;Student.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation Student</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</div><div class="line">    if (sel == @selector(learnClass:)) &#123;</div><div class="line">        class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(myClassMethod:)), &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [class_getSuperclass(self) resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if (aSEL == @selector(goToSchool:)) &#123;</div><div class="line">        class_addMethod([self class], aSEL, class_getMethodImplementation([self class], @selector(myInstanceMethod:)), &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)myClassMethod:(NSString *)string &#123;</div><div class="line">    NSLog(@&quot;myClassMethod = %@&quot;, string);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)myInstanceMethod:(NSString *)string &#123;</div><div class="line">    NSLog(@&quot;myInstanceMethod = %@&quot;, string);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>需要深刻理解 [self class] 与 object_getClass(self) 甚至 object_getClass([self class]) 的关系，其实并不难，重点在于 self 的类型：</p>
<ul>
<li><p>当 self 为实例对象时，[self class] 与 object_getClass(self) 等价，因为前者会调用后者。object_getClass([self class]) 得到元类。</p>
</li>
<li><p>当 self 为类对象时，[self class] 返回值为自身，还是 self。object_getClass(self) 与 object_getClass([self class]) 等价。</p>
</li>
</ul>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/runtime/runtimemessageforward.jpg" alt=""></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载- (id)forwardingTargetForSelector:(SEL)aSelector方法替换消息的接受者为其他对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    //如果代理对象能处理，则转接给代理对象</div><div class="line">    if ([proxyObj respondsToSelector:aSelector]) &#123;</div><div class="line">        return proxyObj;</div><div class="line">    &#125;</div><div class="line">    //不能处理进入转发流程</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择。 如果此方法返回nil或self,则会进入消息转发机制(forwardInvocation:);否则将向返回的对象重新发送消息。</p>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不作处理返回nil时，消息转发机制会被触发。</p>
<p>这时下面两个方法需要被重写： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//获取该方法的方法签名</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line"></div><div class="line">//手动调用该方法</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure>
<p>ps: 如果 methodSignatureForSelector 返回的NSMethodSignature 是 nil 的话不会继续执行 forwardInvocation，转发流程终止，抛出无法处理的异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature *sig = [BBMessageForwardProxy instanceMethodSignatureForSelector:@selector(bb_dealNotRecognizedMessage:)];</div><div class="line">    return sig;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    NSString *debugInfo = [NSString stringWithFormat:@&quot;[debug]unRecognizedMessage:[%@] sent to [%@]&quot;,NSStringFromSelector(anInvocation.selector),NSStringFromClass([self class])];</div><div class="line">    //重定向方法</div><div class="line">    [anInvocation setSelector:@selector(bb_dealNotRecognizedMessage:)];</div><div class="line">    //传递调用信息</div><div class="line">    [anInvocation setArgument:&amp;debugInfo atIndex:2];</div><div class="line">    //BBMessageForwardProxy对象接收转发的消息并打印调用信息</div><div class="line">    [anInvocation invokeWithTarget:[BBMessageForwardProxy new]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>forwardInvocation:方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>ps：forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有negotiate方法。否则，forwardInvocation:将不可能会被调用。</p>
<p>至此 消息的整个转发过程结束。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/31/HTTP协议学习笔记/" itemprop="url">
                  HTTP协议学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-31T14:26:11+08:00" content="2017-03-31">
              2017-03-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/31/HTTP协议学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/31/HTTP协议学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h3><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p>
<h3 id="客户端和服务器如何通信呢"><a href="#客户端和服务器如何通信呢" class="headerlink" title="客户端和服务器如何通信呢"></a>客户端和服务器如何通信呢</h3><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p>
<p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页。</p>
<p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。</p>
<p>代理服务器就是网络信息的中转站，有什么功能呢？</p>
<ol>
<li><p>提高访问速度， 大多数的代理服务器都有缓存功能。</p>
</li>
<li><p>突破限制， 也就是FQ了</p>
</li>
<li><p>隐藏身份。</p>
</li>
</ol>
<h3 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a>URL详解</h3><p>URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scheme://host[:port#]/path/.../[?query-string][#anchor]</div></pre></td></tr></table></figure>
<p>scheme               指定低层使用的协议(例如：http, https, ftp)</p>
<p>host                   HTTP服务器的IP地址或者域名</p>
<p>port#                 HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="noopener">http://www.cnblogs.com:8080/</a></p>
<p>path                   访问资源的路径</p>
<p>query-string       发送给http服务器的数据</p>
<p>anchor-             锚</p>
<h4 id="URL-的一个例子"><a href="#URL-的一个例子" class="headerlink" title="URL 的一个例子"></a>URL 的一个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</div><div class="line"></div><div class="line">Schema:                 http</div><div class="line">host:                   www.mywebsite.com</div><div class="line">path:                   /sj/test/test.aspx</div><div class="line">Query String:           name=sviergn&amp;x=true</div><div class="line">Anchor:                 stuff</div></pre></td></tr></table></figure>
<h3 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h3><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p>
<h3 id="打开一个网页需要浏览器发送很多次Request"><a href="#打开一个网页需要浏览器发送很多次Request" class="headerlink" title="打开一个网页需要浏览器发送很多次Request"></a>打开一个网页需要浏览器发送很多次Request</h3><ol>
<li><p>当你在浏览器输入URL <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的html.  服务器把Response发送回给浏览器.</p>
</li>
<li><p>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</p>
</li>
<li><p>浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</p>
</li>
<li><p>等所有的文件都下载成功后。 网页就被显示出来了。</p>
</li>
</ol>
<h3 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a>HTTP消息的结构</h3><h4 id="Request消息的结构"><a href="#Request消息的结构" class="headerlink" title="Request消息的结构"></a>Request消息的结构</h4><p> Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图<br> <img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/http/httprequest.png" alt=""></p>
<p> 第一行中的Method表示请求方法,比如”POST”,”GET”,  Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号</p>
<p>当使用的是”GET” 方法的时候， body是为空的.</p>
<h4 id="Response消息结构"><a href="#Response消息结构" class="headerlink" title="Response消息结构"></a>Response消息结构</h4><p>和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图<br><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/http/httpresponse.png" alt=""></p>
<p>HTTP/version-number表示HTTP协议的版本号，  status-code 和message 请看下节[状态代码]的详细解释.</p>
<h3 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a>Get和Post方法的区别</h3><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。</p>
<p>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<ol>
<li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</p>
</li>
<li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>
</li>
<li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>
</li>
<li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>
</li>
</ol>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p>
<p>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
<p>1XX  提示信息 - 表示请求已被成功接收，继续处理</p>
<p>2XX  成功 - 表示请求已被成功接收，理解，接受</p>
<p>3XX  重定向 - 要完成请求必须进行更进一步的处理</p>
<p>4XX  客户端错误 -  请求有语法错误或请求无法实现</p>
<p>5XX  服务器端错误 -   服务器未能实现合法的请求</p>
<h4 id="常见的一些状态码"><a href="#常见的一些状态码" class="headerlink" title="常见的一些状态码:"></a>常见的一些状态码:</h4><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p>
<h5 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h5><p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p>
<h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>代表上次的文档已经被缓存了， 还可以继续使用</p>
<h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><p>客户端请求与语法错误，不能被服务器所理解</p>
<h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>服务器收到请求，但是拒绝提供服务</p>
<h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>请求资源不存在（输错了URL）</p>
<h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>服务器发生了不可预期的错误</p>
<h5 id="503-Server-Unavailable"><a href="#503-Server-Unavailable" class="headerlink" title="503 Server Unavailable"></a>503 Server Unavailable</h5><p>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h3 id="HTTP-Request-header"><a href="#HTTP-Request-header" class="headerlink" title="HTTP Request header"></a>HTTP Request header</h3><p>get请求：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/http/getheader.png" alt=""></p>
<p>post请求:</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/http/postheader.png" alt=""></p>
<h4 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a>Cache 头域</h4><p>这个好像只在web中使用</p>
<h5 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h5><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p>
<p>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p>
<p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
<p>Cache-Control:Private     内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache  所有内容都不会被缓存</p>
<h4 id="Client头域"><a href="#Client头域" class="headerlink" title="Client头域"></a>Client头域</h4><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p>作用： 浏览器端可以接受的媒体类型,</p>
<p>例如：  Accept: text/html  代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,</p>
<p>如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)</p>
<p>通配符 * 代表任意类型</p>
<p>例如  Accept: <em>/</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p>
<h5 id="Accept-Encoding："><a href="#Accept-Encoding：" class="headerlink" title="Accept-Encoding："></a>Accept-Encoding：</h5><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p>
<p>例如： Accept-Encoding: gzip, deflate</p>
<h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p>作用： 浏览器申明自己接收的语言。 </p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p>
<p>例如： Accept-Language: zh-Hans-CN;q=1, en-CN;q=0.9</p>
<h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>
<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p>
<p>例如：FocusLive/1.1.1.t (iPhone; iOS 10.0.2; Scale/2.00)</p>
<h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>该请求是否一致保持连接</p>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<p>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h5><p>请求者的身份识别</p>
<p>作用： 最重要的header, 将cookie的值发送给HTTP服务器</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">44</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
