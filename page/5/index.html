<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="耿直的一Boy">
<meta property="og:type" content="website">
<meta property="og:title" content="lly&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="lly&#39;s Blog">
<meta property="og:description" content="耿直的一Boy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lly&#39;s Blog">
<meta name="twitter:description" content="耿直的一Boy">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/5/"/>

  <title> lly's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lly's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用心记录点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/28/AudioQueue学习笔记和实战/" itemprop="url">
                  AudioQueue学习笔记和实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-28T12:09:55+08:00" content="2018-04-28">
              2018-04-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/28/AudioQueue学习笔记和实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/28/AudioQueue学习笔记和实战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioQueue理论学习"><a href="#AudioQueue理论学习" class="headerlink" title="AudioQueue理论学习"></a>AudioQueue理论学习</h3><p>AudioQueue是iOS提供的又一套实现音频播放和录制的框架，怎么说呢，使用起来其实也不比AduioUnit方便很多，特别是在buffer的管理上，新手理解起来还是有点费劲的，在被她折磨了一周后，现在终于把她征服了，这里做一下总结。</p>
<p>首先看一下官方给的AudioQueue工作流程图</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioQueue/audioqueue.png" alt=""></p>
<p>这里给出的是播放本地路径下的音频文件，流程总结如下：</p>
<ol>
<li>读取音频文件，在音频文件的回调中给buffers填充数据</li>
<li>将填充满的buffers给AudioQueue播放</li>
<li>AudioQueue播放完一个Buffer后,把这个buffer还给AudioQueue的回调继续填充</li>
<li>循环2和3直到音频播放完</li>
</ol>
<h4 id="主要的api"><a href="#主要的api" class="headerlink" title="主要的api:"></a>主要的api:</h4><h5 id="AudioQueueNewOutput"><a href="#AudioQueueNewOutput" class="headerlink" title="AudioQueueNewOutput"></a>AudioQueueNewOutput</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueNewOutput(const AudioStreamBasicDescription *inFormat, AudioQueueOutputCallback inCallbackProc, void *inUserData, CFRunLoopRef inCallbackRunLoop, CFStringRef inCallbackRunLoopMode, UInt32 inFlags, AudioQueueRef  _Nullable *outAQ);</div></pre></td></tr></table></figure>
<p>该方法用于创建一个用于输出音频的AudioQueue</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inFormat：该參数指明了即将播放的音频的数据格式 </li>
<li>inCallbackProc：该回调用于当AudioQueue已使用完一个缓冲区时通知用户，用户能够继续填充音频数据 </li>
<li>inUserData：由用户传入的数据指针，用于传递给回调函数 </li>
<li>inCallbackRunLoop：指明回调事件发生在哪个RunLoop之中，假设传递NULL，表示在AudioQueue所在的线程上运行该回调事件，普通情况下，传递NULL就可以。 </li>
<li>inCallbackRunLoopMode：指明回调事件发生的RunLoop的模式，传递NULL相当于kCFRunLoopCommonModes，通常情况下传递NULL就可以 </li>
<li>outAQ：该AudioQueue的引用实例，</li>
</ol>
<h5 id="AudioQueueOutput-Callback"><a href="#AudioQueueOutput-Callback" class="headerlink" title="AudioQueueOutput_Callback"></a>AudioQueueOutput_Callback</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void AudioQueueOutput_Callback(void *inClientData,AudioQueueRef inAQ,AudioQueueBufferRef inBuffer)</div></pre></td></tr></table></figure>
<p>这个是AudioQueue的回调函数，会将已经播放完的buffer还回来。</p>
<h5 id="AudioQueueAllocateBuffer"><a href="#AudioQueueAllocateBuffer" class="headerlink" title="AudioQueueAllocateBuffer"></a>AudioQueueAllocateBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueAllocateBuffer(AudioQueueRef inAQ, UInt32 inBufferByteSize, AudioQueueBufferRef  _Nullable *outBuffer);</div></pre></td></tr></table></figure>
<p>该方法的作用是为存放音频数据的缓冲区开辟空间</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inAQ：AudioQueue的引用实例 </li>
<li>inBufferByteSize：须要开辟的缓冲区的大小 </li>
<li>outBuffer：开辟的缓冲区的引用实例</li>
</ol>
<h5 id="AudioQueueEnqueueBuffer"><a href="#AudioQueueEnqueueBuffer" class="headerlink" title="AudioQueueEnqueueBuffer"></a>AudioQueueEnqueueBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueEnqueueBuffer(AudioQueueRef inAQ, AudioQueueBufferRef inBuffer, UInt32 inNumPacketDescs, const AudioStreamPacketDescription *inPacketDescs);</div></pre></td></tr></table></figure>
<p>该方法用于将已经填充数据的AudioQueueBuffer入队到AudioQueue</p>
<p>參数及返回说明例如以下： </p>
<ol>
<li>inAQ：AudioQueue的引用实例 </li>
<li>inBuffer：须要入队的缓冲区实例 </li>
<li>inNumPacketDescs：缓冲区中共存在有多少帧音频数据 </li>
<li>inPacketDescs：缓冲区中每一帧的相关信息。用户须要指明当中每一帧在缓冲区中数据的偏移值，通过字段mStartOffset来指定</li>
</ol>
<h5 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">OSStatus AudioQueueStart(AudioQueueRef inAQ, const AudioTimeStamp *inStartTime);</div><div class="line">OSStatus AudioQueuePause(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueStop(AudioQueueRef inAQ, Boolean inImmediate);</div><div class="line">OSStatus AudioQueueFlush(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueReset(AudioQueueRef inAQ);</div><div class="line">OSStatus AudioQueueDispose(AudioQueueRef inAQ, Boolean inImmediate);</div></pre></td></tr></table></figure>
<h4 id="AudioFileStream"><a href="#AudioFileStream" class="headerlink" title="AudioFileStream"></a>AudioFileStream</h4><p>数据的相关内容都和它相关，所以还是很重要的，其实AudioQueue使用起来比较简单，复杂的部分都在这个数据的处理上了。。。</p>
<h5 id="AudioFileStreamOpen"><a href="#AudioFileStreamOpen" class="headerlink" title="AudioFileStreamOpen"></a>AudioFileStreamOpen</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//        AudioFileStreamOpen的参数说明如下：</div><div class="line">//        1. inClientData：用户指定的数据，用于传递给回调函数，这里我们指定(__bridge LocalAudioPlayer*)self</div><div class="line">//        2. inPropertyListenerProc：当解析到一个音频信息时，将回调该方法</div><div class="line">//        3. inPacketsProc：当解析到一个音频帧时，将回调该方法</div><div class="line">//        4. inFileTypeHint：指明音频数据的格式，如果你不知道音频数据的格式，可以传0</div><div class="line">//        5. outAudioFileStream：AudioFileStreamID实例，需保存供后续使用</div><div class="line"></div><div class="line">AudioFileStreamOpen (		void * __nullable						inClientData,</div><div class="line">							AudioFileStream_PropertyListenerProc	inPropertyListenerProc,</div><div class="line">							AudioFileStream_PacketsProc				inPacketsProc,</div><div class="line">                			AudioFileTypeID							inFileTypeHint,</div><div class="line">                			AudioFileStreamID __nullable * __nonnull outAudioFileStream)</div></pre></td></tr></table></figure>
<p>这个函数会创建一个AudioFileStreamID,之后所有的操作都是基于这个ID来的，然后还是创建2个回调 inPropertyListenerProc 和 inPacketsProc，这2个回调函数比较重要，下面详说。</p>
<h5 id="AudioFileStreamParseBytes"><a href="#AudioFileStreamParseBytes" class="headerlink" title="AudioFileStreamParseBytes"></a>AudioFileStreamParseBytes</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//        参数的说明如下：</div><div class="line">//        1. inAudioFileStream：AudioFileStreamID实例，由AudioFileStreamOpen打开</div><div class="line">//        2. inDataByteSize：此次解析的数据字节大小</div><div class="line">//        3. inData：此次解析的数据大小</div><div class="line">//        4. inFlags：数据解析标志，其中只有一个值kAudioFileStreamParseFlag_Discontinuity = 1，表示解析的数据是否是不连续的，目前我们可以传0。</div><div class="line"></div><div class="line"></div><div class="line">AudioFileStreamParseBytes(	</div><div class="line">								AudioFileStreamID				inAudioFileStream,</div><div class="line">								UInt32							inDataByteSize,</div><div class="line">								const void * __nullable			inData,</div><div class="line">								AudioFileStreamParseFlags		inFlags)</div></pre></td></tr></table></figure>
<p>只有对数据进行了解析，才会进到上面的2个回调函数里面。</p>
<h5 id="AudioFileStreamPropertyListenerProc"><a href="#AudioFileStreamPropertyListenerProc" class="headerlink" title="AudioFileStreamPropertyListenerProc"></a>AudioFileStreamPropertyListenerProc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void AudioFileStreamPropertyListenerProc(void *inClientData,</div><div class="line">                                         AudioFileStreamID inAudioFileStream,</div><div class="line">                                         AudioFileStreamPropertyID inPropertyID,</div><div class="line">                                         UInt32 *ioFlags)</div></pre></td></tr></table></figure>
<p>在这个回调中，你可以拿到你想要的音频相关信息，比如音频结构（AudioStreamBasicDescription），码率（BitRate），MagicCookie等等，通过这些信息，你还可以计算其他数据，比如音频总时长。</p>
<p>这里分享下音频时长的2种计算方式：</p>
<ul>
<li><p>总时长 = 总帧数*单帧的时长</p>
<p>  单帧的时长 = 单帧的采样个数*每帧的时长</p>
<p>  每帧的时长 = 1/采样率</p>
</li>
</ul>
<p><strong>采样率：单位时间内的采样个数</strong></p>
<ul>
<li>总时长 = 文件总的字节数/码率</li>
</ul>
<p><strong>码率：单位时间内的文件字节数</strong></p>
<h5 id="AudioFileStreamPacketsProc"><a href="#AudioFileStreamPacketsProc" class="headerlink" title="AudioFileStreamPacketsProc"></a>AudioFileStreamPacketsProc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void AudioFileStreamPacketsProc(void *inClientData,</div><div class="line">                                UInt32 inNumberBytes,</div><div class="line">                                UInt32 inNumberPackets,</div><div class="line">                                const void *inInputData,</div><div class="line">                                AudioStreamPacketDescription *inPacketDescriptions)</div></pre></td></tr></table></figure>
<p>在这个回调中，你能够拿到每一个packet的数据，然后数据的填充都在这里完成。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>这里只讲几个比较重要的细节，其他的可以参考demo中的代码。</p>
<ol>
<li>AudioQueueNewOutput在创建的时候有2个runloop相关的参数，这里直接传NULL就行，不要取当前的runloop和model</li>
<li>AudioQueueOutput_Callback里面在标记可使用的buffer时要加锁，不然音频无法正常播放</li>
<li>记得设置AVAudioSession的category</li>
<li>读取音频数据时使用while循环，比使用计时器优雅</li>
<li>kAudioFileStreamProperty_DataFormat这个属性是必须要获取到的，在创建AudioQueue的时候需要传入</li>
<li>填装数据的时候要判断对当前buffer的可用填装空间，如果装不下了就别再装啦。。。</li>
<li>AudioQueueEnqueueBuffer给AudioQueue塞完数据后，需要判断下一个buffer是否可用，不可用的话得一直等着，知道可用为止。</li>
</ol>
<p><a href="https://github.com/lilingyu0620/LLYAudioUnitPlayer.git" target="_blank" rel="noopener">demo</a></p>
<p><a href="http://www.cnblogs.com/llguanli/p/8453133.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/16/AudioUnit实战/" itemprop="url">
                  AudioUnit实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-16T14:33:25+08:00" content="2018-04-16">
              2018-04-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/16/AudioUnit实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/16/AudioUnit实战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面学习了AudioUnit相关理论姿势，现在结合实际demo继续深入学习一下。。。</p>
<h3 id="AudioUnit–播放本地音频"><a href="#AudioUnit–播放本地音频" class="headerlink" title="AudioUnit–播放本地音频"></a>AudioUnit–播放本地音频</h3><p>因为AudioUnit只支持PCM文件，所以这里我们先使用一个本地的PCM文件进行播放，后续会有播放其他格式文件的demo,需要用到转码的相关API。</p>
<p>这里我们使用<strong>NSInputStream</strong>直接读取音频文件，因为不需要转码，所以读取到的数据就是可以直接拿来播放的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSInputStream *inputStream;</div><div class="line"> 	NSURL *url = [NSURL fileURLWithPath:self.pcmPath];</div><div class="line">   inputStream = [NSInputStream inputStreamWithURL:url];</div><div class="line">   if (!inputStream) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败!!!!%@&quot;,url);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">       [inputStream open];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>初始化AudioUnit相关内容前，我们需要全局设置一下<strong>AVAudioSession</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//设置audiosession</div><div class="line"></div><div class="line">   NSError *error = nil;   </div><div class="line">   AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;error];</div></pre></td></tr></table></figure>
<p>然后可以开始初始化AudioUnit，这里我们需要的是Output type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   AudioUnit playerAudioUnit;</div><div class="line"></div><div class="line">//AU描述</div><div class="line">   AudioComponentDescription audioUnitDesc;</div><div class="line">   audioUnitDesc.componentType = kAudioUnitType_Output;</div><div class="line">   audioUnitDesc.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">   audioUnitDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">   audioUnitDesc.componentFlags = 0;</div><div class="line">   audioUnitDesc.componentFlagsMask = 0;</div><div class="line">   </div><div class="line">   //AudioUnit裸创建</div><div class="line">   AudioComponent audioComponent = AudioComponentFindNext(NULL, &amp;audioUnitDesc);</div><div class="line">   AudioComponentInstanceNew(audioComponent, &amp;playerAudioUnit);</div></pre></td></tr></table></figure>
<p>接下来有一个<strong>kAudioOutputUnitProperty_EnableIO</strong>属性的设置，这里如果只是播放功能的话，实际上是不需要设置的，因为AudioUnit默认就是支持播放的，如果需要输入功能（比如录音）时，就必须设置这个属性，之后的demo会有使用，这里我们先不设置这个属性，设置的相关格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//通用参数设置,这里是设置扬声器</div><div class="line">  OSStatus status = noErr;</div><div class="line">  UInt32 flag = 1;</div><div class="line">  UInt32 outputBus = 0;//Element 0</div><div class="line">  status = AudioUnitSetProperty(playerAudioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, outputBus, &amp;flag, sizeof(flag));</div><div class="line">  if (status) &#123;</div><div class="line">      NSLog(@&quot;AudioUnitSetProperty error with status:%d&quot;, status);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后我们需要设置AudioUnit的播放音频的格式，这里一般都是PCM格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//设置音频具体结构</div><div class="line">   AudioStreamBasicDescription audioStreamDesc;</div><div class="line">//    bzero(&amp;audioStreamDesc, sizeof(audioStreamDesc));</div><div class="line">   memset(&amp;audioStreamDesc, 0, sizeof(audioStreamDesc));</div><div class="line">   audioStreamDesc.mFormatID = kAudioFormatLinearPCM;</div><div class="line">   audioStreamDesc.mSampleRate = 44100;//采样率</div><div class="line">   audioStreamDesc.mChannelsPerFrame = 1;//声道数</div><div class="line">   audioStreamDesc.mFramesPerPacket = 1;//每帧只有一个packet</div><div class="line">   audioStreamDesc.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger;//kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;</div><div class="line">   audioStreamDesc.mBitsPerChannel = 16;//位深</div><div class="line">   audioStreamDesc.mBytesPerFrame = 2;</div><div class="line">   audioStreamDesc.mBytesPerPacket = 2;</div><div class="line"></div><div class="line">//这里是设置的输出音频的格式</div><div class="line">   status = AudioUnitSetProperty(playerAudioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, outputBus, &amp;audioStreamDesc,sizeof(audioStreamDesc));</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;AudioUnitSetProperty error with status:%d&quot;, status);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>最后设置一下输出的回调，这个回调是每次扬声器需要播放数据时都会调一次这个回调，然后我们在这个回调里面把要播放的数据塞给扬声器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">	//callback</div><div class="line">    AURenderCallbackStruct callbackStruct;</div><div class="line">    callbackStruct.inputProc = PlayCallback;</div><div class="line">    callbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">    AudioUnitSetProperty(playerAudioUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, outputBus, &amp;callbackStruct, sizeof(callbackStruct));</div><div class="line"></div><div class="line">	//最后初始化AudioUnit</div><div class="line">    OSStatus result = AudioUnitInitialize(playerAudioUnit);</div><div class="line">    NSLog(@&quot;result = %d&quot;,result);</div><div class="line">    </div><div class="line">    //回调实现</div><div class="line">    static OSStatus PlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line"></div><div class="line">    __unsafe_unretained LLYAudioUnitPlayer *play = (__bridge LLYAudioUnitPlayer *)inRefCon;</div><div class="line"></div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;out size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line"></div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就可以开始播放音频了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)play&#123;</div><div class="line">    </div><div class="line">    [self initAudioUnit];</div><div class="line">    </div><div class="line">    AudioOutputUnitStart(playerAudioUnit);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stop&#123;</div><div class="line">    </div><div class="line">    AudioOutputUnitStop(playerAudioUnit);</div><div class="line">    [inputStream close];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AudioUnit–录音-播放-保存本地"><a href="#AudioUnit–录音-播放-保存本地" class="headerlink" title="AudioUnit–录音+播放+保存本地"></a>AudioUnit–录音+播放+保存本地</h3><p>这个demo做的事情是把本地播放的音频和录制的音频一起输出并写入文件。播放音频部分和上面的流程一样，这里主要说一下录制音频部分的流程。</p>
<p>AVAudioSession的设置，这里我们需要用到录音功能，同时我们还需要设置一下采样频率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//设置AVAudioSession</div><div class="line">   [[AVAudioSession sharedInstance]setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;error];</div><div class="line">   if (error) &#123;</div><div class="line">       NSLog(@&quot;setCategory error %@&quot;,error);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   [[AVAudioSession sharedInstance] setPreferredIOBufferDuration:0.05 error:&amp;error];</div><div class="line">   if (error) &#123;</div><div class="line">       NSLog(@&quot;setPreferredIOBufferDuration error:%@&quot;, error);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们使用AudioBufferList 这个数据结构来保存获取到的录音音频数据，先对该数据结构做一个初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">AudioBufferList *bufferList;</div><div class="line"></div><div class="line">// buffer list</div><div class="line">uint32_t numberBuffers = 2;</div><div class="line">bufferList = (AudioBufferList *)malloc(sizeof(AudioBufferList) + (numberBuffers - 1) * sizeof(AudioBuffer));</div><div class="line">bufferList-&gt;mNumberBuffers = numberBuffers;</div><div class="line">bufferList-&gt;mBuffers[0].mNumberChannels = 1;</div><div class="line">bufferList-&gt;mBuffers[0].mDataByteSize = BUFFERSIZE;</div><div class="line">bufferList-&gt;mBuffers[0].mData = malloc(BUFFERSIZE);</div><div class="line"></div><div class="line">for (int i =1; i &lt; numberBuffers; ++i) &#123;</div><div class="line">    bufferList-&gt;mBuffers[i].mNumberChannels = 1;</div><div class="line">    bufferList-&gt;mBuffers[i].mDataByteSize = BUFFERSIZE;</div><div class="line">    bufferList-&gt;mBuffers[i].mData = malloc(BUFFERSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着上个demo的代码，这里我们再设置一下输入的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AudioStreamBasicDescription outputFormat = inputFormat;</div><div class="line">   outputFormat.mChannelsPerFrame = 2;</div><div class="line">   status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                 kAudioUnitProperty_StreamFormat,</div><div class="line">                                 kAudioUnitScope_Input,</div><div class="line">                                 OUTPUT_BUS,</div><div class="line">                                 &amp;outputFormat,</div><div class="line">                                 sizeof(outputFormat));</div><div class="line">   </div><div class="line">   if (status != noErr) &#123;</div><div class="line">       NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后我们需要设置AudioUnit的输入能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// enable record</div><div class="line">  UInt32 flag = 1;</div><div class="line">  status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                kAudioOutputUnitProperty_EnableIO,</div><div class="line">                                kAudioUnitScope_Input,</div><div class="line">                                INPUT_BUS,</div><div class="line">                                &amp;flag,</div><div class="line">                                sizeof(flag));</div><div class="line">  if (status != noErr) &#123;</div><div class="line">      NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>之后设置一下录音的回调，在回调中获取录音的音频数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    // set callback</div><div class="line">    AURenderCallbackStruct recordCallback;</div><div class="line">    recordCallback.inputProc = RecordCallback;</div><div class="line">    recordCallback.inputProcRefCon = (__bridge void *)self;</div><div class="line">    status = AudioUnitSetProperty(recordAudioUnit,</div><div class="line">                                  kAudioOutputUnitProperty_SetInputCallback,</div><div class="line">                                  kAudioUnitScope_Output,</div><div class="line">                                  INPUT_BUS,</div><div class="line">                                  &amp;recordCallback,</div><div class="line">                                  sizeof(recordCallback));</div><div class="line">    if (status != noErr) &#123;</div><div class="line">        NSLog(@&quot;AudioUnitGetProperty error, ret: %d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    #pragma mark - callback</div><div class="line">    </div><div class="line">static OSStatus RecordCallback(void *inRefCon,</div><div class="line">                               AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                               const AudioTimeStamp *inTimeStamp,</div><div class="line">                               UInt32 inBusNumber,</div><div class="line">                               UInt32 inNumberFrames,</div><div class="line">                               AudioBufferList *ioData)</div><div class="line">&#123;</div><div class="line">    LLYAudioUnitRecord *record = (__bridge LLYAudioUnitRecord *)inRefCon;</div><div class="line">    record-&gt;bufferList-&gt;mNumberBuffers = 1;</div><div class="line">    OSStatus status = AudioUnitRender(record-&gt;recordAudioUnit, ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, record-&gt;bufferList);</div><div class="line">    if (status != noErr) &#123;</div><div class="line">        NSLog(@&quot;AudioUnitRender error:%d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;size1 = %d&quot;, record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    [record writePCMData:record-&gt;bufferList-&gt;mBuffers[0].mData size:record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们把录音的音频数据保存在了bufferList中。这个bufferList中的数据将被手动塞给播放的回调进行播放，播放（输出）的回调代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static OSStatus OutPlayCallback(void *inRefCon,</div><div class="line">                             AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                             const AudioTimeStamp *inTimeStamp,</div><div class="line">                             UInt32 inBusNumber,</div><div class="line">                             UInt32 inNumberFrames,</div><div class="line">                             AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitRecord *record = (__bridge LLYAudioUnitRecord *)inRefCon;</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, record-&gt;bufferList-&gt;mBuffers[0].mData, record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = record-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    NSInteger bytes = BUFFERSIZE &lt; ioData-&gt;mBuffers[1].mDataByteSize * 2 ? BUFFERSIZE : ioData-&gt;mBuffers[1].mDataByteSize * 2; //</div><div class="line">    bytes = [record-&gt;inputStream read:record-&gt;buffer maxLength:bytes];</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt; bytes; ++i) &#123;</div><div class="line">        ((Byte*)ioData-&gt;mBuffers[1].mData)[i/2] = record-&gt;buffer[i];</div><div class="line">    &#125;</div><div class="line">    ioData-&gt;mBuffers[1].mDataByteSize = (UInt32)bytes / 2;</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[1].mDataByteSize &lt; ioData-&gt;mBuffers[0].mDataByteSize) &#123;</div><div class="line">        ioData-&gt;mBuffers[0].mDataByteSize = ioData-&gt;mBuffers[1].mDataByteSize;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    NSLog(@&quot;size2 = %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们给ioData-&gt;mBuffers塞了2组数据，一组是从bufferList中获取的录音音频数据，另外一组是从inputStream中读取的本地音频数据，所以播放时既能听到本地音频也能听到我们录音的音频。</p>
<p>将音频写入文件的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)writePCMData:(Byte *)buffer size:(int)size &#123;</div><div class="line">    static FILE *file = NULL;</div><div class="line">    NSString *pathStr = [LLYAudioUnitRecord recordPath];</div><div class="line">    if (!file) &#123;</div><div class="line">        file = fopen(pathStr.UTF8String, &quot;w&quot;);</div><div class="line">    &#125;</div><div class="line">    fwrite(buffer, size, 1, file);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSString *)recordPath&#123;</div><div class="line">    return [CommonUtil documentsPath:@&quot;/record.pcm&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AudioUnit–播放MP3"><a href="#AudioUnit–播放MP3" class="headerlink" title="AudioUnit–播放MP3"></a>AudioUnit–播放MP3</h3><p>上面说过，AudioUnit是不支持直接播放MP3文件格式的，所以这里我们先把MP3转码为pcm格式然后再塞给播放回调去播放。</p>
<p>播放的逻辑我们已经很清楚了，这里我主要说一下怎么转码。这里我们用到了<strong>AudioFile</strong>和<strong>AudioConverter</strong>两个类，AudioFile主要做音频相关信息的读取，AudioConverter主要做转码的工作。</p>
<p>先来看一下AudioFile的相关代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">   AudioFileID audioFileID;</div><div class="line">   AudioStreamBasicDescription audioFileFormat;</div><div class="line">   AudioStreamPacketDescription *audioPacketFormat;</div><div class="line">   </div><div class="line">SInt64 readedPacket;</div><div class="line">   UInt64 packetNums;</div><div class="line">   UInt64 packetNumsInBuffer;</div><div class="line">   </div><div class="line">   //获取源音频的ID</div><div class="line">   NSString *mp3Path = [CommonUtil bundlePath:@&quot;abc.mp3&quot;];</div><div class="line">   NSURL *mp3Url = [NSURL fileURLWithPath:mp3Path];</div><div class="line">   OSStatus status = AudioFileOpenURL((__bridge CFURLRef)mp3Url, kAudioFileReadPermission, 0, &amp;audioFileID);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败 %@&quot;, mp3Url);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频的FileFormat</div><div class="line">   uint32_t size = sizeof(AudioStreamBasicDescription);</div><div class="line">   status = AudioFileGetProperty(audioFileID, kAudioFilePropertyDataFormat, &amp;size, &amp;audioFileFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取fileformat失败 error status %d&quot;, status);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   //获取源音频的packetnum</div><div class="line">   size = sizeof(packetNums);</div><div class="line">   status = AudioFileGetProperty(audioFileID, kAudioFilePropertyAudioDataPacketCount, &amp;size, &amp;packetNums);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取packetnum失败 error status %d&quot;, status);</div><div class="line">       return ;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频单个packet的最大buffer数</div><div class="line">   uint32_t sizePerPacket = audioFileFormat.mFramesPerPacket;</div><div class="line">   if (sizePerPacket == 0) &#123;</div><div class="line">       size = sizeof(sizePerPacket);</div><div class="line">       status = AudioFileGetProperty(audioFileID, kAudioFilePropertyMaximumPacketSize, &amp;size, &amp;sizePerPacket);</div><div class="line">       if (status) &#123;</div><div class="line">           NSLog(@&quot;获取packetmaxnum失败 error status %d&quot;, status);</div><div class="line">           return ;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取源音频的packetformat</div><div class="line">   audioPacketFormat = malloc(sizeof(AudioStreamPacketDescription) * (CONST_BUFFER_SIZE/sizePerPacket + 1));</div></pre></td></tr></table></figure>
<p>这里说一下packetnum这个属性，因为音频数据流都是以一个个packet的格式封装起来的，所以这个获取的packetnum实际上就是音频的总长度，而每个packet里面又以帧（frame）为单位做了一层封装，每个packet里面的帧数不固定。每一帧就是实际的音频数据了。</p>
<p>因为数据的处理都在播放回调中，我们来看看AudioConverter都做了哪些工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">	//上面拿到了音频的数据格式，这里用来做AudioConverter的初始化</div><div class="line">	//初始化audioconverter</div><div class="line">    status = AudioConverterNew(&amp;audioFileFormat, &amp;outputFormat, &amp;audioConverter);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;AudioConverterNew eror with status:%d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">	OSStatus ConPlayCallback(void *inRefCon,</div><div class="line">                      AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                      const AudioTimeStamp *inTimeStamp,</div><div class="line">                      UInt32 inBusNumber,</div><div class="line">                      UInt32 inNumberFrames,</div><div class="line">                      AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitConverter *converter = (__bridge LLYAudioUnitConverter *)inRefCon;</div><div class="line">    </div><div class="line">    converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize = CONST_BUFFER_SIZE;</div><div class="line">    OSStatus status = AudioConverterFillComplexBuffer(converter-&gt;audioConverter, InputDataProc, inRefCon, &amp;inNumberFrames, converter-&gt;bufferList, NULL);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;转换格式失败 %d&quot;, status);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;out size: %d&quot;, converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, converter-&gt;bufferList-&gt;mBuffers[0].mData, converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    //    fwrite(player-&gt;buffList-&gt;mBuffers[0].mData, player-&gt;buffList-&gt;mBuffers[0].mDataByteSize, 1, [player pcmFile]);</div><div class="line">    </div><div class="line">    if (converter-&gt;bufferList-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [converter onPlayEnd];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，是调用了<strong>AudioConverterFillComplexBuffer</strong>这个方法做的转码，其中第二个参数又是一个回调函数，转码后的数据同样是保存在converter-&gt;bufferList这个结构里面，然后在后面塞给ioData-&gt;mBuffers去播放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">OSStatus InputDataProc(AudioConverterRef inAudioConverter, UInt32 *ioNumberDataPackets, AudioBufferList *ioData, AudioStreamPacketDescription **outDataPacketDescription, void *inUserData)</div><div class="line">&#123;</div><div class="line">    LLYAudioUnitConverter *player = (__bridge LLYAudioUnitConverter *)(inUserData);</div><div class="line">    </div><div class="line">    UInt32 byteSize = CONST_BUFFER_SIZE;</div><div class="line">    OSStatus status = AudioFileReadPacketData(player-&gt;audioFileID, NO, &amp;byteSize, player-&gt;audioPacketFormat, player-&gt;readedPacket, ioNumberDataPackets, player-&gt;convertBuffer);</div><div class="line">    </div><div class="line">    if (outDataPacketDescription) &#123; // 这里要设置好packetFormat，否则会转码失败</div><div class="line">        *outDataPacketDescription = player-&gt;audioPacketFormat;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if(status) &#123;</div><div class="line">        NSLog(@&quot;读取文件失败&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!status &amp;&amp; ioNumberDataPackets &gt; 0) &#123;</div><div class="line">        ioData-&gt;mBuffers[0].mDataByteSize = byteSize;</div><div class="line">        ioData-&gt;mBuffers[0].mData = player-&gt;convertBuffer;</div><div class="line">        player-&gt;readedPacket += *ioNumberDataPackets;</div><div class="line">        return noErr;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return NO_MORE_DATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个回调函数主要负责读取mp3文件给上面的AudioConverterFillComplexBuffer函数用来做转码处理。</p>
<h3 id="AudioUnit–更简单的播放MP3"><a href="#AudioUnit–更简单的播放MP3" class="headerlink" title="AudioUnit–更简单的播放MP3"></a>AudioUnit–更简单的播放MP3</h3><p>上一个demo中我们使用AudioUnit播放了一个MP3文件，用到了AudioFile和AudioConverter类的相关方法，可以看到，使用这种方式播放MP3文件是比较繁琐的，我们要获取音频的很多信息，要设置回调，要使用一系列的相关api。。。下面介绍一种更简单的播放MP3的方式，使用<strong>ExtAudioFile</strong>，看名字就知道，它是上面介绍的AudioFile的扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//ExtAudioFileRef对象</div><div class="line"></div><div class="line"> ExtAudioFileRef extAudioFile;</div><div class="line">   AudioStreamBasicDescription audioFileFormat;</div><div class="line">   AudioStreamBasicDescription outputFormat;</div><div class="line">   </div><div class="line">    OSStatus status = noErr;</div><div class="line">   NSURL *mp3Url = [NSURL fileURLWithPath:[CommonUtil bundlePath:@&quot;/abc.mp3&quot;]];</div><div class="line">   status = ExtAudioFileOpenURL((__bridge CFURLRef)mp3Url, &amp;extAudioFile);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取MP3音频的格式（非必需）</div><div class="line">   uint32_t size = sizeof(AudioStreamBasicDescription);</div><div class="line">   status = ExtAudioFileGetProperty(extAudioFile, kExtAudioFileProperty_FileDataFormat, &amp;size, &amp;audioFileFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;读取音频格式失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    //initFormat 设置输出格式</div><div class="line">   memset(&amp;outputFormat, 0, sizeof(outputFormat));</div><div class="line">   outputFormat.mSampleRate       = 44100;</div><div class="line">   outputFormat.mFormatID         = kAudioFormatLinearPCM;</div><div class="line">   outputFormat.mFormatFlags      = kLinearPCMFormatFlagIsSignedInteger;</div><div class="line">   outputFormat.mBytesPerPacket   = 2;</div><div class="line">   outputFormat.mFramesPerPacket  = 1;</div><div class="line">   outputFormat.mBytesPerFrame    = 2;</div><div class="line">   outputFormat.mChannelsPerFrame = 1;</div><div class="line">   outputFormat.mBitsPerChannel   = 16;</div><div class="line">    status = ExtAudioFileSetProperty(extAudioFile, kExtAudioFileProperty_ClientDataFormat, size, &amp;outputFormat);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;设置转码音频格式失败&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //获取总长度（非必需）</div><div class="line">    size = sizeof(totalFrame);</div><div class="line">   status = ExtAudioFileGetProperty(extAudioFile, kExtAudioFileProperty_FileLengthFrames, &amp;size, &amp;totalFrame);</div><div class="line">   if (status) &#123;</div><div class="line">       NSLog(@&quot;获取音频总长度失败&quot;);</div><div class="line">   &#125;</div><div class="line">   NSLog(@&quot;音频总长度：%llu&quot;,totalFrame);</div></pre></td></tr></table></figure>
<p>AudioUnit相关的代码参考上面的几个demo. 这个必需的操作就是open file，获取到extAudioFile。然后我们看看回调里面做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">OSStatus ExtPlayCallback(void *inRefCon,</div><div class="line">                      AudioUnitRenderActionFlags *ioActionFlags,</div><div class="line">                      const AudioTimeStamp *inTimeStamp,</div><div class="line">                      UInt32 inBusNumber,</div><div class="line">                      UInt32 inNumberFrames,</div><div class="line">                      AudioBufferList *ioData) &#123;</div><div class="line">    LLYAudioUnitExtPlayer *player = (__bridge LLYAudioUnitExtPlayer *)inRefCon;</div><div class="line">    player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize = BUFFER_SIZE_CONST;</div><div class="line">    OSStatus status = ExtAudioFileRead(player-&gt;extAudioFile, &amp;inNumberFrames, player-&gt;bufferList);</div><div class="line">    NSLog(@&quot;inNumberFrames = %d&quot;,inNumberFrames);</div><div class="line">    if (status) &#123;</div><div class="line">        NSLog(@&quot;转码失败&quot;);</div><div class="line">    &#125;</div><div class="line">    if (!inNumberFrames) &#123;</div><div class="line">        NSLog(@&quot;播放结束&quot;);</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;out size : %d&quot;,player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, player-&gt;bufferList-&gt;mBuffers[0].mData, player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    player-&gt;readedFrame += player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize / player-&gt;outputFormat.mBytesPerFrame;</div><div class="line">    </div><div class="line">    NSLog(@&quot;readedFrame = %d&quot;,player-&gt;readedFrame);</div><div class="line">    </div><div class="line">    if (player-&gt;bufferList-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [player onPlayEnd];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只调用了一个<strong>ExtAudioFileRead</strong>方法，就把MP3文件转成了pcm文件存到了player-&gt;bufferList中，最终塞给ioData-&gt;mBuffers去播放即可。是不是比上面demo要简单很多呢。</p>
<h3 id="AudioUnit–使用AUGraph播放伴奏-录音"><a href="#AudioUnit–使用AUGraph播放伴奏-录音" class="headerlink" title="AudioUnit–使用AUGraph播放伴奏+录音"></a>AudioUnit–使用AUGraph播放伴奏+录音</h3><p>前面都是直接使用AudioUnit实现播放，录音相关工作，这一小节我们来学习一下使用AUGraph管理AudioUnit，当你需要多个AudioUnit来实现不同的模块，且各模块的输入输出直接又有相关联时，使用AUGraph是比较好的选择，因为它可以为AudioUnit之间建立连接，直接进行数据传递，省去了我们手动传递数据的麻烦。</p>
<p>这里我是分了三步来实现整个功能的：</p>
<ul>
<li>1.先播放本地音频</li>
<li>2.加入录音功能</li>
<li>3.将录音音频和本地音频送给mix,mix的输出绑定到io的输出</li>
</ul>
<p>首先来看第一步，使用AUGraph播放本地音频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">//相关变量</div><div class="line"></div><div class="line">   AUGraph playerGraph;</div><div class="line">   </div><div class="line">   //io相关</div><div class="line">   AUNode ioNode;</div><div class="line">   AudioUnit ioUnit;</div><div class="line">   </div><div class="line">   AudioStreamBasicDescription audioFormat;</div><div class="line">   </div><div class="line">   NSInputStream *inputStream;</div><div class="line"></div><div class="line"></div><div class="line">//init</div><div class="line"></div><div class="line">    </div><div class="line">   NSURL *url = [NSURL fileURLWithPath:[CommonUtil bundlePath:@&quot;/abc.pcm&quot;]];</div><div class="line">   inputStream = [NSInputStream inputStreamWithURL:url];</div><div class="line">   if (!inputStream) &#123;</div><div class="line">       NSLog(@&quot;打开文件失败!!!!%@&quot;,url);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">       [inputStream open];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayback error:nil]; // 只有播放</div><div class="line"></div><div class="line">OSStatus status = noErr;</div><div class="line">   status = NewAUGraph(&amp;playerGraph);</div><div class="line">   CheckStatus(status, @&quot;创建AUGraph失败&quot;, YES);</div><div class="line">   </div><div class="line">   AudioComponentDescription outputAudioDesc;</div><div class="line">   outputAudioDesc.componentType = kAudioUnitType_Output;</div><div class="line">   outputAudioDesc.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">   outputAudioDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">   outputAudioDesc.componentFlags = 0;</div><div class="line">   outputAudioDesc.componentFlagsMask = 0;</div><div class="line">   </div><div class="line">   status = AUGraphAddNode(playerGraph, &amp;outputAudioDesc, &amp;ioNode);</div><div class="line">   CheckStatus(status, @&quot;绑定node失败&quot;, YES);</div><div class="line">   </div><div class="line">   status = AUGraphOpen(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;打开AUGraph失败&quot;, YES);</div><div class="line">   </div><div class="line">   status = AUGraphNodeInfo(playerGraph, ioNode, NULL, &amp;ioUnit);</div><div class="line">   CheckStatus(status, @&quot;创建AudioUnit失败&quot;, YES);</div><div class="line"></div><div class="line">   // audio format</div><div class="line">   audioFormat.mSampleRate = 44100;</div><div class="line">   audioFormat.mFormatID = kAudioFormatLinearPCM;</div><div class="line">   audioFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsNonInterleaved;</div><div class="line">   audioFormat.mFramesPerPacket = 1;</div><div class="line">   audioFormat.mChannelsPerFrame = 1;</div><div class="line">   audioFormat.mBytesPerPacket = 2;</div><div class="line">   audioFormat.mBytesPerFrame = 2;</div><div class="line">   audioFormat.mBitsPerChannel = 16;</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">   CheckStatus(status, @&quot;设置输入音频数据格式失败&quot;, YES);</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">   CheckStatus(status, @&quot;设置输出音频格式失败&quot;, YES);</div><div class="line"></div><div class="line">   </div><div class="line">   //callback</div><div class="line">   AURenderCallbackStruct callbackStruct;</div><div class="line">   callbackStruct.inputProc = LLYPlayCallback;</div><div class="line">   callbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">   AudioUnitSetProperty(playerUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &amp;callbackStruct, sizeof(callbackStruct));</div><div class="line">   </div><div class="line">   status  = AUGraphInitialize(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;Graph初始化失败&quot;, YES);</div><div class="line">   status = AUGraphStart(playerGraph);</div><div class="line">   CheckStatus(status, @&quot;Graph start失败&quot;, YES);</div></pre></td></tr></table></figure>
<p>io的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	static OSStatus LLYPlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;out size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步：加入录音功能，这里其实只需要对第一步做一下修改,将io回调数据处理的bus改为输入，设置输入相关属性即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   AudioBufferList *buffList;</div><div class="line">   Byte *buffer;</div><div class="line">   </div><div class="line">   </div><div class="line">   //init</div><div class="line">   [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];</div><div class="line">   [audioSession setPreferredIOBufferDuration:0.02 error:&amp;error];</div><div class="line"></div><div class="line">   </div><div class="line">   // buffer</div><div class="line">   uint32_t numberBuffers = 1;</div><div class="line">   buffList = (AudioBufferList *)malloc(sizeof(AudioBufferList));</div><div class="line">   buffList-&gt;mNumberBuffers = numberBuffers;</div><div class="line">   buffList-&gt;mBuffers[0].mNumberChannels = 1;</div><div class="line">   buffList-&gt;mBuffers[0].mDataByteSize = GRAPH_CONST_BUFFER_SIZE;</div><div class="line">   buffList-&gt;mBuffers[0].mData = malloc(GRAPH_CONST_BUFFER_SIZE);</div><div class="line">   buffer = malloc(GRAPH_CONST_BUFFER_SIZE);</div><div class="line"></div><div class="line">//设置输入格式</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(AudioStreamBasicDescription));</div><div class="line">   CheckStatus(status, @&quot;设置输出音频格式失败&quot;, YES);</div><div class="line">   </div><div class="line">   </div><div class="line">//设置输入部分的回调，实际的录音数据是在这里获取的，</div><div class="line">   AURenderCallbackStruct outputCallbackStruct;</div><div class="line">   outputCallbackStruct.inputProc = OutputPlayCallback;</div><div class="line">   outputCallbackStruct.inputProcRefCon = (__bridge void *)self;</div><div class="line">   status = AudioUnitSetProperty(ioUnit, kAudioOutputUnitProperty_SetInputCallback, kAudioUnitScope_Output, 1, &amp;outputCallbackStruct, sizeof(outputCallbackStruct));</div><div class="line">   CheckStatus(status, @&quot;ioUnit绑定回调失败&quot;, YES);</div></pre></td></tr></table></figure>
<p>io的回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	static OSStatus OutputPlayCallback(void *inRefCon,AudioUnitRenderActionFlags *ioActionFlag,const AudioTimeStamp *inTimeStamp,UInt32 inBusNumber,UInt32 inNumberFrames,AudioBufferList *ioData)&#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    play-&gt;buffList-&gt;mNumberBuffers = 1;</div><div class="line">    OSStatus status = AudioUnitRender(play-&gt;ioUnit, ioActionFlag, inTimeStamp, inBusNumber, inNumberFrames, play-&gt;buffList);</div><div class="line">    CheckStatus(status, @&quot;获取录音音频失败&quot;, YES);</div><div class="line">    </div><div class="line">//    NSLog(@&quot;record size %d:&quot;,play-&gt;buffList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    //将录音写入文件</div><div class="line">    </div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步：获取2路音频并同时播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    //负责获取2路音频和混合</div><div class="line">    AUNode mixNode;</div><div class="line">    AudioUnit mixUnit;</div><div class="line"></div><div class="line">	 //混合相关</div><div class="line">    AudioComponentDescription mixAudioDesc;</div><div class="line">    mixAudioDesc.componentType = kAudioUnitType_Mixer;</div><div class="line">    mixAudioDesc.componentSubType = kAudioUnitSubType_MultiChannelMixer;</div><div class="line">    mixAudioDesc.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    mixAudioDesc.componentFlags = 0;</div><div class="line">    mixAudioDesc.componentFlagsMask = 0;</div><div class="line">    </div><div class="line">    status = AUGraphAddNode(playerGraph, &amp;mixAudioDesc, &amp;mixNode);</div><div class="line">    CheckStatus(status, @&quot;绑定混合node失败&quot;, YES);</div><div class="line">    </div><div class="line">    status = AUGraphNodeInfo(playerGraph, mixNode, NULL, &amp;mixUnit);</div><div class="line">    CheckStatus(status, @&quot;创建混合AudioUnit失败&quot;, YES);</div><div class="line"></div><div class="line">    //绑定nodes，这里就是将mix的输出和io的输出绑定起来，不再需要手动设置io的输出回调了</div><div class="line">    status = AUGraphConnectNodeInput(playerGraph, mixNode, 0, ioNode, 0);</div><div class="line">    CheckStatus(status, @&quot;绑定node失败&quot;, YES);</div><div class="line"></div><div class="line">    //设置bus数</div><div class="line">    UInt32 busCount = 2;</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &amp;busCount, sizeof(busCount));</div><div class="line">    CheckStatus(status, @&quot;设置声道数失败&quot;, YES);</div><div class="line">    </div><div class="line">    //设置混合的输入格式,有多条输入</div><div class="line">    //bus0</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">    CheckStatus(status, @&quot;设置混合音频输入数据格式失败&quot;, YES);</div><div class="line">    //bus1</div><div class="line">    status = AudioUnitSetProperty(mixUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 1, &amp;audioFormat, sizeof(audioFormat));</div><div class="line">    CheckStatus(status, @&quot;设置混合音频输入数据格式失败&quot;, YES);</div><div class="line"></div><div class="line">	 //获取背景音频数据</div><div class="line">    AURenderCallbackStruct callback0;</div><div class="line">    callback0.inputProc = mixCallback0;</div><div class="line">    callback0.inputProcRefCon = (__bridge void *)self;</div><div class="line">//    status = AUGraphSetNodeInputCallback(playerGraph, mixNode, 0, &amp;callback0);</div><div class="line">    CheckStatus(AudioUnitSetProperty(mixUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &amp;callback0, sizeof(callback0)), @&quot;add mix callback fail&quot;,YES);</div><div class="line"></div><div class="line">    //获取录音数据</div><div class="line">    AURenderCallbackStruct callback1;</div><div class="line">    callback1.inputProc = mixCallback1;</div><div class="line">    callback1.inputProcRefCon = (__bridge void *)self;</div><div class="line">//    status = AUGraphSetNodeInputCallback(playerGraph, mixNode, 1, &amp;callback1);</div><div class="line">    CheckStatus(AudioUnitSetProperty(mixUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 1, &amp;callback1, sizeof(callback1)), @&quot;add mix callback fail&quot;,YES);</div></pre></td></tr></table></figure>
<p>mix的2路数据的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	//获取本地播放的音频</div><div class="line">	static OSStatus mixCallback0(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData) &#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line">    </div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = (UInt32)[play-&gt;inputStream read:ioData-&gt;mBuffers[0].mData maxLength:(NSInteger)ioData-&gt;mBuffers[0].mDataByteSize];</div><div class="line">    NSLog(@&quot;audio size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    </div><div class="line">    if (ioData-&gt;mBuffers[0].mDataByteSize &lt;= 0) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [play stop];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return noErr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	//获取录音音频</div><div class="line">	static OSStatus mixCallback1(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData) &#123;</div><div class="line">    </div><div class="line">    __unsafe_unretained LLYAUGraphRecord *play = (__bridge LLYAUGraphRecord *)inRefCon;</div><div class="line"></div><div class="line">    memcpy(ioData-&gt;mBuffers[0].mData, play-&gt;buffList-&gt;mBuffers[0].mData, play-&gt;buffList-&gt;mBuffers[0].mDataByteSize);</div><div class="line">    ioData-&gt;mBuffers[0].mDataByteSize = play-&gt;buffList-&gt;mBuffers[0].mDataByteSize;</div><div class="line">    </div><div class="line">    NSLog(@&quot;record size: %d&quot;, ioData-&gt;mBuffers[0].mDataByteSize);</div><div class="line"></div><div class="line">    return noErr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mix的2路回调中，我们分别获取到了数据并塞给mix的输入，然后mix直接输出到io的输出bus进行播放，中间不在需要我们做额外的工作。</p>
<p><a href="https://github.com/lilingyu0620/LLYAudioUnitPlayer.git" target="_blank" rel="noopener">我的demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/AudioUnit学习笔记/" itemprop="url">
                  AudioUnit学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T16:15:43+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/AudioUnit学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/AudioUnit学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AudioUnit简介"><a href="#AudioUnit简介" class="headerlink" title="AudioUnit简介"></a>AudioUnit简介</h3><p>在iOS中，所有的上层音频技术都是基于AudioUnit和CoreMedia来实现的。<br>下图可以直观的反应出AudioUnit的层级关系。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/auidounit1-1.png" alt=""></p>
<p>对于普通的音频播放功能可能不需要直接使用AudioUnit来实现，但是如果你需要实现比较高级的功能（比如录音，混音等），就需要使用AudioUnit了。</p>
<p>根据不同的音频目的，iOS将AudioUnit共分为7类。如下图所示</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-2.png" alt=""></p>
<ul>
<li><p>effect units 这个是用在ipod类app上的，比较少使用到。</p>
</li>
<li><p>mixer units 做混音的，有2个audio unit，3D mixer比较适合用来做游戏的3d音效。multichannel mixer提供混合任意数量的单声道或立体声流,立体声输出。</p>
</li>
<li><p>i/o units  远程I/O单元是最常用的。它连接到输入和输出音频硬件和给你对传入和传出的低延迟访问音频样本值。它提供了硬件音频格式和应用程序之间的格式转换音频格式。声音处理I/O单元扩展了远程I/O单元，通过添加声学回声取消使用网络电话或者语音聊天应用程序。通用输出装置不连接到音频硬件,而是提供了一个机制来处理链的输出发送到您的应用程序。</p>
</li>
<li><p>Format Converter Unit 用来处理音频格式的转换。</p>
</li>
</ul>
<h3 id="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit"><a href="#iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit-另一种是通过AUGraph来使用AudioUnit" class="headerlink" title="iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit."></a>iOS提供了2种创建AudioUnit方式，一种是直接创建AudioUnit,另一种是通过AUGraph来使用AudioUnit.</h3><h4 id="通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit"><a href="#通过AudioComponentDescription-amp-AudioComponent音频组件创建AudioUnit" class="headerlink" title="通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit"></a>通过AudioComponentDescription&amp;AudioComponent音频组件创建AudioUnit</h4><p>在创建一个AudioUnit实例之前，需要先创建一个audiocomponent 创建方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//组件描述</div><div class="line">AudioComponentDescription ioUnitDescription;</div><div class="line">//组件类型</div><div class="line">ioUnitDescription.componentType          = kAudioUnitType_Output;</div><div class="line">//组件子类型</div><div class="line">ioUnitDescription.componentSubType       = kAudioUnitSubType_RemoteIO;</div><div class="line">//默认值</div><div class="line">ioUnitDescription.componentManufacturer  = kAudioUnitManufacturer_Apple;</div><div class="line">ioUnitDescription.componentFlags         = 0;</div><div class="line">ioUnitDescription.componentFlagsMask     = 0;</div><div class="line"></div><div class="line">AudioComponent foundIoUnitReference = AudioComponentFindNext (NULL,&amp;ioUnitDescription);</div><div class="line">AudioUnit ioUnitInstance;</div><div class="line">AudioComponentInstanceNew (</div><div class="line">    foundIoUnitReference,</div><div class="line">    &amp;ioUnitInstance</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="使用AUGraph创建AudioUnit"><a href="#使用AUGraph创建AudioUnit" class="headerlink" title="使用AUGraph创建AudioUnit"></a>使用AUGraph创建AudioUnit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">AUGraph processingGraph;</div><div class="line">NewAUGraph (&amp;processingGraph);</div><div class="line"> </div><div class="line">// Add an audio unit node to the graph, then instantiate the audio unit</div><div class="line">AUNode ioNode;</div><div class="line">AUGraphAddNode (</div><div class="line">    processingGraph,</div><div class="line">    &amp;ioUnitDescription,</div><div class="line">    &amp;ioNode</div><div class="line">);</div><div class="line">AUGraphOpen (processingGraph); // indirectly performs audio unit instantiation</div><div class="line"> </div><div class="line">// Obtain a reference to the newly-instantiated I/O unit</div><div class="line">AudioUnit ioUnit;</div><div class="line">AUGraphNodeInfo (</div><div class="line">    processingGraph,</div><div class="line">    ioNode,</div><div class="line">    NULL,</div><div class="line">    &amp;ioUnit</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="使用Scopes和Elements来指定AudioUnit"><a href="#使用Scopes和Elements来指定AudioUnit" class="headerlink" title="使用Scopes和Elements来指定AudioUnit"></a>使用Scopes和Elements来指定AudioUnit</h3><p>Scope和Elements的关系如下图所示：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-3.png" alt=""></p>
<p>对于通用的audioUnit,可以有1-2条输入输出流，输入和输出不一定相等，比如mixer,可以两个音频输入，混音合成一个音频流输出。每个element表示一个音频处理上下文(context), 也称为bus。每个element有输出和输出部分，称为scope，分别是input scope和Output scope。Global scope确定只有一个element，就是element0，有些属性只能在Global scope上设置。</p>
<p>inputbus = Element1 = 1,outputbus = Element0 = 0</p>
<h3 id="使用Property来config-AudioUnit"><a href="#使用Property来config-AudioUnit" class="headerlink" title="使用Property来config AudioUnit"></a>使用Property来config AudioUnit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UInt32 busCount = 2;</div><div class="line"> </div><div class="line">OSStatus result = AudioUnitSetProperty (</div><div class="line">    mixerUnit,</div><div class="line">    kAudioUnitProperty_ElementCount,   // the property key</div><div class="line">    kAudioUnitScope_Input,             // the scope to set the property on</div><div class="line">    0,                                 // the element to set the property on</div><div class="line">    &amp;busCount,                         // the property value</div><div class="line">    sizeof (busCount)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一个普通的播放行为可能需要设置的属性有 <em>kAudioOutputUnitProperty_EnableIO</em>，<em>kAudioUnitProperty_StreamFormat</em>，<em>kAudioUnitProperty_SetRenderCallback</em> 三个，不同行为需要设置不同的属性。</p>
<h3 id="I-O-Unit的基本特征"><a href="#I-O-Unit的基本特征" class="headerlink" title="I/O Unit的基本特征"></a>I/O Unit的基本特征</h3><p>i/o unit是最常见的一种AudioUnit</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-4.png" alt=""></p>
<p>对于remote_IO类型audioUnit，即从硬件采集和输出到硬件的audioUnit,它的逻辑是固定的：固定2个element,麦克风经过element1到APP，APP经element0到扬声器。</p>
<p>我们能把控的是中间的“APP内处理”部分，结合上图，淡黄色的部分就是APP可控的，Element1这个组件负责链接麦克风和APP，它的输入部分是系统控制，输出部分是APP控制；Element0负责连接APP和扬声器，输入部分APP控制，输出部分系统控制。</p>
<h3 id="使用AUGraph来管理AudioUnit"><a href="#使用AUGraph来管理AudioUnit" class="headerlink" title="使用AUGraph来管理AudioUnit"></a>使用AUGraph来管理AudioUnit</h3><h3 id="Render-Callback-Functions-Feed-Audio-to-Audio-Units"><a href="#Render-Callback-Functions-Feed-Audio-to-Audio-Units" class="headerlink" title="Render Callback Functions Feed Audio to Audio Units"></a>Render Callback Functions Feed Audio to Audio Units</h3><p>当音频数据是由内存或者磁盘提供的话，数据都需要从渲染回调函数这里提供给inputbus，当你想要对音频数据进行自定义的处理的话，就在这里进行吧。</p>
<p>渲染回调函数格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static OSStatus MyAURenderCallback (</div><div class="line">    void                        *inRefCon,</div><div class="line">    AudioUnitRenderActionFlags  *ioActionFlags,</div><div class="line">    const AudioTimeStamp        *inTimeStamp,</div><div class="line">    UInt32                      inBusNumber,</div><div class="line">    UInt32                      inNumberFrames,</div><div class="line">    AudioBufferList             *ioData</div><div class="line">) &#123; /* callback body */ &#125;</div></pre></td></tr></table></figure>
<p>各参数的关系如下图：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-5.png" alt=""></p>
<h3 id="Working-with-the-AudioStreamBasicDescription-structure"><a href="#Working-with-the-AudioStreamBasicDescription-structure" class="headerlink" title="Working with the AudioStreamBasicDescription structure"></a>Working with the AudioStreamBasicDescription structure</h3><p>AudioStreamBasicDescription 这个结构体表示当前音频的格式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct AudioStreamBasicDescription &#123;</div><div class="line">    Float64 mSampleRate;//采样率</div><div class="line">    UInt32  mFormatID;//格式ID</div><div class="line">    UInt32  mFormatFlags;//存储标识</div><div class="line">    UInt32  mBytesPerPacket;//每个packet的字节数</div><div class="line">    UInt32  mFramesPerPacket;//每个packet包含几个frame</div><div class="line">    UInt32  mBytesPerFrame;//每个frame的字节数</div><div class="line">    UInt32  mChannelsPerFrame;//每个frame的声道数</div><div class="line">    UInt32  mBitsPerChannel;//每个声道的位数</div><div class="line">    UInt32  mReserved;</div><div class="line">&#125;;</div><div class="line">typedef struct AudioStreamBasicDescription  AudioStreamBasicDescription;</div></pre></td></tr></table></figure>
<h3 id="Understanding-Where-and-How-to-Set-Stream-Formats"><a href="#Understanding-Where-and-How-to-Set-Stream-Formats" class="headerlink" title="Understanding Where and How to Set Stream Formats"></a>Understanding Where and How to Set Stream Formats</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit1-6.png" alt=""></p>
<p>这个图展示了一个完整的录音+混音+播放的流程，在组件两边设置stream的格式，在代码里的概念是scope。</p>
<h3 id="在使用AUGraph时选择不同的设计模式"><a href="#在使用AUGraph时选择不同的设计模式" class="headerlink" title="在使用AUGraph时选择不同的设计模式"></a>在使用AUGraph时选择不同的设计模式</h3><h4 id="I-O-Pass-Through"><a href="#I-O-Pass-Through" class="headerlink" title="I/O Pass Through"></a>I/O Pass Through</h4><p>简单的音频输入输出场景，直接使用AudioUnit链接两端，不需要设置渲染回调.</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-1.png" alt=""></p>
<h4 id="I-O-Without-a-Render-Callback-Function"><a href="#I-O-Without-a-Render-Callback-Function" class="headerlink" title="I/O Without a Render Callback Function"></a>I/O Without a Render Callback Function</h4><p>需要多个AudioUnit来处理的场景，使用AudioUnit链接各部分，不需要设置回调。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-2.png" alt=""></p>
<h4 id="I-O-with-a-Render-Callback-Function"><a href="#I-O-with-a-Render-Callback-Function" class="headerlink" title="I/O with a Render Callback Function"></a>I/O with a Render Callback Function</h4><p>设置渲染回调的方式来处理输入输出的链接。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-3.png" alt=""></p>
<h4 id="Output-Only-with-a-Render-Callback-Function"><a href="#Output-Only-with-a-Render-Callback-Function" class="headerlink" title="Output-Only with a Render Callback Function"></a>Output-Only with a Render Callback Function</h4><p>只有输出没有输入的场景，设置渲染回调来链接输出端。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-4.png" alt=""></p>
<p>复杂的场景，需要设置多个渲染回调。同时需要多个AudioUnit来处理链接。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit2-5.png" alt=""></p>
<h3 id="构建AudioUnit-app的流程"><a href="#构建AudioUnit-app的流程" class="headerlink" title="构建AudioUnit app的流程"></a>构建AudioUnit app的流程</h3><p>无论选择上面的哪种设计，构建app的基本流程如下：</p>
<ul>
<li><p>Configure your audio session.</p>
</li>
<li><p>Specify audio units.</p>
</li>
<li><p>Create an audio processing graph, then obtain the<br>audio units.</p>
</li>
<li><p>Configure the audio units.</p>
</li>
<li><p>Connect the audio unit nodes.</p>
</li>
<li><p>Provide a user interface.</p>
</li>
<li><p>Initialize and then start the audio processing graph.</p>
</li>
</ul>
<h3 id="使用指定的AudioUnit"><a href="#使用指定的AudioUnit" class="headerlink" title="使用指定的AudioUnit"></a>使用指定的AudioUnit</h3><h4 id="Using-I-O-Units"><a href="#Using-I-O-Units" class="headerlink" title="Using I/O Units"></a>Using I/O Units</h4><ul>
<li>Remote I/O Unit</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-1.png" alt=""></p>
<ul>
<li><p>Voice-Processing I/O Unit</p>
</li>
<li><p>Generic Output Unit</p>
</li>
</ul>
<h4 id="Using-Mixer-Units"><a href="#Using-Mixer-Units" class="headerlink" title="Using Mixer Units"></a>Using Mixer Units</h4><ul>
<li>Multichannel Mixer Unit</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-2.png" alt=""></p>
<ul>
<li>3D Mixer Unit</li>
</ul>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-3.png" alt=""></p>
<h4 id="Using-Effect-Units"><a href="#Using-Effect-Units" class="headerlink" title="Using Effect Units"></a>Using Effect Units</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-4.png" alt=""></p>
<h3 id="Identifier-Keys-for-Audio-Units"><a href="#Identifier-Keys-for-Audio-Units" class="headerlink" title="Identifier Keys for Audio Units"></a>Identifier Keys for Audio Units</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/AudioUnit/audiounit3-5.png" alt=""></p>
<p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/08/flv格式和seek原理/" itemprop="url">
                  flv格式和seek原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-08T09:42:55+08:00" content="2018-04-08">
              2018-04-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/08/flv格式和seek原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/08/flv格式和seek原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FLV（Flash Video）是Adobe公司设计开发的一种流行的流媒体格式，由于其视频文件体积轻巧、封装简单等特点，使其很适合在互联网上进行应用。此外，FLV可以使用Flash Player进行播放，而Flash Player插件已经安装在全世界绝大部分浏览器上，这使得通过网页播放FLV视频十分容易。目前主流的视频网站如优酷网，土豆网，乐视网等网站无一例外地使用了FLV格式。FLV封装格式的文件后缀通常为“.flv”。</p>
<h3 id="flv数据格式"><a href="#flv数据格式" class="headerlink" title="flv数据格式"></a>flv数据格式</h3><p>从整个文件上来看,FLV是由The FLV header 和 The FLV File Body 组成.</p>
<h4 id="FLV-header"><a href="#FLV-header" class="headerlink" title="FLV header"></a>FLV header</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/header.png" alt=""></p>
<p>Signature: FLV 文件的前3个字节为固定的‘F’‘L’‘V’,用来标识这个文件是flv格式的.在做格式探测的时候，</p>
<p>如果发现前3个字节为“FLV”，就认为它是flv文件.</p>
<p>Version: 第4个字节表示flv版本号.</p>
<p>Flags: 第5个字节中的第0位和第2位,分别表示 video 与 audio 存在的情况.(1表示存在,0表示不存在)</p>
<p>DataOffset : 最后4个字节表示FLV header 长度.</p>
<h4 id="FLV-File-Body"><a href="#FLV-File-Body" class="headerlink" title="FLV File Body"></a>FLV File Body</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/body.png" alt=""></p>
<p>FLV File Body是由一连串的<strong>Previous Tag Size</strong> + tags构成.<strong>Previous Tag Size</strong>就是4个字节数据,表示前一个tag的size.</p>
<h4 id="FLV-Tag"><a href="#FLV-Tag" class="headerlink" title="FLV Tag"></a>FLV Tag</h4><p>FLV文件中的数据都是由一个个TAG组成,TAG里面的数据可能是video、audio、scripts.</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/tag2.png" alt=""></p>
<p>TagType: TAG中第1个字节中的前5位表示这个TAG中包含数据的类型,8 = audio,9 = video,18 = script data.</p>
<p>DataSize:StreamID之后的数据长度.</p>
<p>Timestamp和TimestampExtended组成了这个TAG 包数据的PTS信息,PTS= Timestamp | TimestampExtended &lt;&lt; 24.</p>
<p>StreamID之后的数据就是每种格式的情况不一样了，接下格式进行详细的介绍.</p>
<h4 id="Audio-Tags"><a href="#Audio-Tags" class="headerlink" title="Audio Tags"></a>Audio Tags</h4><p>如果TAG包中的TagType==8时，就表示这个TAG是audio。</p>
<p>StreamID之后的数据就表示是AudioTagHeader，AudioTagHeader结构如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/audiotagheader.png" alt=""></p>
<h4 id="Video-Tags"><a href="#Video-Tags" class="headerlink" title="Video Tags"></a>Video Tags</h4><p>如果TAG包中的TagType==9时，就表示这个TAG是video.</p>
<p>StreamID之后的数据就表示是VideoTagHeader，VideoTagHeader结构如下：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/videotagheader.png" alt=""></p>
<h4 id="SCRIPTDATA-控制帧）"><a href="#SCRIPTDATA-控制帧）" class="headerlink" title="SCRIPTDATA(控制帧）"></a>SCRIPTDATA(控制帧）</h4><p>如果TAG包中的TagType==18时，就表示这个TAG是SCRIPT.</p>
<p>该类型Tag又通常被称为Metadata Tag，会放一些关于FLV视频和音频的元数据信息如：duration、width、height等。<strong>通常该类型Tag会跟在File Header后面作为第一个Tag出现，而且只有一个。</strong></p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/STD.png" alt=""></p>
<p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，用来装入一个“onMetaData”标志，这个标志与Adobe的一些API调用有，在此不细述。第二个AMF包封装一个数组类型，这个数组中包含了音视频信息项的名称和值。具体说明如下，大家可以参照图片上的数据进行理解。</p>
<p>第一个AMF包：<br>       第1个字节表示AMF包类型，一般总是0x02，表示字符串，其他值表示意义请查阅文档。<br>       第2-3个字节为UI16类型值，表示字符串的长度，一般总是0x000A（“onMetaData”长度）。<br>       后面字节为字符串数据，一般总为“onMetaData”。</p>
<p>第二个AMF包：<br>       第1个字节表示AMF包类型，一般总是0x08，表示数组。<br>       第2-5个字节为UI32类型值，表示数组元素的个数。<br>       后面即为各数组元素的封装，数组元素为元素名称和值组成的对。表示方法如下：<br>       第1-2个字节表示元素名称的长度，假设为L。<br>       后面跟着为长度为L的字符串。<br>       第L+3个字节表示元素值的类型。<br>       后面跟着为对应值，占用字节数取决于值的类型</p>
<h4 id="onMetaData"><a href="#onMetaData" class="headerlink" title="onMetaData"></a>onMetaData</h4><p>onMetaData 是SCRIPTDATA中对我们来说十分重要的信息，结构如下表：<br><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/flv格式和seek原理/onMetaData.png" alt=""></p>
<p>这里面的duration、filesize、视频的width、height等这些信息对我们来说很有用.</p>
<h3 id="metadata和yamdi-flvtool2-ruby-FLVMDI-非开源"><a href="#metadata和yamdi-flvtool2-ruby-FLVMDI-非开源" class="headerlink" title="metadata和yamdi,flvtool2(ruby),FLVMDI(非开源)"></a>metadata和yamdi,flvtool2(ruby),FLVMDI(非开源)</h3><p>yamdi为flv文件增加了很多metadata信息，比如创建者、是否有关键帧、是否有视频、是否有音频，视频高度和宽度等等。而yamdi加入的meta数据中，最有效的要数关键帧。被注入了关键帧的flv可以实现像土豆网、优酷网等大型视频网站一样的“拖进度”，提前拖到缓冲还未加载到的位置开始播放。</p>
<h4 id="keyframes"><a href="#keyframes" class="headerlink" title="keyframes"></a>keyframes</h4><p>keyframes中包含着2个内容 ‘filepositions’ and ‘times’分别指的是关键帧的文件位置和关键帧的PTS.通过keyframes可以建立起自己的Index，然后再seek和快进快退的操作中，快速有效的跳转到你想要找的关键帧的位置进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/20/IP地址与协议详解/" itemprop="url">
                  IP地址与协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-20T18:29:57+08:00" content="2018-03-20">
              2018-03-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/20/IP地址与协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/20/IP地址与协议详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本的ip地址结构"><a href="#基本的ip地址结构" class="headerlink" title="基本的ip地址结构"></a>基本的ip地址结构</h3><p>ipv4:点分十进制，共32位</p>
<p>ipv6:冒号隔开8个16位数，共128位</p>
<h4 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h4><p>ip地址中一些连续的位称为网络号，其余位称为主机号。</p>
<p>ip地址空间的划分涉及五大类：</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ip地址与协议详解/ipcategory.png" alt=""></p>
<p>A,B,C为单播，D为组播。</p>
<h4 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h4><p>在一个站点接入Internet后为其分配一个网络号，然后由站点管理员进一步划分本地的子网数。</p>
<p>通过子网寻址，一个站点被分配一个A，B或C类的<strong>网络号</strong>，保留一些剩余主机号进一步用于站点内分配。该站点可能将基础地址中的主机部分进一步划分为一个<strong>子网号</strong>和一个<strong>主机号</strong>.</p>
<p>如下图，该站点将每一个地址的前16位固定为网络号，后16位8位为子网号，8位为主机号。这个特殊配置允许站点支持256个子网，每个子网最多可包含254台主机。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ip地址与协议详解/subnet.png" alt=""></p>
<p><strong>同一个子网中每台主机的IPv4地址拥有相同的子网号</strong></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应的IP地址中获取网络和子网信息。</p>
<p>掩码由路由器和主机使用，以确认一个IP地址的网络/子网部分的结束和主机部分的开始。子网掩码中的一位设为1表示一个IP地址的对应位与一个地址的网络/子网部分的对应位相结合（位与）.并将结果作为转发数据报的基础。</p>
<p>IP地址与子网掩码做（位与）运算，以形成用于路由的地址的网络/子网标识符。</p>
<p>子网掩码纯粹是站点内部的局部问题。。。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议是无连接的，这意味着IP不维护网络单元（路由器）中数据报相关的任何链接状态信息，每个数据报独立于其他数据报来处理。这也意味着IP数据报可不按顺序交付。</p>
<p>当某些错误发生时，例如一台路由器临时用尽缓冲区，IP提供一个简单的错误处理方式：丢弃一些数据（通常是最后到达的数据报）。</p>
<h4 id="协议头部结构"><a href="#协议头部结构" class="headerlink" title="协议头部结构"></a>协议头部结构</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/ip地址与协议详解/ipv4head.png" alt=""></p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>它包含IP数据报的版本号：IPV4是4，IPV6是6.</p>
<p>IPV4和IPV6两个协议之间不能直接互操作。</p>
<h4 id="IHL（头部长度）"><a href="#IHL（头部长度）" class="headerlink" title="IHL（头部长度）"></a>IHL（头部长度）</h4><p>保存IPV4头部中32位字的数量，包括任何选项。由于他是一个4位的字段，所以IPV4的头部被限制最多15个32位字（60个字节）.</p>
<h4 id="DS-区分服务"><a href="#DS-区分服务" class="headerlink" title="DS(区分服务)"></a>DS(区分服务)</h4><p>前6位被称为区分服务字段，后两位是显示拥塞通知字段或指示位。</p>
<h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>IPV4数据报的总长度。通过这个字段和IHL字段，我们知道数据报的数据部分从哪里开始，以及他的长度。由于它是一个16位的字段，所以IPV4数据报的最大长度是65535字节。</p>
<p>由于一些携带IPV4数据报的低层协议不能精确表达自己封装数据的大小，所以需要在头部中给出总长度字段。例如，以太网会将短帧补充到最小长度（64字节）。虽然以太网最小有效载荷为46字节，单一个IPV4数据报也可能会更小（20字节）。如果没有提供总长度字段，IPV4实现将无法知道一个46字节的以太网帧是一个IP数据报，还是经过填充的IP数据报，这样可能会导致混淆。</p>
<p>尽管可发送一个65535字节的IP数据报，但是大多数链路层不能携带这么大的数据，所以会对发数据进行<strong>分片</strong>。主机不接受大于576字节的IPV4数据报。</p>
<h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>标识字段帮助标识由IPV4主机发送的数据报，为了避免将一个数据报分片和其他分片混淆，发送主机通常在每次发送数据报时都将一个内部计数器加1，并将该计算器值复制到IPV4标识字段。</p>
<h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>TTL字段用于设置一个数据报可经过的路由器数量的上限。发送方将他初始化为某一个值（文档建议为64，但128或255也不少见），每台路由器在转发数据报时将该值减1.当这个字段值达到0时，改数据报被丢弃，并使用一个ICMP消息通知发送方。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>IPV4头部中的协议字段包含一个数字，表示数据报有效载荷部分的数据类型。最常见的值为17（UDP）和6（TCP）。</p>
<h4 id="头部校验和"><a href="#头部校验和" class="headerlink" title="头部校验和"></a>头部校验和</h4><p>头部校验和字段仅计算IPV4头部。理解这一点很重要，因为这意味着IP协议不检测IPV4数据报有效载荷的正确性。需要其他上层协议自己去实现（<strong>比如TCP的校验和字段</strong>）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/05/TCP协议学习笔记/" itemprop="url">
                  TCP协议学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-05T10:35:50+08:00" content="2018-03-05">
              2018-03-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/05/TCP协议学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/05/TCP协议学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="tcp报文段格式如下"><a href="#tcp报文段格式如下" class="headerlink" title="tcp报文段格式如下"></a>tcp报文段格式如下</h3><p>图中保留字段有6位，看最新的书上面是4位，还有2位分别是<strong>CWR</strong>和<strong>ECE</strong>位。</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcp头部结构.jpg" alt=""></p>
<h4 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h4><p>这两个值与IP头部的源和目标IP地址一起唯一的标识了每个连接。端口和IP地址的组合被称为端点或套接字</p>
<h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>在发送用于建立连接的SYN之前，通信双方会选择一个初始序列号。<strong>初始序列号会随着时间而改变</strong>。因此每一个连接都拥有不同的序列号。文档指出，序列号可以被视为一个32位的计算器。<strong>该计算器的数值每4微秒+1</strong><br>主要是防止序列号重复。</p>
<p>标识了TCP发送端发送到接收端的数据的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节。这是一个32位的无符号数，到达2的32次方-1之后在循环回到0。</p>
<p><strong>消耗一个序列号意味着使用重传进行可靠传输</strong></p>
<h4 id="确认序号"><a href="#确认序号" class="headerlink" title="确认序号"></a>确认序号</h4><p>包含的值是该确认号的发送方期待接收到的下一个序列号。 <strong>即最后被成功接收的数据字节的序列号+1.</strong></p>
<p>这个字段只有在ACK位被启用的情况下才有效。这个ACK位字段通常用于除了初始化和末尾报文段之外的所有报文段。</p>
<h4 id="数据偏移（头部长度）"><a href="#数据偏移（头部长度）" class="headerlink" title="数据偏移（头部长度）"></a>数据偏移（头部长度）</h4><p>给出了头部的长度，以32位字节为单位，这个字段是必须的，因为选项字段的长度是可变的。作为一个4位的字段，TCP被限制为只能带60个字节的头部。而不带选项。大小是20字节。</p>
<h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>TCP的流量控制由每一个端点使用窗口大小字段来通告一个窗口大小来完成。这个窗口大小是字节数，从ACK号指定的，也是接收方想要接收的那个字节开始。这是一个16位的字段，限制窗口大小65535字节，从而限制了TCP的吞吐量性能。</p>
<h4 id="TCP校验和"><a href="#TCP校验和" class="headerlink" title="TCP校验和"></a>TCP校验和</h4><p>覆盖了TCP的头部和数据以及头部中的一些字段。这个字段是强制的，由发送方进行计算和保存，然后由接收发验证。</p>
<h4 id="CWR拥塞窗口减（发送方降低它的发送速度）"><a href="#CWR拥塞窗口减（发送方降低它的发送速度）" class="headerlink" title="CWR拥塞窗口减（发送方降低它的发送速度）"></a>CWR拥塞窗口减（发送方降低它的发送速度）</h4><h4 id="ECE（发送方接收了一个更早的拥塞通告）"><a href="#ECE（发送方接收了一个更早的拥塞通告）" class="headerlink" title="ECE（发送方接收了一个更早的拥塞通告）"></a>ECE（发送方接收了一个更早的拥塞通告）</h4><h4 id="URG-紧急（紧急字段有效很少被用到）"><a href="#URG-紧急（紧急字段有效很少被用到）" class="headerlink" title="URG 紧急（紧急字段有效很少被用到）"></a>URG 紧急（紧急字段有效很少被用到）</h4><h4 id="ACK-确认（确认号字段有效，连接建立以后一般都是开启状态）"><a href="#ACK-确认（确认号字段有效，连接建立以后一般都是开启状态）" class="headerlink" title="ACK 确认（确认号字段有效，连接建立以后一般都是开启状态）"></a>ACK 确认（确认号字段有效，连接建立以后一般都是开启状态）</h4><h4 id="PSH-推送"><a href="#PSH-推送" class="headerlink" title="PSH 推送"></a>PSH 推送</h4><h4 id="RST重置连接（连接取消，一般是因为错误）"><a href="#RST重置连接（连接取消，一般是因为错误）" class="headerlink" title="RST重置连接（连接取消，一般是因为错误）"></a>RST重置连接（连接取消，一般是因为错误）</h4><h4 id="SYN（用于初始化一个连接的同步序列号）"><a href="#SYN（用于初始化一个连接的同步序列号）" class="headerlink" title="SYN（用于初始化一个连接的同步序列号）"></a>SYN（用于初始化一个连接的同步序列号）</h4><h4 id="FIN-该报文段的发送发已经结束向对方发送数据"><a href="#FIN-该报文段的发送发已经结束向对方发送数据" class="headerlink" title="FIN 该报文段的发送发已经结束向对方发送数据"></a>FIN 该报文段的发送发已经结束向对方发送数据</h4><h4 id="tcp选项"><a href="#tcp选项" class="headerlink" title="tcp选项"></a>tcp选项</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcpchoice.png" alt=""></p>
<h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcpshark.png" alt=""></p>
<p>一个TCP连接由4个元组组成，它们分别是2个IP地址和2个端口号。即一对端点或者套接字。</p>
<p>为了建立一个TCP连接，需要完成以下步骤：</p>
<ul>
<li><p>主动开启者（一般称为客户端）发送一个SYN报文段，并指明自己想要连接的端口号和它的客户端初始序列号（即为ISN(c)）。通常客户端还会借此发送一个或者多个选项。</p>
</li>
<li><p>服务器在收到客户端的SYN报文段后，也发送自己的SYN报文段作为响应，并包含它们初始序列号（记为SIN(s)）。此外，为了确认客户端的SYN，服务器将其包含的ISN(c)数值+1后作为返回的ACK数值。因此，每发送一个SYN，序列号就会自动+1，这样如果出现丢失的情况，该SYN段将会重传。</p>
</li>
<li><p>为了确认服务器的SYN，客户端将ISN(s)的数字+1作为返回的ACK数值。</p>
</li>
</ul>
<p>通过上述的3个报文段就能够完成一个TCP连接的建立。它们也常称为<em>三次握手</em></p>
<p>TCP协议规定通过发送一个FIN段来发起关闭操作。只有当连接双方都完成关闭操作以后，才构成一个完整关闭。</p>
<ul>
<li><p>连接的主动关闭者发送一个FIN段指明接收者希望看到的自己当前的序列号（K），FIN段还包含了一个ACK段用于确认对方最近一次发来的数据。</p>
</li>
<li><p>连接的被动关闭者将K的数值+1作为响应的ACK值，以表示它已经成功接收到主动关闭者发送的FIN。</p>
</li>
<li><p>被动关闭者将身份转变为主动关闭者，发送自己的FIN.</p>
</li>
<li><p>为了完成连接的关闭，最后发送的报文段还包含一个ACK用于确认上一个FIN.值得注定的是，如果出现FIN丢失的情况，那么被动关闭方将重新传输直到收到一个ACK确认为止。</p>
</li>
</ul>
<p>通过上诉的4个报文就能够完成一个TCP连接的关闭。他们也常称为<em>四次挥手</em></p>
<h3 id="TCP的状态转换图"><a href="#TCP的状态转换图" class="headerlink" title="TCP的状态转换图"></a>TCP的状态转换图</h3><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcpstatus.png" alt=""></p>
<p>tcp连接和断开过程中的状态变化</p>
<p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcpsharkstatus.png" alt=""></p>
<h3 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h3><p>TCP拥有两套独立机制来完成重传，一是基于时间，二是基于确认信息的构成。</p>
<p>TCP在发送数据的会设置一个计时器，若计时器超时仍未收到数据的确认信息，则会引发相应的<em>超时</em>或者<em>基于计时器的重传</em>操作，计时器超时称为<em>重传超时（RTO）</em>。</p>
<p>另一种方式的重传称为<em>快速重传</em>，通常发生在没有延时的情况下，若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢失包。在发送端认为接收端可能出现数据丢失时，需要决定发送新数据还是重传。</p>
<ul>
<li><p>使用往返时间（RTT）估计策略</p>
<p>  TCP在收到数据后会返回确认信息，因此可在该信息中携带一个字节的数据来测量传输该确认信息所需要的时间。每个此类的测量结果称为RTT样本。TCP首先需要根据一段时间内的样本值建立好的估计值。然后使用计算公式根据RTT估值得到RTO值。</p>
<p>  选择一组RTT样本的样本均值作为真实的RTT是最有可能的，注意这个均值很自然的会随着时间而改变，因为通信穿过的网络的路径可能改变。</p>
</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传机制基于接收端的反馈信息来引发重传，而非重传计时器的超时。因此与超时重传相比，快速重传能更加及时有效的修复丢包情况。</p>
<p>当接收到失序报文段时，TCP需要立即生成确认信息（重复ACK）。并且失序情况表明在后续数据到达前出现了丢段，即<strong>接收端缓存</strong>出现了空缺。发送端的工作即为尽快的，高效的填补空缺。所以当失序数据到达是，重复ACK应该立即返回，不能延迟发送。</p>
<p>当重复ACK的数量达到一定的数目（称为重复ACK阈值）时，快速重传机制才会被触发。</p>
<h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>ACK号与接收端缓存中的的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为<strong>失序数据</strong>，因为这些数据与之前接收的序列号不连续。</p>
<p>TCP发送端的任务是通过重传丢失数据来填补接收端缓存中的空缺，但同时也要尽可能保证不重传 已正确接收到的数据。在很多环境下，合理采用SACK信息能更快的实现空缺填补，且能减少不必要的重传，原因在于其在一个RTT内能获知多个空缺。当采用SACK选项时，一个ACK可包含三四个告知失序数据的SACK信息。每个SACK信息包含32位的序列号，代表接收端存储的失序数据的起始至最后一个序列号（+1）。    </p>
<h3 id="数据流与窗口管理"><a href="#数据流与窗口管理" class="headerlink" title="数据流与窗口管理"></a>数据流与窗口管理</h3><p>可以采用可变滑动窗口来实现流量控制</p>
<h4 id="发送窗口结构"><a href="#发送窗口结构" class="headerlink" title="发送窗口结构"></a>发送窗口结构</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcpwindow.png" alt=""></p>
<p>TCP发送端滑动窗口结构记录了已确认，在传以及还未传的数据的序列号。<strong>提供窗口的大小控制由接收端返回的ACK中的窗口大小字段控制</strong></p>
<p>随着时间的推移，当接收到返回的数据ACK，滑动窗口也随之右移。窗口两端的相对运动使得窗口增大或减小。可用三个术语来描述窗口左右边界的运动。</p>
<ul>
<li>关闭：即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小。</li>
<li>打开：即窗口右边界右移，使得可发送数据增大。当已确认数据得到处理，接收端可用缓存增大，窗口也随之变大。</li>
<li>收缩：即窗口右边界左移。</li>
</ul>
<h4 id="接收窗口结构"><a href="#接收窗口结构" class="headerlink" title="接收窗口结构"></a>接收窗口结构</h4><p><img src="https://github.com/lilingyu0620/LLYBlogImageSource/raw/master/TCP协议学习笔记/tcpreceivewindow.png" alt=""></p>
<p>该窗口结构记录了已接收并确认的数据，以及它能够接收的最大序列号。该窗口可以保证其接收数据的正确性。特别是接收端希望避免存储重复的已接收和确认的数据，以及避免存储不应该接收的数据。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象称为拥塞。</p>
<p>在有线网络中，出现在路由器或者交换机中的拥塞是造成丢包的主要原因；<br>在无线网络中，传输和接收错误是导致丢包的重要因素。</p>
<p>反映网络传输能力的变量称为拥塞窗口，记做（cwnd）.</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当一个新的TCP连接建立或者检测到由重传超时（RTO）导致的丢包时，需要执行慢启动。TCP发送端长时间处于空闲状态也可能调用慢启动算法。慢启动的目的是，是TCP在用拥塞避免探寻更多可用带宽之前得到cwnd值，以及帮助TCP建立ACK时钟。通常，TCP在建立新连接时执行慢启动，直至有丢包时，执行拥塞避免算法进入稳定状态。</p>
<p><strong>在传输初始阶段，由于未知网络传输能力，需要缓慢探测可用传输资源，防止短时间内大量数据注入导致拥塞。慢启动算法正是针对这一问题而设计。在数据传输之初或者重传计时器检测到丢包后，需要执行慢启动</strong></p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>为了得到更多的传输资源而不至于影响其他连接传输，TCP实现了拥塞避免算法。一旦确立慢启动阈值，TCP会进入拥塞避免阶段，cwnd每次的增长值近似于成功传输的数据段大小。这种随时间线性增长的方式于慢启动的指数增长相比缓慢许多。</p>
<h4 id="慢启动和拥塞避免的选择"><a href="#慢启动和拥塞避免的选择" class="headerlink" title="慢启动和拥塞避免的选择"></a>慢启动和拥塞避免的选择</h4><p>慢启动阈值（ssthresh）和cwnd的关系决定了采用慢启动还是拥塞避免的界限。当cwnd<ssthresh 使用慢启动算法。当cwnd="">ssthresh时，需要执行拥塞避免，而当两者相等时，任何一种算法都可以。</ssthresh></p>
<p>慢启动和拥塞控制之间最大的却别在于，cwnd怎样增长。慢启动是指数增长，拥塞避免时是线性增长。</p>
<h3 id="TCP保活机制（keepalive）"><a href="#TCP保活机制（keepalive）" class="headerlink" title="TCP保活机制（keepalive）"></a>TCP保活机制（keepalive）</h3><p>保活机制是一种不影响数据流内容的情况下探测对方的方式。它是由一个保活计时器实现的。当计时器被激活，连接一端将发送一个保活报文，另一端接收到报文的同时会发送一个ACK作为响应。</p>
<p>如果在一段时间（<strong>保活时间keepalive time</strong>）内连接处于非活动状态，开启保活功能的一端将向对方发送一个保活探测报文。如果发送端没有收到响应报文，那么经过一个已经提前配置好的保活时间间隔（keepalive interval），将继续发送保活探测报文，直到发送探测报文的次数达到保活探测数（keepalive probe）。这是对方主机将被确认为不可到达，连接也将中断。</p>
<p>保活探测报文为一个空报文段（或只包含一个字节），他的序列号等于对方主机发送的ACK报文的最大序列号减1.因为这一序列号的数据已经被成功接收，所以不会对到达的报文段造成影响。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/01/iOS中cookie的使用/" itemprop="url">
                  iOS中cookie的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-01T17:57:47+08:00" content="2018-03-01">
              2018-03-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/01/iOS中cookie的使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/01/iOS中cookie的使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="cookie是啥？"><a href="#cookie是啥？" class="headerlink" title="cookie是啥？"></a>cookie是啥？</h3><p>简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie 只包含数据，就其本身而言并不有害。</p>
<p>在浏览器访问WEB服务器的某个资源时，由WEB服务器在HTTP响应消息头中附带传送给浏览器的一个小文本文件。一旦WEB浏览器保存了某个Cookie，那么它在以后每次访问该WEB服务器时，都会在HTTP请求头中将这个Cookie回传给WEB服务器。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>WEB服务器通过在HTTP响应消息中增加Set-Cookie响应头字段将Cookie信息发送给浏览器，浏览器则通过在HTTP请求消息中增加Cookie请求头字段将Cookie回传给WEB服务器。<br>一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。<br>一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。<br>浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Cookie可以分为两类，会话Cookie和持久Cookie,会话Cookie是临时Cookie,当前会话结束(浏览器退出)时Cookie会被删除。持久Cookie会存储在用户的硬盘上,浏览器退出，然后重新启动后Cookie仍然存在。会话Cookie和持久Cookie的区别在于过期时间，如果设置了Discard参数(Cookie 版本1)或者没有设置Expires(Cookie版本0)或Max-Age(Cookie版本1)<br>没有设置过期时间，则此Cookie为会话Cookie</p>
<p>Cookie有两个版本,一个是版本0(Netscape Cookies)和版本1(RFC 2965),目前大多数服务器使用的Cookie 0。</p>
<h3 id="iOS中如何使用cookie"><a href="#iOS中如何使用cookie" class="headerlink" title="iOS中如何使用cookie"></a>iOS中如何使用cookie</h3><h4 id="NSHTTPCookie"><a href="#NSHTTPCookie" class="headerlink" title="NSHTTPCookie"></a>NSHTTPCookie</h4><p>在iOS中使用NSHTTPCookie类封装一条cookie,通过NSHTTPCookie的方法读取到cookie的通用属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)version;</div><div class="line">- (NSString *)name;</div><div class="line">- (NSString *)value;</div><div class="line">- (NSString *)domain;</div><div class="line">- (NSString *)path;</div><div class="line">- (BOOL)isSessionOnly;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以通过手工赋值的方式创建Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (id)cookieWithProperties:(NSDictionary *)properties;</div><div class="line">- (id)initWithProperties:(NSDictionary *)properties;</div></pre></td></tr></table></figure>
<p>也可以从Cookie中读取到所有属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSDictionary *)properties;</div></pre></td></tr></table></figure>
<p>使用NSHTTPCookie的类方法可以将NSHTTPCookie实例与HTTP cookie header相互转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">根据NSHTTPCookie实例数组生成对应的HTTP cookie header</div><div class="line">+ (NSDictionary *)requestHeaderFieldsWithCookies:(NSArray *)cookies;</div><div class="line"></div><div class="line">从headerFileds中读取到Cookie相关内容,生成NSHTTPCookie实例对象数组。</div><div class="line">+ (NSArray *)cookiesWithResponseHeaderFields:(NSDictionary *)headerFields forURL:(NSURL *)theURL;</div><div class="line"></div><div class="line">该方法会忽略headerFileds中与cookie无关的字段，如果headerFileds中的cookie没有指定domain,则使用theURL的domain,如果没有指定path,则使用”/”.</div><div class="line"></div><div class="line">除非NSURLRequest明确指定不使用cookie(HTTPShouldHandleCookies设为NO),否则URL loading system会自动为NSURLRequest发送合适的存储cookie。从NSURLResponse返回的cookie也会根据当前的cookie访问策略(cookie acceptance policy)接收到系统中。</div></pre></td></tr></table></figure>
<h4 id="NSHTTPCookieStorage"><a href="#NSHTTPCookieStorage" class="headerlink" title="NSHTTPCookieStorage"></a>NSHTTPCookieStorage</h4><p>NSHTTPCookieStorage单件类提供了管理所有NSHTTPCookie对象的接口，在OS X里,cookie是在所有程序中共享的，而在iOS中,cookie只当当前应用中有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">通过sharedHTTPCookieStorage方法可获取到共享的NSHTTPCookieStorage单件对象。</div><div class="line">+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage；</div><div class="line"></div><div class="line">使用NSHTTPCookieStorage单件对象可获取到当前存储的所有cookie</div><div class="line">- (NSArray *)cookies</div><div class="line"></div><div class="line">或针对特定URL的cookie</div><div class="line">- (NSArray *)cookiesForURL:(NSURL *)theURL;</div><div class="line"></div><div class="line">还可以添加/删除Cookie</div><div class="line">– deleteCookie:</div><div class="line">– setCookie:</div><div class="line">– setCookies:forURL:mainDocumentURL:</div><div class="line"></div><div class="line">通过NSHTTPCookieStorage可读取/修改cookie接收策略,默认为NSHTTPCookieAcceptPolicyAlways.</div><div class="line">- (NSHTTPCookieAcceptPolicy)cookieAcceptPolicy；</div><div class="line">- (void)setCookieAcceptPolicy:(NSHTTPCookieAcceptPolicy)aPolicy.</div><div class="line"></div><div class="line">一共有三种cookie accept policy,</div><div class="line">typedef enum &#123;</div><div class="line">   NSHTTPCookieAcceptPolicyAlways,</div><div class="line">   NSHTTPCookieAcceptPolicyNever,</div><div class="line">   NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain</div><div class="line">&#125; NSHTTPCookieAcceptPolicy;</div><div class="line"></div><div class="line">NSHTTPCookieAcceptPolicyAlways:接收所有cookie,默认策略.</div><div class="line">NSHTTPCookieAcceptPolicyNever: 拒绝所有cookie</div><div class="line">NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain:只接收main document domain中的cookie.</div></pre></td></tr></table></figure>
<p>相关通知Notification</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieManagerCookiesChangedNotification</div><div class="line">当NSHTTPCookieStorage实例中的cookies变化时发出此通知。</div><div class="line">NSHTTPCookieManagerAcceptPolicyChangedNotification</div><div class="line">当NSHTTPCookieStorage实例的cookie acceptance policy变化时发出此通知。</div></pre></td></tr></table></figure>
<h4 id="cookie的使用"><a href="#cookie的使用" class="headerlink" title="cookie的使用"></a>cookie的使用</h4><p>当你利用一个URL请求时，NSURLRequest都会帮你主动记录下来你访问的站点设置的cookie（因为NSHTTPCookieStorage可读取/修改cookie接收策略,默认为NSHTTPCookieAcceptPolicyAlways.当然你也可以给它设置为NSHTTPCookieAcceptPolicyNever: 拒绝所有cookie），而且很负责任的，当你下次再访问这个站点时，NSURLRequest会拿着上次保存下来了的cookie继续去请求。这规律同样适用于 ASIHTTPRequest。所以当你做一些基于认证的网络请求时，cookie不失为一个完美的解决方案。</p>
<h5 id="查看cookie"><a href="#查看cookie" class="headerlink" title="查看cookie"></a>查看cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123;</div><div class="line">       NSLog(@&quot;%@&quot;, cookie);</div><div class="line">&#125;</div><div class="line">这样就列出了所有已保存的cookie,如果当前为空怎么办呢？随便请求一个url喽。</div><div class="line">NSURLRequest *request = [NSURLRequest requestWithURL:</div><div class="line">[NSURL URLWithString:@&quot;http://blog.cnrainbird.com&quot;] cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData    timeoutInterval:3];</div><div class="line">[NSURLConnection sendSynchronousRequest:request </div><div class="line">                      returningResponse:nil </div><div class="line">                                     error:nil]; </div><div class="line"></div><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, cookie);</div><div class="line">&#125;</div><div class="line"></div><div class="line">是不是得到了类似:</div><div class="line">&lt;NSHTTPCookie version:0 name:&quot;PHPSESSID&quot; value:&quot;evf5rcboo8th1dnl53fs4ukmt2&quot; expiresDate:(null) created:2012-03-13 14:28:13 +0000 (3.53342e+08) sessionOnly:TRUE domain:&quot;blog.cnrainbird.com&quot; path:&quot;/&quot; isSecure:FALSE&gt;</div><div class="line">的东东？这就是cookie啦</div></pre></td></tr></table></figure>
<h5 id="清空cookie"><a href="#清空cookie" class="headerlink" title="清空cookie"></a>清空cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">NSArray *_tmpArray = [NSArray arrayWithArray:[cookieJar cookies]];</div><div class="line">for (id obj in _tmpArray) &#123;</div><div class="line">    [cookieJar deleteCookie:obj];</div><div class="line">&#125;</div><div class="line">这样cookie就消失的一干二净了。</div></pre></td></tr></table></figure>
<h5 id="设置指定的cookie"><a href="#设置指定的cookie" class="headerlink" title="设置指定的cookie"></a>设置指定的cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];</div><div class="line">[cookieProperties setObject:@&quot;username&quot; forKey:NSHTTPCookieName];</div><div class="line">[cookieProperties setObject:@&quot;rainbird&quot; forKey:NSHTTPCookieValue];</div><div class="line">[cookieProperties setObject:@&quot;cnrainbird.com&quot; forKey:NSHTTPCookieDomain];</div><div class="line">[cookieProperties setObject:@&quot;cnrainbird.com&quot; forKey:NSHTTPCookieOriginURL];</div><div class="line">[cookieProperties setObject:@&quot;/&quot; forKey:NSHTTPCookiePath];</div><div class="line">[cookieProperties setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion];</div><div class="line"></div><div class="line">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];</div><div class="line">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</div></pre></td></tr></table></figure>
<p><a href="http://jinqianchina.github.io/2016/01/07/Cookie机制以及cookie在iOS中使用介绍/" target="_blank" rel="noopener">参考资料一</a></p>
<p><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">参考资料二</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/28/MAC地址和IP地址的区别和联系/" itemprop="url">
                  MAC地址、IP地址和端口号
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-02-28T16:50:33+08:00" content="2018-02-28">
              2018-02-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/28/MAC地址和IP地址的区别和联系/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/28/MAC地址和IP地址的区别和联系/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>简单的说：IP地址是网络服务商给你分配的，MAC地址是网卡制造商写在网卡上的，端口号用来区分同一台设备上的不同服务。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于IP地址，相信大家都很熟悉，即指使用TCP/IP协议指定给主机的32位地址。IP地址由用点分隔开的4个8八位组构成，如192.168.0.1就是一个IP地址，这种写法叫点分十进制格式。IP地址由网络地址和主机地址两部分组成，分配给这两部分的位数随地址类（A类、B类、C类等）的不同而不同。网络地址用于路由选择，而主机地址用于在网络或子网内部寻找一个单独的主机。一个IP地址使得将来自源地址的数据通过路由而传送到目的地址变为可能。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>对于MAC地址，由于我们不直接和它接触，所以大家不一定很熟悉。在OSI（Open System Interconnection，开放系统互连）7层网络协议（物理层，数据链路层，网络层，传输层，会话层，表示层，应用层）参考模型中，第二层为数据链路层（Data Link）。它包含两个子层，上一层是逻辑链路控制（LLC：Logical Link Control），下一层即是我们前面所提到的MAC（Media Access Control）层，即介质访问控制层。所谓介质（Media），是指传输信号所通过的多种物理环境。常用网络介质包括电缆（如：双绞线，同轴电缆，光纤），还有微波、激光、红外线等，有时也称介质为物理介质。MAC地址也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。这个地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，它都有相同的MAC地址，MAC地址一般不可改变，不能由用户自己设定。</p>
<p>MAC地址的长度为48位（6个字节），通常表示为12个16进制数，每2个16进制数之间用冒号隔开，如：08:00:20:0A:8C:6D就是一个MAC地址，其中前6位16进制数08:00:20代表网络硬件制造商的编号，它由IEEE（Istitute of Electrical and Electronics Engineers，电气与电子工程师协会）分配，而后3位16进制数0A:8C:6D代表该制造商所制造的某个网络产品（如网卡）的系列号。每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC地址。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p> 为了在一台设备上可以运行多个程序，人为的设计了端口(Port)的概念，类似的例子是公司内部的分机号码。规定一个设备有216个，也就是65536个端口，每个端口对应一个唯一的程序。每个网络程序，无论是客户端还是服务器端，都对应一个或多个特定的端口号。由于0-1024之间多被操作系统占用，所以实际编程时一般采用1024以后的端口号。 下面是一些常见的服务对应的端口：</p>
<p>ftp：23，telnet：23，smtp：25，dns：53，http：80，https：443</p>
<p>使用端口号，可以找到一台设备上唯一的一个程序。  所以如果需要和某台计算机建立连接的话，只需要知道IP地址或域名即可，但是如果想和该台计算机上的某个程序交换数据的话，还必须知道该程序使用的端口号。</p>
<h3 id="IP地址与MAC地址在互连网中的作用"><a href="#IP地址与MAC地址在互连网中的作用" class="headerlink" title="IP地址与MAC地址在互连网中的作用"></a>IP地址与MAC地址在互连网中的作用</h3><p>既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？或者说为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：（1）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。（3）无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的。下面我们来通过一个例子看看IP地址和MAC地址是怎样结合来传送数据包的。</p>
<p>　　假设网络上要将一个数据包（名为PAC）由北京的一台主机（名称为A，IP地址为IP_A，MAC地址为MAC_A）发送到华盛顿的一台主机（名称为B，IP地址为IP_B，MAC地址为MAC_B）。这两台主机之间不可能是直接连接起来的，因而数据包在传递时必然要经过许多中间节点（如路由器，服务器等等），我们假定在传输过程中要经过C1、C2、C3（其MAC地址分别为M1，M2，M3）三个节点。A在将PAC发出之前，先发送一个ARP请求，找到其要到达IP_B所必须经历的第一个中间节点C1的MAC地址M1，然后在其数据包中封装（Encapsulation）这些地址：IP_A、IP_B，MAC_A和M1。当PAC传到C1后，再由ARP根据其目的IP地址IP_B，找到其要经历的第二个中间节点C2的MAC地址M2，然后再将带有M2的数据包传送到C2。如此类推，直到最后找到带有IP地址为IP_B的B主机的地址MAC_B，最终传送给主机B。在传输过程中，IP_A、IP_B和MAC_A不变，而中间节点的MAC地址通过ARP在不断改变（M1，M2，M3），直至目的地址MAC_B。</p>
<h3 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h3><ul>
<li><p>IP地址和MAC地址相同点是它们都唯一</p>
</li>
<li><p>对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。</p>
</li>
<li><p>长度不同。IP地址为32位，MAC地址为48位。</p>
</li>
<li><p>分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。</p>
</li>
<li><p>寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/21/Python的一些高级特性/" itemprop="url">
                  Python的一些高级特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-21T10:26:11+08:00" content="2017-08-21">
              2017-08-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/08/21/Python的一些高级特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/21/Python的一些高级特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Python的一些高级特性"><a href="#Python的一些高级特性" class="headerlink" title="Python的一些高级特性"></a>Python的一些高级特性</h3><h4 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h4><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def person(name, age, **kw):</div><div class="line">    print &apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw</div></pre></td></tr></table></figure>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">person(&apos;Michael&apos;, 30)</div><div class="line"></div><div class="line">person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</div><div class="line"></div><div class="line">person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kw = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">person(&apos;Jack&apos;, 24, **kw)</div></pre></td></tr></table></figure>
<h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p><strong>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数</strong></p>
<ul>
<li>变量可以指向函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = abs</div><div class="line"></div><div class="line">f(-10)</div></pre></td></tr></table></figure>
<ul>
<li>函数名也是变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abs = 10</div><div class="line"></div><div class="line">abs</div><div class="line"></div><div class="line">abs(-10)</div></pre></td></tr></table></figure>
<ul>
<li>传入参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f = abs</div><div class="line"></div><div class="line">def add(x,y,f):</div><div class="line">	return f(x) + f(y)</div></pre></td></tr></table></figure>
<ul>
<li><p>内建map()</p>
<p>  <strong>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def f(x):</div><div class="line">	return x * x</div><div class="line"></div><div class="line">map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div class="line"></div><div class="line">map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div class="line"></div><div class="line">//&apos;&apos; &quot;&quot; 区别</div></pre></td></tr></table></figure>
<ul>
<li><p>内建reduce()</p>
<p>  <strong>reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</strong></p>
</li>
</ul>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def add(x,y):</div><div class="line">	return x + y</div><div class="line"></div><div class="line">reduce(add,range(1,10))</div><div class="line"></div><div class="line">sum(range(1,10))</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def fn(x,y)</div><div class="line">	return x * 10 + y</div><div class="line"></div><div class="line">reduce(fn,[1,3,5,7,9])</div></pre></td></tr></table></figure>
<ul>
<li><p>内建filter()</p>
<p>  <strong>filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//奇数</div><div class="line">def is_odd(n):</div><div class="line">    return n % 2 == 1</div><div class="line"></div><div class="line">filter(is_odd,range(1,10))</div></pre></td></tr></table></figure>
<ul>
<li>内建sorted()</li>
</ul>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 逆序</div><div class="line">def reversed_cmp(x, y):</div><div class="line">    if x &gt; y:</div><div class="line">        return -1</div><div class="line">    if x &lt; y:</div><div class="line">        return 1</div><div class="line">    return 0</div><div class="line"></div><div class="line">sorted([36, 5, 12, 9, 21], reversed_cmp)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 字符串忽略大小写排序</div><div class="line">def cmp_ignore_case(s1, s2):</div><div class="line">    u1 = s1.upper()</div><div class="line">    u2 = s2.upper()</div><div class="line">    if u1 &lt; u2:</div><div class="line">        return -1</div><div class="line">    if u1 &gt; u2:</div><div class="line">        return 1</div><div class="line">    return 0</div><div class="line"></div><div class="line">sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)</div></pre></td></tr></table></figure>
<h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def lazy_sum(L=[]):</div><div class="line">    def sum():</div><div class="line">        ax = 0</div><div class="line">        for n in L:</div><div class="line">            ax = ax + n</div><div class="line">        return ax</div><div class="line">    return sum</div><div class="line">    </div><div class="line">f = lazy_sum(range(1,10))</div><div class="line"></div><div class="line">f</div><div class="line"></div><div class="line">f()</div></pre></td></tr></table></figure>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p><strong>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</strong></p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print &apos;call %s():&apos; % func.__name__</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line">    </div><div class="line">@log</div><div class="line">def name():</div><div class="line">    print &apos;lly&apos;</div></pre></td></tr></table></figure>
<p>把<em>@log</em>放到<em>now()</em>函数的定义处，相当于执行了语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now = log(now)</div></pre></td></tr></table></figure>
<p>由于<em>log()</em>是一个<strong>decorator</strong>，返回一个函数，所以，原来的<em>now()</em>函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用<em>now()</em>将执行新函数，即在<em>log()</em>函数中返回的<em>wrapper()</em>函数。</p>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def log(text):</div><div class="line">    def decorator(func):</div><div class="line">        def wrapper(*args, **kw):</div><div class="line">            print &apos;%s %s():&apos; % (text, func.__name__)</div><div class="line">            return func(*args, **kw)</div><div class="line">        return wrapper</div><div class="line">    return decorator</div><div class="line">    </div><div class="line">@log(&apos;netease&apos;)</div><div class="line">def name():</div><div class="line">    print &apos;lly&apos;</div></pre></td></tr></table></figure>
<p>示例三:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line"></div><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print &apos;call %s():&apos; % func.__name__</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="属性、方法的动态绑定和限制"><a href="#属性、方法的动态绑定和限制" class="headerlink" title="属性、方法的动态绑定和限制"></a>属性、方法的动态绑定和限制</h5><p>一、属性的动态绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">s = Student()</div><div class="line">s.name = &apos;lly&apos;</div><div class="line"></div><div class="line">print s.name</div></pre></td></tr></table></figure>
<p>二、方法的动态绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">def set_age(self, age): # 定义一个函数作为实例方法</div><div class="line">	self.age = age</div><div class="line"></div><div class="line">from types import MethodType</div><div class="line"></div><div class="line">s.set_age = MethodType(set_age, s, Student)</div><div class="line">s.set_age(25)</div><div class="line"></div><div class="line">s.age</div></pre></td></tr></table></figure>
<p>三、类的方法绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	pass</div><div class="line"></div><div class="line">def set_score(self, score):</div><div class="line">	self.score = score</div><div class="line"></div><div class="line">from types import MethodType</div><div class="line"></div><div class="line">Student.set_score = MethodType(set_score, None, Student)</div></pre></td></tr></table></figure>
<p>四、限制动态添加</p>
<p><strong>Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class能添加的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">	__slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 插槽</div><div class="line"></div><div class="line">s = Student() # 创建新的实例</div><div class="line">s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</div><div class="line">s.age = 25 # 绑定属性&apos;age&apos;</div><div class="line">s.score = 99 # 绑定属性&apos;score&apos;</div></pre></td></tr></table></figure>
<p><em><strong>slots</strong>定义的属性仅对当前类起作用，对继承的子类是不起作用</em></p>
<h5 id="安全简洁的属性"><a href="#安全简洁的属性" class="headerlink" title="安全简洁的属性"></a>安全简洁的属性</h5><p><strong>Python内置的@property装饰器就是负责把一个方法变成属性调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line"></div><div class="line">    @property</div><div class="line">    def score(self):</div><div class="line">        return self._score</div><div class="line"></div><div class="line">    @score.setter</div><div class="line">    def score(self, value):</div><div class="line">        if not isinstance(value, int):</div><div class="line">            raise ValueError(&apos;score must be an integer!&apos;)</div><div class="line">        if value &lt; 0 or value &gt; 100:</div><div class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</div><div class="line">        self._score = value</div><div class="line">        </div><div class="line">s = Student()</div><div class="line">s.score = 60 # OK，实际转化为s.set_score(60)</div><div class="line">s.score # OK，实际转化为s.get_score()</div></pre></td></tr></table></figure>
<h4 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h4><h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">print &apos;Process (%s) start...&apos; % os.getpid()</div><div class="line">pid = os.fork()</div><div class="line">if pid==0:</div><div class="line">    print &apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getppid())</div><div class="line">else:</div><div class="line">    print &apos;I (%s) just created a child process (%s).&apos; % (os.getpid(), pid)</div></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def run_proc(name):</div><div class="line">    print &apos;Run child process %s (%s)...&apos; % (name, os.getpid())</div><div class="line"></div><div class="line">if __name__==&apos;__main__&apos;:</div><div class="line">    print &apos;Parent process %s.&apos; % os.getpid()</div><div class="line">    p = multiprocessing.Process(target=run_proc, args=(&apos;test&apos;,))</div><div class="line">    print &apos;Process will start.&apos;</div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    print &apos;Process end.&apos;</div></pre></td></tr></table></figure>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import time, threading</div><div class="line"></div><div class="line"># 新线程执行的代码:</div><div class="line">def loop():</div><div class="line">    print &apos;thread %s is running...&apos; % threading.current_thread().name</div><div class="line">    n = 0</div><div class="line">    while n &lt; 5:</div><div class="line">        n = n + 1</div><div class="line">        print &apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)</div><div class="line">        time.sleep(1)</div><div class="line">    print &apos;thread %s ended.&apos; % threading.current_thread().name</div><div class="line"></div><div class="line">print &apos;thread %s is running...&apos; % threading.current_thread().name</div><div class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</div><div class="line">t.start()</div><div class="line">t.join()</div><div class="line">print &apos;thread %s ended.&apos; % threading.current_thread().name</div></pre></td></tr></table></figure>
<p>线程加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">balance = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def run_thread(n):</div><div class="line">    for i in range(100000):</div><div class="line">        # 先要获取锁:</div><div class="line">        lock.acquire()</div><div class="line">        try:</div><div class="line">            # 放心地改吧:</div><div class="line">            change_it(n)</div><div class="line">        finally:</div><div class="line">            # 改完了一定要释放锁:</div><div class="line">            lock.release()</div></pre></td></tr></table></figure>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<h4 id="简单爬虫"><a href="#简单爬虫" class="headerlink" title="简单爬虫"></a>简单爬虫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import urllib</div><div class="line"></div><div class="line">uf = urllib.urlopen(&apos;https://baidu.com&apos;)</div><div class="line"></div><div class="line">uf.read()</div><div class="line"></div><div class="line">urllib.urlretrieve(&apos;urlpath&apos;,&apos;filename&apos;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/" itemprop="url">
                  高性能iOS应用开发读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-07T10:02:22+08:00" content="2017-07-07">
              2017-07-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/07/高性能iOS应用开发/高性能iOS应用开发读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ofy1hyquv.bkt.clouddn.com/%E9%AB%98%E6%80%A7%E8%83%BDiOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.png" alt=""></p>
<h3 id="第一章-移动应用的性能"><a href="#第一章-移动应用的性能" class="headerlink" title="第一章 移动应用的性能"></a>第一章 移动应用的性能</h3><ul>
<li>应用首次工作出错以后，79%的用户只会再重试一两次</li>
<li>当应用载入时间超过3秒时，25%的用户会放弃使用该应用。</li>
<li>31%的用户会将糟糕的体验转告他人。</li>
</ul>
<h4 id="定义性能"><a href="#定义性能" class="headerlink" title="定义性能"></a>定义性能</h4><p>高性能有着多重的含义和丰富的解释方式。</p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul>
<li>内存</li>
<li>电池消耗</li>
<li>程序初始化时间</li>
<li>执行速度</li>
<li>响应速度</li>
<li>本地存储</li>
<li>互操作性</li>
<li>网络环境</li>
<li>带宽</li>
<li>数据刷新</li>
<li>多用户支持</li>
<li>单点登录</li>
<li>安全</li>
<li>崩溃</li>
</ul>
<h4 id="应用性能分析"><a href="#应用性能分析" class="headerlink" title="应用性能分析"></a>应用性能分析</h4><ul>
<li>采样</li>
<li>埋点</li>
</ul>
<h4 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h4><p>过早优化是编程领域的万恶之源–高德纳？？？</p>
<p><a href="https://github.com/gvaish/hpios" target="_blank" rel="noopener">测试代码地址</a></p>
<h3 id="第二章-内存管理"><a href="#第二章-内存管理" class="headerlink" title="第二章 内存管理"></a>第二章 内存管理</h3><p>90%的应用崩溃与内存管理有关，其中最主要的原因是错误的内存访问和保留环所引起的内存泄露 – Apple Dev</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.png"
               alt="lly" />
          <p class="site-author-name" itemprop="name">lly</p>
          <p class="site-description motion-element" itemprop="description">耿直的一Boy</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">73</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"llyblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
